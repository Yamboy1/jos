<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
    <TITLE>DeviceDetection.Imported @ jos.sf.net</TITLE>
  </HEAD>

<BODY BGCOLOR="#FFFFFF">

<!-- The FORM encloses the entire header, because it renders better that way. !-->
<FORM ACTION="/jump.php"><input type="hidden" name="PHPSESSID" value="e9b17b14e97244de37784852a7589564" />

<!-- The JOS logo. !-->
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR VALIGN="TOP" ALIGN="LEFT">
	<TD><A HREF="http://cjos.sourceforge.net/archive/"><IMG 
		VSPACE="0" HSPACE="0" ALIGN="MIDDLE" BORDER="0"
		SRC="image/wikiHome.gif"></A></TD>
	<!-- The tab table. !-->
	<TD WIDTH="100%" ALIGN="RIGHT" BGCOLOR="#FFFFFF" VALIGN="BOTTOM"> 
		<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%" ALIGN="RIGHT">
			<TR VALIGN="MIDDLE" ALIGN="LEFT">

<TD BGCOLOR="White" WIDTH="60%">&nbsp;</TD>
<TD BGCOLOR="#FFFFCC"><A HREF="http://cjos.sourceforge.net/archive/">Home</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/info/">Info</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/dev/">DevZone</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFCC66" ALIGN="CENTER"><A
HREF="http://jos.sourceforge.net/">Wiki</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
			</TR>
			<TR>
				<TD BGCOLOR="#FFCC66" ALIGN="RIGHT" COLSPAN="9">
					<A HREF="UsersWebHome.html">UsersWeb</A>
					&nbsp;|&nbsp;
					<A HREF="MainWebHome.html">MainWeb</A>
					&nbsp;|&nbsp;
					<A HREF="InfoWebHome.html">InfoWeb</A>
					&nbsp;|&nbsp;
					<A HREF="DevZoneWebHome.html">DevZoneWeb</A>
					&nbsp;|&nbsp;
					<A HREF="SupportWebHome.html">SupportWeb</A>
				</TD>
			</TR>
		</TABLE>
	</TD>		
</TR>
<!-- The WikiHeader. !-->
<TR><TD COLSPAN="2">
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="CENTER">
		<B>[&nbsp;<! page="">DeviceDetection</a>&nbsp;]</B>
	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="CENTER">
		<B>[ not logged in ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="CENTER">
		<B>[ Web: <a href="ImportedWebHome.html">Imported</a> ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFCC66" VALIGN="CENTER">
		goto:&nbsp;<INPUT TYPE="TEXT" SIZE="10" NAME="topic"><!--<INPUT TYPE="IMAGE" SRC="/media/go.gif?PHPSESSID=e9b17b14e97244de37784852a7589564" BORDER="0" VALUE="topic" ALT="goto">!-->&nbsp;<! page=""><FONT SIZE="-1">options</FONT></a>
	</TD>
</TR>
</TABLE>

<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
	<TR>
	<TD ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="TOP">
		[&nbsp;get <! page="">info</a> on or <a href="WebHome.html">edit</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="TOP">
		[&nbsp;<! page="">login</a> or <! page="">new&nbsp;user</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="TOP">
		[&nbsp;list of <a href="Glossary.html">topics</a>, <! page="">hubs&nbsp;&amp;&nbsp;nodes</a>, or <a href="NewArticles2a.html">recent&nbsp;changes</a>&nbsp;]	</TD>
	</TR>
</TABLE>

<!-- From CommonHeader !-->
</TR></TD>
</TABLE>
</FORM>

<!-- start BODY page !-->
<P>
Initial note: if anyone has access to Micro$oft's Device Developer Kit, please send me the detailed description of the .inf files used in device configuration.  If we could use these in JOS, it would be a huge amount of hardware testing already complete.
<HR>
</P><P>
The current code and description has gone under the knife.  This project has grown exponentially in scope, and now covers the Platform interfaces (which is almost done coding, pending some changes under discusion in the kernel mailing list), the <! page="">JOS</a> <! page="">ConfigurationDatabase</a>, Jini Look-up services, Device and Bus Driver base design, and the <! page="">ConfigurationManager</a>. The current design is listed under
<a href="DeviceArchitecture.html">DeviceArchitecture</a>.
</P><P>
Other related references:
<UL> <LI> <a href="KernelInterface.html">KernelInterface</a>
<LI> <a href="HardwareResource.html">HardwareResource</a>
<LI> <a href="HardwareResourceManager.html">HardwareResourceManager</a>
</UL> 
-MattAlbrecht
30-MAR-1999
</P><P>
<HR>
<center><h2>Device Detection</h2></center>
</P><P>
To properly develop a hardware device detection system, a basic platform architecture needs to first be created.  Since no one has yet come up with an agreed upon architecture, I'll propose a simple one based on IBM/Sun's <a href="JavaOS.html">JavaOS</a> (hopefully, loosely so no lawsuits can ensue).  The base example driver I'll use is the <! page="">VGA</a> video driver for the PC.
</P><P>
<h3>Platform</h3>
</P><P>
The platform package contains Java versions of generally native calls to base I/O operations needed for device drivers:
</P><P>
<UL> <LI> direct memory location allocation.  The <! page="">VGA</a> card requires memory address space (in virtual memory terms) 0x0A0000 - 0x0Bffff.
<LI> I/O port allocation.  The <! page="">VGA</a> card requires a large port address range (I don't have specs in front of me, but if I remember right it is like 0x0320 - 0x03ff).
<LI> Interrupt/IRQ allocation.  The <! page="">VGA</a> doesn't use interrupts, but, for example, Mice do.
<LI> <a href="DMA.html">DMA</a> channel allocation.  The <! page="">VGA</a> doesn't use DMA, but, for example, the <! page="">IDE</a> drive drivers do.
</UL> 
According to my <! page="">PlugAndPlay</a> Architecture texts, this is all that is needed for PC and <! page="">PowerPC</a> driver hardware allocations.  If you have knowledge of more, please spread the info.
</P><P>
Along with maintaining an interface to said hardware, it should also keep track of who has allocated these resources, and should prevent multiple drivers from allocating the same resources.
</P><P>
</P><P>
<h3>Bus</h3>
</P><P>
There may be multiple busses per platform. Each bus is in charge of:
</P><P>
<UL> <LI> Finding all devices using it.
<LI> Discovering the Platform hardware used.
<LI> Assiging an unique identifier to each device found.
<LI> Giving an interface to the device drivers for them to interface with the hardware, giving a <! page="">HardwareAbstractionLayer</a>.
</UL> 
If we give the job of (2) to the bus as opposed to the device driver itself, we are able to make the device drivers more bus independant (for examples of this, note Win'95's virtual device drivers - yeah, its winblows, but it has some research behind it).  In some cases, we can't do this easily (e.g. <! page="">LegacyISA</a> cards), but it can be done.  I'll expand on this later in my discussion of the different busses.
</P><P>
</P><P>
<h3>Bus Manager</h3>
</P><P>
This class is in charge of managing the various bus classes which populate the hardware.
</P><P>
It is, in the general <! page="">JOS</a> implementation, an abstract class.  This is because of the extremely hardware-dependant interfaces which can occur.  However, certain "helper methods" should be added to make the basic management much easier.
</P><P>
</P><P>
<h3>Driver Repository</h3>
</P><P>
(This is heavily influenced by <a href="JavaOS.html">JavaOS</a> - have any better ideas? Then post them!)
</P><P>
The driver repository has an RMI-esque interface to keep a network-wide access open for known devices on the network.
</P><P>
After a device has been discovered and has been assigned to the proper allocated and initialized hardware resources, it is passed to the driver repository.  It is the repository's duty to find a driver and associate it with the machine/device passed to it, then to initialize the driver.
</P><P>
<H3>A Complex Example</h3>
</P><P>
As an example of how convoluted this can be, let's look at the PC with all of its variations.
</P><P>
Initially, we must check for any <! page="">LegacyISA</a> (International Standard Architecture) cards. These are very difficult to find, since there is no systematic approach to discovery - we must have a set of "finder" functions which tell us how to discover as many cards as possible.  Or, we could require the user to tell us which is in the system, then attempt to check if the given information is true.  Since this can be an indepth and time consuming process, a record of the current configuration should be maintained (a la Win'95's <! page="">CMOS</a> registry, but without the <! page="">CMOS</a> storage).  This would require the user to inform the OS when a card has been added (removal is more easily detected).
</P><P>
Assuming that we found all of these Legacy <! page="">ISA</a> cards, we then move on to <! page="">EISA</a> (Extended ISA) cards.  These are easier to detect as they support <! page="">PlugAndPlay</a> architecture.  Also, every <! page="">EISA</a> card is assigned a slot number, and can be accessed individually through different port ranges per slot.
</P><P>
It is then the bus manager's responsibility to integrate the <! page="">ISA</a> and <! page="">EISA</a> device lists - if an <! page="">ISA</a> card is also in the <! page="">EISA</a> list, then remove it from the <! page="">ISA</a> list.  We must search <! page="">ISA</a> initially to prevent possible <! page="">PlugAndPlay</a> screwups (notice Win'95 <a href="PnP.html">PnP</a> support).
</P><P>
Then we can search for <! page="">PCI</a> cards.  They fully support <! page="">PlugAndPlay</a>, so we follow the same procedure as for EISA.
</P><P>
If we find that there exists on this PC a <! page="">PCMCIA</a> bus, then the Platform <! page="">MUST</a> support sharable interrupts (i.e. interrupt chaining).  To be fully <! page="">PCMCIA</a> compliant, it must also support 32-bit <! page="">PCMCIA</a> device drivers. We must also set up a Socket and Card Service interfaces for these drivers to interact with.
</P><P>
Even then, with all cards discovered, we must pass all the hardware requirements on to the Bus Manager (or someone else who is qualified) to sort out who gets which resources (with <a href="PnP.html">PnP</a>, the configuration is commonly configurable, with an optimized configuration).
</P><P>
I believe that the above architecture can fully cover the needs of any architecture, but only if most classes are left abstract, to be filled in by each platform's needs.
</P><P>
</P><P>
-MattAlbrecht 25-AUG-1998
Updated 27-AUG-1998<BR><BR></P><!--

<TABLE width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="737b9c">
<TR><TD ALIGN="CENTER">
<! page="">login</a> or <! page="">new&nbsp;user</a><TR><TD>
</TABLE>

!-->
<!-- end BODY page !-->

<HR>

<DIV ALIGN="CENTER">
<TABLE BORDER="0" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR>
	<TD ALIGN="CENTER" COLSPAN="2">
		Content of these pages are owned and copyrighted by the poster.
	</TD>
</TR>
<TR>
	<TD ALIGN="RIGHT" WIDTH="50%">
		Hosted by:
	</TD>
	<TD ALIGN="LEFT">
		<A HREF="http://sourceforge.net/"><IMG 
			SRC="http://sourceforge.net/sflogo.php?group_id=2376&type=1"
			BORDER=0 HSPACE=0 VSPACE=0></A>
	</TD>
</TR>
</TABLE>
</DIV>
</BODY>
</HTML>
