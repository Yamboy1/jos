<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [JOS-Kernel] Fwd: Java Virtual Machine Development</TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:robfitz%40273k.net">
   <LINK REL="Previous"  HREF="000913.html">
   <LINK REL="Next" HREF="000916.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[JOS-Kernel] Fwd: Java Virtual Machine Development</H1>
    <B>Robert Fitzsimons</B> 
    <A HREF="mailto:robfitz%40273k.net"
       TITLE="[JOS-Kernel] Fwd: Java Virtual Machine Development">robfitz@273k.net</A><BR>
    <I>Sun, 24 Sep 2000 03:24:34 +0000</I>
    <P><UL>
        <LI> Previous message: <A HREF="000913.html">[JOS-Kernel] [kernel machine code cache] Definition</A></li>
        <LI> Next message: <A HREF="000916.html">[JOS-Kernel] Starting a program</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#915">[ date ]</a>
              <a href="thread.html#915">[ thread ]</a>
              <a href="subject.html#915">[ subject ]</a>
              <a href="author.html#915">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--ZPt4rx8FFjLCG7dd
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

Hi everybody

The attached email's are from a private discussion I've been having with
Gilbert Carl Herschberger, Todd Miller and John Leuner.  The discussion
is about us working on a combined JVM project.  This discussion was one
of the reasons for my email &quot;The JOS Project?&quot; to the general mailing
list.

Robert Fitzsimons
<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>


--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Tue, 12 Sep 2000 05:16:50 +0000 (UTC)
Received: from tux (<A HREF="mailto:postfix@c851848-b.mntp1.il.home.com">postfix@c851848-b.mntp1.il.home.com</A> [24.22.234.61])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id AAA09882
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Tue, 12 Sep 2000 00:47:02 -0400
Received: by tux (Postfix, from userid 1000)
	id A2A71EABD7; Tue, 12 Sep 2000 04:44:10 +0000 (UTC)
Date: Tue, 12 Sep 2000 04:44:10 +0000
From: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
To: Todd Miller &lt;<A HREF="mailto:tmiller@haverfod.edu">tmiller@haverfod.edu</A>&gt;,
        Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;
Cc: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
Subject: Java Virtual Machine Development
Message-ID: &lt;<A HREF="mailto:20000912044410.A4039@tux.yi.org">20000912044410.A4039@tux.yi.org</A>&gt;
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
User-Agent: Mutt/1.0.1i
Sender: <A HREF="mailto:bob@tux.yi.org">bob@tux.yi.org</A>

Hello Todd, Gilbert

As I hope you two know i've been playing around with writing my own JVM
for the last few months.  It began as an experiment when I got a bit of
writers block with RJK, it's goals were to share as much information
between multiple Java processes and be fast and efficient.  It is
currently at the stage where class files can be loaded, simple code
executed and objects created.

Now i've stopped working on one code base and restarted with a new one
about three times so far.  I have found this a very good way to improve
the quality of the code, and include the much better ideas you come up
with after you've written a piece of code.  Now I reached this stage
again and this is where you two come in.

We have all been working on our own JVM related projects decafe, Pure
Reflection, my JVM, etc.  Also as part of the architecture group we've
also had a lot of really good ideas, including multiple Java processes,
BCNI, MPCL, etc.  The issue is with all the work thats going on and all
the ideas we've had this still isn't that much to show for it.

So lets take all we've learned and all the ideas, and start again.  But
this time as a group!  Lets come up with a design using all our current
ideas and allow for future expansion, then write it so that is can be
fast, efficient, flexible and portable.

So what do you guy's think, is it worth doing, can we do it?

I'm willing to listen to all ideas and issues on design, implementation,
programming language, coding style, etc.

Robert Fitzsimons
<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>

PS.  I'm making my current code base available at
&lt;URL:<A HREF="http://www.273k.net/jos/jvm.20000911.tar.gz">http://www.273k.net/jos/jvm.20000911.tar.gz</A>&gt;, so if you have any
questions or comments give me a shout.

--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Tue, 12 Sep 2000 23:07:17 +0000 (UTC)
Received: from tisch.mail.mindspring.net (tisch.mail.mindspring.net [207.69.200.157])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id OAA01108
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Tue, 12 Sep 2000 14:33:01 -0400
Received: from gchii.mindspring.com (user-38lcint.dialup.mindspring.com [209.86.74.253])
	by tisch.mail.mindspring.net (8.9.3/8.8.5) with SMTP id OAA25168
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Tue, 12 Sep 2000 14:32:55 -0400 (EDT)
Message-Id: &lt;<A HREF="mailto:3.0.1.32.20000912143516.006c3134@pop.mindspring.com">3.0.1.32.20000912143516.006c3134@pop.mindspring.com</A>&gt;
X-Sender: <A HREF="mailto:gchii@pop.mindspring.com">gchii@pop.mindspring.com</A>
X-Mailer: Windows Eudora Light Version 3.0.1 (32)
Date: Tue, 12 Sep 2000 14:35:16 -0400
To: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
From: Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;
Subject: Re: Java Virtual Machine Development
In-Reply-To: &lt;<A HREF="mailto:20000912044410.A4039@tux.yi.org">20000912044410.A4039@tux.yi.org</A>&gt;
Mime-Version: 1.0
Content-Type: text/plain; charset=&quot;us-ascii&quot;

As you may know, I have suggested we export existing components to a VMKit.
We can build common vm-related components so that each of us can build our
own virtual machine. We are not limited to building a single virtual
machine together.

Are you again suggesting that we work together on a single virtual machine?

I want a virtual machine that runs on jJOS, Linux and Windows. I would like
most of it to be written in C/C++. I don't care if some of it is written in
x86 assembler. I don't care if it is compiled from Java source code.

We should learn from the mismanagement of the decaf project. A community
won't volunteer to work on a virtual machine that satisfies the
requirements of only one person. No, a community finds it easy to work on
reusable components that will satify the requirements of everyone.

--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Wed, 13 Sep 2000 18:03:51 +0000 (UTC)
Received: from maynard.mail.mindspring.net (maynard.mail.mindspring.net [207.69.200.243])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id MAA07103
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Wed, 13 Sep 2000 12:22:36 -0400
Received: from gchii.mindspring.com (user-38ld411.dialup.mindspring.com [209.86.144.33])
	by maynard.mail.mindspring.net (8.9.3/8.8.5) with SMTP id MAA03858
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Wed, 13 Sep 2000 12:22:32 -0400 (EDT)
Message-Id: &lt;<A HREF="mailto:3.0.1.32.20000913122310.006c0a00@pop.mindspring.com">3.0.1.32.20000913122310.006c0a00@pop.mindspring.com</A>&gt;
X-Sender: <A HREF="mailto:gchii@pop.mindspring.com">gchii@pop.mindspring.com</A>
X-Mailer: Windows Eudora Light Version 3.0.1 (32)
Date: Wed, 13 Sep 2000 12:23:10 -0400
To: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
From: Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;
Subject: Re: Java Virtual Machine Development
In-Reply-To: &lt;<A HREF="mailto:20000913035356.A15446@tux.yi.org">20000913035356.A15446@tux.yi.org</A>&gt;
References: &lt;<A HREF="mailto:3.0.1.32.20000912143516.006c3134@pop.mindspring.com">3.0.1.32.20000912143516.006c3134@pop.mindspring.com</A>&gt;
 &lt;<A HREF="mailto:20000912044410.A4039@tux.yi.org">20000912044410.A4039@tux.yi.org</A>&gt;
 &lt;<A HREF="mailto:3.0.1.32.20000912143516.006c3134@pop.mindspring.com">3.0.1.32.20000912143516.006c3134@pop.mindspring.com</A>&gt;
Mime-Version: 1.0
Content-Type: text/plain; charset=&quot;us-ascii&quot;

At 03:53 AM 9/13/00 +0000, you wrote:
&gt;<i>Yes.  I think it would be to the projects advantage for there to be a
</I>&gt;<i>single JVM.  Although it's nice to have more I don't think it's not very
</I>&gt;<i>practical at this moment in time.
</I>
I believe it might be easier to attract virtual machine designers if we
support all virtual machine designs. Diversity is good. While /we/ don't
have to form a team to build many virtual machines at once, we should
expect our base virtual machine to be customize-able and specialize-able. I
embrace the idea of multiple virtual machines through extension of a base
virtual machine. Our goal should be to build that base.

&gt;<i>The VMKit is a good idea, we just need to figure out how to accomplish
</I>&gt;<i>it.  We should try and write each component to be reusable, but doing
</I>&gt;<i>this and writing two or more JVM at the same time is just a waste.
</I>
When each member of a VMKit group is expected to write their own virtual
machine, it forces certain issues. It forces us to think of each component
as a plug-in. If I write a component, for example, that you can plug into
your custom virtual machine, that's a good thing. Isn't it?

By opening up the expectations, many more virtual machine designers will be
attracted to the VMKit group...because they can get the specialized virtual
machine they always wanted. If a group wants to work on a single virtual
machine, that's no problem. It's a start.

I am fully opposed to the one-size-fits-all approach. Members of a VMKit
group are not required to work on a group virtual machine if they don't
want to. They can contribute vm-related components.

Also, we can salvage vm-related components from other open source project.

&gt;<i>I wouldn't say that decaf was mismanaged it just couldn't attract many
</I>&gt;<i>long term developers like myself, and for me that was more due to JJOS
</I>&gt;<i>than anything else.
</I>
This might be significant. Like you, I do not like jJOS, the decaf-specific
kernel. I think you mean jJOS (the kernel) and not JJOS (the kernel and
virtual machine). The jJOS kernel is so decaf-specific that it invokes
decaf_main(). It provides no well-defined kernel interface. It uses C++ and
classes; but, it lacks object oriented design in specialization for
Etherboot and GRUB.

What else is wrong with jJOS? Can't we replace jJOS with something better?
I think so. We can salvage parts of jJOS to create a better kernel.

Reading the Linux Programming White Papers, I see that the Linux project
organized its header files properly, leading to a strong parallel
development process. The header files for jJOS and decaf are organized
horribly.

Inside Pure Reflection for C++, I tried to distinguish between public
classes and private classes. I also put classes in class libraries. jJOS
and decaf do not distinguish between public and private classes, making all
classes public. There isn't a single class library in the entire project!

For example, Many calculator libraries can implement the public calculator
interface. When a &quot;calculator&quot; is compiled into an independent library, it
can be plugged into a custom virtual machine. Only the calculator interface
is exposed to a virtual machine. Only the calculator interface must be
stored in a public header file. When I pre-compile the calculator library
and distribute it in a binary edition, any specialized tools needed to
build the calculator library are optional, not required. That is
encapsulation.

An enhanced calculator can extend the calculator interface. That is
inheritence. A debugging version of the calculator could log each
calculator request. A remote calculator can run on another CPU. A backup
calculator can be compared to a new one. Three calculators can be used
simultaneously to reduce the chance of a math error at runtime.

You could choose a calculator from a list of calculators at runtime. That
is a good use of polymorphism.

For each component in a virtual machine, there is a similar story.

--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Mon, 18 Sep 2000 18:36:50 +0000 (UTC)
Received: from azaphrael.haverford.edu (<A HREF="mailto:root@165-82-108-36.students.haverford.edu">root@165-82-108-36.students.haverford.edu</A> [165.82.108.36])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id OAA17594
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Mon, 18 Sep 2000 14:10:11 -0400
Received: from localhost (<A HREF="mailto:tmiller@localhost">tmiller@localhost</A> [127.0.0.1])
	by azaphrael.haverford.edu (8.9.3/8.9.3) with ESMTP id OAA00736;
	Mon, 18 Sep 2000 14:09:03 -0400
Date: Mon, 18 Sep 2000 14:09:03 -0400 (EDT)
From: &quot;Todd L. Miller&quot; &lt;<A HREF="mailto:tmiller@haverford.edu">tmiller@haverford.edu</A>&gt;
To: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
cc: Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;
Subject: Re: Java Virtual Machine Development
In-Reply-To: &lt;<A HREF="mailto:20000916001524.B3063@tux.yi.org">20000916001524.B3063@tux.yi.org</A>&gt;
Message-ID: &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt;
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

	I'm very interested in your ideas about how to implement multiple
java processes.  Right now, I have two main priorities.  The greater
priorities are first to write a JVM amenable to integration with a class
library, and then perform that integration; and second, for that JVM to
support multiple java processes.  BCNI is not as important, and though I
haven't thought it through as much, should be a well-enscapulated change
to make.  (That is, only invokenative should have to be changed.  And we
have to do some thinking about handling exceptions in the 'native'
bytecode, etc.)

	I was thinking about architecture questions, and it occured to me
that the idea of converting bytecode into an array of function calls has
the benefit that it becomes much simpler to replace parts of it with
JIT-compiled code or accelerated interpretation.  (For instance, many
common sequences are longer than they 'need' to be because of the operand
stack.  Recognizing what those sequences do allows them to be shortened
and the stack avoided.)

	What about Jay Lepreau?  ('kissme')

-_Quinn






--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Tue, 19 Sep 2000 03:55:39 +0000 (UTC)
Received: from tux (<A HREF="mailto:mail@c851848-b.mntp1.il.home.com">mail@c851848-b.mntp1.il.home.com</A> [24.22.234.61])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id XAA04974
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Mon, 18 Sep 2000 23:54:22 -0400
Received: from bob by tux with local (Exim 3.12 #1 (Debian))
	id 13bESm-0000C8-00; Tue, 19 Sep 2000 03:52:56 +0000
Date: Tue, 19 Sep 2000 03:52:56 +0000
From: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
To: &quot;Todd L. Miller&quot; &lt;<A HREF="mailto:tmiller@haverford.edu">tmiller@haverford.edu</A>&gt;
Cc: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;,
        Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;,
        John Leuner &lt;<A HREF="mailto:jewel@mweb.co.za">jewel@mweb.co.za</A>&gt;
Subject: Re: Java Virtual Machine Development
Message-ID: &lt;<A HREF="mailto:20000919035256.A331@tux.yi.org">20000919035256.A331@tux.yi.org</A>&gt;
References: &lt;<A HREF="mailto:20000916001524.B3063@tux.yi.org">20000916001524.B3063@tux.yi.org</A>&gt; &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt;
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i
In-Reply-To: &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt;; from <A HREF="mailto:tmiller@haverford.edu">tmiller@haverford.edu</A> on Mon, Sep 18, 2000 at 02:09:03PM -0400

&gt;<i> 	I'm very interested in your ideas about how to implement multiple
</I>&gt;<i> Java processes.  Right now, I have two main priorities.  The greater
</I>&gt;<i> priorities are first to write a JVM amenable to integration with a class
</I>&gt;<i> library, and then perform that integration; and second, for that JVM to
</I>&gt;<i> support multiple Java processes.  BCNI is not as important, and though I
</I>&gt;<i> haven't thought it through as much, should be a well-enscapulated change
</I>&gt;<i> to make.  (That is, only invokenative should have to be changed.  And we
</I>&gt;<i> have to do some thinking about handling exceptions in the 'native'
</I>&gt;<i> bytecode, etc.)
</I>
Basically the goal for multiple Java processes is to save memory by not
having multiple copies of the same information in memory.  So what we
need to decide is what information can be shared and what can't.

It's easier to start with what can't be shared between processes:
* instance data
* static data
* thread data (stack frames, ip, etc)

And what can be shared between processes:
* class data
* method data
* field data
* interface data

I haven't listed constant data or string data because these are a little
fuzzy.

With this list in your mind you can now start coding, but you have to
make sure that the non shared data has no pointers to shared data.

+---------------------+-------------+
|<i> Object &lt;---&gt; Class -+-&gt; ClassData |
</I>+---------------------+-------------+

It really is that easy to create the data structures for multiple
processes.  The problem is with writing an execution engine, the code
needs to be written so that it doesn't reference the non shared data
directly (this is a lot easier to do with an interpreter).  This is what
i've spent the last month or so working on.

There are a lot of other things as well, I can't really explain them in
words but the code in my JVM covers most of them.

&gt;<i> 	I was thinking about architecture questions, and it occured to me
</I>&gt;<i> that the idea of converting bytecode into an array of function calls has
</I>&gt;<i> the benefit that it becomes much simpler to replace parts of it with
</I>&gt;<i> JIT-compiled code or accelerated interpretation.  (For instance, many
</I>&gt;<i> common sequences are longer than they 'need' to be because of the operand
</I>&gt;<i> stack.  Recognizing what those sequences do allows them to be shortened
</I>&gt;<i> and the stack avoided.)
</I>
Do you mean convert each bytecode opcode into a function call?  The call
over head is just too great for that to work.  I think we need to forget
about interpreters and go for a native compiler or JIT.  With JOS we
have the best chance in the world to write the fastest JVM the whole OS
is written to run Java bytecode.

Though recognizing common bytecode sequences is a good place to start with
improving speed.

&gt;<i> 	What about Jay Lepreau?  ('kissme')
</I>
I forwarded the same email to him a day or so after I sent it to you and
Gilbert.

Robert Fitzsimons
<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>

--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Tue, 19 Sep 2000 21:11:40 +0000 (UTC)
Received: from tisch.mail.mindspring.net (tisch.mail.mindspring.net [207.69.200.157])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id JAA09775
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Tue, 19 Sep 2000 09:48:59 -0400
Received: from gchii.mindspring.com (user-38ld5es.dialup.mindspring.com [209.86.149.220])
	by tisch.mail.mindspring.net (8.9.3/8.8.5) with SMTP id JAA07616
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Tue, 19 Sep 2000 09:48:56 -0400 (EDT)
Message-Id: &lt;<A HREF="mailto:3.0.1.32.20000919094941.006da2dc@pop.mindspring.com">3.0.1.32.20000919094941.006da2dc@pop.mindspring.com</A>&gt;
X-Sender: <A HREF="mailto:gchii@pop.mindspring.com">gchii@pop.mindspring.com</A>
X-Mailer: Windows Eudora Light Version 3.0.1 (32)
Date: Tue, 19 Sep 2000 09:49:41 -0400
To: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
From: Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;
Subject: Re: Java Virtual Machine Development
In-Reply-To: &lt;<A HREF="mailto:20000919035256.A331@tux.yi.org">20000919035256.A331@tux.yi.org</A>&gt;
References: &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt;
 &lt;<A HREF="mailto:20000916001524.B3063@tux.yi.org">20000916001524.B3063@tux.yi.org</A>&gt;
 &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt;
Mime-Version: 1.0
Content-Type: text/plain; charset=&quot;us-ascii&quot;

&gt;<i>Basically the goal for multiple Java processes is to save memory by not
</I>&gt;<i>having multiple copies of the same information in memory.
</I>
The goal is to save &quot;memory&quot; by /any/ mechanism, not just multiple bytecode
processes. Multiple bytecode process is not required. It is only one
approach to this problem. Unfortunately, it seems to be the least likely to
succeed.

Most of the potential to save &quot;memory&quot; seems to come from specifically
optimizing a virtual machine to use the kernel's virtual memory manager
properly. Bytecode in virtual memory should be marked &quot;read-only&quot;, not
&quot;read-write&quot;. It should be stored in a system-wide bytecode cache.

Think about it. The potential to save memory is limited. An application
that has 10MB of object data will always have 10MB of object data. Most of
the potential to save memory is found inside the duplication of raw
bytecode. Is it necessary to define multiple Java processes in order to
save memory? No. Is multiple Java processes the only way to save memory?
No. Could there be a simpler alternative that saves just as much memory, or
more? Yes. Is there a platform-independent solution? Yes.

Without a bytecode cache, if there are 4MB of the same read/write bytecode
per virtual machine and there are 100 virtual machines, that's 400MB of
wasted swap space. With a bytecode cache, the same scene would require 4MB
of swap space. By making bytecode a resource, it requires no swap space.

So much effort has been consumed (wasted?) by the theory of multiple
bytecode processes. The theory of multiple bytecode processes has been
adopted and assumed by some without a lot of thought. It is a theory that
may have never been challenged. I'll challenge it. By comparing multiple
bytecode processes within a virtual machine to a highly optimized virtual
machine, I have concluded that multiple bytecode processes within the same
virtual machine does not &quot;save&quot; memory. Instead, it adds far too much
complexity to the internal workings of a virtual machine. When the solution
is reduced, it requires just as much memory to run multiple bytecode
processes as it does to run multiple virtual machines. It is six of one,
half dozen of the other.

Add a bytecode cache and bytecode resource to an off-the-shelf virtual
machine and this saves potentially all of the memory that might be saved by
multiple bytecode processes.

--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Wed, 20 Sep 2000 07:15:49 +0000 (UTC)
Received: from tux.yi.org (<A HREF="mailto:root@c851848-b.mntp1.il.home.com">root@c851848-b.mntp1.il.home.com</A> [24.22.234.61])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id DAA30457
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Wed, 20 Sep 2000 03:17:05 -0400
Received: (from <A HREF="mailto:bob@localhost">bob@localhost</A>)
	by tux.yi.org (8.9.3/8.9.3/Debian 8.9.3-21) id HAA09684;
	Wed, 20 Sep 2000 07:14:11 GMT
Date: Wed, 20 Sep 2000 07:14:11 +0000
From: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
To: Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;
Cc: &quot;Todd L. Miller&quot; &lt;<A HREF="mailto:tmiller@haverford.edu">tmiller@haverford.edu</A>&gt;, John Leuner &lt;<A HREF="mailto:jewel@mweb.co.za">jewel@mweb.co.za</A>&gt;,
        Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
Subject: Re: Java Virtual Machine Development
Message-ID: &lt;<A HREF="mailto:20000920071411.A9668@tux.yi.org">20000920071411.A9668@tux.yi.org</A>&gt;
References: &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt; &lt;<A HREF="mailto:20000916001524.B3063@tux.yi.org">20000916001524.B3063@tux.yi.org</A>&gt; &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt; &lt;<A HREF="mailto:20000919035256.A331@tux.yi.org">20000919035256.A331@tux.yi.org</A>&gt; &lt;<A HREF="mailto:3.0.1.32.20000919094941.006da2dc@pop.mindspring.com">3.0.1.32.20000919094941.006da2dc@pop.mindspring.com</A>&gt;
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i
In-Reply-To: &lt;<A HREF="mailto:3.0.1.32.20000919094941.006da2dc@pop.mindspring.com">3.0.1.32.20000919094941.006da2dc@pop.mindspring.com</A>&gt;; from <A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A> on Tue, Sep 19, 2000 at 09:49:41AM -0400

Hi Gilbert

I don't think there's anything in your email that Todd and John couldn't
see, so i've included them in my reply.

I'm not sure what you mean by &quot;bytecode cache&quot;.  Could you explain it in
more detail?  Are you talking about this email from last year?

&lt;URL:<A HREF="http://jos.org/pipermail/arch/1999-November/000325.html">http://jos.org/pipermail/arch/1999-November/000325.html</A>&gt;

# What is a bytecode cache? There are plenty of options. You might
# install a bytecode cache servlet in your Java-enabled HTTP server.
# Configure it for cache size and trusted Internet websites and you're
# done. Everyone on the network can use all your applications.
#
# You might install package files on a static HTTP server. You might
# install the bytecode cache daemon on a server and skip the HTTP thing.
# What does it really mean to install an application. For everyone that
# just wants to take it for a test drive, they just run it. Distributing
# the bytecode -- that is what a network is for, isn't it?

What you talk about in the above email is a way of caching information
so that you don't have to download it again.  This does not save any
memory at the JVM level.

If you look at the classfile data structure you will see that it is
optimized for size.  This means it has to be convert into an internal
data
structure before it can be used by a JVM [1].  Only having to load this
internal data structure once is where you get the saving when you use
multiple Java processes.

If the &quot;bytecode cache&quot; contains this internal data structure then it
might save memory but not otherwise.

Robert Fitzsimons
<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>

1.  Any developer that writes a JVM that used the classfile directly as
it's internal data structure should be shot IMHO.

On Tue, Sep 19, 2000 at 09:49:41AM -0400, Gilbert Carl Herschberger II wrote:
&gt;<i> &gt;Basically the goal for multiple Java processes is to save memory by not
</I>&gt;<i> &gt;having multiple copies of the same information in memory.
</I>&gt;<i>
</I>&gt;<i> The goal is to save &quot;memory&quot; by /any/ mechanism, not just multiple
</I>&gt;<i> bytecode
</I>&gt;<i> processes. Multiple bytecode process is not required. It is only one
</I>&gt;<i> approach to this problem. Unfortunately, it seems to be the least
</I>&gt;<i> likely to
</I>&gt;<i> succeed.
</I>&gt;<i>
</I>&gt;<i> Most of the potential to save &quot;memory&quot; seems to come from specifically
</I>&gt;<i> optimizing a virtual machine to use the kernel's virtual memory
</I>&gt;<i> manager
</I>&gt;<i> properly. Bytecode in virtual memory should be marked &quot;read-only&quot;, not
</I>&gt;<i> &quot;read-write&quot;. It should be stored in a system-wide bytecode cache.
</I>&gt;<i>
</I>&gt;<i> Think about it. The potential to save memory is limited. An
</I>&gt;<i> application
</I>&gt;<i> that has 10MB of object data will always have 10MB of object data.
</I>&gt;<i> Most of
</I>&gt;<i> the potential to save memory is found inside the duplication of raw
</I>&gt;<i> bytecode. Is it necessary to define multiple Java processes in order
</I>&gt;<i> to
</I>&gt;<i> save memory? No. Is multiple Java processes the only way to save
</I>&gt;<i> memory?
</I>&gt;<i> No. Could there be a simpler alternative that saves just as much
</I>&gt;<i> memory, or
</I>&gt;<i> more? Yes. Is there a platform-independent solution? Yes.
</I>&gt;<i>
</I>&gt;<i> Without a bytecode cache, if there are 4MB of the same read/write
</I>&gt;<i> bytecode
</I>&gt;<i> per virtual machine and there are 100 virtual machines, that's 400MB
</I>&gt;<i> of
</I>&gt;<i> wasted swap space. With a bytecode cache, the same scene would require
</I>&gt;<i> 4MB
</I>&gt;<i> of swap space. By making bytecode a resource, it requires no swap
</I>&gt;<i> space.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> So much effort has been consumed (wasted?) by the theory of multiple
</I>&gt;<i> bytecode processes. The theory of multiple bytecode processes has been
</I>&gt;<i> adopted and assumed by some without a lot of thought. It is a theory
</I>&gt;<i> that
</I>&gt;<i> may have never been challenged. I'll challenge it. By comparing
</I>&gt;<i> multiple
</I>&gt;<i> bytecode processes within a virtual machine to a highly optimized
</I>&gt;<i> virtual
</I>&gt;<i> machine, I have concluded that multiple bytecode processes within the
</I>&gt;<i> same
</I>&gt;<i> virtual machine does not &quot;save&quot; memory. Instead, it adds far too much
</I>&gt;<i> complexity to the internal workings of a virtual machine. When the
</I>&gt;<i> solution
</I>&gt;<i> is reduced, it requires just as much memory to run multiple bytecode
</I>&gt;<i> processes as it does to run multiple virtual machines. It is six of
</I>&gt;<i> one,
</I>&gt;<i> half dozen of the other.
</I>&gt;<i>
</I>&gt;<i> Add a bytecode cache and bytecode resource to an off-the-shelf virtual
</I>&gt;<i> machine and this saves potentially all of the memory that might be
</I>&gt;<i> saved by
</I>&gt;<i> multiple bytecode processes.
</I>
--ZPt4rx8FFjLCG7dd
Content-Type: message/rfc822
Content-Disposition: inline

X-POP3-Rcpt: <A HREF="mailto:robfitz@host4.the-web-host.com">robfitz@host4.the-web-host.com</A>
Received: from 273k.net
	by localhost with POP3 (fetchmail-5.3.3)
	for <A HREF="mailto:bob@localhost">bob@localhost</A> (single-drop); Thu, 21 Sep 2000 13:46:32 +0000 (UTC)
Received: from smtp10.atl.mindspring.net (smtp10.atl.mindspring.net [207.69.200.246])
	by host4.the-web-host.com (8.9.3/8.9.3) with ESMTP id JAA00811
	for &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;; Thu, 21 Sep 2000 09:12:33 -0400
Received: from gchii.mindspring.com (user-38ld4d4.dialup.mindspring.com [209.86.145.164])
	by smtp10.atl.mindspring.net (8.9.3/8.8.5) with SMTP id JAA13728;
	Thu, 21 Sep 2000 09:12:26 -0400 (EDT)
Message-Id: &lt;<A HREF="mailto:3.0.1.32.20000921090909.006bec64@pop.mindspring.com">3.0.1.32.20000921090909.006bec64@pop.mindspring.com</A>&gt;
X-Sender: <A HREF="mailto:gchii@pop.mindspring.com">gchii@pop.mindspring.com</A>
X-Mailer: Windows Eudora Light Version 3.0.1 (32)
Date: Thu, 21 Sep 2000 09:09:09 -0400
To: Robert Fitzsimons &lt;<A HREF="mailto:robfitz@273k.net">robfitz@273k.net</A>&gt;
From: Gilbert Carl Herschberger II &lt;<A HREF="mailto:gchii@mindspring.com">gchii@mindspring.com</A>&gt;
Subject: Re: Java Virtual Machine Development
Cc: &quot;Todd L. Miller&quot; &lt;<A HREF="mailto:tmiller@haverford.edu">tmiller@haverford.edu</A>&gt;, John Leuner &lt;<A HREF="mailto:jewel@mweb.co.za">jewel@mweb.co.za</A>&gt;
In-Reply-To: &lt;<A HREF="mailto:20000920030605.A1280@tux.yi.org">20000920030605.A1280@tux.yi.org</A>&gt;
References: &lt;<A HREF="mailto:3.0.1.32.20000919094941.006da2dc@pop.mindspring.com">3.0.1.32.20000919094941.006da2dc@pop.mindspring.com</A>&gt;
 &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt;
 &lt;<A HREF="mailto:20000916001524.B3063@tux.yi.org">20000916001524.B3063@tux.yi.org</A>&gt;
 &lt;<A HREF="mailto:Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu">Pine.LNX.4.20.0009160045060.3702-100000@azaphrael.haverford.edu</A>&gt;
 &lt;<A HREF="mailto:20000919035256.A331@tux.yi.org">20000919035256.A331@tux.yi.org</A>&gt;
 &lt;<A HREF="mailto:3.0.1.32.20000919094941.006da2dc@pop.mindspring.com">3.0.1.32.20000919094941.006da2dc@pop.mindspring.com</A>&gt;
Mime-Version: 1.0
Content-Type: text/plain; charset=&quot;us-ascii&quot;

Hmm. Shouldn't we discuss this openly, on the kernel mailing list?

At 03:06 AM 9/20/00 +0000, you wrote:
&gt;<i>I'm not sure what you mean by &quot;bytecode cache&quot;.  Could you explain it in
</I>&gt;<i>more detail?
</I>
&gt;<i>Are you talking about this email from last year?
</I>&gt;<i>
</I>&gt;<i>&lt;URL:<A HREF="http://jos.org/pipermail/arch/1999-November/000325.html">http://jos.org/pipermail/arch/1999-November/000325.html</A>&gt;
</I>
No, no. That bytecode cache is a network bytecode cache. It enables a
network to cache bytecode at an HTTP, SQL, application or proxy server.

The kernel bytecode cache is system-wide and enables a kernel to cache
bytecode for multiple virtual machines and/or multiple bytecode processes.

&gt;<i>What you talk about in the above email is a way of caching information
</I>&gt;<i>so that you don't have to download it again.  This does not save any
</I>&gt;<i>memory at the JVM level.
</I>
A network bytecode cache reduces the amount of time required to download
bytecode; it does not save memory.

In contrast, a kernel bytecode cache saves memory; it does not reduce the
amount of time required to download bytecode. This is the kind of bytecode
cache I was describing.

&gt;<i>If you look at the classfile data structure you will see that it is
</I>&gt;<i>optimized for size.  This means it has to be convert into an internal data
</I>&gt;<i>structure before it can be used by a JVM [1].  Only having to load this
</I>&gt;<i>internal data structure once is where you get the saving when you use
</I>&gt;<i>multiple Java processes.
</I>
Let's see if I understand this correctly. You say that the classfile data
structure is optimized for size. You also agree that our goal is the
conservation of memory, a very precious resource. If the classfile is
already optimize for size and size matters, we can use classfile data
structure to save memory.

&gt;<i>If the &quot;bytecode cache&quot; contains this internal data structure then it
</I>&gt;<i>might save memory but not otherwise.
</I>
You're saying that an internal data structure cache is the /only/ way to
save memory; but, it's not. Such a cache can contain bytecode, internal
data structures, or both and still save memory.

There is more than one way to construct a kernel bytecode cache, not just
one. While you may desire a cache that throws away the original bytecode
and saves internal data structures, I would like it to keep the original
bytecode.

I believe there are many reasons to save the original bytecode. Here are a
few.

1. The bytecode cache is vm-independent. An internal data structure is
always specific to a virtual machine. The internal data structure should be
internal to a virtual machine. It should not be exposed to a kernel and/or
other virtual machines. Multiple virtual machines should not share a common
internal data structure. If a virtual machine is optimized for speed, its
internal data structure is optimized for speed. If a virtual machine is
optimized for size, its internal data structure is optimized for size. And
so on.

2. Two classes are able to modify the state of an object if they are
equivalent. They are obviously equivalent if they share the same bytecode.
They are also obviously equivalent if there bytecode is matches
byte-for-byte. The internal data structure is more difficult, but not
impossible, to compare.

3. Boot classes can be statically linked to a kernel. The java.lang,
java.util, java.io and java.net packages, for example, can be pre-loaded in
a kernel bytecode cache. There are many examples of where this can save
space. When a virtual machine &quot;loads&quot; its boot classes directly from the
kernel, this saves time and opens up the possibility of downloading the
remainder of the standard Java class library from across the network.

For a MPCL-compatible virtual machine, it always &quot;loads&quot; its boot classes
directly from the kernel. Boot classes are guaranteed to be equivalent and
conserve memory in every bytecode process because CLASSPATH is not used for
boot classes. Also, static fields are unique for each primordial class
loader making that part of a bytecode process independent from all other
bytecode processes.

On the other hand, a similar cache is required within a virtual machine. It
is not a bytecode cache, but an internal class structure cache. The
internal class structure cache is part of a virtual machine, not a kernel.
It cannot be safely shared among virtual machines.

The operation of an internel class structure cache seems to be redundent
with the operation of a kernel bytecode cache. Is it? No. Here's why.

If we build five virtual machines, we must build five internal class
structure caches because the internal class structure is always unique to a
virtual machine. It might be a class hiearchy like this:

InternalClassStructureCache
  |
  +-- DecafInternalClassStructureCache
  |
  +-- KaffeInternalClassStructureCache
  |
  +-- JapharInternalClassStructureCache
  |
  +-- KissmeInternalClassStructureCache

There must be five different caches because the internel class structure of
one virtual machine does not match any other.

If we build five virtual machines, we build one kernel bytecode caches, not
five.

KernelBytecodeCache

There seems to be a fixation on the one kernel/one virtual machine
implementation. Why is this? It is not the only way. When decaf, Kaffe,
Japhar and Kissme are running at the same time on one kernel, there is one
kernel/multiple virtual machines. The maximum amount of conservation comes
from integrating the kernel bytecode cache with a virtual memory manager.
Bytecode that is not &quot;in use&quot; does not have to be stored in real memory.

In the future, it is more likely that multiple instances of a virtual
machine will be running on a kernel. It is more likely they will use a
preemptive multitasking kernel. This is also one kernel/multiple virtual
machines.

With John's proof of concept, it is more likely we'll use more of the Linux
kernel. And please don't try to convince me that only one instance of decaf
will ever be running on a kernel. Today, we're using the Linux kernel to
run decaf in host mode. Multiple instances of decaf can be running at the
same time on a Linux kernel. While this might not be ideal, it is real.

&gt;<i>1.  Any developer that writes a JVM that used the classfile directly as
</I>&gt;<i>it's internal data structure should be shot IMHO.
</I>
When the stated goal is optimization for size, it seems obvious that a
classfile format is the best choice. It is already optimized for size. It
is undesireable and unnecessary to duplicate the data that is already
stored inside raw bytecode.

1. constant pool (class names, field names, method names, attribute names)
2. field table
3. method table
4. code attribute of a method
5. exception attribute of a method

Measured in bytes, more than 90% of my internal data structure is already
stored appropriately in raw bytecode. I see no need to duplicate 90% in
order to save 10% for each primordial class loader. I'd rather save the 90%.

When the stated goal is optimization for speed, size doesn't matter.
Conservation of memory is not an issue. The code attribute of all methods
can be compiled into machine code. The machine code has to be stored
somewhere in real memory. This is the domain of an internal data structure
for a virtual machine, not a system-wide kernel bytecode cache. For
multiple bytecode processes, classes must be compiled at least once for
each CLASSPATH.

I am doing whatever I can to understand the implications of my stated goal.
I am building a bytecode interpreter optimized for size. I have every
reason to believe the original bytecode is critical to my design. I
continue to combine bytecode resource and bytecode cache to save memory.

--ZPt4rx8FFjLCG7dd--


</pre>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000913.html">[JOS-Kernel] [kernel machine code cache] Definition</A></li>
	<LI> Next message: <A HREF="000916.html">[JOS-Kernel] Starting a program</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#915">[ date ]</a>
              <a href="thread.html#915">[ thread ]</a>
              <a href="subject.html#915">[ subject ]</a>
              <a href="author.html#915">[ author ]</a>
         </LI>
       </UL>
</body></html>
