From tmiller@haverford.edu Wed, 2 Jun 1999 22:45:48 -0400 (EDT)
Date: Wed, 2 Jun 1999 22:45:48 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] decaf/JJOS: keyboard driver

	Monitors & all, decaf & its keyboard driver are on CVS for your
viewing pleasure.  It works, but is mostly incomplete.  (I have a JVM to
work on, all you device-driver people :))

	Things fixed: a nasty bug in invokeinterface (which I think I had
found before and lost in the great refactoring); a nasty bug in
tableswitch (which might mean lookupswitch is also broken, haven't checked
yet); several less-nasty bugs in the Java code; a minor correction to
checkcast ( NULL/null values cast to everything ); other minor fixes en
route.  Made several small changes to make the output prettier.  (Turned
off dot-each-clock printing, interrupt #9 notification, etc.)  Because
decaf still lacks support for exceptions, I had to add some work-around
code for the translation table.

	Known problems: can't get it to boot via GRUB, even w/ robfitz's
patch & makefile.  GRUB complains that it's in an invalid file format.
We're still stuck with EtherBoot for now.  (robfitz, if you could help me
out with this, I'd much appreciate it.  Email me off-list.)  The
jos.system.event.KeyEvent.VK_* constants aren't right, except for VK_A
through VK_Z and VK_1 throught VK_10.  Someone who feels like being
helpful could finish the rest of the mapping.  (Why not use AWT?  Long
story.  Why not copy the source?  Possible legal complications.  Luckily, 
most of it's ASCII... er, unicode.)  I haven't finished porting Albrecht's
code over, so the keyboard doesn't do nifty things like type upper-case
letters :)  Oh -- it only works with standard 102 key keyboards, so if
you've got something funky, write us a driver.

	Let us know if you hit any snags.

-_Quinn

"All the world's a JVM, and we are but bytecodes in it, tying to remember
our line-numbers." -- William Sunspear




From onewith1@flash.net Thu, 3 Jun 1999 22:21:29 -0500
Date: Thu, 3 Jun 1999 22:21:29 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Kernel] Re: monitors in decaf


----------
> From: Todd L. Miller <tmiller@haverford.edu>
> To: John Morrison <jm@mak.com>
> Cc: onewith1@flash.net
> Subject: monitors in decaf
> Date: Sunday, May 30, 1999 12:12 AM
> 	Matt: this is to let you know that the latest stuff in CVS
> supports everything but throws (recognizes them and complains) and
> instanceof / checkcast, where the function that compares classes to each
> other (checkcast()) isn't completely finished yet -- it, by default, will
> let casts go through; in general, avoid writing something that depends on
> exceptions to work properly.  -- That list is, of course, not gaurenteed
> to be complete.  As you see above, large chunks of the java class library
> can behave erratically.
> 
> 	This might suggest it would be wise, for the time being, NOT to
> use the AWT KeyEvent, but clone it / expand jos.system.event.KeyEvent to
> do the things the AWT's KeyEvent does.  (Most importantly, offer all
three
> event types, and (unicode) character and keycode information with each
> message.)
I'm re-working the CVSed Java files "in my own image", so that I can
actually do some testing.  Also, I've cut-n-paste out the java.awt.KeyEvent
into jos.system.event.KeyEvent to make a clone of it.  In my view that
makes us a bit more stable than depending on a bunch of awt stuff, which
has no place in the kernel.

> 
> 	As you can probably tell from looking at the source,
> jos/platform/driver should contain the software that converts from the
> hardware (i.e. jos.system.KeyEvent events generated by the
> jos.system.keyboard abstraction -- which, perhaps, should be moved to the
> driver class?) into the JOS platform (i.e. the virtualized hardware used
> to interface w/ the O/S).  This particular division also suggests moving
> jos.system.interrupts, InterruptHandler, InterruptDispatcher, machine,
and
> keyboard to jos.platform, leaving console and consoled in jos.system, but
> I'm not picky and I'm pretty sure the tree doesn't match what's posted as
> the 'standard' on the WikiWeb anyway.  Once we get the
scancode->character
> stuff working, it might be worthwhile to move things around.
I'll try that out in my mucking around.


-Matt



From tmiller@haverford.edu Mon, 7 Jun 1999 20:44:06 -0400 (EDT)
Date: Mon, 7 Jun 1999 20:44:06 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] decaf updates

	Rewrote checkcast(); it's only missing the checks for casting
/from/ an array, which I'll add in the near future.  Added an
interface_list pointer to java_class because checkcast() needs to be able
to check it; probably included some other small and sundry bug-fixes
en-route.

	Anyway, I'm now looking at tackling java throws.  Throws generated
by the java code itself should be relatively easy to handle.  Throws
generated by the VM in runOpCode() should be somewhat more difficult, but
nonetheless straightforward.  The problem will be in handling exceptions
generated by functions called from w/in runOpcode() and their sundry and
various sub-functions.  I am loathe to put the exception is some global
area and put a check in at the end of runOpcode(); it's not terribly
elegant and will die a horribly screaming death if we ever have multiple
native processes.  JM, I know you've got the hood open, so to speak, right
now?  Do you, or does anyone else, have any suggestions, aside from rather
gruntingly brute-force "rewrite everything to return an exception pointer"
approach?

	Note that access to a classloader might be problematic as well --
the JVM needs to generate java_objects to point to for these exceptions,
though this might be done by some other code than the originator at some
later point in time.  [A global 'enviroment' table with the
JVM-generatable exception classes in it?  (which each carry their own
classloader)]

-_Quinn




From jm@mak.com Wed, 09 Jun 1999 09:39:41 -0400
Date: Wed, 09 Jun 1999 09:39:41 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Progress report.

Hi Todd et al;

I am so sorry to be taking so long to finish what I'm doing.

Here's the Short Version:  The opcode-execution global fcns are now frame
methods.  I have neither merged my local mods with Todd's latest committed
changes nor committed my own changes.  Yet.

The Longer Version:

(1) The opcode-execution functions should now be much more efficient (and
significantly simpler to read/understand) as methods of the frame class, in that
they now avoid at least one level of indirection for almost everything they do. 
This actually entailed more extensive mods than I originally thought.

(2) I have made moved duplicative code from the global functions into methods of
the various classes (java_thread, java_class, frame).

(3) I propagated the active thread throughout the class loading, linking,
preparing, and resolving steps because I thought I could, at this stage, and
prior to having native threads, handle this entirely WITHOUT keeping context in
native stacks.  This would enable the scheduler to know which thread was
running, and it would enable a debugger to know, and it would enable pre-emption
of static initializers.  I was wrong, wrong, wrong.  I do not know whether I
should back these changes out, or leave them in (they don't seem to break
anything).

(4) In perusing this machinery, I think there are some further changes I might
like to make with respect to how classes are known to be
resolved/linked/whatever, and, in specific, when the initializer threads get
spawned (right now they get spawned really early, but don't get executed, so
there are a LOT of dormant threads lying about).  I shall discuss these with
Todd after I commit the merged changes.

(5) I need to merge Todd's latest changes in, retest, and then commit.

(6) I have not (cannot?) build the latest Java source successfully.  Todd, would
you please be so kind as to put your latest successful zipfile (compressed, of
course) somewhere I can FTP it from?  Then I can test my merged changes before I
commit them so as not to break anything.  It would also help if you put a
logfile (obviously, host build only) showing me what output to expect.

Thanks,

-jm

-- 
==== John Morrison            ==== MaK Technologies, Inc.
==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA 02138
==== jm@mak.com               ==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115    ==== fax:617-876-9208



From jm@mak.com Wed, 09 Jun 1999 09:48:30 -0400
Date: Wed, 09 Jun 1999 09:48:30 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] decaf updates

Hi;

Todd L. Miller wrote:
>         Anyway, I'm now looking at tackling java throws.  Throws generated
> by the java code itself should be relatively easy to handle.  Throws
> generated by the VM in runOpCode() should be somewhat more difficult, but
> nonetheless straightforward.  The problem will be in handling exceptions
> generated by functions called from w/in runOpcode() and their sundry and
> various sub-functions.  I am loathe to put the exception is some global
> area and put a check in at the end of runOpcode(); it's not terribly
> elegant and will die a horribly screaming death if we ever have multiple
> native processes.  JM, I know you've got the hood open, so to speak, right
> now?  Do you, or does anyone else, have any suggestions, aside from rather
> gruntingly brute-force "rewrite everything to return an exception pointer"
> approach?

Based upon a whole 5 seconds of thought, I think you can handle both the "code
itself" and "functions called from w/in runOpcode" cases the same way.  Since
they're (just about) frame methods, you can call a frame/java_thread method to
pop the appropriate stack frames in the classical fashion.  Right?

>         Note that access to a classloader might be problematic as well --
> the JVM needs to generate java_objects to point to for these exceptions,
> though this might be done by some other code than the originator at some
> later point in time.  [A global 'enviroment' table with the
> JVM-generatable exception classes in it?  (which each carry their own
> classloader)]

Based upon another whole 5 seconds of thought, the only nasty problem I can
think of is (if there is?) an "out of memory" exception (it would Truly Suck to
be out of memory and then have to allocate an "out of memory" exception to
throw).  One might want to have a preallocated exception allocated for that
case.

-jm

-- 
==== John Morrison            ==== MaK Technologies, Inc.
==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA 02138
==== jm@mak.com               ==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115    ==== fax:617-876-9208



From tmiller@haverford.edu Wed, 9 Jun 1999 11:32:47 -0400 (EDT)
Date: Wed, 9 Jun 1999 11:32:47 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Re: Progress report.

> (2) I have made moved duplicative code from the global functions
> into methods of the various classes (java_thread, java_class, frame).

	Increasing their efficiency as well, I'd imagine.

> (3) I propagated the active thread throughout the class loading, linking,
> preparing, and resolving steps because I thought I could, at this stage, and
> prior to having native threads, handle this entirely WITHOUT keeping context in
> native stacks.  This would enable the scheduler to know which thread was
> running, and it would enable a debugger to know, and it would enable pre-emption
> of static initializers.  I was wrong, wrong, wrong.  I do not know whether I
> should back these changes out, or leave them in (they don't seem to break
> anything).

	They might be useful later on (viz: exceptions).  But why doesn't
propogating the thread throughout allow for pre-emptive static
initializers?

> (4) In perusing this machinery, I think there are some further changes I might
> like to make with respect to how classes are known to be
> resolved/linked/whatever, and, in specific, when the initializer threads get
> spawned (right now they get spawned really early, but don't get executed, so
> there are a LOT of dormant threads lying about).  I shall discuss these with
> Todd after I commit the merged changes.

	Right now, threads don't cost a whole lot more than frames do, and
they're a little more convenient.  We could get away with nothing more
than a pointer to the opcodes, but that's probably inflicting unnecessary
pain on ourselves.

> (6) I have not (cannot?) build the latest Java source successfully.  Todd, would
> you please be so kind as to put your latest successful zipfile (compressed, of
> course) somewhere I can FTP it from?  Then I can test my merged changes before I
> commit them so as not to break anything.  It would also help if you put a
> logfile (obviously, host build only) showing me what output to expect.

	Sure thing.  Has anyone else had problems building the latest java
sources?

-_Quinn




From jm@mak.com Wed, 09 Jun 1999 10:54:17 -0400
Date: Wed, 09 Jun 1999 10:54:17 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Re: Progress report.

Hi Todd;

Todd L. Miller wrote:
> 
> > (2) I have made moved duplicative code from the global functions
> > into methods of the various classes (java_thread, java_class, frame).
> 
>         Increasing their efficiency as well, I'd imagine.

Well, I don't know that it's any more efficient (there is now subroutine
overhead), but it shrinks the size of the executable (a good thing), and, since
we'll probably be revisiting the initialization phase (when we get native
threads), it'll mean we've only got to muck about in one place.  (Also,
hopefully, it's easier to understand for new code-readers/contributors.)

> > (3) I propagated the active thread throughout the class loading, linking,
> > preparing, and resolving steps because I thought I could, at this stage, and
> > prior to having native threads, handle this entirely WITHOUT keeping context in
> > native stacks.  This would enable the scheduler to know which thread was
> > running, and it would enable a debugger to know, and it would enable pre-emption
> > of static initializers.  I was wrong, wrong, wrong.  I do not know whether I
> > should back these changes out, or leave them in (they don't seem to break
> > anything).
> 
>         They might be useful later on (viz: exceptions).  But why doesn't
> propogating the thread throughout allow for pre-emptive static
> initializers?

It's a necessary (but not sufficient) condition for pre-emptive initializers. 
There were some complications.  You know how the PC value is
incremented/decremented at several places in the runOpcode/runInvoke methods? 
Well, in order to pre-empt, I'd have to absolutely back out of the instruction
completely so as to enable a clean restart, and the PC is mucked about with in
literally dozens of places (and I would have had to chase them all down and
verify that I hadn't broken anything).  So, I wimped out.

The threads are also created pretty far down in the bowels of the resolution
machinery, and I would've had to "throw" (conceptually, anyways) all the way
back up the native stack, and catch it in an utterly clean way (e.g., don't
create garbage, although a Boehm-whatever GC would help), and back out of the
offending opcode, and then make sure all the state machinery of the various
classes (java_class, java_thread, class_loader, etc.) were all restartable. 
Maybe also "wait" the current thread on the initializer thread.  Seemed like too
big a job at this point.  So, more reasons to wimp out.  Alternatively, we can
punt on this until we get native threads, and then just keep the context on the
native stack.

> > (4) In perusing this machinery, I think there are some further changes I might
> > like to make with respect to how classes are known to be
> > resolved/linked/whatever, and, in specific, when the initializer threads get
> > spawned (right now they get spawned really early, but don't get executed, so
> > there are a LOT of dormant threads lying about).  I shall discuss these with
> > Todd after I commit the merged changes.
> 
>         Right now, threads don't cost a whole lot more than frames do, and
> they're a little more convenient.  We could get away with nothing more
> than a pointer to the opcodes, but that's probably inflicting unnecessary
> pain on ourselves.

Fine -- the changes I was talking about are (more or less) to address those
resolution concerns (especially when we get user-provided class loaders).

> > (6) I have not (cannot?) build the latest Java source successfully.  Todd, would
> > you please be so kind as to put your latest successful zipfile (compressed, of
> > course) somewhere I can FTP it from?  Then I can test my merged changes before I
> > commit them so as not to break anything.  It would also help if you put a
> > logfile (obviously, host build only) showing me what output to expect.
> 
>         Sure thing.  Has anyone else had problems building the latest java
> sources?

I confess I haven't tried to rebuild them yet since you all have reduced
dependencies upon AWT (I just got as far as I described in my email this
morning, and haven't gotten any further).

Later!

-jm

-- 
==== John Morrison            ==== MaK Technologies, Inc.
==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA 02138
==== jm@mak.com               ==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115    ==== fax:617-876-9208



From tmiller@haverford.edu Wed, 9 Jun 1999 11:58:56 -0400 (EDT)
Date: Wed, 9 Jun 1999 11:58:56 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] decaf updates

> Based upon a whole 5 seconds of thought, I think you can handle both the "code
> itself" and "functions called from w/in runOpcode" cases the same way.  Since
> they're (just about) frame methods, you can call a frame/java_thread method to
> pop the appropriate stack frames in the classical fashion.  Right?

	 Now that you've written the thread pointer in, yes.  Otherwise,
whose stack do I pop/pc do I manipulate?  I want to call
thread->throwExecption( new IndexOutOfBoundsException() ) and have
everything happen automagically.  The problem is the return values --
runOpcode() /must/ return, which (AFAIK) means that the function called
from runOpcode() /must itself/ return, and in some fashion that prevents
runOpcode() from doing Bad Things.  The obvious way would be C++
exceptions causing a jump to the throwException() handler, which does the
Right Thing w.r.t. to its java_thread (and, BTW, also means that I don't
have to make sure that /every/ function gets the current thread pointer),
so that the next time the java_thread runs, it's running the 
exception-handling opcodes, and then returns to the scheduler (which
might be somewhat problematic).  Since, AFAIK, JJOS doesn't support 
exceptions, that route is closed.

	Without exceptions, you can pass the thread along, (just modifying
all the function headers is non-trivial) but the problem
of returning to the scheduler still exists.*

> Based upon another whole 5 seconds of thought, the only nasty problem I can
> think of is (if there is?) an "out of memory" exception (it would Truly Suck to
> be out of memory and then have to allocate an "out of memory" exception to
> throw).  One might want to have a preallocated exception allocated for that
> case.

	Yes.  The problem I was thinking about had more to deal with the
problem of creating a java instance (i.e. IndexOutOfBoundsException) from
the nativecode that didn't have access to the classloader.  Though this
could probably be gotten around.

-_Quinn

* The only idea that would save me from having to rewrite all the return
values and function calls would be some bit of (machine?) code that would
pop the stack until it got back to scheduler, perhaps set at the beginning
of the runOpcode() call.  But I have no idea how to do this.




From tmiller@haverford.edu Wed, 9 Jun 1999 12:06:42 -0400 (EDT)
Date: Wed, 9 Jun 1999 12:06:42 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Re: Progress report.

[PC stuff]

	Yeesh.  Had forgotten about that.  Reason enough for me :)

[other stuff]

	Basically its too complicated to be worth it right now.  (At
least, the way things are set up at this point.)

> I confess I haven't tried to rebuild them yet since you all have reduced
> dependencies upon AWT (I just got as far as I described in my email this
> morning, and haven't gotten any further).

	Okay.  Here's hoping everything works.

-_Quinn




From jm@mak.com Wed, 09 Jun 1999 12:50:58 -0400
Date: Wed, 09 Jun 1999 12:50:58 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] decaf updates

Hi;

Todd L. Miller wrote:
> 
> > Based upon a whole 5 seconds of thought, I think you can handle both the "code
> > itself" and "functions called from w/in runOpcode" cases the same way.  Since
> > they're (just about) frame methods, you can call a frame/java_thread method to
> > pop the appropriate stack frames in the classical fashion.  Right?
> 
>          Now that you've written the thread pointer in, yes.  Otherwise,
> whose stack do I pop/pc do I manipulate?  I want to call
> thread->throwExecption( new IndexOutOfBoundsException() ) and have
> everything happen automagically.  The problem is the return values --
> runOpcode() /must/ return, which (AFAIK) means that the function called
> from runOpcode() /must itself/ return, and in some fashion that prevents
> runOpcode() from doing Bad Things.  The obvious way would be C++
> exceptions causing a jump to the throwException() handler, which does the
> Right Thing w.r.t. to its java_thread (and, BTW, also means that I don't
> have to make sure that /every/ function gets the current thread pointer),
> so that the next time the java_thread runs, it's running the
> exception-handling opcodes, and then returns to the scheduler (which
> might be somewhat problematic).  Since, AFAIK, JJOS doesn't support
> exceptions, that route is closed.

I'm afraid I don't understand: why can't you just call some sort of member
function like:
	bool frame::throwException(java_object *);
or
	bool java_thread::throwException(java_object *);

It would unwind the frame stack to the "right" frame (based upon either an
explicit exception stack or a traversal of the frames).  frame::runOpcode would
simply return "true" to indicate that the thread should continue execution.  The
next java_thread::runOpcode calls currentFrame()->runOpcode(), and you get the
"right" frame.  (I'm presuming that exception handlers are simply different PC
locations within a given frame -- right?)  I'm thinking this will All Just Work.

>         Without exceptions, you can pass the thread along, (just modifying
> all the function headers is non-trivial) but the problem
> of returning to the scheduler still exists.*
> 
> > Based upon another whole 5 seconds of thought, the only nasty problem I can
> > think of is (if there is?) an "out of memory" exception (it would Truly Suck to
> > be out of memory and then have to allocate an "out of memory" exception to
> > throw).  One might want to have a preallocated exception allocated for that
> > case.
> 
>         Yes.  The problem I was thinking about had more to deal with the
> problem of creating a java instance (i.e. IndexOutOfBoundsException) from
> the nativecode that didn't have access to the classloader.  Though this
> could probably be gotten around.

I think the java_thread's java_class keeps a reference to its class loader lying
about, although I'll have to check.

> * The only idea that would save me from having to rewrite all the return
> values and function calls would be some bit of (machine?) code that would
> pop the stack until it got back to scheduler, perhaps set at the beginning
> of the runOpcode() call.  But I have no idea how to do this.

Obviously, I'm hoping we don't need to do this...

-jm
-- 
==== John Morrison            ==== MaK Technologies, Inc.
==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA 02138
==== jm@mak.com               ==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115    ==== fax:617-876-9208



From tmiller@haverford.edu Wed, 9 Jun 1999 14:35:24 -0400 (EDT)
Date: Wed, 9 Jun 1999 14:35:24 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] decaf updates

> I'm afraid I don't understand: why can't you just call some sort of member
> function like:
> 	bool frame::throwException(java_object *);
> or
> 	bool java_thread::throwException(java_object *);
>
> It would unwind the frame stack to the "right" frame (based upon either an
> explicit exception stack or a traversal of the frames).  frame::runOpcode would
> simply return "true" to indicate that the thread should continue execution.  The
> next java_thread::runOpcode calls currentFrame()->runOpcode(), and you get the
> "right" frame.  (I'm presuming that exception handlers are simply different PC
> locations within a given frame -- right?)  I'm thinking this will All Just Work.

	Maybe an example is necessary:  I'm three frames deep in a JVM
call, say I'm doing getClass(), which throws a NoSuchClassDefinition
exception.  I /can/ call thread::throwException( NoSuchClassDefinition ),
and all the java-specific things would happen, but, here's the kicker:

	case bc::some_bytecode:
		...
		jc = getClass();
		...
		op_stack.push( jc->fields[x] );
		break;

	...
	return true;

	How does the code AFTER the getClass() call know NOT to push
something on the op_stack after getClass() throws an exception?  I do NOT
want to rewrite every single function call in the JVM to (a) check all of
/its/ calls for exceptions and abort back to runOpcode() (which will in 
turn, have to abort) and (b) return true or false depending on if an
exception was thrown or not.  It's doable now, but it won't be in the
future: native methods that throw exceptions need to be handled (unravel
the native stack same as I mentioned in the last email for intra-JVM
throws); the native portion of the class library (classpath?) is where you
can't get around exception-handling in native methods.  (Rewriting the
classlibrary is a heroic effort and Not The Right Thing To Do, either, I
think.)

	It is difficult but doable to arrange for the native exception to
be converted into a java exception and have the necessary things happen to
the thread's data structures -- the tremendous difficulty is in aborting
the rest of the call(s), all the way back to where the scheduler can move
on to the next timeslice.  It seems to me that we'd be re-writing C++'s
exception codes by hand; further, it seems evident to me that the Right
Way to handle exceptions in native code is with native exceptions, which
would all be trapped and converted in runOpcode().

	Am I being clear about the problem here?

-_Quinn




From tullmann@cs.utah.edu Wed, 9 Jun 1999 13:27:58 -0600
Date: Wed, 9 Jun 1999 13:27:58 -0600
From: Patrick Tullmann tullmann@cs.utah.edu
Subject: [JOS-Kernel] decaf updates

Hi JOSers,

Just wanted to interject some of my experience with threading,
exceptions and JVMs in this discussion.  I'm very familiar with how
all of this stuff works in Kaffe, so I think I've got good
credentials.  On the other hand, I've never looked at any of the JOS
code, so I only understand what you're working on from emails that fly 
back and forth.

Anyway...

Todd wrote:
> I do NOT want to rewrite every single function call in the JVM to
> (a) check all of /its/ calls for exceptions and abort back to
> runOpcode() (which will in turn, have to abort) and (b) return true
> or false depending on if an exception was thrown or not.

Yes you do.  You do want every caller be able to tell if functions it
called have aborted or are aborting.  Without fail, you will define
functions that need to execute special code for handling failures.
I see two ways of doing that.

Originally, Kaffe would throw exceptions from deep within native code
and these exceptions would correctly unwind the native stack all the
way back into Java code, and proceed from there looking for exception
handlers.  This worked fine in most cases.  (As an aside, Kaffe uses
the same stack for Java and native code.)

What we discovered later is that frequently native code needs to do
things like release locks, or free data structures if an error
occurs.  Example

	lock_ClassPool();
	...	
	jc = get_Class(...);
	...
	unlock_ClassPool();
	
If get_Class() throws an error and unwinds the stack, the ClassPool
doesn't get unlocked.  Thus, this caller of get_Class() really needs
to handle the error.  Either a full-blown exception handler (ugly in
C, but see the book _C Interfaces and Implementations_ by David Hanson
for a setjmp-based implementation), or explicit return codes from the
methods.  We opted for explicit returns codes.  At the least, you'll
need to do this in your code that implements exceptions and exception
handling.  (Can't have them throwing errors, now can we?)

On the other hand, as Todd points out:

> the native portion of the class library (classpath?) is where you
> can't get around exception-handling in native methods.

That is, calls into native functions like FileInputStream.read()
should be able to just directly throw exceptions that will unroll the
native stack like they unroll the java stack.  

We decided (err, Godmar Back who designed/implemented this for Kaffe,
decided) to make all VM internal functions return an integer status
code and take an exception description struct.

So, the above code effectively looks like this in Kaffe:

	lock_ClassPool();
	...	
	success = get_Class(..., &errorInfo);
	...
	unlock_ClassPool();

At some point, a caller in an appropriate context will do:

	if (!success)
		throwError(&errorInfo);

Error info contains things like the name of the exception (or an
exception object) and the string message, etc.

throwError() can still be called by any code (e.g., native methods for 
class library functions like read()), but you just have to agree on
what functions/libraries use return codes and which ones are allowed
to throw exceptions willy-nilly.  

I hope this helps some,

Pat

----- ----- ---- ---  ---  --   -    -      -         -               -
Pat Tullmann                                       tullmann@cs.utah.edu
		   ${HOME} is where the .emacs is.



From jm@mak.com Wed, 09 Jun 1999 14:33:03 -0400
Date: Wed, 09 Jun 1999 14:33:03 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] decaf updates

Hi;

Todd L. Miller wrote:
>         Maybe an example is necessary:  I'm three frames deep in a JVM
> call, say I'm doing getClass(), which throws a NoSuchClassDefinition
> exception.  I /can/ call thread::throwException( NoSuchClassDefinition ),
> and all the java-specific things would happen, but, here's the kicker:
> 
>         case bc::some_bytecode:
>                 ...
>                 jc = getClass();
>                 ...
>                 op_stack.push( jc->fields[x] );
>                 break;
> 
>         ...
>         return true;

Um, I think you *have* to check the results, because you cannot afford to
dereference something bad.  We're in OS-land (a.k.a., systems programming land),
not application-land.  There are no guard-rails (a.k.a., memory protection
mechanisms).  We do not want to become (in)famous for our version of the BSOD
(even though I am sure we could pick a more, well, tasteful color, and, perhaps,
put a more interesting text up on the screen like "Hey, at least you didn't PAY
for this!").

However, if one adopts a Lisp-ish functional programming style, in which
routines almost always are structured:

foo *bar::baz(quux *)
{
  if (!quux)
  {
     return(NULL); /* Or perror, etc. */
  }
  else ...
}

it's not so bad.  It will also almost always compile to a single conditional
jump (OK, well, maybe a load followed by a conditional jump), and if the
compiler is smart enough to make it a jump-if-zero (condition codes are usually
set upon a load to a register), then it'll often only take a single machine
cycle because there will be no pipeline flushes because the jump will not often
be taken.  (On the other hand, if the compiler is stupid but predictable, you
can change the polarity of the check, and achieve the same goal.)

>         How does the code AFTER the getClass() call know NOT to push
> something on the op_stack after getClass() throws an exception?  I do NOT
> want to rewrite every single function call in the JVM to (a) check all of
> /its/ calls for exceptions and abort back to runOpcode() (which will in
> turn, have to abort) and (b) return true or false depending on if an

Throwing native exceptions is tricky, and interacts with the memory reclamation
stuff (although, like I said before, a conservative GC can help).

> exception was thrown or not.  It's doable now, but it won't be in the
> future: native methods that throw exceptions need to be handled (unravel
> the native stack same as I mentioned in the last email for intra-JVM
> throws); the native portion of the class library (classpath?) is where you
> can't get around exception-handling in native methods.  (Rewriting the
> classlibrary is a heroic effort and Not The Right Thing To Do, either, I
> think.)

Now, I'm a little out of my depth here, but here goes (somebody correct me if
I'm wrong) -- it is my understanding that native methods are inherently
non-portable, so we have some freedom to define how they should be
compiled/written (if, in fact, we support them in the medium to long term -- we
certainly won't support them in the short term).  Furthermore, given that we
currently envision no memory protection (e.g., separate address spaces for
native methods), allowing native methods is an huge invitation to Bad Things
like BSODs, and viruses, etc.

>         It is difficult but doable to arrange for the native exception to
> be converted into a java exception and have the necessary things happen to
> the thread's data structures -- the tremendous difficulty is in aborting
> the rest of the call(s), all the way back to where the scheduler can move
> on to the next timeslice.  It seems to me that we'd be re-writing C++'s
> exception codes by hand; further, it seems evident to me that the Right
> Way to handle exceptions in native code is with native exceptions, which
> would all be trapped and converted in runOpcode().
> 
>         Am I being clear about the problem here?


When you say "native exception," do you mean C++ "throw," or vanilla-C reference
to memory that ain't there (a.k.a., bus error, address error, memory error)?

-jm

p.s., you want me to stop putting your specific email address on the "To" list
so you get the mail slower, but get only one copy?

-- 
==== John Morrison            ==== MaK Technologies, Inc.
==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA 02138
==== jm@mak.com               ==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115    ==== fax:617-876-9208



From jm@mak.com Wed, 09 Jun 1999 15:02:31 -0400
Date: Wed, 09 Jun 1999 15:02:31 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Native methods [Was Re: [JOS-Kernel] decaf updates]

Hi;

Is it considered Poor Form to follow-up your own message?

Actually, I realized something else that needed to be said AFTER I sent the
message ("Doh!" <slap>):

John Morrison wrote:
> Now, I'm a little out of my depth here, but here goes (somebody correct me if
> I'm wrong) -- it is my understanding that native methods are inherently
> non-portable, so we have some freedom to define how they should be
> compiled/written (if, in fact, we support them in the medium to long term -- we
> certainly won't support them in the short term).  Furthermore, given that we
> currently envision no memory protection (e.g., separate address spaces for
> native methods), allowing native methods is an huge invitation to Bad Things
> like BSODs, and viruses, etc.

It is fair to respond to that last assertion of mine "How is this different from
native methods in Kaffe?" (Hi Patrick!)

Well, typically Kaffe (or your favorite JVM) runs inside of a "real OS"
heavyweight process (I understand this is not always the case -- didn't you guys
retarget Kaffe to your FluxOS toolkit? -- and I'm REALLY sorry if I have
incorrectly attributed this or misnamed/misspelled something).  So, the Bad
Things a native method could do are pretty much limited to the bad things the
user could do.  I know this could be bad if you're administrator/root, but, hey,
at least it puts the brakes on the accidentally stupid (as opposed to outright
malicious) mistakes like scribbling to memory that ain't there -- which is
probably a fairly common thing.  And, running as a non-privileged user limits
(somewhat) the bad things that a malicious thing could do.  (I'm not sure which
would be more common -- e.g., viruses are pretty damned common.)

However, running on bare iron, in a SASOS like jjos+decaf, there's NOTHING it
couldn't do by accident.  Like, say, hammering your in-memory, Java, filesystem
implementation, so as to render the box unbootable.  Boy, oh boy, would I be
torqued if that happened to me.

It is also my understanding (and I'm a little out of my depth here, too --
somebody please speak up if I'm failing to tell the truth here) that some of the
infamous instabilities of NT are due in part to drivers and other software that,
for performance reasons, run inside privileged space (where there are fewer
guardrails) so as to incur fewer protection-ring boundary-crossings.

-jm

-- 
==== John Morrison            ==== MaK Technologies, Inc.
==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA 02138
==== jm@mak.com               ==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115    ==== fax:617-876-9208



From tullmann@cs.utah.edu Wed, 9 Jun 1999 14:20:26 -0600
Date: Wed, 9 Jun 1999 14:20:26 -0600
From: Patrick Tullmann tullmann@cs.utah.edu
Subject: [JOS-Kernel] Native methods [Was Re: [JOS-Kernel] decaf updates]

John Morrison wrote:
> It is fair to respond to that last assertion of mine "How is this different from
> native methods in Kaffe?" (Hi Patrick!)

I think you're thinking of native methods in terms of C code linked in
by Java code via Runtime.loadLibrary()?  As you say, allowing that
sort of thing in JOS is real bad.  The problem with this code is that
is neither "contained" (its C not Java) nor is it trusted (A JOS
kernel writer didn't necessairly write it.)

But, you'll still have native C code that is trusted.  For example,
the code that reads bits off a disk or gets the current time from the
internal clock.  All the native code that implements trusted native
methods.  Hmm, I guess you could write most of those bits in Java...
In any event, that's what I was talking about by native methods that
might want to throw exceptions: e.g., converting errno from a read()
system call into a Java exception.

> didn't you guys retarget Kaffe to your FluxOS toolkit?

Yep.  See http://www.cs.utah.edu/projects/flux/java/.

-Pat

----- ----- ---- ---  ---  --   -    -      -         -               -
Pat Tullmann                                       tullmann@cs.utah.edu
  "You can't have everything.  Where would you put it?" -- S. Wright



From tmiller@haverford.edu Wed, 9 Jun 1999 17:34:37 -0400 (EDT)
Date: Wed, 9 Jun 1999 17:34:37 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] decaf updates

> Um, I think you *have* to check the results, because you cannot afford to
> dereference something bad.  We're in OS-land (a.k.a., systems programming land),
> not application-land.  There are no guard-rails (a.k.a., memory protection
> mechanisms).  We do not want to become (in)famous for our version of the BSOD
> (even though I am sure we could pick a more, well, tasteful color, and, perhaps,
> put a more interesting text up on the screen like "Hey, at least you didn't PAY
> for this!").

	I'm aware that we have to check our results.  Having exceptions
just obviates the need to do it on every single call -- you're writing the
'check' into the function, not its caller.  At any rate, your suggestion
below seems fairly reasonable.  (If painful in terms of coding time.)

> Now, I'm a little out of my depth here, but here goes (somebody correct me if
> I'm wrong) -- it is my understanding that native methods are inherently
> non-portable, so we have some freedom to define how they should be
> compiled/written (if, in fact, we support them in the medium to long term -- we
> certainly won't support them in the short term).  Furthermore, given that we
> currently envision no memory protection (e.g., separate address spaces for
> native methods), allowing native methods is an huge invitation to Bad Things
> like BSODs, and viruses, etc.

	It might be premature to be worrying about native methods, but as
long as I'm going to be rewriting runOpCode on a line-by-line basis, I
figure I might as well be doing it /right/ and not have to do it /again/
when we do allow native methods, however they may be protected.

> When you say "native exception," do you mean C++ "throw," or vanilla-C reference
> to memory that ain't there (a.k.a., bus error, address error, memory error)?

	C++ "throw."

> p.s., you want me to stop putting your specific email address on the "To" list
> so you get the mail slower, but get only one copy?

	I don't particularly care either way.  It's nice when I'm actually
here when the mail arrives, and worth it, but otherwise it's not much of
an annoyance.

-_Quinn




From tmiller@haverford.edu Wed, 9 Jun 1999 17:42:31 -0400 (EDT)
Date: Wed, 9 Jun 1999 17:42:31 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] decaf updates

> Yes you do.  You do want every caller be able to tell if functions it
> called have aborted or are aborting.  Without fail, you will define
> functions that need to execute special code for handling failures.

	Every caller /should/ be able to catch exceptions that /might/ be
thrown by the callee and otherwise let it be handled by the default C++ ->
Java exception converter, which it will probably call anyway.  But this
p.o.v. might be too strongly influenced by Java.

> Originally, Kaffe would throw exceptions from deep within native code
> and these exceptions would correctly unwind the native stack all the
> way back into Java code, and proceed from there looking for exception
> handlers.  This worked fine in most cases.  (As an aside, Kaffe uses
> the same stack for Java and native code.)

	To my understanding, this is precisely the approach that I /can't/
take because of the limitations in JJOS.  (As an aside, decaf doesn't use
the same stack because it caused problems with preemption of threads --
which might not exist under an OS more advanced than JJOS.)

> We opted for explicit returns codes.

	This seems to be somewhat wiser than rewriting C++ exceptions by
hand in C, which is what the option sounded like.	

> > the native portion of the class library (classpath?) is where you
> > can't get around exception-handling in native methods.
> 
> That is, calls into native functions like FileInputStream.read()
> should be able to just directly throw exceptions that will unroll the
> native stack like they unroll the java stack.
> 
> We decided (err, Godmar Back who designed/implemented this for Kaffe,
> decided) to make all VM internal functions return an integer status
> code and take an exception description struct.

	...sigh...  This is exactly the same massive rewrite that I had
started this message-thread trying to avoid.  But it doesn't look that's
going to happen, does it?

> I hope this helps some,

	Thanks.  I should have guessed that other JVM efforts have tackled
this problem, but it's good to get the justification as well as the
result.

-_Quinn




From tmiller@haverford.edu Wed, 9 Jun 1999 17:55:24 -0400 (EDT)
Date: Wed, 9 Jun 1999 17:55:24 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Native methods [Was Re: [JOS-Kernel] decaf updates]

> I think you're thinking of native methods in terms of C code linked in
> by Java code via Runtime.loadLibrary()?  As you say, allowing that
> sort of thing in JOS is real bad.  The problem with this code is that
> is neither "contained" (its C not Java) nor is it trusted (A JOS
> kernel writer didn't necessairly write it.)

	On the other hand, I can almost gaurentee that someone will want
to do it. Luckily, we don't have any shareholders, and can safely ignore
them :)

	Did a little more thinking about Pat's information.  It sounds
like the Right Thing for decaf to do is go with the massive rewrite, so
that all VM functions have a return code and take an exception reference
(pointer) as an argument, and thusly /have to/ write the
exception-handling code in at every level. -- Which because this is an o/s
project and not app project, is a Good Thing anyway.  Because we need this
'delayed throw' ability in native libraries, it's rather pointless to
spend all the time it would take to implement a native throw scheme for
the rest of decaf, given that the 'delayed throw' will work.

	And here I was thinking that we were close to finishing the
interperter because there's only one opcode left!

-_Quinn






From jm@mak.com Fri, 11 Jun 1999 16:44:42 -0400
Date: Fri, 11 Jun 1999 16:44:42 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Hey, did I break anything?

Hi Todd;

I have managed to merge your changes with mine, and the merged sources
(including the latest java sources, which I have not changed one whit)
produce the following output (debugging/tracing is obviously off). 
Please tell me if this looks to be correct.  If so, I shall commit the
merges sources immediately upon your reply.

Thanks!

-jm

jm's JOS Kernel Host!
init for decaf, version 0.0.1
testing the VM...
testing integer comparisons... ops failed: 
testing double comparisons... ops failed: 
Testing float comparisons... ops failed: 
Testing float ops... ops failed: 
Testing double ops... ops failed: neg 
testing array operations... 
"one" should be printed: one
testing casting...
fixme: test interface casting.
o = (Object)Vector;
Vector = (Vector)o;
o = Object; Vector = (Vector)o
fixme: class cast exception should be thrown.
o = (Object)int[];
o = (Object)String[];
o = (Object)int[]; int[] = (int[])o;
casting tests complete
does 56 = 56?
is true = true?
This sentence should end with a period.
init(): testing threading.
init() starting counter...
counter ready.
init() starting decounter...
counter ready.
init() entering .wait() loop...
scheduler::start -- no active threads, exiting...
memory used: 2280K
main exiting -- OK!

 

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From onewith1@flash.net Fri, 11 Jun 1999 20:46:35 -0500
Date: Fri, 11 Jun 1999 20:46:35 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Kernel] UDI Drivers & JOS

This is a multi-part message in MIME format.

------=_NextPart_000_0018_01BEB44B.7E750E20
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

I don't know if anyone else is aware of this, but I just found out today =
about "UDI" - Uniform Driver Interface, which is intended to make a =
standard interface between kernels and drivers, so that a driver will =
only be written once, and will work on any intel platform and OS.

You can find its homepage at http://www.sco.com/UDI/.  I put a wiki page =
up about it for user comments (under the topic UDI).

-Matt

------=_NextPart_000_0018_01BEB44B.7E750E20
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD W3 HTML//EN">
<HTML>
<HEAD>

<META content=3Dtext/html;charset=3Diso-8859-1 =
http-equiv=3DContent-Type>
<META content=3D'"MSHTML 4.72.3110.7"' name=3DGENERATOR>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT color=3D#000000 size=3D2>I don't know if anyone else is aware =
of this,=20
but I just found out today about &quot;UDI&quot; - Uniform Driver =
Interface,=20
which is intended to make a standard interface between kernels and =
drivers, so=20
that a driver will only be written once, and will work on any intel =
platform and=20
OS.</FONT></DIV>
<DIV><FONT color=3D#000000 size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT color=3D#000000 size=3D2>You can find its homepage at <A=20
href=3D"http://www.sco.com/UDI/">http://www.sco.com/UDI/</A>.&nbsp; I =
put a wiki=20
page up about it for user comments (under the topic UDI).</FONT></DIV>
<DIV><FONT color=3D#000000 size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT color=3D#000000 size=3D2>-Matt</FONT></DIV></BODY></HTML>

------=_NextPart_000_0018_01BEB44B.7E750E20--




From jm@mak.com Sat, 12 Jun 1999 08:35:19 -0400
Date: Sat, 12 Jun 1999 08:35:19 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Committed changes

Hi All;

I didn't hear anything bad (didn't hear anything at ALL), so I just
committed the changes I wrote about yesterday.  The core
runOpcode/runInvoke methods are now methods of the frame class rather
than the java_thread.  This should be clearer, simpler, and faster.  The
java_thread which causes any classloading is now propagated throughout
the class loading/resolution mechanism, thus paving the way for
pre-emptive class initializations.  I also factored out some late
resolution code into new methods.

I do have a question for Todd re: initializing the "init" class...

As usual, if I broke anything, please let me know so I can help try to
fix it.

Next up on the agenda is the internment of built-in methods, so that I
can implement "memory" accessors so that somebody can write a VGA/SVGA
driver (actually, most of the above work was preparing the sources for
this task).

-jm

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From iainshigeoka@yahoo.com Sat, 12 Jun 1999 14:44:17 -0700 (PDT)
Date: Sat, 12 Jun 1999 14:44:17 -0700 (PDT)
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Kernel] Re: [JOS] Any volunteers?

Hello,

> So what I need is a group of people who can help by
> giving me 
> feedback or by writing some parts of the
> documentation for or with 
> me.  You don't need to be a kernel expert (i'm not)
> to help, it's 
> just common sense.

A bit of feedback.  I've looked over your interface so
far and it looks good.  I would suggest however that
you reconsider the thread part of the interface.  Many
kernels don't support threads natively and I wonder if
it might be better to try and implement threading in
the jvm rather than the kernel.  If I recall, one of
the goals is to try and keep the kernel as small as
possible and move any other functionality up into
the JVM or higher (allowing them to be written in 
java optimally).  I also see the same issue for the
virtual memory interface.  Much of this is coming from
two OS's I've been looking at lately, RTEMS and QNX.
RTEMS because its a possible kernel target for the
interface, and QNX because I really like their OS
design.  Neither supports threads or virtual memory.

I'd think that the best option is to assume a message
passing micro kernel that only does task switching
(for multi-processing), resource access protection,
and message passing from process to process.  
All other tasks will be handled by the JVM or higher.
This would include threading, virtual memory, and
device drivers (device drivers are simply separate
programs).  This is following from the QNX design.
I'm also assuming that we even want/need 
multi-processing.  In this design, I'd imagine many
aspects of a full JOS system to be running as multiple
processes with full system integration being done
using RMI or jini (using RMI).

In fact, perhaps even resource access protection 
should be moved up into the JVM.

Just some thoughts.

-iain
_________________________________________________________
Do You Yahoo!?
Get your free @yahoo.com address at http://mail.yahoo.com




From hilarycheng@usa.net Mon, 14 Jun 1999 11:19:17 +0800
Date: Mon, 14 Jun 1999 11:19:17 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Kernel] About JOS Kernel Status

Hi,

    I would like to know, is there any current development status of JOS
Kernel ?
I would like to read it and see what I can help in it. Thanks

Regards,

Hilary




From tullmann@cs.utah.edu Mon, 14 Jun 1999 09:54:27 -0600
Date: Mon, 14 Jun 1999 09:54:27 -0600
From: Patrick Tullmann tullmann@cs.utah.edu
Subject: [JOS-Kernel] New JavaOS Book

There's a JavaOS book out that I thought many of you might be
interested in:  "Inside the JavaOS Operating System".

http://www.amazon.com/exec/obidos/ASIN/0201183935/qid%3D929374786/002-1741159-2708027

(Note, I'm not affiliated with Amazon or with any of the authors.
Also, I haven't actually read the book...  I'll post a review when I
do...  maybe next week...)

-Pat

----- ----- ---- ---  ---  --   -    -      -         -               -
Pat Tullmann                                       tullmann@cs.utah.edu
     To understand recursion one must first understand recursion



From iainshigeoka@yahoo.com Mon, 14 Jun 1999 09:11:24 -0700 (PDT)
Date: Mon, 14 Jun 1999 09:11:24 -0700 (PDT)
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Kernel] About JOS Kernel Status

See KernelSummary on the JOS website.  (you can
type that into the "go" box in the left navigation
frame)

-iain

--- Hilary Cheng <hilarycheng@usa.net> wrote:
> Hi,
> 
>     I would like to know, is there any current
> development status of JOS
> Kernel ?
> I would like to read it and see what I can help in
> it. Thanks
> 
> Regards,
> 
> Hilary
> 
> 
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel
> 
> 

_________________________________________________________
Do You Yahoo!?
Get your free @yahoo.com address at http://mail.yahoo.com




From jm@mak.com Tue, 15 Jun 1999 06:35:10 -0400
Date: Tue, 15 Jun 1999 06:35:10 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Want me to nuke the NOTDEF stuff?

Hi Todd et al;

[ For those of you following our Story at home; jm broke no less than 3
or 4 things that Todd re-fixed last night.  Will Todd be able to keep
pace fixing the stuff as jm breaks it?  And make progress?  Will we ever
converge to a working system?  Is "progress" a signed quantity?  For the
answers to these and other exciting questions, stay tuned!  Meanwhile,
back at the ranch, ... -ed ]

Do you want me to reap the NOTDEF late-resolution/static-initialization
stuff now?  And, maybe, the other NOTDEF stuff?  Carefully, this time?  

How about make the read_java_order stuff frame:: methods, and make
::checkcast into java_object::checkcast?

-jm

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From tmiller@haverford.edu Tue, 15 Jun 1999 07:39:05 -0400 (EDT)
Date: Tue, 15 Jun 1999 07:39:05 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Re: Want me to nuke the NOTDEF stuff?

> Do you want me to reap the NOTDEF late-resolution/static-initialization
> stuff now?  And, maybe, the other NOTDEF stuff?  Carefully, this time?  

	Let's avoid reaping the late-resolution/static-initialization
stuff for right now; the new stuff hasn't really been tested (by me,
anyway!) all that thoroughly.

> How about make the read_java_order stuff frame:: methods, and make
> ::checkcast into java_object::checkcast?

	Sounds good.

-_Quinn




From jewel@pixie.co.za Tue, 15 Jun 1999 21:19:38 +0000
Date: Tue, 15 Jun 1999 21:19:38 +0000
From: John Leuner jewel@pixie.co.za
Subject: [JOS-Kernel] Free VM implementations

Hi guys

I've been following this list with half an ear open, but I'm afraid I don't
have the time to participate. I'm busy working on (as in adding
functionality to) a clean-room JVM that someone else wrote, all written in
C and pretty portable across platforms. I didn't write it, so I can't
answer implementation questions, but I was wondering if maybe you want to
get a copy of the source for reference purposes. It is probably simpler
than other free VMs available, for example the threads aren't native (the
whole machine runs as one process) and there is no JITing. 

There are some issues though, the machine has been modified to support
persistent programming in java, so there is a whole lot of code to fault
objects in and out of a "persistent store", but you can just ignore that
stuff.

So what I'm saying is, are you interested in the source?

John Leuner



From tmiller@haverford.edu Tue, 15 Jun 1999 16:53:45 -0400 (EDT)
Date: Tue, 15 Jun 1999 16:53:45 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Free VM implementations

> So what I'm saying is, are you interested in the source?

	It sounds like it could be very helpful -- what's the liscense?

-_Quinn




From jewel@pixie.co.za Wed, 16 Jun 1999 19:01:56 +0000
Date: Wed, 16 Jun 1999 19:01:56 +0000
From: John Leuner jewel@pixie.co.za
Subject: [JOS-Kernel] Free VM implementations

>> So what I'm saying is, are you interested in the source?
>
>	It sounds like it could be very helpful -- what's the liscense?

There is no license currently, the guy who handed it over to me muttered
something about GPL, but I'm  sure any kind of Open-Source license will
suffice.

I can make it available as a zip file, just shout if you want it.


John



From tmiller@haverford.edu Wed, 16 Jun 1999 14:46:51 -0400 (EDT)
Date: Wed, 16 Jun 1999 14:46:51 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Free VM implementations

> There is no license currently, the guy who handed it over to me muttered
> something about GPL, but I'm  sure any kind of Open-Source license will
> suffice.
>
> I can make it available as a zip file, just shout if you want it.

	Okay, cool.  Let's have it.	

-_Quinn




From jewel@pixie.co.za Thu, 17 Jun 1999 02:49:16 +0000
Date: Thu, 17 Jun 1999 02:49:16 +0000
From: John Leuner jewel@pixie.co.za
Subject: [JOS-Kernel] Free VM implementations

>> There is no license currently, the guy who handed it over to me muttered
>> something about GPL, but I'm  sure any kind of Open-Source license will
>> suffice.
>>
>> I can make it available as a zip file, just shout if you want it.
>
>	Okay, cool.  Let's have it.	

Okay:

http://www.cs.uct.ac.za/~jleuner/plava.tar.gz

It won't be easy to be build it without some help from me, but I'm assuming
you're interested in the source anyway. I can't say much about the
organization of the files, you'll just have to scout around, but for
example the main interpreter loop is in interp.c, code to handle class file
stuff in classfil.c, garbage collection in garbage.c etc.

If anyone does want to build and run it, I'll be happy to help.


John



From Dmitry.M.Golubovsky@p22.f163.n5030.z2.fidonet.org Fri, 18 Jun 99 13:16:01 +0400
Date: Fri, 18 Jun 99 13:16:01 +0400
From: Dmitry M. Golubovsky Dmitry.M.Golubovsky@p22.f163.n5030.z2.fidonet.org
Subject: [JOS-Kernel] Linux kernel as the JOS kernel

From: "Dmitry M. Golubovsky" <dima@dmghome.local>


Hi,

I'm new in this list. As I found at the JOS site there exist some separate
projects to develop native kernels for Java OS (probably such an OS cannot
exist without some native part). Has someone tried to build a Java-oriented OS
as a combination of some existing Linux kernel (maybe patched) and one of
known free JVMs (Kaffe for example)?

Also does someone know if there exist purchaseable hardware Java accelerators
for PC (Picojava chip had been announced by SUN some years ago), what is a
price of such an unit and if such things exist how are those taken into
consideration within the JOS development process?

Dmitry M. Golubovsky
      St-Petersburg, Russia






From linus@bomben.nu Fri, 18 Jun 1999 15:49:19 +0200 (MEST)
Date: Fri, 18 Jun 1999 15:49:19 +0200 (MEST)
From: Linus G Larsson linus@bomben.nu
Subject: [JOS-Kernel] Linux kernel as the JOS kernel


On Fri, 18 Jun 1999, Dmitry M. Golubovsky wrote:

>From: "Dmitry M. Golubovsky" <dima@dmghome.local>
>
>I'm new in this list. As I found at the JOS site there exist some separate
>projects to develop native kernels for Java OS (probably such an OS cannot
>exist without some native part). Has someone tried to build a Java-oriented OS
>as a combination of some existing Linux kernel (maybe patched) and one of
>known free JVMs (Kaffe for example)?

There have been discussions in that direction.
I, for one, don't know of such a project. One could, for instance, have a JOS
prototype running on top of Linux or RTEMS. But that's not JOS's mission.

Oh, and it should be JOS, _not_ Java OS. Java OS is Sun's project.

Greetz
//Linus G Larsson




From joel@OARcorp.com Fri, 18 Jun 1999 08:57:51 -0500 (CDT)
Date: Fri, 18 Jun 1999 08:57:51 -0500 (CDT)
From: joel@OARcorp.com joel@OARcorp.com
Subject: [JOS-Kernel] Linux kernel as the JOS kernel


On Fri, 18 Jun 1999, Linus G Larsson wrote:

> On Fri, 18 Jun 1999, Dmitry M. Golubovsky wrote:
> 
> >From: "Dmitry M. Golubovsky" <dima@dmghome.local>
> >
> >I'm new in this list. As I found at the JOS site there exist some separate
> >projects to develop native kernels for Java OS (probably such an OS cannot
> >exist without some native part). Has someone tried to build a Java-oriented OS
> >as a combination of some existing Linux kernel (maybe patched) and one of
> >known free JVMs (Kaffe for example)?
> 
> There have been discussions in that direction.
> I, for one, don't know of such a project. One could, for instance, have a JOS
> prototype running on top of Linux or RTEMS. But that's not JOS's mission.

A few people over recent years have worked with Kaffe and RTEMS.  As I
recall, Erik Bruchez even demonstrated a working system a few years ago.
I don't think this was ever merged with Kaffe though. :(

Doing such a port would give you an embedded Java on about 10 CPU
families with a relatively low investment of effort.

--joel
Joel Sherrill, Ph.D.             Director of Research & Development
joel@OARcorp.com                 On-Line Applications Research
Ask me about RTEMS: a free RTOS  Huntsville AL 35805
   Support Available             (256) 722-9985





From onewith1@flash.net Fri, 18 Jun 1999 16:02:45 -0500
Date: Fri, 18 Jun 1999 16:02:45 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Kernel] Linux kernel as the JOS kernel

-----Original Message-----
From: Dmitry M. Golubovsky
<Dmitry.M.Golubovsky@p22.f163.n5030.z2.fidonet.org>
To: kernel@jos.org <kernel%jos.org@f128.n5030.z2.fidonet.org>
Date: Friday, June 18, 1999 8:30 AM
Subject: [JOS-Kernel] Linux kernel as the JOS kernel


>From: "Dmitry M. Golubovsky" <dima@dmghome.local>
>
>
>Also does someone know if there exist purchaseable hardware Java
accelerators
>for PC (Picojava chip had been announced by SUN some years ago), what is a
>price of such an unit and if such things exist how are those taken into
>consideration within the JOS development process?


The PicoJava chip was a proof-of-concept thing.  No one wants to use it -
not even Sun.  The Merced processor has the "undocumented" chip in it, which
is rumored to be a JVM chip.  Also, Transmeta is working on a "morph" chip
which should be able to emulate any machine, including the JVM.

So to answer this question: no, there's no PC java chip out yet, but people
are working on it.

>
>Dmitry M. Golubovsky
>      St-Petersburg, Russia





From abc@abc.com Sat, 19 Jun 1999 12:39:17 +0800
Date: Sat, 19 Jun 1999 12:39:17 +0800
From: Hilary Cheng abc@abc.com
Subject: [JOS-Kernel] Linux kernel as the JOS kernel

I am new in this list too. Hm, In My Opinion, I think using Linux Kernel is good
idea.
Since Linux Kernel already have disk access, memory management. I think this is
not
urgent tasks for JOS to implemenet it. Also, these things are not related to Java
Itself.
Anyone got idea about it?

"Dmitry M. Golubovsky" wrote:

> From: "Dmitry M. Golubovsky" <dima@dmghome.local>
>
> Hi,
>
> I'm new in this list. As I found at the JOS site there exist some separate
> projects to develop native kernels for Java OS (probably such an OS cannot
> exist without some native part). Has someone tried to build a Java-oriented OS
> as a combination of some existing Linux kernel (maybe patched) and one of
> known free JVMs (Kaffe for example)?
>
> Also does someone know if there exist purchaseable hardware Java accelerators
> for PC (Picojava chip had been announced by SUN some years ago), what is a
> price of such an unit and if such things exist how are those taken into
> consideration within the JOS development process?
>
> Dmitry M. Golubovsky
>       St-Petersburg, Russia
>
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel





From rolandpj@bigfoot.com Sun, 20 Jun 1999 08:02:05 +0100
Date: Sun, 20 Jun 1999 08:02:05 +0100
From: Roland PJ rolandpj@bigfoot.com
Subject: [JOS-Kernel] Linux kernel as the JOS kernel

I feel the more you implement in C(++), the more you have to worry about
crossing the barrier between C and Java. The barrier is the tough part,
particularly for GC, and difficult to make efficient.

Roland

-----Original Message-----
From: Hilary Cheng <abc@abc.com>
To: kernel@jos.org <kernel@jos.org>
Date: 20 June 1999 03:46
Subject: Re: [JOS-Kernel] Linux kernel as the JOS kernel


>I am new in this list too. Hm, In My Opinion, I think using Linux Kernel is
good
>idea.
>Since Linux Kernel already have disk access, memory management. I think
this is
>not
>urgent tasks for JOS to implemenet it. Also, these things are not related
to Java
>Itself.
>Anyone got idea about it?
>
>"Dmitry M. Golubovsky" wrote:
>
>> From: "Dmitry M. Golubovsky" <dima@dmghome.local>
>>
>> Hi,
>>
>> I'm new in this list. As I found at the JOS site there exist some
separate
>> projects to develop native kernels for Java OS (probably such an OS
cannot
>> exist without some native part). Has someone tried to build a
Java-oriented OS
>> as a combination of some existing Linux kernel (maybe patched) and one of
>> known free JVMs (Kaffe for example)?
>>
>> Also does someone know if there exist purchaseable hardware Java
accelerators
>> for PC (Picojava chip had been announced by SUN some years ago), what is
a
>> price of such an unit and if such things exist how are those taken into
>> consideration within the JOS development process?
>>
>> Dmitry M. Golubovsky
>>       St-Petersburg, Russia
>>
>> _______________________________________________
>> Kernel maillist  -  Kernel@jos.org
>> http://jos.org/mailman/listinfo/kernel
>
>
>
>_______________________________________________
>Kernel maillist  -  Kernel@jos.org
>http://jos.org/mailman/listinfo/kernel
>





From jm@mak.com Sun, 20 Jun 1999 17:07:51 +0000
Date: Sun, 20 Jun 1999 17:07:51 +0000
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Problems w/ i386 build

Hi Guys;

The Short Version: If you're working with the i386 build (as opposed to
the host build) of jjos+decaf, please upgrade to version Etherboot 4.2
(from version 4.0).


The Longer Version: Thomas Bocek just contacted me telling me that the
i386 build doesn't work for him, and that he's tracked it down as far
as: if he allows jbHeap::scrubMemory to scrub between 1MB and 8MB, then
decaf doesn't start.  He's got 64MB DRAM.

I just tried to build and execute the i386 target for the first time in
a long while (longer than I care to admit).  I had to redo all that
TFTP/BOOTP stuff under RedHat 6.0.  I ran into a couple problems worth
mentioning -- FYI, here is what I found.

(1) The Etherboot v4.0 floppies don't seem to want to TFTP over the
entire 9MB (approx) jjos.zip file we create.  I manually deleted sun/*
from the zipfile to get the 9MB file down to about 1.5MB, and it loaded
successfully.

(2) When this shrunken jjos.zip was finally ran, it looked like it
stalled after enabling A20, and then said something quickly about the
CPU type, and then it fielded a WHOLE LOT of interrupt zeroes, and then
it just got, real, REAL, quiet.

(3) I upgraded to Etherboot 4.2, which took a whole 10 minutes.  (I did
this because of the downloading problem, but also because the release
notes muttered something about "not clearing memory" to avoid hammering
something.)  I rebuilt the jjos.zip file so as to get it back up to
9MB.  I changed NO SOURCES at all in either java or C++/ASM between
problematic step (2) and this step (3).

(4) It ran fine (well, identically to the slightly broken arch/host
build I am working on).

Thus, Thomas (and others), please be so kind as to upgrade to Etherboot
4.2, available from:
	http://www.slug.org.au/etherboot/
and try again, and let me know what happens.

-jm

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From jm@mak.com Mon, 21 Jun 1999 13:09:26 +0000
Date: Mon, 21 Jun 1999 13:09:26 +0000
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Re: decaf rewrite

Hi Todd (et al);

"Todd L. Miller" wrote:
> 
>         Just realized that it looks like the throws rewrite will require
> function calls of the form
> 
> int fn( ..., exception* e )
> 
> so you should bear that in mind while moving the stuff in interp about.

OK.  I factored out each of the 250 (or so) opcodes into its own method,
with the exception that I did not change the "all invoke opcodes handled
in a single function" scheme, although that should almost certainly be
changed.  God, emacs macros are wonderful, powerful things.  

All opcodes are now methods on class frame, of the form:
	bool frame::opcode(exception_to_throw &);

I made up the exception_to_throw class for a place-holder.  If you have
a predefined class I should've used instead (I looked but didn't notice
any obvious candidates), please reply ASAP, and I'll make the global
change before I commit the sources.  If not, please feel utterly free to
replace it with whatever you like.

Items of note:

(1) Some poor bastard has got to go and chase around all the PC
referencing and incrementing, and localize it to each opcode method
(like we discussed, to enable "backing out" of not (yet) executable
opcodes, the opcode must not increment the PC unless it worked, and the
runOpcode demultiplexer must NOT increment the PC).  Although a
separable task, this is coupled to doing the exception handling.  Please
advise as to how I should or should not proceed.

(2) I think the various invoke opcodes arguably should each have its own
method, and the "common" functionality they need should become new
(protected? private?) methods.  I have this opinion because I think it
might help readability/maintainability, and it would also certainly help
efficiency (we probably don't want the execution engine to "forget"
which invoke opcode it's executing, and have to go back and look it up
repeatedly, and then set control flags for how many things are on the
stack, yadda yadda yadda...).  Please advise as to how I should or
should not proceed.

(3) In an attempt to be less, er, cavalier about whether the committed
sources actually RUN on the i386 target (Hi, Thomas!), I actually BUILT
the sources and ran them successfully on the i386 target.  If you wish
me to do anything about items (1) & (2), I promise (cross my heart,
etc.) to verify that any changes I make actually run on the i386 target.

(4) Please let me know if you ran into the same problems that either
Thomas or I did with respect to the i386 target.  Thomas, please let me
know if upgrading to Etherboot 4.2 solved your difficulties as it did
mine.

(5) I am actually taking the week off from the Day Job, so if there is
any power-tooling to be done, now is a really, Really, REALLY good
time.  Please advise.

-jm

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From tmiller@haverford.edu Tue, 22 Jun 1999 08:48:23 -0400 (EDT)
Date: Tue, 22 Jun 1999 08:48:23 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Re: decaf rewrite

> All opcodes are now methods on class frame, of the form:
> 	bool frame::opcode(exception_to_throw &);
> 
> I made up the exception_to_throw class for a place-holder.  If you have
> a predefined class I should've used instead (I looked but didn't notice
> any obvious candidates), please reply ASAP, and I'll make the global
> change before I commit the sources.  If not, please feel utterly free to
> replace it with whatever you like.

	I didn't have a class ready, but exception_to_throw is not one of
the prettier (or shorter) class names I've ever come accross :)

> (1) Some poor bastard has got to go and chase around all the PC
> referencing and incrementing, and localize it to each opcode method
> (like we discussed, to enable "backing out" of not (yet) executable
> opcodes, the opcode must not increment the PC unless it worked, and the
> runOpcode demultiplexer must NOT increment the PC).  Although a
> separable task, this is coupled to doing the exception handling.  Please
> advise as to how I should or should not proceed.

	If the runOpcode demultiplexer can't increment the PC -- which
makes sense -- another nice emacs macro ought to take care of that bit of
the rewrite (thought it means we'll be weeding out myPC--; ... myPC++;
statements for a while!); as for whether or not to proceed, IIRC, you've
got plenty on your plate right now anyway.  I don't know when I'll be
able to resume work on jjos+decaf; probably but not certainly this
weekend, so you're in the clear for big changes.

> (2) I think the various invoke opcodes arguably should each have its own
> method, and the "common" functionality they need should become new
> (protected? private?) methods.  I have this opinion because I think it
> might help readability/maintainability, and it would also certainly help
> efficiency (we probably don't want the execution engine to "forget"
> which invoke opcode it's executing, and have to go back and look it up
> repeatedly, and then set control flags for how many things are on the
> stack, yadda yadda yadda...).  Please advise as to how I should or
> should not proceed.

	This sounds like a good idea; hopefully it will also eliminate
some of those ugly switch/case statements from the invocation code.  It
might be worthwhile and/or necessary to make more than one protected
helper function, especially if the various invoke-common bits are spread
around and/or throw radically different exceptions.  Again, you've
probably got quite a bit to handle already, but you'll probably get to
this before I do.  

> (4) Please let me know if you ran into the same problems that either
> Thomas or I did with respect to the i386 target.  Thomas, please let me
> know if upgrading to Etherboot 4.2 solved your difficulties as it did
> mine.

	No.  I tested the second-to-last set of changes I made against the
i386 build (with the full 9.6MB ramdisk) and it worked fine; on the other
hand, the two computers were on a null-ethernet cable, which might have
affected things.  (I couldn't get one to find the other when plugged into
the wall network here; I don't know if that's a problem with Etherboot or
the wall network...)

> (5) I am actually taking the week off from the Day Job, so if there is
> any power-tooling to be done, now is a really, Really, REALLY good
> time.  Please advise.

	AFAIK, the only  major thing we must get done before we can
integrate classpath is throws.  

-_Quinn





From jm@mak.com Tue, 22 Jun 1999 14:34:27 +0000
Date: Tue, 22 Jun 1999 14:34:27 +0000
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Re: Problems w/ i386 build

Hello Thomas;

Please note that I took the liberty of cc-ing the list, because the
answers to your questions might satisfy some broader interest...

Thomas Bocek wrote:
> I tried, but some files are missing to build a netbootfloppy, so I used
> netboot 0.9 (0.81 din't work).
> what is so special about the etherboot package?

I use Etherboot instead of netboot.  I suppose there is not much
difference (netboot uses (DOS?) "packet mode" drivers -- etherboot uses
its own drivers).  However, Etherboot 4.2 includes netboot 8.81, which
you say doesn't work -- I suppose this is OK because etherboot uses its
own bootloader, not netboot's.

> > The Longer Version: Thomas Bocek just contacted me telling me that the
> > i386 build doesn't work for him, and that he's tracked it down as far
> > as: if he allows jbHeap::scrubMemory to scrub between 1MB and 8MB, then
> > decaf doesn't start.  He's got 64MB DRAM.
> 
> I still don't get the point? 1-55MB heap 55-64MB ramdisk. where's the
> code?

Because one cannot have a program counter (PC) value greater than 1MB
while in x86 "real mode," the code must be below the 1MB "barrier" --
actually, it's got to be below the 640K frame buffers, too.  (This means
we can avoid a two-stage bootloader, and/or an even more baroque build
process.)  So, the memory map is something like:

10K-200K "nativecode" (200K = current text+data+bss)
200K-600K nativecode stack (stack grows down from 600K)
640K-1MB VGA frame buffer(s)
1MB-54MB C++ heap (really, 10MB less than your max DRAM)
54MB-64MB zipfile-format ramdisk

There are some other things (e.g., bootloader code/data areas, BIOS
code/data ares) that I have omitted (you can find these out from any
decent PC book -- I suggest "The Undocumented PC"), but those are the
jjos+decaf-specific areas.  The other etherboot/netboot specific ones
(e.g., the location of the NBI "directory," and the command-line args,
and the BOOTP reply) are documented within the etherboot/netboot
documentation.

> > (1) The Etherboot v4.0 floppies don't seem to want to TFTP over the
> > entire 9MB (approx) jjos.zip file we create.  I manually deleted sun/*
> > from the zipfile to get the 9MB file down to about 1.5MB, and it loaded
> > successfully.
> 
> I did exactely the same thing and loaded decaf and found init.class

Does this mean that you have (at least) a work-around for your problems?

> > (2) When this shrunken jjos.zip was finally ran, it looked like it
> > stalled after enabling A20, and then said something quickly about the
> > CPU type, and then it fielded a WHOLE LOT of interrupt zeroes, and then
> > it just got, real, REAL, quiet.
> 
> well, my pc just rebooted.

When, after it found init.class?  I realize it is hard to catch the text
as it flies by at warp speed, but what's the last thing the computer
printed before it rebooted?

> I downloaded Etherboot 4.2 but what should I upgrade?

Well, if I understand correctly, you're using netboot rather than
etherboot.  So, I am not sure what the issues are with netboot (as
opposed to etherboot).  If what I've told you previously doesn't help,
I'd be tempted to use Etherboot 4.2 instead of netboot, and see if the
problems go away.

Please Let me know things go.  If the problems don't go away, please let
me know as much detailed information as possible, so I can help as much
as possible (albeit remotely).

Thanks for being so brave to run pre-pre-alpha code!

-jm


-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From jm@mak.com Wed, 23 Jun 1999 21:05:23 -0400
Date: Wed, 23 Jun 1999 21:05:23 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Committed changes

Hi Todd (et al);

The Short Version: I broke apart the monolithic opcode-execution
engine into one method per opcode.  This is preparatory to adding
"throws," pre-emptible initialization code, etc.

The Longer Version: Files affected are frame.h, interp.cc, and
java_thread.cc.  There are about 250-odd new methods on frame: one per
opcode, and a few helper routines.  Have not yet localized program
counter management into the individual routines (although that's all
set to go now that there *are* individual routines).  STILL have not
gotten around to adding the memory read/write things.  I think I'll do
that before I do the environemnt stuff so that people can write
drivers (I was going to do these in the opposite order, but it's
taking me too long).

Please provide feedback on the code (e.g., "What the Hell were you
SMOKING when you wrote, this, this, ABOMINATION!?!").  As usual,
please advise me of any problems I have inadvertantly caused ("You,
you, IDIOT!  You broke the Illudium-238 space modulator!  AGAIN!").
Finally, please let me know of anything I can do to make the code
easier to work on for those hardy, adventurous souls out there.

Thanks,

-jm

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From hilarycheng@usa.net Thu, 24 Jun 1999 17:18:15 +0800
Date: Thu, 24 Jun 1999 17:18:15 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Kernel] About JOS Kernel Developement

This is a multi-part message in MIME format.

------=_NextPart_000_0047_01BEBE65.8B579620
Content-Type: text/plain;
	charset="big5"
Content-Transfer-Encoding: quoted-printable

Hi,

    I have read the document of JOS Kernel. It seems interesting that It =
boots kernel from BOOTP.
But I havn't tried it. Since my Unix OS is SunOS. I need to install =
Linux so that I can run it.

    As Development Plan state, implementation of VGA JJOS are requried. =
I have interest in developing
this. Would u mind let join me in ?

    Also, Is that possible to boot current Kernel from Floppy instead of =
Ethernet one ?

Regards,

Hilary

------=_NextPart_000_0047_01BEBE65.8B579620
Content-Type: text/html;
	charset="big5"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD W3 HTML//EN">
<HTML><HEAD>
<META content=3Dtext/html;charset=3Dbig5 http-equiv=3DContent-Type>
<STYLE></STYLE>

<META content=3D'"MSHTML 5.00.0910.1309"' name=3DGENERATOR></HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>Hi,</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; I have read the =
document of JOS=20
Kernel. It seems interesting that It boots kernel from =
BOOTP.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>But I havn't tried it. Since my Unix OS =
is SunOS. I=20
need to install Linux so that I can run it.</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; As Development Plan =
state,=20
implementation of VGA JJOS are requried. I have interest in=20
developing</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>this. Would u mind let join me in =
?</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; Also, Is that =
possible to boot=20
current Kernel from Floppy instead of Ethernet one ?</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Regards,</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Hilary</FONT></DIV></BODY></HTML>

------=_NextPart_000_0047_01BEBE65.8B579620--




From jm@mak.com Thu, 24 Jun 1999 16:52:47 -0400
Date: Thu, 24 Jun 1999 16:52:47 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Seeking scheme to handle unsigned data types for drivers

Hi;

It seems that the Java language designers have attempted to achieve
their goal of a "language without sharp edges," in part, by preventing
Children From Playing With Unsigned Types.

(Q. Can anybody out there name another language that did the same
thing?  One answer is below my signature .. no fair peeking!)

Somewhat obviously, in writing drivers (e.g., VGA), one wishes to
employ unsigned types -- 8-bit and 16-bit for "data," and (at least)
32-bit for addresses.  (So there -- thhhhbpt!)

Thus, the issue becomes, how to do this in JOS in the most, well,
*palatable* way.  I figure there's one semi-obvious way, and probably
lots of others.  (E.g., how do Java-language network protocol
implementations handle this?  Network protocols are chock *full* of
unsigned quantities.)  Please feel free to reply with candidates
schemes to either me and/or the list.  I am especially interested to
know how JavaOS handles this problem (without, of course, compromising
my "clean room" status).  Obviously, we cannot possibly be the first
people to run across this problem.

Here's one semi-obvious candidate:

(0) Have separate native methods for each and every Java type.
(1) Use Java shorts for reading/writing unsigned 8-bit quantities.
(2) Use Java ints for reading/writing unsigned 16-bit quantities.
(3) Use Java longs for reading/writing unsigned 32-bit
quantities/addresses.
(4) Use atomic operations for all reads/writes.
(5) Build "array" types out of these primitives.

An advantage is that it's pretty straightforward.  Also, the Java
programmer will have control of what kind of memory cycle is generated
(in my limited experience, this is often important to the device being
prodded).  Finally, because we don't synthesize 16-bit operations out
of consecutive 8-bit operations (and likewise 32-bits operations out
16-bit operations), we can get atomic reads and writes (and thus avoid
race conditions).

However, one big drawback (as I see it based on a whole 10 seconds'
thought) is that the address stuff might run like dog-meat --
8bit/16bit stuff should be OK because it fits in one register or
machine-word.

Another big drawback is that we'd basically be throwing bits away when
we cross the boundary into C++/asm from Java (hmm... can we throw an
exception saying "too many bits?" if they're set?), and inventing
(zero-padding) bits on the way back in.

Finally -- don't we have this problem currently with the current
in/out primitives?  (Oh, yeah, and what's the right thing to do with
respect to read-modify-writes?)

Thanks,

-jm

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com

(A. It's Ada!)



From joel@OARcorp.com Thu, 24 Jun 1999 16:19:06 -0500 (CDT)
Date: Thu, 24 Jun 1999 16:19:06 -0500 (CDT)
From: joel@OARcorp.com joel@OARcorp.com
Subject: [JOS-Kernel] Seeking scheme to handle unsigned data types for
 drivers


On Thu, 24 Jun 1999, John Morrison wrote:

> (Q. Can anybody out there name another language that did the same
> thing?  One answer is below my signature .. no fair peeking!)
> 
> Somewhat obviously, in writing drivers (e.g., VGA), one wishes to
> employ unsigned types -- 8-bit and 16-bit for "data," and (at least)
> 32-bit for addresses.  (So there -- thhhhbpt!)

Properly the answer is Ada83.  Ada95 addressed this problem.

> Here's one semi-obvious candidate:
> 
> (0) Have separate native methods for each and every Java type.
> (1) Use Java shorts for reading/writing unsigned 8-bit quantities.
> (2) Use Java ints for reading/writing unsigned 16-bit quantities.
> (3) Use Java longs for reading/writing unsigned 32-bit
> quantities/addresses.

These are pretty typical of the solutions used by Ada83 vendors with their
Unsigned_Types packages.  I recall being highly irritated at one
compiler vendor's choice that a 32-bit unsigned quantity was actually
64-bits.

> (A. It's Ada!)

Ada83. :)

--joel
Joel Sherrill, Ph.D.             Director of Research & Development
joel@OARcorp.com                 On-Line Applications Research
Ask me about RTEMS: a free RTOS  Huntsville AL 35805
   Support Available             (256) 722-9985





From tullmann@cs.utah.edu Thu, 24 Jun 1999 16:39:18 -0600
Date: Thu, 24 Jun 1999 16:39:18 -0600
From: Patrick Tullmann tullmann@cs.utah.edu
Subject: [JOS-Kernel] Seeking scheme to handle unsigned data types for drivers

> Somewhat obviously, in writing drivers (e.g., VGA), one wishes to
> employ unsigned types -- 8-bit and 16-bit for "data," and (at least)
> 32-bit for addresses.

Why do you care about the sign of these types?  Java is nice enough
that all of the primitives types have fixed sizes.  ints are 32 bits,
shorts and bytes are exactly what you'd expect, etc.  There are
exactly three places where you will run into problems treating
unsigned values as signed values, I don't think any of them are common 
enough to be a real problem.  (All the common operations: like adding 1;
and clearing and setting bits just work.)

First is sign extension. This only happens when casting from a small
size to a larger bit width.  Using masks prevents the problem:
	int x = (int)byteVal & 0xFF;

Second is comparisons.  Comparing unsigned quantities via unsigned
operators may not always give you what you want.  How often does that
happen in a driver anyway?  Casting (without sign extension) to a
larger type will work, though.

Third problem is printing the number on the screen.  Thankfully we
have Integer.toHexString(x).

Certainly, this isn't nearly as clean as having real support in the
language for signed vs. unsigned types, but its quite workable. (Of
course, that invites its own host of problems.)

-Pat

----- ----- ---- ---  ---  --   -    -      -         -               -
Pat Tullmann                                       tullmann@cs.utah.edu
	  This signature witticism intentionally left blank.



From tmiller@haverford.edu Thu, 24 Jun 1999 19:01:21 -0400 (EDT)
Date: Thu, 24 Jun 1999 19:01:21 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] About JOS Kernel Developement

>     I have read the document of JOS Kernel. It seems interesting
> that it boots kernel from BOOTP.

	This is related to your question below...

	Basically, John Morrison, who wrote the kernel part of JJOS,
decided it would be better to write a kernel that doesn't have its own
bootloader, for several reasons: first, it saved him a lot of time;
second, it would be one less thing to port when we do; third, it meant we
would /have/ to use some standard boot loader; the easiest among those
from a coding standpoint being etherboot, which uses the BOOTP protocol.
	There's been some experimental work done with getting GRUB (the
GRand Unified Bootloader) to load JJOS; Robert Fitzsimmons has reported
success, but I have, as yet, been unable to replicate his work and
integrate the GRUB solution into the build process for the i386 JJOS
target.  This is something you could work on.

>     As Development Plan state, implementation of VGA JJOS are requried. I 
> have interest in developing this. Would u mind let join me in ?

	We'd be delighted to have you join in.  Right now, I'd guess the
parts necessary for implementing VGA are missing, but they should be added
pretty quickly now that someone (you) has volunteered to write it!  Talk
to John Morrison (jm@mak.com) for more info about this.

>     Also, Is that possible to boot current Kernel from Floppy 
> instead of Ethernet one ?

	See above.

-_Quinn




From scholr@slip.net Fri, 25 Jun 1999 08:05:58 -0700
Date: Fri, 25 Jun 1999 08:05:58 -0700
From: Joseph Osako scholr@slip.net
Subject: [JOS-Kernel] Seeking scheme to handle unsigned data types
 for drivers

At 04:52 PM 06/24/1999 -0400, you wrote:
>Hi;
>
>It seems that the Java language designers have attempted to achieve
>their goal of a "language without sharp edges," in part, by preventing
>Children From Playing With Unsigned Types.
>
>(Q. Can anybody out there name another language that did the same
>thing?  One answer is below my signature .. no fair peeking!)

<clip>

>(A. It's Ada!)

As for others, lessee now... Standard Pascal, ALGOL-60, most LISP variants,
at least one Smalltalk implementation, virtually all BASICs, and just about
any FP language I've ever heard of. In fact, the vast majority of languages
out there have no concept of 'unsigned' at all, and can't be changed very
easily because they also don't have bit-twiddling.

Pretty much the only ones that *do* have them which I'm familiar with are
system languages: C, C++, BCPL (which does not, strictly speaking, have
*signed* types IIRC), PL/1, Forth (IIRC), and Modula-2 (type Cardinal). The
issue just don't show up in applications programming very much.

If it's any consolation, I'm facing the same question myself in another
context - I need to build a class for bit-fiddling so I can read certain
file formats. I'll let you know if I settle on anything (I'm thinking I'll
either use a byte and deal with the sign flipping using rotates, or else
I'll unpack them - represent a bit field with an array of bools, a every
wastefull but easy method for my needs). 

I'm also still trying to figure out how to send a TCP URGENT message in a
Java socket (for telnet), but that's a different mailing list.
J Osako
Programmer Analyst, Operating Systems Designer, Notational Engineer
http://www.slip.net/~scholr/resume.html



From tmiller@haverford.edu Fri, 25 Jun 1999 23:55:18 -0400 (EDT)
Date: Fri, 25 Jun 1999 23:55:18 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] decaf progress

	Just thought I'd let people know that I've gotten Java-language
(only) throws working.  I haven't tested the implementation thoroughly,
and I've left some problematic code in (noteably, taking the address of a
reference parameter -- which should be new()d and then free()d in
java_thread but isn't for now); once I clean the code up and do some
more extensive testing, I'll commit it to the CVS.  It's relatively
straightforward code; all the necessary infastructure was already in
place.
	This does /not/ include support for exceptions thrown by native
code, which is by far the more difficult part.  I'll be tackling that
support next, but progress will probably be slow.

	AFAIK, this completes support the non-native, not-class-library
portions of the JVM 1.0.2 specs.  It will be difficult, at best, to test
compliance quite yet because we don't have a fully-functional class
library (i.e. native calls).  However, I will make an effort to comb over
the 1.0.2 JVM spec after I finish exception handling and verify that
everything is coded (not necessarily correctly).

-_Quinn




From jm@mak.com Tue, 29 Jun 1999 08:25:28 -0400
Date: Tue, 29 Jun 1999 08:25:28 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Kernel] Alternative approach to "memory" classes...

Hi All;

Sorry for the wide distribution, but I am interested in hearing your
thoughts on the following, JOS-wide, and (unfortunately) related
issues...

Issue #1:

Just bought the "Inside JavaOS" book.  Haven't had time to read the
whole thing (you know how it is).  JavaOS has a quite different (and
much more comprehensive) approach to memory classes than any of the ones
I wrote about in my recent message to the kernel list (those of you who
aren't on the kernel list can check the archives if you're really
interested, but I really need your inputs on Issue #2...)

Seems they have opaque (to Java, anyways) address32 and address64
classes.  They also have "address range" classes, DMA address space
classes, and even (seems to me) I/O space classes (as a 16-bit address
space).  I haven't exactly figured out and/or read far enough to know
if/how they handle the *contents* of addresses as unsigned quantities,
although I'm sure they can handle it also via opaque classes.  Finally,
they even seem to have an approach to handling physical<->virtual
mapping machinery.

So, I guess this comes down to either of two options (please excuse the
hyperbole):

(1) inventing our own, unique, simplistic, must-be-upgraded-later
approach, which will be expedient in the short term, but will never be
able to use JavaOS drivers/software, and will be much harder for us to
get consensus upon (e.g., agreeing upon driver, system, OS, and "kernel"
APIs), or

(2) implementing something as close as is humanly possible to the JavaOS
API(s), which will be more work in the short term, but maybe less in the
long term, and which will obviate the consensus-building group-grope
problem we currently have, which makes it much harder to get anything
done that involves more than one person...

Basically, option (1) is the "let's re-invent the wheel" approach, and
(2) is the time-honored, Open Source "chase the tail-lights" approach. 
As much as I like designing my own APIs (of course, they would be far
superior to and more aesthetically pleasing than the JavaOS ones --
*N-O-T*), I'm kind of leaning towards option (2).  I mean, hell, we're
not redesigning the Java language, the bytecodes, or the java.* classes,
so...

Issue #2:

Are there any legal ramifications of cloning the JavaOS APIs?  Is
anybody in a position to find out?  If there are issues, I'd sure like
to know about them right now so that we can do option (1) instead...

-jm

-- 
==== John Morrison
==== MaK Technologies Inc.
==== 185 Alewife Brook Parkway, Cambridge, MA 02138
==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115
==== fax:617-876-9208
==== jm@mak.com



From Alexis Petrounias Tue, 29 Jun 1999 15:42:39 +0300
Date: Tue, 29 Jun 1999 15:42:39 +0300
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Alternative approach to "memory" classes...

John Morrison wrote:

> (2) implementing something as close as is humanly possible to the
> JavaOS API(s)

If Sun one day says: Java can run native on hardware, and these are the
APIs that handle hardware drivers, then everyone will use those APIs.
Unless we are quick enough to create a standard that Sun could use. But
I have a hunch that Sun is not omitting the pure Java PC, I think that
they will create something very big, but they are simply making sure
that large hardware firms will comply ad provide Java versions of their
drivers. This we cannot do, but we can look ahead and go with Sun's
waters...


-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[REFERENCE: 15MAY08] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]

DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From tmiller@haverford.edu Tue, 29 Jun 1999 09:24:25 -0400 (EDT)
Date: Tue, 29 Jun 1999 09:24:25 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Re: [JOS-Admin] Alternative approach to "memory" classes...

> Issue #2:
> 
> Are there any legal ramifications of cloning the JavaOS APIs?  Is
> anybody in a position to find out?  If there are issues, I'd sure like
> to know about them right now so that we can do option (1) instead...

	Paired with this issue: does anyone know what the
kind of redistribution of the JavaOS drivers is allowed?  I would guess
that individual manufacturers don't particularly care, but Sun might have
something against letting the drivers it ships with JavaOS spread to the
four routers of the internet.

	As for the legal ramifications of cloning the JavaOS APIs, we'll
be engaged in an even more time-honored approach than Open Source
"tail-light chasing" -- reverse engineering!

-_Quinn




From cevans@viaduct.com Tue, 29 Jun 1999 09:40:45 -0400
Date: Tue, 29 Jun 1999 09:40:45 -0400
From: Clark Evans cevans@viaduct.com
Subject: [JOS-Kernel] Alternative approach to "memory" classes...

John Morrison wrote:
> Issue #2:
> 
> Are there any legal ramifications of cloning the JavaOS APIs?  Is
> anybody in a position to find out?  If there are issues, I'd sure like
> to know about them right now so that we can do option (1) instead...

I don't think there are any serious legal concerns,
if there are, then those concerns apply to the 
whole effort, including the classpath.org fellas.

The only "generic" concern that I can dream up
is patent oriented -- if their API "forces" the 
specific use of patented technique.  In this case,
much research will be needed for the work around... 
so no use trying to plan for it.

Have fun chasing!

Clark



From iainshigeoka@yahoo.com Tue, 29 Jun 1999 08:18:48 -0700 (PDT)
Date: Tue, 29 Jun 1999 08:18:48 -0700 (PDT)
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Kernel] Alternative approach to "memory" classes...

> (2) implementing something as close as is humanly
> possible to the JavaOS API(s), 

I would strongly vote for this option. Not only do we
get to use their architecture and hopefully reap
benefits from JavaOS Driver compatibility, but we
will have access to common documentation for the API
(good for our developers, and for users... open
source has always had some difficulty in providing
documentation that's as high quality as their code),
and perhaps more willingness on hardware manufacturer's
part to support such drivers.

> Issue #2:
> 
> Are there any legal ramifications of cloning the
> JavaOS APIs?  Is
> anybody in a position to find out?  If there are
> issues, I'd sure like
> to know about them right now so that we can do
> option (1) instead...

If you're taking it from a book (not looking at the
source) I can't see how it would be.  If SUN doesn't
like what you're doing, I'm sure they'll let you know!
:)

-iain
_________________________________________________________
Do You Yahoo!?
Get your free @yahoo.com address at http://mail.yahoo.com




From myoung@bristol.st.com Tue, 29 Jun 1999 16:40:34 +0100
Date: Tue, 29 Jun 1999 16:40:34 +0100
From: Martin Young myoung@bristol.st.com
Subject: [JOS-Kernel] Alternative approach to "memory" classes...

> Subject: Re: [JOS-Kernel] Alternative approach to "memory" classes...
> > (2) implementing something as close as is humanly
> > possible to the JavaOS API(s),

I too saw this book.  As far as I can tell it's based on the "JavaOS" used by
IBM in its "JavaOS for Business" product.

I haven't seen any official announcements but it is my impression that this is
now obselete.  Very, very, few systems were shipped and there is no on-going
development.  I haven't read the book or had any direct experience but, again,
it it my impression that this form of JavaOS was a minimal-effort hack
performed solely to get something out into the marketplace so IBM could sell
Java based thin clients (i.e. network computers).

I have a vested interest in operating systems and Java (it's more-or-less what
I do for a living) so I had a fairly good look around JavaOne.  I don't recall
seeing *anything* using this JavaOS.

The current push is for "JavaOS for Consumers" which is Personal Java on top of
ChorusOS.  This is quite a different animal to "JavaOS for Business" and I find
it hard to imagine Sun basing any new JavaOS variants on a different
architecture.  Several vendors were showing Personal Java running on top of
VxWorks and OS-9; these are very similar to JOS4C.

Before cloning the interfaces in your book I recommend you investigate whether
or not they're the same as those used in JOS4C.  Personally I'm not aware of
any published documentation for JOS4C's interfaces (but if you find some, I'm
interested).


-- 
Martin Young, at STMicroelectronics,   \O    O   \O    O
  at 1000 Aztec West, Almondsbury,     //\  /\\  //\  /\\   ,^O
Bristol, BS32 4SQ. +44 145 446 2523   / |  / \  / |  //    // `   \\__|O
     myoung@bristol.st.com           Ah   Ah   Ah   Ah   Stayin' alive



From ryan@whitewolf.com.au Wed, 30 Jun 1999 10:22:49 +1000
Date: Wed, 30 Jun 1999 10:22:49 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Kernel] Cloning Sun's APIs { was: Re: [JOS-Kernel] Alternative approach to
 "memory" classes... }
 "memory" classes... }

John Morrison wrote:

> Issue #2:
> 
> Are there any legal ramifications of cloning the JavaOS APIs?  Is
> anybody in a position to find out?  If there are issues, I'd sure like
> to know about them right now so that we can do option (1) instead...

Sun seem to think it's illegal (what a joke!). At least that's what this
article appears to say:

	http://www.infoworld.com/articles/hn/xml/990628hnmsjavax.xml

Basically, the court said Microsoft has the right to distribute an
independently developed software that does not comply with Sun's Java
compatibility requirements. Down in the last paragraph, a Sun
spokesperson says:

"That's Sun intellectual property. And the judge has been very clear
about that, that if Microsoft uses the specs or uses the documentation,
it is not an independent work, or if Microsoft purchases something from
a third party that had used the documentation or the specs, it's not an
independent work."

Pfff...

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From hilarycheng@usa.net Wed, 30 Jun 1999 09:05:13 +0800
Date: Wed, 30 Jun 1999 09:05:13 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Kernel] Alternative approach to "memory" classes...

Hi,

>(2) implementing something as close as is humanly possible to the JavaOS
>API(s), which will be more work in the short term, but maybe less in the
>long term, and which will obviate the consensus-building group-grope
>problem we currently have, which makes it much harder to get anything
>done that involves more than one person...
>
>Basically, option (1) is the "let's re-invent the wheel" approach, and
>(2) is the time-honored, Open Source "chase the tail-lights" approach.
>As much as I like designing my own APIs (of course, they would be far
>superior to and more aesthetically pleasing than the JavaOS ones --
>*N-O-T*), I'm kind of leaning towards option (2).  I mean, hell, we're
>not redesigning the Java language, the bytecodes, or the java.* classes,
>so...
>

For the Option (2), personally, I don't prefer this approach. Since all the
APIs
are provided by Sun. Once Sun found that the APIs is not good enough, they
will change it (e.g. Swing). If we follow Sun's APIs, we need to "re-do" all
our
works. Is that good ? I don't think so. One more thing, right now, all Of
Products
of Sun Java are not OPEN SOURCE. If we follow Sun's APIs, THEY MAY NOT
ALLOW US TO RELEASE SOURCE.

Regards,

Hilary






From hilarycheng@usa.net Wed, 30 Jun 1999 09:15:31 +0800
Date: Wed, 30 Jun 1999 09:15:31 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Kernel] Some Questions on Current Design

This is a multi-part message in MIME format.

------=_NextPart_000_007E_01BEC2D9.1A687E20
Content-Type: text/plain;
	charset="big5"
Content-Transfer-Encoding: quoted-printable

Hi,

    Finally, I can boot JJOS remotely using Floppy. So that I can join =
the development of JJOS. :)
    But I have some questions on JJOS.

1. Is that any discussion are already talking about desiging I/O, Mem in =
JJOS? What I mean is that,
    Which Parts of Objects Should be implememted By C, Which Parts of =
Objects Should be=20
    implememted By Java ?

2. Should Everything use Java to Implement ? or For Hardware Driver, we =
use C. Except Driver, We use     Java ?

3. Is that any works has been started to due with Graphics Adaptor ?

4. Any standard of Native Implementation of Java in JJOS ?

Regards,

Hilary

------=_NextPart_000_007E_01BEC2D9.1A687E20
Content-Type: text/html;
	charset="big5"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD W3 HTML//EN">
<HTML><HEAD>
<META content=3Dtext/html;charset=3Dbig5 http-equiv=3DContent-Type>
<STYLE></STYLE>

<META content=3D'"MSHTML 5.00.0910.1309"' name=3DGENERATOR></HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>Hi,</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; Finally, I can boot =
JJOS=20
remotely using Floppy. So that I can join the development of JJOS.=20
:)</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; But I have some =
questions on=20
JJOS.</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>1. Is that any discussion are already =
talking about=20
desiging I/O, Mem in JJOS? What I mean is that,</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>&nbsp;&nbsp;&nbsp; Which Parts of=20
Objects</FONT><FONT face=3DArial size=3D2> Should be implememted By C, =
<FONT=20
face=3DArial size=3D2>Which Parts of Objects </FONT><FONT face=3DArial =
size=3D2>Should=20
be</FONT></FONT><FONT face=3DArial size=3D2><FONT face=3DArial size=3D2> =

</FONT></FONT></DIV>
<DIV><FONT face=3DArial size=3D2><FONT face=3DArial =
size=3D2>&nbsp;&nbsp;&nbsp;=20
implememted By Java ?</FONT></FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>2. Should Everything use Java to =
Implement ? or For=20
Hardware Driver, we use C. Except Driver, We use &nbsp;&nbsp;&nbsp; Java =

?</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>3. Is that any works has been started =
to due with=20
Graphics Adaptor ?</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>4. Any standard of Native =
Implementation of Java in=20
JJOS ?</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Regards,</FONT></DIV>
<DIV>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Hilary</FONT></DIV></BODY></HTML>

------=_NextPart_000_007E_01BEC2D9.1A687E20--




From tmiller@haverford.edu Tue, 29 Jun 1999 23:14:57 -0400 (EDT)
Date: Tue, 29 Jun 1999 23:14:57 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Some Questions on Current Design

> 1. Is that any discussion are already talking about desiging I/O, Mem in JJOS? What I mean is that,
>     Which Parts of Objects Should be implememted By C, Which Parts of Objects Should be 
>     implememted By Java ?

	We want to do as much as possible in Java; the specifics are under
discussion on this list; see the thread "alternative approach to memory
classes" for the issues.

> 2. Should Everything use Java to Implement ? or For Hardware Driver, we use C. Except Driver, We use     Java ?

	Java is used to implement "as much as possible."  Practically,
that means the kernel and the JVM are written in native code; drivers are
written in Java using native method calls for access to the hardware.

> 3. Is that any works has been started to due with Graphics Adaptor ?

	Well, JJOS runs in text mode :)  JM is going to write up memory
access classes as soon as the problems raised by question #1 are decided.

> 4. Any standard of Native Implementation of Java in JJOS ?

	Currently, no.  Eventually, I plan on support JNI.

-_Quinn





