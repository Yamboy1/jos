<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [JOS-Kernel] event handling &amp; decaf/JJOS</TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:RegierAveryJ%40JDCORP.deere.com">
   <LINK REL="Previous"  HREF="000024.html">
   <LINK REL="Next" HREF="000026.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[JOS-Kernel] event handling &amp; decaf/JJOS</H1>
    <B>Regier Avery J</B> 
    <A HREF="mailto:RegierAveryJ%40JDCORP.deere.com"
       TITLE="[JOS-Kernel] event handling &amp; decaf/JJOS">RegierAveryJ@JDCORP.deere.com</A><BR>
    <I>Thu, 1 Apr 1999 14:25:56 -0600</I>
    <P><UL>
        <LI> Previous message: <A HREF="000024.html">[JOS-Kernel] event handling &amp; decaf/JJOS</A></li>
        <LI> Next message: <A HREF="000026.html">[JOS-Kernel] event handling &amp; decaf/JJOS</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25">[ date ]</a>
              <a href="thread.html#25">[ thread ]</a>
              <a href="subject.html#25">[ subject ]</a>
              <a href="author.html#25">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Todd,

I think you both misunderstood what I was saying and reinvented it all at
the same time. :)

MY concern with this is how to distribute events &amp; streams from a parent
Process (ProcessEnvironment) to its child processes.  That is essentially
what I was describing before that will need to be implemented into the
org.jos.core.* library which will be used to implement java.lang.*, and (now
that I think about it) the event handling system (java.awt.event.*,
java.util.EventObject, java.awt.AWTEventMulticaster, etc.).  What I
described before was how we can let the shell (of which its
ProcessEnvironment is a parent to the ProcessEnvironments of applications
started from that shell) translate KeyEvents into the System.in for each
process (and each process will need its own seperate System.in - which means
that statics will have to be unique to a Process, not accross all Processes
in the VM!).  This is essentially the type of system you descibe in the
first paragraph below.  Also, not all KeyEvents sent to a shell necessarily
get turned into System.in, but some will have to be sent as KeyEvents to
various GUI components.  I think that it is enough for now to say that the
shell's ProcessEnvironment will have to have its own smart event distributor
which will know where to send such events next.  This is a topic completely
seperate from the VM &amp; device driver implementation and is best hashed out
in the <A HREF="mailto:arch@jos.org">arch@jos.org</A> list.

The real question before us is how to get KeyEvents (and other events
generated by device drivers) to the shell(s?) so that the shell can take
care of sending them where they ultimately need to go.  What we may need is
a simple Proxy that is not necessarily a static class but perhaps daemon
process which is a parent to all of the shells.  This Proxy would then be
'designated' for sending events wherever they need to go, and how it handles
them is of no concern to the vm and device drivers.  This EventProxy could
be replaced by the user with another implementation that has characteristics
more suitable to the user (For instance, one that is more real-time in
nature, or one that has a complicated threading scheme to make sure that an
errant process's event handling doesn't tie up the system, etc.)

I don't particularly like the second way that you mention because I can see
a lot of overhead when components change focus and another component
suddenly needs to be recieving the key events.  But on the other hand, all
of the options have overhead somewhere, it is just a matter of where do we
want the overhead to be, and which one makes for the most flexible and
robust system.

Avery J. Regier


&gt;<i> -----Original Message-----
</I>&gt;<i> From:	Todd L. Miller [SMTP:<A HREF="mailto:tmiller@haverford.edu">tmiller@haverford.edu</A>]
</I>&gt;<i> Sent:	Wednesday, March 31, 1999 11:49 PM
</I>&gt;<i> To:	<A HREF="mailto:kernel@jos.org">kernel@jos.org</A>
</I>&gt;<i> Subject:	[JOS-Kernel] event handling &amp; decaf/JJOS
</I>&gt;<i> 
</I>&gt;<i> 	I was just thinking about how one might go about distributing
</I>&gt;<i> jos.system.event.* to where they might need to go, in the context of
</I>&gt;<i> how java.lang.System.* variables will be redirected *by the shell.*  Uh...
</I>&gt;<i> why not let the 'shell' handle event dispatching?  The shell pretty
</I>&gt;<i> clearly will know which program is 'active' and needs to have keyEvents
</I>&gt;<i> distributed to; make the shell both a keyListener and a keySpeaker, in
</I>&gt;<i> other words, where it speaks keys to the applications that are running
</I>&gt;<i> under it as necessary, as part of its java.lang.System.* redirects,
</I>&gt;<i> basically.  If an application from the c/l implements interface
</I>&gt;<i> jos.system.event.keyListener (xxxListener, in the general case, for
</I>&gt;<i> whatever redirects the shell supports), the events are direct to the
</I>&gt;<i> application; otherwise the shell employs whatever its default handling
</I>&gt;<i> might be -- which is probably just converting the keyEvents into a
</I>&gt;<i> character stream for the 'active' (fg) application's java.lang.System.*
</I>&gt;<i> variables.
</I>&gt;<i> 
</I>&gt;<i> 	Obviously, the console could do some keyEvent filtering and
</I>&gt;<i> redirects as well, and then the Virtual Console Manager (or whatever we
</I>&gt;<i> call it -- the consoled that should be the sole jos.system.keyboard
</I>&gt;<i> listener in text mode (the listener switching to the WM upon invocation),
</I>&gt;<i> started by init, would direct keyEvents to the current console.  Likewise,
</I>&gt;<i> the WM could handle redirects to the xterm console objects.  Clearly,
</I>&gt;<i> consoled would install a keyboard interperter that would handle the
</I>&gt;<i> trapping of ALT-F1 (or whatever) that's used to handle console swapping.
</I>&gt;<i> 
</I>&gt;<i> viz, with three virtual consoles, one in use: ( -&gt; speaks to )
</I>&gt;<i> 
</I>&gt;<i> jos.system.keyboard -&gt; jos.system.consoled -&gt;
</I>&gt;<i> 	-&gt; jos.core.console -&gt; login 
</I>&gt;<i> 	-&gt; jos.core.console -&gt; login
</I>&gt;<i> 	-&gt; jos.core.console -&gt; jsh -&gt;
</I>&gt;<i> 		-&gt; j_pine
</I>&gt;<i> 		-&gt; j_ftp
</I>&gt;<i> 
</I>&gt;<i> Clearly, then, access to jos.system.keyboard needs to be limited in some
</I>&gt;<i> fashion, because it would screw things up royally to have multiple
</I>&gt;<i> identical keyEvent sources in the same dispatch tree.
</I>&gt;<i> 
</I>&gt;<i> 	There are two ways to implement this.  The first is to implement a
</I>&gt;<i> 'static' variable somewhere that in turns points to the next object up on
</I>&gt;<i> the tree; this would Aviery's (?) idea, with the added understanding that
</I>&gt;<i> the static variable is used as the instance for an addKeyListener()
</I>&gt;<i> method; and have the access methods, etc. to handle those 'redirects.'
</I>&gt;<i> The major problem with this is that it voluntarily adds another static
</I>&gt;<i> class to keep track of across different processes, which strikes me as
</I>&gt;<i> asking for trouble.
</I>&gt;<i> 
</I>&gt;<i> 	The second way (there might be more -- any ideas?) would be to
</I>&gt;<i> provide a method for the parent process to tell the child process to
</I>&gt;<i> listen to it, i.e. setKeySpeaker().  ('discovery' methods, i.e.
</I>&gt;<i> findKeySpeaker() simply move the static variable setting stuff a level
</I>&gt;<i> away.)  The jos.core.application superclass we provide to simplify the
</I>&gt;<i> making of jos-aware applications would provide an addKeyListener()
</I>&gt;<i> function in much the same way that Component does for the AWT.
</I>&gt;<i> 
</I>&gt;<i> 	Comments?
</I>&gt;<i> 
</I>&gt;<i> -_Quinn
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Kernel maillist  -  <A HREF="mailto:Kernel@jos.org">Kernel@jos.org</A>
</I>&gt;<i> <A HREF="http://jos.org/mailman/listinfo/kernel">http://jos.org/mailman/listinfo/kernel</A>
</I>
</pre>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000024.html">[JOS-Kernel] event handling &amp; decaf/JJOS</A></li>
	<LI> Next message: <A HREF="000026.html">[JOS-Kernel] event handling &amp; decaf/JJOS</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25">[ date ]</a>
              <a href="thread.html#25">[ thread ]</a>
              <a href="subject.html#25">[ subject ]</a>
              <a href="author.html#25">[ author ]</a>
         </LI>
       </UL>
</body></html>
