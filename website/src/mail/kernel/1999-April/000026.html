<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [JOS-Kernel] event handling &amp; decaf/JJOS</TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:tmiller%40haverford.edu">
   <LINK REL="Previous"  HREF="000025.html">
   <LINK REL="Next" HREF="000027.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[JOS-Kernel] event handling &amp; decaf/JJOS</H1>
    <B>Todd L. Miller</B> 
    <A HREF="mailto:tmiller%40haverford.edu"
       TITLE="[JOS-Kernel] event handling &amp; decaf/JJOS">tmiller@haverford.edu</A><BR>
    <I>Thu, 1 Apr 1999 20:11:25 -0500 (EST)</I>
    <P><UL>
        <LI> Previous message: <A HREF="000025.html">[JOS-Kernel] event handling &amp; decaf/JJOS</A></li>
        <LI> Next message: <A HREF="000027.html">[JOS-Kernel] (more or less) weekly update</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26">[ date ]</a>
              <a href="thread.html#26">[ thread ]</a>
              <a href="subject.html#26">[ subject ]</a>
              <a href="author.html#26">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> I think that it is enough for now to say that the
</I>&gt;<i> shell's ProcessEnvironment will have to have its own smart event distributor
</I>&gt;<i> which will know where to send such events next.  This is a topic completely
</I>&gt;<i> seperate from the VM &amp; device driver implementation and is best hashed out
</I>&gt;<i> in the <A HREF="mailto:arch@jos.org">arch@jos.org</A> list.
</I>
	Right.  I believe I mentioned this -- once we get the events to
the shell, it's no longer our problem.

&gt;<i> The real question before us is how to get KeyEvents (and other events
</I>&gt;<i> generated by device drivers) to the shell(s?) so that the shell can take
</I>&gt;<i> care of sending them where they ultimately need to go.  What we may need is
</I>&gt;<i> a simple Proxy that is not necessarily a static class but perhaps daemon
</I>&gt;<i> process which is a parent to all of the shells.
</I>
	AKA &quot;consoled,&quot; the daemon I suggested to handle multiple
virtual consoles would be the Proxy you're talking about.  consoled would
send each (of an arbitrary, RAM-limited number) virtual console instance
Events that they were Listeners for and had the focus to recieve.  Whether
the WM then displaces consoled as the &quot;prime reciever&quot; of Events or not is
entirely immaterial and depends on if you think a virtual console should
virtualize the graphics subsytem as well -- something we don't have to
worry about for a while, if at all.  (i.e. it might be more <A HREF="mailto:arch@jos.org">arch@jos.org</A>
stuff.)  Each shell, then, that would be a child of a virtual console
instance, would be responsible (or not, depending on the shell) listening
to its parent ( ProcessContext, etc: the interface between shell and
console (or shell and jterm, etc) needs to be standardized) for Events
which might concern it.
 
&gt;<i> I don't particularly like the second way that you mention because I can see
</I>&gt;<i> a lot of overhead when components change focus and another component
</I>&gt;<i> suddenly needs to be recieving the key events.  But on the other hand, all
</I>&gt;<i> of the options have overhead somewhere, it is just a matter of where do we
</I>&gt;<i> want the overhead to be, and which one makes for the most flexible and
</I>&gt;<i> robust system.
</I>
	It is, isn't it?  And you're probably right that this particular
discussion should be moved to <A HREF="mailto:arch@jos.org">arch@jos.org</A>; the concern of the kernel
group is mostly &quot;How many listeners should we allow per Device?  Should
each Device decide that on its own?&quot;  And so on.

	At any rate, I'll try to hack Albrecht's (?) scancode translation
stuff into the current setup, assuming for now that jos.system.keyboard
is the system-wide static abstraction of the physical keyboard generating
raw scancode KeyEvents, punting on the issue of single/multiple listeners
for now; and that the echo console (which is the short-term point of
writing in the scancode translator) subscribes a KeyboardInterperter to
jos.system.keyboard and listens to that interperter in turn, writing the
VK out to the screen as a character.  This echo console would probably
then become the consoled...

-_Quinn


</pre>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000025.html">[JOS-Kernel] event handling &amp; decaf/JJOS</A></li>
	<LI> Next message: <A HREF="000027.html">[JOS-Kernel] (more or less) weekly update</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26">[ date ]</a>
              <a href="thread.html#26">[ thread ]</a>
              <a href="subject.html#26">[ subject ]</a>
              <a href="author.html#26">[ author ]</a>
         </LI>
       </UL>
</body></html>
