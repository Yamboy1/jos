From gchii@mindspring.com Tue, 29 Feb 2000 18:25:22 -0500
Date: Tue, 29 Feb 2000 18:25:22 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JOS Machine

I picked up another JOS Machine ('486/66MHz/8MB RAM/420MB HD) for US$40. I
would like to work toward doing all my work within the JOS environment,
even if that means running telnet to other machines on the network.

Using JOS to get my work done would force certain issues about the scope of
the kernel and virtual machine.

Question: What is the status of decaf/classpath?

Is it possible to develop decaf so that it is compatible with Kore *and*
JDK 1.1.6 *and* classpath? We might have concurrent "subplatforms" defined
decaf. By changing the list when decaf binds machine code to native
methods, decaf works across all versions of Java.




From tmiller@haverford.edu Tue, 29 Feb 2000 20:56:41 -0500 (EST)
Date: Tue, 29 Feb 2000 20:56:41 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Machine

> Question: What is the status of decaf/classpath?

	decaf is currently under extremely heavy development at my
top-secret research labs located on the seafloor just outside of
Norfolk.  Unfortunately, their fiber was cut during a Navy training
excercise and they won't be able to code to the CVS for at least another
week.

	More seriously, I'm working on a total rewrite of the common/decaf
code, designed so that the VM-specific native code required to run
classpath will be as elegant and efficient as possible.  I'm giving
consideration to writing the native code calls & lookups toward ERIC,
specifically its SharedLibrary class (I don't recall if you've posted the
source or not).  Insulating decaf from how it fetches its native code is a
good idea; that the native code for VM-specific classes (and /all/ native
code on the host) will be linked in statically shouldn't prove to be too
much of a problem, right?

> Is it possible to develop decaf so that it is compatible with Kore *and*
> JDK 1.1.6 *and* classpath? We might have concurrent "subplatforms" defined
> decaf. By changing the list when decaf binds machine code to native
> methods, decaf works across all versions of Java.

	This should be possible.  I will not, however, be providing
support for anything aside from classpath.  Kore should be fairly simple
for someone to add; JDK 1.1.x will be very difficult, unless Kaffe (et
al) have a remarkably clean JVM/VM class separation that allows us to look
at their source to derive what, exactly, Sun's native code is supposed to
be doing.


	Just as note -- even if we can link and load classpath libraries,
we can't do anything useful with them yet, because decaf does not
currently (and may not ever) support JNI.  It would seem advisable to
develop dynamic library support for the i386 build (or borrow it from
somewhere else) for fairly straight-forward reasons about driving the
hardware (especially hot-pluggable h/w), but I'm not quite so sure that
JNI is a good idea.  In certain locations (e.g. h/w) we must use native
code until such a time that decaf can run a java device driver fast enough
to handle h/w timeouts and buffers, etc (and even then, it's probably wise
to stick with native drivers in most cases), but no user-level task should
require native code aside from (possibly) driver support.

-_Quinn






From gchii@mindspring.com Wed, 01 Mar 2000 11:23:38 -0500
Date: Wed, 01 Mar 2000 11:23:38 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JOS Machine

At 08:56 PM 2/29/00 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> Question: What is the status of decaf/classpath?
>
>	decaf is currently under extremely heavy development at my
>top-secret research labs located on the seafloor just outside of
>Norfolk.  Unfortunately, their fiber was cut during a Navy training
>excercise and they won't be able to code to the CVS for at least another
>week.
>
>	More seriously, I'm working on a total rewrite of the common/decaf
>code, designed so that the VM-specific native code required to run
>classpath will be as elegant and efficient as possible.  I'm giving
>consideration to writing the native code calls & lookups toward ERIC,
>specifically its SharedLibrary class (I don't recall if you've posted the
>source or not).  Insulating decaf from how it fetches its native code is a
>good idea; that the native code for VM-specific classes (and /all/ native
>code on the host) will be linked in statically shouldn't prove to be too
>much of a problem, right?

Oh, wow. I hadn't thought of that. If we have a SharedLibrary interface in
C++, we can have a corresponding shared library factory for JVM-specific
"classes". I was thinking of decaf as one big shared library; but no! it
can be more modular.

When compiled to a shared library, I can invoke the decaf virtual machine
through a function like this:

  const char *libname = "decaf";

  void example() {
    SharedLibrary lib = createSharedLibrary( libname );
    decaf_main = lib.getMethod( "decaf_main" );

    decaf_main( argc, argv, Kernel *k );
  }

To extend it as you describe, we *could* get a shared library for "classes"
within decaf virtual machine through a similar function:

  const char *libname = "decaf";
  const char *classname = "java.lang.Object";

  void example() {
    SharedLibrary lib = createSharedLibrary( libname );
    void *(*getNativeClass)(const char *);
    getNativeClass = lib.getMethod( "getNativeClass" );

    SharedLibrary o = getNativeClass( classname );
    jclass *(*object_getClass)(jobject *);
    object_getClass = o.getMethod( "getClass" );

    jclass v = object_getClass( jobject );
  }

Of course, getNativeClass() is JVM-specific. For decaf, it can return an
instance of SharedLibrary appropriate to the requested class. Using the
existing decaf mechanism to bind methods to machine code, each decaf
sublibrary might return pointers to methods of a single class.

I would prefer to Kore-like approach used in the Alt packages. It uses a
shared library for each *package*, instead of for each class. While both
are functionally equivalent, one shared library per package is simpler.

  const char *libname = "decaf";
  const char *classname = "java.lang";

  void example() {
    SharedLibrary lib = createSharedLibrary( libname );
    void *(*getNativeClass)(const char *);
    getNativeClass = lib.getMethod( "getNativeClass" );

    SharedLibrary lang = getNativeClass( classname );
    jclass *(*object_getClass)(jobject *);
    object_getClass = lang.getMethod( "Object.getClass" );

    jclass v = object_getClass( jobject );
  }

At the next level, the above code *could* be reduced using a multi-stage
factory to create a shared library:

  const char *libname = "decaf:java.lang";

  void example() {
    SharedLibrary lang = createSharedLibrary( libname );
    jclass *(*object_getClass)(jobject *);
    object_getClass = lang.getMethod( "Object.getClass" );

    jclass v = object_getClass( jobject );
  }

All features of the shared library factory can be delegated to a
platform-specific implementation of createSharedLibrary(). Or, a
platform-specific behavior can be implemented as plug-ins.

Note: Method names are mapped to machine code by each shared library. The
name of a Java native method can be *anything*; it does not have to use the
JNI naming convention. In C++, I want a method called object_getClass
instead of a method called Java_java_lang_object_getClass.

>> Is it possible to develop decaf so that it is compatible with Kore *and*
>> JDK 1.1.6 *and* classpath? We might have concurrent "subplatforms" defined
>> decaf. By changing the list when decaf binds machine code to native
>> methods, decaf works across all versions of Java.
>
>	This should be possible.  I will not, however, be providing
>support for anything aside from classpath.  Kore should be fairly simple
>for someone to add; JDK 1.1.x will be very difficult, unless Kaffe (et
>al) have a remarkably clean JVM/VM class separation that allows us to look
>at their source to derive what, exactly, Sun's native code is supposed to
>be doing.

Thanks for the clarification. I'd like to continue working on Kore/BCNI.

>	Just as note -- even if we can link and load classpath libraries,
>we can't do anything useful with them yet, because decaf does not
>currently (and may not ever) support JNI.  It would seem advisable to
>develop dynamic library support for the i386 build (or borrow it from
>somewhere else) for fairly straight-forward reasons about driving the
>hardware (especially hot-pluggable h/w), but I'm not quite so sure that
>JNI is a good idea.  In certain locations (e.g. h/w) we must use native
>code until such a time that decaf can run a java device driver fast enough
>to handle h/w timeouts and buffers, etc (and even then, it's probably wise
>to stick with native drivers in most cases), but no user-level task should
>require native code aside from (possibly) driver support.

The SharedLibrary mechanism shown above might be simpler than JNI. I prefer
BCNI over JNI. decaf works without JNI. To start decaf after its a shared
library, any program can call decaf_main() to start the virtual machine.
decaf returns from decaf_main() after all of non-daemon threads are
complete (doesn't it?).

The interface between jJOS and decaf (and any other virtual machine for
that matter) might be reduced to an interface like that of a command line,
similar to the java tool. A caller must assemble argv and pass it to
decaf_main().

void decaf_main( int argc, char *argv[], Kernel *k );

This is what jJOS does, isn't it?




From tmiller@haverford.edu Wed, 1 Mar 2000 13:27:18 -0500 (EST)
Date: Wed, 1 Mar 2000 13:27:18 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Machine

> Oh, wow. I hadn't thought of that. If we have a SharedLibrary interface in
> C++, we can have a corresponding shared library factory for JVM-specific
> "classes". I was thinking of decaf as one big shared library; but no! it
> can be more modular.

	Specifically, there could be the interpreter and bytecode
internalization* in one module, and the VM-specific code in another module
or set of modules; ditto the native code for the class library to be
used.  My specific concern for JNI is that class library native code that
the maintainers of the class library write in JNI (to maintain VM
independence).  It would be /very/ nice not to add another Java class
library to the mix...

> Of course, getNativeClass() is JVM-specific. For decaf, it can return an
> instance of SharedLibrary appropriate to the requested class. Using the
> existing decaf mechanism to bind methods to machine code, each decaf
> sublibrary might return pointers to methods of a single class.

	And that's the key -- for JVM-specific classes, it's fine to use
JVM-specific methods (duh.)  But this mechanism doesn't extend to extant
native libraries which use JNI.

> Thanks for the clarification. I'd like to continue working on Kore/BCNI.

	And I will be more than happy to slurp the BCNI code at the
appropriate point -- and the Kore code if you can get it and its libraries
working before I get classpath working.  Happy hacking!

> The SharedLibrary mechanism shown above might be simpler than JNI. I prefer
> BCNI over JNI. decaf works without JNI. To start decaf after its a shared
> library, any program can call decaf_main() to start the virtual machine.
> decaf returns from decaf_main() after all of non-daemon threads are
> complete (doesn't it?).

	Yes.  That's why the current implementation of 'init' sits in an
infinite loop.  This may be changed so that some VMs will continue to
exist for daemon threads like the TCP/IP stack -- things at the system
level.  (On the other hand, decaf doesn't make an explicit distinction
between daemon and regular threads, so I'll have to look at the specs and
see what to do.  The technical behavoir of decaf is to terminate when
(a) there are no unserviced interrupts pending, (b) there are no
unserviced notifications pending, and (c) there are no threads in the
active queue.  This will probably create problems for event-based apps
(most of them!) unless they also leave a busy-waiting thread lying
around, so I'll look at that before I CVS the new code.  Thanks for
bringing it to my attention.)

> The interface between jJOS and decaf (and any other virtual machine for
> that matter) might be reduced to an interface like that of a command line,
> similar to the java tool. A caller must assemble argv and pass it to
> decaf_main().
> 
> void decaf_main( int argc, char *argv[], Kernel *k );
> 
> This is what jJOS does, isn't it?

	Yes.  If the initialization code for getting the 'Kernel'
(jjmachine *) weren't platform-specific, decaf_main() could be the C++ 
entry point for jJOS/decaf.

	In general, I don't see any particular technical difficulty to
maintaining a decaf distribution as a system-wide 'libjvm' type of thing,
and with a bit of work, it should be able to work much like TCL.  I've
(obviously!) got other things to work on right now, but this could be an
interesting project.

-_Quinn

* Note that the bytecode /fetching/, as per the classloader spec, can be
done by just about anything -- and there's no reason to suppose that the
primordial classloader couldn't also be provided by the application,
though I'm not going to go out of my way to allow that right now.




From hilarycheng@usa.net Thu, 02 Mar 2000 09:30:52 +0800
Date: Thu, 02 Mar 2000 09:30:52 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Kernel] JOS Machine

HI ALl,

    As u propose the code as below, some what like a JNI. If we need it,
better to port decaf to JNI compatible one. :P

Regards,

Hilary



>
> When compiled to a shared library, I can invoke the decaf virtual machine
> through a function like this:
>
>   const char *libname = "decaf";
>
>   void example() {
>     SharedLibrary lib = createSharedLibrary( libname );
>     decaf_main = lib.getMethod( "decaf_main" );
>
>     decaf_main( argc, argv, Kernel *k );
>   }
>
> To extend it as you describe, we *could* get a shared library for "classes"
> within decaf virtual machine through a similar function:
>
>   const char *libname = "decaf";
>   const char *classname = "java.lang.Object";
>
>   void example() {
>     SharedLibrary lib = createSharedLibrary( libname );
>     void *(*getNativeClass)(const char *);
>     getNativeClass = lib.getMethod( "getNativeClass" );
>
>     SharedLibrary o = getNativeClass( classname );
>     jclass *(*object_getClass)(jobject *);
>     object_getClass = o.getMethod( "getClass" );
>
>     jclass v = object_getClass( jobject );
>   }
>
> Of course, getNativeClass() is JVM-specific. For decaf, it can return an
> instance of SharedLibrary appropriate to the requested class. Using the
> existing decaf mechanism to bind methods to machine code, each decaf
> sublibrary might return pointers to methods of a single class.
>
> I would prefer to Kore-like approach used in the Alt packages. It uses a
> shared library for each *package*, instead of for each class. While both
> are functionally equivalent, one shared library per package is simpler.
>
>   const char *libname = "decaf";
>   const char *classname = "java.lang";
>
>   void example() {
>     SharedLibrary lib = createSharedLibrary( libname );
>     void *(*getNativeClass)(const char *);
>     getNativeClass = lib.getMethod( "getNativeClass" );
>
>     SharedLibrary lang = getNativeClass( classname );
>     jclass *(*object_getClass)(jobject *);
>     object_getClass = lang.getMethod( "Object.getClass" );
>
>     jclass v = object_getClass( jobject );
>   }
>
> At the next level, the above code *could* be reduced using a multi-stage
> factory to create a shared library:
>
>   const char *libname = "decaf:java.lang";
>
>   void example() {
>     SharedLibrary lang = createSharedLibrary( libname );
>     jclass *(*object_getClass)(jobject *);
>     object_getClass = lang.getMethod( "Object.getClass" );
>
>     jclass v = object_getClass( jobject );
>   }
>
> All features of the shared library factory can be delegated to a
> platform-specific implementation of createSharedLibrary(). Or, a
> platform-specific behavior can be implemented as plug-ins.
>
> Note: Method names are mapped to machine code by each shared library. The
> name of a Java native method can be *anything*; it does not have to use the
> JNI naming convention. In C++, I want a method called object_getClass
> instead of a method called Java_java_lang_object_getClass.
>
> >> Is it possible to develop decaf so that it is compatible with Kore *and*
> >> JDK 1.1.6 *and* classpath? We might have concurrent "subplatforms" defined
> >> decaf. By changing the list when decaf binds machine code to native
> >> methods, decaf works across all versions of Java.
> >
> >       This should be possible.  I will not, however, be providing
> >support for anything aside from classpath.  Kore should be fairly simple
> >for someone to add; JDK 1.1.x will be very difficult, unless Kaffe (et
> >al) have a remarkably clean JVM/VM class separation that allows us to look
> >at their source to derive what, exactly, Sun's native code is supposed to
> >be doing.
>
> Thanks for the clarification. I'd like to continue working on Kore/BCNI.
>
> >       Just as note -- even if we can link and load classpath libraries,
> >we can't do anything useful with them yet, because decaf does not
> >currently (and may not ever) support JNI.  It would seem advisable to
> >develop dynamic library support for the i386 build (or borrow it from
> >somewhere else) for fairly straight-forward reasons about driving the
> >hardware (especially hot-pluggable h/w), but I'm not quite so sure that
> >JNI is a good idea.  In certain locations (e.g. h/w) we must use native
> >code until such a time that decaf can run a java device driver fast enough
> >to handle h/w timeouts and buffers, etc (and even then, it's probably wise
> >to stick with native drivers in most cases), but no user-level task should
> >require native code aside from (possibly) driver support.
>
> The SharedLibrary mechanism shown above might be simpler than JNI. I prefer
> BCNI over JNI. decaf works without JNI. To start decaf after its a shared
> library, any program can call decaf_main() to start the virtual machine.
> decaf returns from decaf_main() after all of non-daemon threads are
> complete (doesn't it?).
>
> The interface between jJOS and decaf (and any other virtual machine for
> that matter) might be reduced to an interface like that of a command line,
> similar to the java tool. A caller must assemble argv and pass it to
> decaf_main().
>
> void decaf_main( int argc, char *argv[], Kernel *k );
>
> This is what jJOS does, isn't it?
>
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel




From tmiller@haverford.edu Wed, 1 Mar 2000 23:51:15 -0500 (EST)
Date: Wed, 1 Mar 2000 23:51:15 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Machine

>     As u propose the code as below, some what like a JNI. If we need it,
> better to port decaf to JNI compatible one. :P

	The problem with JNI in addition to defining a set of ways to
slurp dynamically-linked code, it specifies a very large and complete
interface that the JNI-compliant JVM must support.  It may be that this
support won't be as hopelessly difficult to write with the new version of
common/decaf (I'm working on it, honest!) but it certainly is for the
current, because the internals of (the old) decaf don't map very closely
at all to the JNI interface.

	As I mentioned before, JNI is not high on my list of things to
support right now for a few reasons: dynamic linking is not supported on
the i386 build; class library code, especially with BCNI and JOS as the
operating system, should probably not require native libraries -- though
that could be construed as a policy decision I'd be happy to punt on and
decide later; and finally, I'm not sure that application code should be
allowed to call native code in general in JOS either; certainly a general
facility on either build is a good distance away (scheduling, etc).

-_Quinn




From gchii@mindspring.com Sun, 05 Mar 2000 15:09:47 -0500
Date: Sun, 05 Mar 2000 15:09:47 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Installation instructions

It seems to me that there are many ways JOS can be installed. The
installation instructions depend on which model you want.

The basic requirements for the JOS machine itself are '486/66MHz/8MB Ram
(right?).

1. JOS/i386

Etherboot Option: This option also requires a JOS machine and network
server. The JOS machine to have a network interface card (NIC) and boot
media (1.44MB floppy, CD-ROM or hard drive). JOS for a network computer is
installed on a server and downloaded to a JOS machine with Etherboot. Use
Linux to format a diskette and copy a Etherboot boot image to it. Boot your
JOS machine from a floppy. Any network server with BOOTP and TFTP services
will do. I think installation instructions for this are found in the JOS1d
Distribution Binary Edition from Corrado Santoro
<Corrado.Santoro@IIT.UNICT.IT>.

GRUB Option: This option does not require a network interface card. JOS for
a personal computer (desktop or laptop) is installed on a Linux partition
(right?) and loaded with GRUB. Where are the instructions for this?

2. JOS/host

The "host" build of JOS runs on Linux. Run the decaf executable (right?)
from the command line. If you compiled jJOS/decaf into a binary executable,
what would I have to do to run it on my Linux box?




From gchii@mindspring.com Sun, 05 Mar 2000 20:12:32 -0500
Date: Sun, 05 Mar 2000 20:12:32 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] [zerich] C header file for dl..()

Functions for loading shared libraries dynamically are implemented in
libdl.so. There is a header file for this library. What is it?

According to Linux Programmer's Reference from Osborne/McGraw-Hill, my C
program should include "dlfcnt.h", like this:

#include <dlfcnt.h>

But not on my Linux distribution! I search for all files on my computer
that start with "dl" and end with ".h" and I can find none.

I looked up these functions on the Linux documentation project. While it
gives the signatures for dlopen(), dlclose(), dlerror() and dlsym(), it
does not give the values of RTLD_.. enumeration (like RTLD_LAZY) that's
passed to dlopen().




From alain@qnx.com Sun, 5 Mar 2000 21:40:13 -0500 (EST)
Date: Sun, 5 Mar 2000 21:40:13 -0500 (EST)
From: Alain Magloire alain@qnx.com
Subject: [JOS-Kernel] [zerich] C header file for dl..()

Bonjour

> Functions for loading shared libraries dynamically are implemented in
> libdl.so. There is a header file for this library. What is it?
> 

#include <dlfcn.h>

> According to Linux Programmer's Reference from Osborne/McGraw-Hill, my C
> program should include "dlfcnt.h", like this:
> 
> #include <dlfcnt.h>

It is probably a typo, This is not a Linux specific thing,
it is how the stds for example Unix98, define things.

> 
> But not on my Linux distribution! I search for all files on my computer
> that start with "dl" and end with ".h" and I can find none.

/usr/include/dlfcn.h

> 
> I looked up these functions on the Linux documentation project. While it
> gives the signatures for dlopen(), dlclose(), dlerror() and dlsym(), it
> does not give the values of RTLD_.. enumeration (like RTLD_LAZY) that's
> passed to dlopen().

RTLD_* are not defines directly in dlfcn for GNU lib C, since glibc
is use for many different operating systems and arch (i.e. GNU/Linux,
GNU/Hurd, etc ..) the dependent parts are included, for example in
bits/*.h are asm/*.h etc .. but in you case you should never include
them directly but use
#include <dlfcnt.h>

Look at the man pages or info files for more, this should have been
your first stop.  You may wine about info and all but how hard could
it have been to do `man dlopen' ??

-- 
au revoir, alain
----
Aussi haut que l'on soit assis, on est toujours assis que sur son cul !!!




From alain@qnx.com Sun, 5 Mar 2000 22:31:30 -0500 (EST)
Date: Sun, 5 Mar 2000 22:31:30 -0500 (EST)
From: Alain Magloire alain@qnx.com
Subject: [JOS-Kernel] [zerich] C header file for dl..()

Bonjour

> bits/*.h are asm/*.h etc .. but in you case you should never include
> them directly but use
> #include <dlfcnt.h>
> 

sigh .. another typo, maybe someone should ln -s those two ,

#include <dlfcn.h>


Good luck.


-- 
au revoir, alain
----
Aussi haut que l'on soit assis, on est toujours assis que sur son cul !!!




From George.Marrows@Smallworld.co.uk Mon, 6 Mar 2000 10:04:31 -0000
Date: Mon, 6 Mar 2000 10:04:31 -0000
From: George.Marrows@Smallworld.co.uk George.Marrows@Smallworld.co.uk
Subject: [JOS-Kernel] Installation instructions

There's some minimal instructions for GRUB booting at:

http://www.triptych.freeserve.co.uk/grub/index.html

Also, I doubt that the basic requirements of '486/66MHz/8MB Ram' are enough
-- it used to be (haven't tried for a while) that the i386 build failed to
finish the tests on a 16Mb machine cos it ran out of memory. It would also
be very s-l-o-w with that spec processor.

-- George

> -----Original Message-----
> From:	Gilbert Carl Herschberger II [SMTP:gchii@mindspring.com]
> Sent:	Sunday, March 05, 2000 8:10 PM
> To:	kernel@jos.org
> Subject:	[JOS-Kernel] Installation instructions
> 
> It seems to me that there are many ways JOS can be installed. The
> installation instructions depend on which model you want.
> 
> The basic requirements for the JOS machine itself are '486/66MHz/8MB Ram
> (right?).
> 
> 1. JOS/i386
> 
> Etherboot Option: This option also requires a JOS machine and network
> server. The JOS machine to have a network interface card (NIC) and boot
> media (1.44MB floppy, CD-ROM or hard drive). JOS for a network computer is
> installed on a server and downloaded to a JOS machine with Etherboot. Use
> Linux to format a diskette and copy a Etherboot boot image to it. Boot
> your
> JOS machine from a floppy. Any network server with BOOTP and TFTP services
> will do. I think installation instructions for this are found in the JOS1d
> Distribution Binary Edition from Corrado Santoro
> <Corrado.Santoro@IIT.UNICT.IT>.
> 
> GRUB Option: This option does not require a network interface card. JOS
> for
> a personal computer (desktop or laptop) is installed on a Linux partition
> (right?) and loaded with GRUB. Where are the instructions for this?
> 
> 2. JOS/host
> 
> The "host" build of JOS runs on Linux. Run the decaf executable (right?)
> from the command line. If you compiled jJOS/decaf into a binary
> executable,
> what would I have to do to run it on my Linux box?
> 
> 
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel



From Corrado.Santoro@IIT.UNICT.IT Mon, 6 Mar 2000 11:27:21 +0100
Date: Mon, 6 Mar 2000 11:27:21 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

On Mon, 06 Mar 2000, you wrote:
> 
> Also, I doubt that the basic requirements of '486/66MHz/8MB Ram' are enough
> -- it used to be (haven't tried for a while) that the i386 build failed to
> finish the tests on a 16Mb machine cos it ran out of memory. It would also
> be very s-l-o-w with that spec processor.
> 
No, no.... I've tried to boot JOS on 8MB RAM machine. It does not work!!!

-Corrado

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://osweb.iit.unict.it/ARCA
======================================================




From draft@fear.ch Mon, 6 Mar 2000 15:47:04 +0100
Date: Mon, 6 Mar 2000 15:47:04 +0100
From: Thomas Bocek draft@fear.ch
Subject: [JOS-Kernel] CVS

Hello

I tried to download the latest source from CVS. But CVS tells me: "cvs [login
aborted]: connect to jos.org:2401 failed:..."

could someone fix this? 

thanks

Thomas


--
Thomas Bocek
draft@fear.ch
--
mob: +41 79 678 9328
lab: +41 56 210 9242



From gchii@mindspring.com Mon, 06 Mar 2000 09:45:53 -0500
Date: Mon, 06 Mar 2000 09:45:53 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] [zerich] C header file for dl..()

At 09:40 PM 3/5/00 -0500, "Alain Magloire" <alain@qnx.com> wrote:
>Bonjour

Thanks for your response. If I had to guess, there are differences among
Linux distributions. Neither my Slackware nor my SuSE distribution have an
include file called dlfcn.h.

At the moment of installation, I did not anticipate my need for dlfcn.h.
From your description, it must an installation problem. I did not install
the dl package, nor any of its dependencies. Could that be it?

>> Functions for loading shared libraries dynamically are implemented in
>> libdl.so. There is a header file for this library. What is it?
>> 
>
>#include <dlfcn.h>

Thanks. Since you definitely know the name of the include file, I know now
that I definitely do not have it and can't find it.

>> But not on my Linux distribution! I search for all files on my computer
>> that start with "dl" and end with ".h" and I can find none.
>
>/usr/include/dlfcn.h

Sorry, I have no /usr/include/dlfcn.h on my Linux machines. It is
definitely missing. I searched for everything that starts with "dl",
something like this:

$ find -name dl*.h

If the find program cannot find it, it must not be there.

>> I looked up these functions on the Linux documentation project. While it
>> gives the signatures for dlopen(), dlclose(), dlerror() and dlsym(), it
>> does not give the values of RTLD_.. enumeration (like RTLD_LAZY) that's
>> passed to dlopen().
>
>RTLD_* are not defines directly in dlfcn for GNU lib C, since glibc
>is use for many different operating systems and arch (i.e. GNU/Linux,
>GNU/Hurd, etc ..) the dependent parts are included, for example in
>bits/*.h are asm/*.h etc .. but in you case you should never include
>them directly but use
>#include <dlfcnt.h>
>
>Look at the man pages or info files for more, this should have been
>your first stop.  You may wine about info and all but how hard could
>it have been to do `man dlopen' ??

I looked on the man pages on-line at the Linux Documentation Project. I
saved the link in the SharedLibraryOnLinux article on JOS Wiki. It helped a
little. I bought a book. It helped a little, too. But I am still unable to
load shared libraries dynamically.




From hilarycheng@usa.net Tue, 07 Mar 2000 20:41:21 +0800
Date: Tue, 07 Mar 2000 20:41:21 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Kernel] CVS

Hi All,

    Could we use sourceforge instead of current CVS Jos one ? Since
it seems that JOS one is not so stable.

Regards,

Hilary

Thomas Bocek wrote:

> Hello
>
> I tried to download the latest source from CVS. But CVS tells me: "cvs [login
> aborted]: connect to jos.org:2401 failed:..."
>
> could someone fix this?
>
> thanks
>
> Thomas
>
> --
> Thomas Bocek
> draft@fear.ch
> --
> mob: +41 79 678 9328
> lab: +41 56 210 9242
>
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel




From gchii@mindspring.com Tue, 07 Mar 2000 10:42:43 -0500
Date: Tue, 07 Mar 2000 10:42:43 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] CVS

At 08:41 PM 3/7/00 +0800, Hilary Cheng <hilarycheng@usa.net> wrote:
>    Could we use sourceforge instead of current CVS Jos one ? Since
>it seems that JOS one is not so stable.

Our first goal must be to "fix" the CVS we already have. Couldn't someone
monitor the CVS site, making sure CVS is up-and-running every day? Couldn't
we create an automatic restart for CVS, starting it whenever it goes down?
Couldn't we create a HTML link to restart CVS when its down?

CVS doesn't really need to be running for check-out, only check-in. If
someone would volunteer to make a snapshot of CVS as an archive, these
files would be available even when CVS is down.

Isn't it possible for the "old" CVS to be a mirror of SourceForge?

What about the future? I think moving CVS is a pretty big deal. It is a big
step. Who is going to do the migration work? Isn't this issue big enough to
require a vote on the vote mailing list?

If we decide to make the move, we should look forward and set a date.
Before that date, the "old" CVS would be the official site. After that
date, the "new" CVS would be the official site. How much time do we need?




From gchii@mindspring.com Tue, 07 Mar 2000 10:49:25 -0500
Date: Tue, 07 Mar 2000 10:49:25 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JOS Installation

I have written new articles on JOS Installation. Enter "InstallPages" at
the Go: prompt. Or, use the following link:

<URL:http://www.jos.org/wiki/view/Main/InstallPages>

Your help is needed. Please check these pages for accuracy. If you have
questions (or answers!) please post them to mailto:kernel@jos.org or e-mail
me at mailto:gchii@mindspring.com

Thanks,




From iainshigeoka@yahoo.com Tue, 7 Mar 2000 12:48:47 -0600
Date: Tue, 7 Mar 2000 12:48:47 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Kernel] CVS

On 7 Mar 00, at 10:42, Gilbert Carl Herschberger II wrote:

> At 08:41 PM 3/7/00 +0800, Hilary Cheng <hilarycheng@usa.net> wrote:
> >    Could we use sourceforge instead of current CVS Jos one ? Since
> >it seems that JOS one is not so stable.
> 
> Our first goal must be to "fix" the CVS we already have. Couldn't someone
> monitor the CVS site, making sure CVS is up-and-running every day? Couldn't
> we create an automatic restart for CVS, starting it whenever it goes down?
> Couldn't we create a HTML link to restart CVS when its down?

This is basically what we're doing now.  The CVS server on jos.org 
has been having semi-regular problems and is being restarted when 
needed.  It's flakey nature is prompting the move to SourceForge's 
CVS.

> CVS doesn't really need to be running for check-out, only check-in. If
> someone would volunteer to make a snapshot of CVS as an archive, these
> files would be available even when CVS is down.

Well, if you actually want to use _CVS_ check out, you need CVS 
running.  

As far as making snapshots available, that sounds like a good 
idea.  Once we move to SourceForge, this process is automated 
as we can have it automatically make CVS snap shots available on 
a daily basis.

> Isn't it possible for the "old" CVS to be a mirror of SourceForge?

Yes.  But to what advantage?

> What about the future? I think moving CVS is a pretty big deal. It is a big
> step. Who is going to do the migration work? Isn't this issue big enough to
> require a vote on the vote mailing list?

It's not actually hard at all.  If we do a fresh setup (which most of 
the kernel developers favor) someone with commit priviledges in 
sourceforge simple checks in the source to start things off.  If we 
want to save the CVS histories in the jos.org server, we simply tar-
gzip up the CVSROOT and email it to sourceforge.  They will install 
it within 24 hours.

> If we decide to make the move, we should look forward and set a date.
> Before that date, the "old" CVS would be the official site. After that
> date, the "new" CVS would be the official site. How much time do we need?

Last I heard, we're waiting for the kernel rewrite to get to a stable 
state.  Then, one of the core developers (Jim? Ryan?) will check in 
the sources to get the SourceForge cvs populated.

-iain



From gchii@mindspring.com Tue, 07 Mar 2000 19:43:23 -0500
Date: Tue, 07 Mar 2000 19:43:23 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Kernel Tests

It is possible, isn't it? We can write C/C++ programs to test/demonstrate
kernel functions. At the point where jJOS invokes decaf, jJOS could invoke
a power-on self-test, a diagnostic program, or some other
test/demonstration program written in C/C++.

This has the following benefits. Kernel functions, like virtual memory
management, interrupts and shared libraries, could be independently tested.
When decaf uses a kernel function, we'd know it works.

-----

Where and when should we implement memory management? In the kernel? Or, in
decaf? Should we do it now, when there is no swap file? Or later?

We should implement memory management in the kernel. The host build of the
kernel simply uses the memory management of a foreign operating system. The
i386 build of the kernel must implement memory management independently
from any other operating system.

With the memory management inherent in the i386, there is only so much JOS
can do differently than Linux. The interface between decaf and a kernel is
something like this:

void *alloc( size_t size );
void free( void * );

When decaf is the only kernel process, it is simple. When decaf must share
memory with other libraries, memory should be allocated on a per-library basis.




From tmiller@haverford.edu Tue, 7 Mar 2000 22:21:49 -0500 (EST)
Date: Tue, 7 Mar 2000 22:21:49 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

> No, no.... I've tried to boot JOS on 8MB RAM machine. It does not work!!!

	If someone felt like cutting down Sun's library, it might.  The
major barrier to an 8 MB machine is that Sun's class library alone weighs
in at about 7.6 MB, IIRC.  The rest of JJOS should fit in that 8 MB w/o
too much difficulty (e.g. turn off debug info) but that doesn't leave any
room for a heap or a stack :)

-_Quinn




From tmiller@haverford.edu Tue, 7 Mar 2000 22:23:38 -0500 (EST)
Date: Tue, 7 Mar 2000 22:23:38 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] CVS

>     Could we use sourceforge instead of current CVS Jos one ? Since
> it seems that JOS one is not so stable.

	While it's up, it's perfectly stable :)  I don't know why the
jos.org admin (shared box) keeps killing it :)

-_Quinn




From tmiller@haverford.edu Tue, 7 Mar 2000 22:26:43 -0500 (EST)
Date: Tue, 7 Mar 2000 22:26:43 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] CVS

> Last I heard, we're waiting for the kernel rewrite to get to a stable 
> state.  Then, one of the core developers (Jim? Ryan?) will check in 
> the sources to get the SourceForge cvs populated.

	Probably me, actually, at least for the JJOS subdirectory.  Moving
to a new CVS server will simplify the job of pushing the completely new
common/decaf directory immensely :)

-_Quinn




From tmiller@haverford.edu Tue, 7 Mar 2000 22:43:03 -0500 (EST)
Date: Tue, 7 Mar 2000 22:43:03 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] CVS

	Just finished womping up a script that will wake up every ten
minutes and hopefully restart CVS if it isn't up.  Not sure if it'll stay
up any longer than the server, but we can hope...

-_Quinn




From tmiller@haverford.edu Tue, 7 Mar 2000 22:48:31 -0500 (EST)
Date: Tue, 7 Mar 2000 22:48:31 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] [zerich] C header file for dl..()

> Thanks for your response. If I had to guess, there are differences among
> Linux distributions. Neither my Slackware nor my SuSE distribution have an
> include file called dlfcn.h.

	My distro of Slack 7 has it /usr/include.  My guess is that
re-installing the ELF development packages will put it in for you.  (e.g.
select the development package set from 'setup' and look for the ELF
development stuff.)

-_Quinn




From tmiller@haverford.edu Tue, 7 Mar 2000 22:58:24 -0500 (EST)
Date: Tue, 7 Mar 2000 22:58:24 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Kernel Tests

> It is possible, isn't it? We can write C/C++ programs to test/demonstrate
> kernel functions. At the point where jJOS invokes decaf, jJOS could invoke
> a power-on self-test, a diagnostic program, or some other
> test/demonstration program written in C/C++.

	The kernel right now is cleanly (sort of) divided between the
ASM, C, and C++ sections.  The C++ sections could be unit tested by class,
but almost all of the ASM can't be tested without running it.  Someone
who's sufficiently adventerous might be able to hack kdb or VMware to help
out here, but I'm certainly note one of them :)  The C section is the
garbage collector, whic is One Of Those Things I Would Someday Like To Try
My Hand At.  I'm not really sure what the proper testing procedure for a
garbage collector (esp. on written in C) might be, but if you're curios,
ask George Marrows, who wrote it.

> Where and when should we implement memory management? In the kernel? Or, in
> decaf? Should we do it now, when there is no swap file? Or later?

	No, definitely not in decaf.  The memory management is going to be
intimately tied with the virtual memory system and the garbage collector,
so they'll need to be looked at together.  (For instance, it may be
worthwhile to garbage-collect a page before swapping it out, and so on; do
we prefer to garbage collect before swapping when we run out of RAM?  How
does the pager's LRU list interact with the possibility of generational
GC?  Etc.)

> We should implement memory management in the kernel. The host build of the
> kernel simply uses the memory management of a foreign operating system. The
> i386 build of the kernel must implement memory management independently
> from any other operating system.

	Since we're currently running a monolithic system, much less a
monolithic kernel, I have to agree with you here.  On the other hand,
Linux seems to be doing just fine with a user-space swapper, etc -- and
Mach with its microkernel architecture.  Whatever we en up doing w.r.t. to
memory management should be portable with the minimum of effort to
whatever kernel/system design we end up `finalizing' on.

-_Quinn
	




From tmiller@haverford.edu Tue, 7 Mar 2000 23:34:59 -0500 (EST)
Date: Tue, 7 Mar 2000 23:34:59 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Installation

Generally:

	You keep giving a 4 MB figure for the distribution size -- does
that include the (required) class library (uncompressed zipfile)?

http://www.metamech.com/wiki/view/Main/InstallOptions

	Monolithic is spelled with an i.  The 'preferred' boot method is
now GRUB -- I won't be checking to make sure the Etherboot version works
as often because the GRUB booter is more convenient for me, now that
George Marrows has down the grunt work :)  Whether or not the GRUB or
Etherboot installation is preferred 'in the real world' is open to
question...

http://www.metamech.com/wiki/view/Main/InstallWithLinux

What are the minimum requirements of Linux in order to install JOS?

	JOS should not be using any libraries from your system except in
its 'kernel emulation', where it uses bits and pieces of the standard C++
library and the math library.  Optionally, it uses ncurses and libdl.  In
general, it depends on how the binary was compiled.

Which Linux distribution(s) should I use?

	I haven't noticed a particular preference on the list for
one; jJOS/decaf isn't terribly demanding.

What Linux packages should I install to run JOS? to build JOS?

	Running jJOS/decaf will only require whatever libraries it was
compiled to link against, hopefully.  To build the host target of
jJOS/decaf will require g++, gmake, javac, zip, optionally libncurses, and
optionally libdl.  Work-alikes might work also, though I have no idea if
they do or not.  (gmake for the makefile, g++ for the nativecode, javac
and zip for creating the jJOS/decaf classfiles and ramdisk image)  The
i386 build also needs the jjos-nbi softs (should be in CVS or somewhere on
the website?), etherboot or grub (GM gave a link to where his build of a
bootdisk is), and NASM. (a build of which should also be lying around on
the website somewhere.  Probably named 'tools.tgz', though I wouldn't
count on it.)

Runtime Edition

How do I install a runtime/binary distribution of JOS on Linux?

	Presumably, you untar it.  The distributor may well include a
tarball-root script file to execute jJOS/decaf from the right place and
with the default options.

	The host build creates a Linux executable. Where should it be
installed?

	In the deepest and darkest dungeon of your filesystem, where
nobody (uid 99) and the grues (in 'thedark' group) gather to celebrate
lossage by the light of a flaming core...

	... jJOS/decaf is so amazingly alpha that it emits bad bits as it
decays; its half-life is inversely proportional to the free time of the
developers.  (Wave, everybody!)

	In other words, anywhere other than where it will feel safe and
happy surrounded by its source is probably A Bad Idea.

How many Linux executables -- including shared libraries -- are created by
the build process? What are their names?

	only 'jjos', AFAIK, for the host build; the i386 build has either
jjos-grub or jjos-nbi depending on which boot process you selected, and a
group of intermediate binaries that are utterly useless.

Is there a runtime edition of the host build? If not, what prevents us
from creating one?

	Laziness?

Is there a runtime edition of the JVM-specific classes? If not, what
prevents us from creating one?

	That they don't actually exist yet?


Technical Edition

How do I download jJOS/decaf from CVS?

	With lead-lined packets; see "alpha (-radiation-leaking"
software)" in manual section 9.  The particular incantation used here at
the top-secret jJOS labs buried somewhere under the appalachians, is, of
course, top secret, but the following approximation will probably work:

cvs -d :pserver:anonymous@jos.org:/sites/jos/cvs/cvsroot login
cvs -d :pserver:anonymous@jos.org:/sites/jos/cvs/cvsroot co JJOS

How do I make jJOS?, decaf? JVM-specific classes?

	'cd JJOS/arch/*/nativecode; make' usually takes care of
it.  Options for * are currently limited to i386 and host.

Which standard Java class library should I use? How do I obtain it?

	Right now, the Sun libraries from the Blackdown (for me, anyway,
YMMV) JDK 1.1.x series.  Hopefully sooner than later, classpath.


	I'd be more specific in some sections, but my build process is
broken in all sorts of interesting ways right now, so I can't do some of
this stuff and find out...

-_Quinn




From R.Argentini@student.tudelft.nl Wed, 08 Mar 2000 10:21:41 +0100
Date: Wed, 08 Mar 2000 10:21:41 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Kernel] JOS Installation

Howdy all! 

Sorry if i've been really quiet lately. It's not that i haven't been doing
anything, it's just that i haven't produced any working code yet :)
I have been looking very hard at the TCP finite state machine and i'm
trying to think up ways to fit it in an OO framework.
I'm confident it will work :)

>What are the minimum requirements of Linux in order to install JOS?
>
>	JOS should not be using any libraries from your system except in
>its 'kernel emulation', where it uses bits and pieces of the standard C++
>library and the math library.  Optionally, it uses ncurses and libdl.  In
>general, it depends on how the binary was compiled.

Well, i'd like to get out of the way that when/if JEPS gets integrated in
the host build version, you are going to need at least kernel 2.2 and glibc
2.0.
The reason for this is that the raw packet kernel interface got majorly
redone during the 2.1 series. Since the 2.0 releases seem to be dying a
pretty swift death now (with alan stepping down as a mantainer and no one
stepping in) i decided not to support them for something that's purely for
ourselves (the host build).

As far as integration into the native port goes, i must admit i have
extremely little experience in coding drivers for pci hardware, but i'm
willing to improve in that respect.
Based on the hardware i have over here it would be a driver for an either
PCI or ISA NE2000 clone though. Would that be an acceptable starting point ?

Keep the code coming! :)

Ranieri.




From George.Marrows@Smallworld.co.uk Wed, 8 Mar 2000 09:51:45 -0000
Date: Wed, 8 Mar 2000 09:51:45 -0000
From: George.Marrows@Smallworld.co.uk George.Marrows@Smallworld.co.uk
Subject: [JOS-Kernel] Kernel Tests

Regarding testing the garbage collector, nothing beats seeing decaf survive
three or more GCs ... as I know to my cost from trying to get this to work
back in October/November, it all falls into a quivering heap if the
slightest thing goes wrong. The test code I wrote was spectacularly
underpowered in comparison.

-- George

> -----Original Message-----
> From:	Todd L. Miller [SMTP:tmiller@haverford.edu]
> Sent:	Wednesday, March 08, 2000 3:58 AM
> To:	kernel@jos.org
> Subject:	Re: [JOS-Kernel] Kernel Tests
> 
> > It is possible, isn't it? We can write C/C++ programs to
> test/demonstrate
> > kernel functions. At the point where jJOS invokes decaf, jJOS could
> invoke
> > a power-on self-test, a diagnostic program, or some other
> > test/demonstration program written in C/C++.
> 
> 	The kernel right now is cleanly (sort of) divided between the
> ASM, C, and C++ sections.  The C++ sections could be unit tested by class,
> but almost all of the ASM can't be tested without running it.  Someone
> who's sufficiently adventerous might be able to hack kdb or VMware to help
> out here, but I'm certainly note one of them :)  The C section is the
> garbage collector, whic is One Of Those Things I Would Someday Like To Try
> My Hand At.  I'm not really sure what the proper testing procedure for a
> garbage collector (esp. on written in C) might be, but if you're curios,
> ask George Marrows, who wrote it.
> 
> > Where and when should we implement memory management? In the kernel? Or,
> in
> > decaf? Should we do it now, when there is no swap file? Or later?
> 
> 	No, definitely not in decaf.  The memory management is going to be
> intimately tied with the virtual memory system and the garbage collector,
> so they'll need to be looked at together.  (For instance, it may be
> worthwhile to garbage-collect a page before swapping it out, and so on; do
> we prefer to garbage collect before swapping when we run out of RAM?  How
> does the pager's LRU list interact with the possibility of generational
> GC?  Etc.)
> 
> > We should implement memory management in the kernel. The host build of
> the
> > kernel simply uses the memory management of a foreign operating system.
> The
> > i386 build of the kernel must implement memory management independently
> > from any other operating system.
> 
> 	Since we're currently running a monolithic system, much less a
> monolithic kernel, I have to agree with you here.  On the other hand,
> Linux seems to be doing just fine with a user-space swapper, etc -- and
> Mach with its microkernel architecture.  Whatever we en up doing w.r.t. to
> memory management should be portable with the minimum of effort to
> whatever kernel/system design we end up `finalizing' on.
> 
> -_Quinn
> 	
> 
> 
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel



From gchii@mindspring.com Wed, 08 Mar 2000 08:01:18 -0500
Date: Wed, 08 Mar 2000 08:01:18 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

At 10:21 PM 3/7/00 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> No, no.... I've tried to boot JOS on 8MB RAM machine. It does not work!!!

What about 16MB?

If we had a virtual memory manager and swap file/partition, wouldn't JOS
require less real RAM? We need to get that virtual memory manager working.

>	If someone felt like cutting down Sun's library, it might.  The
>major barrier to an 8 MB machine is that Sun's class library alone weighs
>in at about 7.6 MB, IIRC.  The rest of JJOS should fit in that 8 MB w/o
>too much difficulty (e.g. turn off debug info) but that doesn't leave any
>room for a heap or a stack :)

This is one of the very good reasons for pursuing (1) Kore and (2) package
files.

We could use Kore on a machine that has only 8MB. Kore fits in a "tiny" zip
file. While it only implements the Java 0 Platform from JDK 1.02, it has
all of the Java essentials. In fact, I'm using Kore without the AWT. Why
should I carry the AWT along on an embedded machine that doesn't have a
monitor? That is a waste of RAM on a machine that has little RAM to spare.

We could use package files on a machine that has only 8MB. Package files
are a very good replacement for rt.jar or classes.zip. Each java.* package
has its own package file. Package files are implemented in different ways.
They can be implemented as .zip files, too. If put only one package in a
zip file and call it by the name of the package, you have a package file.
Here is my most recent design for bootstrapping JOS without a large
monolythic classes.zip archive:

core.zip:
  java.io
  java.lang
  java.net
  java.util

java.applet.zip:
  java.applet

java.awt.zip:
  java.awt

java.awt.image.zip:
  java.awt.image

java.awt.peer.zip:
  java.awt.peer

java.sql.zip:
  java.sql

javax.servlet.zip:
  javax.servlet

javax.servlet.http.zip:
  javax.servlet.http

javax.comm.zip:
  javax.comm

javax.swing.zip:
  javax.swing

Because java.io is inside core.zip, extra packages can be loaded as needed
from the I/O subsystem. Because java.net is inside core.zip, extra packages
can be downloaded from across the network from a HTTP service.




From gchii@mindspring.com Wed, 08 Mar 2000 08:05:49 -0500
Date: Wed, 08 Mar 2000 08:05:49 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] [zerich] C header file for dl..()

At 10:48 PM 3/7/00 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> Thanks for your response. If I had to guess, there are differences among
>> Linux distributions. Neither my Slackware nor my SuSE distribution have an
>> include file called dlfcn.h.
>
>	My distro of Slack 7 has it /usr/include.  My guess is that
>re-installing the ELF development packages will put it in for you.  (e.g.
>select the development package set from 'setup' and look for the ELF
>development stuff.)

Oh. OH! ELF is one package I haven't tried. It makes sense. The ELF package
must include the dynamic shared library functions, or depend on a package
that does. Either way, if I install ELF I should get dlfcn.h, right? I'll
try this right away.

Thanks,




From tmiller@haverford.edu Wed, 8 Mar 2000 08:29:38 -0500 (EST)
Date: Wed, 8 Mar 2000 08:29:38 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Installation

> Based on the hardware i have over here it would be a driver for an either
> PCI or ISA NE2000 clone though. Would that be an acceptable starting point ?

	I think that's the `standard' starting point for ethernet drivers
because there are so many NE2000 clones and they're so
cheap.  (e.g. developers who don't have an NE2000 already can almost
certainly afford to get one)

-_Quinn




From tmiller@haverford.edu Wed, 8 Mar 2000 08:32:30 -0500 (EST)
Date: Wed, 8 Mar 2000 08:32:30 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] [zerich] C header file for dl..()

> Oh. OH! ELF is one package I haven't tried. It makes sense. The ELF package
> must include the dynamic shared library functions, or depend on a package
> that does. Either way, if I install ELF I should get dlfcn.h, right? I'll
> try this right away.

	Good luck :)

-_Quinn




From tmiller@haverford.edu Wed, 8 Mar 2000 08:39:57 -0500 (EST)
Date: Wed, 8 Mar 2000 08:39:57 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

> If we had a virtual memory manager and swap file/partition, wouldn't JOS
> require less real RAM? We need to get that virtual memory manager working.

	Yes, but it would probably be unusably slow without a great deal
of work on our part to make sure that things like java.lang.String aren't
swapped out :)

> This is one of the very good reasons for pursuing (1) Kore and (2) package
> files.

	Package files I don't have any objection too, and it should be
fairly straightforward to write support for them, in either the C++
primordial classloader or (as you suggest below) in a Java
classloader.  (As a matter of fact, doing it in a Java classloader would
come in handy for testing decaf's integration/support with/of a given
classlibrary, because the file/io/net/VM-interaction stuff covers a whole
lot of the core functionality.)

	When I get a chance, I'll try to look into the size of classpath
vs. Kore -- if Kore is compellingly smaller, I'll look into a switch.


-_Quinn




From tmiller@haverford.edu Wed, 8 Mar 2000 08:40:35 -0500 (EST)
Date: Wed, 8 Mar 2000 08:40:35 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Kernel Tests

> Regarding testing the garbage collector, nothing beats seeing decaf survive
> three or more GCs ... as I know to my cost from trying to get this to work
> back in October/November, it all falls into a quivering heap if the
> slightest thing goes wrong. The test code I wrote was spectacularly
> underpowered in comparison.

	So I have to wonder if that's because decaf is correct but tough
in its memory usage, or broken in a reliable way :)

-_Quinn




From tullmann@cs.utah.edu Wed, 8 Mar 2000 10:51:56 -0700
Date: Wed, 8 Mar 2000 10:51:56 -0700
From: Patrick Tullmann tullmann@cs.utah.edu
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

Todd L. Miller wrote:
> 	When I get a chance, I'll try to look into the size of classpath
> vs. Kore -- if Kore is compellingly smaller, I'll look into a switch.

I don't know how big Classpath is but I know Kore is far smaller.  :)
However, Kore is only JDK1.0 compliant.  I do recommend it as a
stepping stone to more full featured class libraries at a later date,
though---its good enough to run Javac on, for example.  The other nice
property of Kore is that there are few native methods and they are all
grouped together in a nice, simple static-native-method-only
package-private classes.

The .zip file is 214K uncompressed.  There are about 160 files in
Kore.  It includes java.lang, java.net, and java.io.  I have a local
version that has a few fixes w.r.t. v0.0.7 (the last public version).

The homepage for Kore (embarassingly out of date) is 
	http://www.cs.utah.edu/flux/java/kore/index.html

Let me know if you've got questions,

Pat

----- ----- ---- ---  ---  --   -    -      -         -               -
Pat Tullmann                                       tullmann@cs.utah.edu
	  This signature witticism intentionally left blank.



From gchii@mindspring.com Wed, 08 Mar 2000 19:26:25 -0500
Date: Wed, 08 Mar 2000 19:26:25 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

At 10:51 AM 3/8/00 -0700, Patrick Tullmann <tullmann@cs.utah.edu> wrote:
>Todd L. Miller wrote:
>> 	When I get a chance, I'll try to look into the size of classpath
>> vs. Kore -- if Kore is compellingly smaller, I'll look into a switch.
>
>I don't know how big Classpath is but I know Kore is far smaller.  :)
>However, Kore is only JDK1.0 compliant.  I do recommend it as a
>stepping stone to more full featured class libraries at a later date,
>though---its good enough to run Javac on, for example.  The other nice
>property of Kore is that there are few native methods and they are all
>grouped together in a nice, simple static-native-method-only
>package-private classes.

We must be brave and think of Kore as a stepping stone. It is most
efficient to support Java 0, and then Java 1, and then Java 2 -- in that
sequence. Think of it as the first step to bootstrap jJOS/decaf into
something you can fit into 8MB, with room left over for applications.

Kore design is similar to the Bytecode Native Interface (BCNI) and alt.*
package proposal. I like Kore and BCNI because they have few native
methods. These native methods are "concentrated" together in NativeLang,
NativeIO, NativeNet, etc. for Kore and LangBridge, IOBridge, NetBridge for
BCNI. Concentrating native methods into single classes is easier on a C/C++
programmer!

Unlike Kore, BCNI gives you the flexibility to create many implementations
of the bridge classes, in whatever package you want. While Kore puts its
Native.. classes in the java.* packages, BCNI lets you put your bridges in
your personal package. For example, a bridge for decaf should be in a decaf
package.

When Kore and BCNI are combined, wonderful things start happening. There
are many positive implications. Suddenly, your JVM-specific classes have
the freedom to be implemented in machine code *or* bytecode. That's the
ticket.

It is overwhelming to demonstrate this with Kaffe (Java 1) or classpath
(Java 2). I want to run JOS. I want to use JOS. I hope you do to.

>The .zip file is 214K uncompressed.  There are about 160 files in
>Kore.  It includes java.lang, java.net, and java.io.  I have a local
>version that has a few fixes w.r.t. v0.0.7 (the last public version).

I am very pleased to find out that you have fixes to Kore. I have also been
"fixing" Kore. I'm sure many other people have fixed it, too. It is
unfortunate that we can't send fixes to Kore CVS. I have already contacted
one of the contributors to Kore. I asked if the JOS Project could use Kore
as a starting point. He said, "Yes".

I think we should work toward a distribution of Kore 0.1.0 and make it
available to the public. Why can't we put together a Kore Extension project
on SourceForge? I have code that's ready to upload, don't you?

>The homepage for Kore (embarassingly out of date) is 
>	http://www.cs.utah.edu/flux/java/kore/index.html

If we start a Kore Extension project on SourceForge -- for the purpose of
plugging it into decaf as a stepping stone, we should be able to contact
the author of the Kore homepage. That author should add a link to SourceForge.




From tullmann@cs.utah.edu Wed, 8 Mar 2000 17:41:53 -0700
Date: Wed, 8 Mar 2000 17:41:53 -0700
From: Patrick Tullmann tullmann@cs.utah.edu
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

Gilbert Carl Herschberger II wrote:
> >The homepage for Kore (embarassingly out of date) is 
> >	http://www.cs.utah.edu/flux/java/kore/index.html
> 
> If we start a Kore Extension project on SourceForge -- for the purpose of
> plugging it into decaf as a stepping stone, we should be able to contact
> the author of the Kore homepage. That author should add a link to SourceForge.

That author is me.  :)   I would be happy to update the web page with
a pointer to a SourceForge repository for Kore.  

There is also a mailing list for Kore maintained by jimpick.com:

kore-list@jimpick.com

The original authors of Kore (Glynn Clements and George Morrison) put
it out under a very liberal license, so you can legally put it onto
SourceForge, though it would be polite to ask them...

I'd just call the project 'Kore' if the name isn't already taken.

-Pat

----- ----- ---- ---  ---  --   -    -      -         -               -
Pat Tullmann                                       tullmann@cs.utah.edu
	 This bit of signature was randomly selected. Really.



From gchii@mindspring.com Wed, 08 Mar 2000 19:38:58 -0500
Date: Wed, 08 Mar 2000 19:38:58 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] [zerich] C header file for dl..()

At 10:48 PM 3/7/00 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> Thanks for your response. If I had to guess, there are differences among
>> Linux distributions. Neither my Slackware nor my SuSE distribution have an
>> include file called dlfcn.h.
>
>	My distro of Slack 7 has it /usr/include.  My guess is that
>re-installing the ELF development packages will put it in for you.  (e.g.
>select the development package set from 'setup' and look for the ELF
>development stuff.)

Ah hah! It worked! The dlfcn.h header file appeared in /usr/include, just
like my friends said. It declares dlopen(), dlerror(), dlsym() and
dlclose(). It defines RLDT_LAZY and other codes that are passed to
dlopen(), too.

Well, it worked sort of. I couldn't find an "ELF" package exactly. I
"randomly" installed a few more development tools. I picked a few that
looked like they might need to load libraries dynamically. I guess that was
good enough.

For the benefit of others, I'm sorry I can't explain exactly which package
contains which files. I heard there's an index somewhere that shows which
files belong to which package.

My next step: ERIC for Linux, version 1, release 1




From gchii@mindspring.com Wed, 08 Mar 2000 19:48:46 -0500
Date: Wed, 08 Mar 2000 19:48:46 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] LangBridge example

Here is an example of a BCNI-compatible bridge for the java.lang package:

package alt;

public interface LangBridge {
  public abstract Object ClassForName( String className );
  public abstract String ClassGetName( Object o );
  public abstract boolean ClassIsInterface( Object o );
  public abstract Object ClassGetSuperclass( Object o );
  public abstract Object[] ClassGetInterfaces( Object o );
  public abstract ClassLoader ClassGetClassLoader( Object o );
  public abstract Object ClassNewInstance( Object o );

  public abstract Object[] ThrowableGetStackTrace( Object o );

  public abstract Class ClassLoaderDefineClass( Object o, byte[] data, int
offset, int length );
  public abstract void ClassLoaderResolveClass( Object o, Class c );
  public abstract Class ClassLoaderFindSystemClass( Object o, String
className );

  public abstract Class ObjectGetClass( Object o );
  public abstract void ObjectNotify( Object o )
      throws IllegalMonitorStateException;
  public abstract void ObjectNotifyAll( Object o )
      throws IllegalMonitorStateException;
  public abstract void ObjectWait( Object o, long millis, int nanos )
      throws IllegalMonitorStateException, InterruptedException;
  public abstract int ObjectHashCode( Object o );
  public abstract Object ObjectClone( Object o )
      throws CloneNotSupportedException;

  public abstract Class[] SecurityManagerGetClassContext( Object o );

  public abstract String[] SystemGetVMProperties();
  public abstract String SystemDefaultPropertiesFile();
  public abstract String[] SystemGetCommandLineProperties();
  public abstract long SystemCurrentTimeMillis();

  public abstract Thread ThreadCurrentThread();
  public abstract void ThreadSleep(long millis, int nanos) 
      throws InterruptedException;
  public abstract void ThreadYield();
  public abstract void ThreadSetThreadState( Object o, int state );
  public abstract int ThreadCountStackFrames( Object o );
  public abstract void ThreadStop( Object o, Throwable error );
  public abstract void ThreadSetPriority(int priority);
}

This interface is implemented by a JVM-specific class, such as
decaf.BasicLangBridge. It is returned by a generic BCNI factory, like this:

String in = "alt.LangBridge";
LangBridge bridge = (LangBridge) Factory.getFactory().getObject( in );

You ask the BCNI factory for an interface; it gives you the JVM-specific
implementation of that interface. Once you have the interface, you can use
it to perform functions supported by a virtual machine.

BCNI supports well-known interfaces, like alt.LangBridge. Plus, it is
open-ended. It support JVM-specific interfaces to JVM-specific classes, too.

Because it is open-ended, it supports all platforms:

Java 0, Java 1, Java 2, Java 3, Java 4, etc.




From gchii@mindspring.com Wed, 08 Mar 2000 21:30:50 -0500
Date: Wed, 08 Mar 2000 21:30:50 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] [zerich] Release 1 is available

Release 1 of both Zerich 1a and 1b is available for immediate download at
<URL:http://www.jos.org/redist/mirror>

Zerich is an ERIC sub-project. These classes were compiled first on
Windows. Now that I found /usr/include/dlfcn.h, I have been able to compile
these classes on Linux, too. The point of this project is to use the
SharedLibrary class throughout platform-independent C/C++ code, even though
shared libraries are implemented differently on Linux and Windows.

SharedLibrary is integrated into the C++ environment, so you can write code
like this:

  void example() {
    SharedLibrary a = "jvm";
    SharedLibrary b = a;

    void (*decaf_main)( int argc, char *argv[], kernel *k );
    decaf_main = a.getMethod( "decaf_main" );
  }

NativeLibrary is a pure virtual class, like an interface, for a native
library. SharedLibrary is an integrated wrapper for NativeLibrary.

The purpose is clear. I want a NativeLibrary that only a native library
factory can instantiate. At the same time, I want a SharedLibrary that is
fully integrated into the C/C++ environment.

The critical part for a virtual machine, like decaf, is to implement the
native library factory. Note: Linux returns a symbol, not a method.




From gchii@mindspring.com Wed, 08 Mar 2000 21:43:36 -0500
Date: Wed, 08 Mar 2000 21:43:36 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] AltBridge 1a - Release 1

Release 1 of AltBridge Version 1a is now available for immediate download
at <URL:http://www.jos.org/redist/mirror/>

This package is only a baby step. It provides methods for the Java 0
Platform. Addition work is definitely needed to define well-known
interfaces for Java 1 and Java 2. I have been able to rework Kore into a
kore_alt package (coming soon!) that uses AltBridge. Here it is a "picture":

     Kore ->
    Kaffe -> BCNI -> AltBridge -> JVM-specific classes -> JVM
classpath ->

Your JVM can implement JVM-specific classes once and still be compatible
with Java 0, Java 1 and Java 2.

The AltBridge only provides a minimum interface. It is anticipated that a
bridge interface for Java 1 might extend a bridge inteface for Java 0,
making it possible for JVM-specific classes to implement the bridge once,
while maintaining compatibility with all Java platforms.

One side of the AltBridge is a virtual machine. A virtual machine must
install its own factory in the BCNI Factory class. This JVM-specific
factory can be put in any package. This JVM-specific factory might have
zero or more native methods. Only these native methods must have
corresponding machine code in the virtual machine. (Everything else is
bytecode.)

The other side of the AltBridge is a Java standard class library. These are
classes from the java.* packages. I am looking forward to re-working Kore
so that it uses the AltBridge.




From alain@qnx.com Wed, 8 Mar 2000 22:23:16 -0500 (EST)
Date: Wed, 8 Mar 2000 22:23:16 -0500 (EST)
From: Alain Magloire alain@qnx.com
Subject: [JOS-Kernel] Installation instructions (8MB Ram)

> 
> Gilbert Carl Herschberger II wrote:
> > >The homepage for Kore (embarassingly out of date) is 
> > >	http://www.cs.utah.edu/flux/java/kore/index.html
> > 
> > If we start a Kore Extension project on SourceForge -- for the purpose of
> > plugging it into decaf as a stepping stone, we should be able to contact
> > the author of the Kore homepage. That author should add a link to SourceForge.
> 
> That author is me.  :)   I would be happy to update the web page with
> a pointer to a SourceForge repository for Kore.  
> 
> There is also a mailing list for Kore maintained by jimpick.com:
> 
> kore-list@jimpick.com
> 
> The original authors of Kore (Glynn Clements and George Morrison) put
> it out under a very liberal license, so you can legally put it onto
> SourceForge, though it would be polite to ask them...

I thought all work stopped on this project.  I remember trying to
get involve at the begin, then bail out when I had to get intimately
involve in Sun's code.  Kore IIRC, was nicely done and could really
serves as good startup.

-- 
au revoir, alain
----
Aussi haut que l'on soit assis, on est toujours assis que sur son cul !!!




From gchii@mindspring.com Sat, 11 Mar 2000 20:53:45 -0500
Date: Sat, 11 Mar 2000 20:53:45 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Kore-Alt

Starting with Kore 0.0.7, I reworked the Java source code to create an
alternative class library for a virtual machine.

kore.alt1a.io <-- java.io
kore.alt1a.lang <-- java.lang
kore.alt1a.net <-- java.net
kore.alt1a.util <-- java.util

I think the JJOS module should have much better support for
cross-compiling. I want to build decaf on one computer and classes.zip on
another. In fact, I want to build, not one, but many flavors of classes.zip.

I want an experimental version of classes.zip for multiple process support.
I want a version with no native methods. I want a version to plug into an
off-the-shelf virtual machine for testing.

If classes.zip were treated more like a shared library on Linux, we would
have separate JJOS and CLASSES modules in CVS. When CLASSES creates
classes.zip, it must be *installed* into the JJOS directory. A symbolic
link from JJOS to CLASSES would be similar to a symbolic link to NASM.

If it were organized this way, JJOS would not be concerned with where the
classes.zip file came from. Is this possible?




From gchii@mindspring.com Sat, 11 Mar 2000 21:02:03 -0500
Date: Sat, 11 Mar 2000 21:02:03 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] UNIX vs. DOS files

By experimentation, I find that .java files will compile in either UNIX or
DOS format. The UNIX line ends with LF. The DOS line ends with CR/LF.

I also find that my make tool will work with either UNIX or DOS format. The
extra CR doesn't interfere most of the time. My make tool only has a
problem with continuation. It doesn't understand the slash / at the end of
a line because it is /CRLF, not /LF. The extra CR prevents continuation.

The GNU C/C++ compiler is a different story. I find that .cc (and .h) files
won't compile in DOS format. It compiles just find in UNIX format. The
"separator" error message is coming from the GNU C/C++ compiler.

When checking out .cc and .h files from CVS for compiling on Linux, it is
important to specify UNIX text file format. (I still don't know how to do
that with jCVS.)




From tmiller@haverford.edu Mon, 13 Mar 2000 01:50:08 -0500 (EST)
Date: Mon, 13 Mar 2000 01:50:08 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Kore-Alt

> If it were organized this way, JJOS would not be concerned with where the
> classes.zip file came from. Is this possible?

	Should be; the build processes simply copies an extant classes.zip
in and adds JJOS-specific classes to the zipfile right now, so adding a
CLASSES module has definite potential as a solution.  My hope is that
whatever class library we end up using we will NOT end up maintaining,
because it's a large job that other groups are working on.

-_Quinn




From gchii@mindspring.com Mon, 13 Mar 2000 21:30:36 -0500
Date: Mon, 13 Mar 2000 21:30:36 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] [zerich] Release 2

Release 2 of Zerich 1b is available now. Basically, it is a fix for
SharedLibrary. There is no need whatsoever for a createSharedLibrary()
method. Rather, SharedLibrary is supposed to be a regular class.

void demo::example( int argc, char *argv[], kernel ) {
  SharedLibrary lib("decaf");
  void (*decaf_main)(int argc, char *argv[], kernel *k);

  decaf_main = lib.getMethod( "decaf_main" );
  decaf_main( argc, argv, kernel );
}




From mgangelen@quintop.nl Thu, 16 Mar 2000 11:43:29 +0100
Date: Thu, 16 Mar 2000 11:43:29 +0100
From: mgangelen@quintop.nl mgangelen@quintop.nl
Subject: [JOS-Kernel] Good article on JVM's

Hi there,

I found a really interesting article discribing the inner workings of
japaleno, a JVM written in JAVA, for JAVA.
The programmers follow an approach that is appealing to me. They have
written the main JVM in JAVA...

http://www-4.ibm.com/software/developer/library/jalapeno/index.html

To be short, they are dong the following:
On startup, a classic VM (lets call it VM1) is loaded, which loads the main
VM ( VM2 ). Both VM's are written in JAVA, but VM1 has been compiled to
static machinecode, and is not really optimized.
VM1 doesn't need to be oprimized, cause the only job it must do is to load
and invoke VM2. VM2 has a very optimized JIT: it takes bytecodes and
transformes them into machinecode.
The last thing isn't really surprising, but it is if you consider that VM2
is written in JAVA it is.

IBM claims that the entire source of the VM's contains only 1000 lines of C
code. It's that small because the only thing they need to program in C are
the glue-functions to IO, memory and interrrupts. All the other things
suchs as thread-switching, memory-management and synchronisation are
written in JAVA.

There are also some other interesting issues addressed in this article,
such as how they prevent normal users from executing privileged code,
locking and parallel-garbage-collecting.

I think that this approach should also be interesting to JOS: write the VM
in JAVA insteadof C++...

Just some thoughts.

Fushion.




From tmiller@haverford.edu Thu, 16 Mar 2000 19:31:05 -0500 (EST)
Date: Thu, 16 Mar 2000 19:31:05 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] checkPendingNotifies

	In scheduler::checkPendingNotifies(), the CVS version (I believe
the copy I'm looking at is the recent one), does anyone else find it odd
that the terminating condition is (pnip->myNext != NULL) yet pnip -- so
far as I can tell -- is never changed?  Could someone who's got an intact
CVS tree point the debugger at this and figure out why the loop
terminates?  (Is my copy of scheduler.cc right?  Are the jbSLL items not
set up right, e.g. myNext is always NULL?  Is the list of pending notifies
always empty (despite addPendingNotify() being called from threadable.cc?)  
Have we, for some reason, only ever had a single thread in the pending
queue?)  I'm asking because I just finished moving that code to the 'new'
scheduler, and realized, contrary to the comment, that it never did walk
the list, and I wanted to find out what was going on.  Thanks.

-_Quinn





From gchii@mindspring.com Thu, 16 Mar 2000 20:12:28 -0500
Date: Thu, 16 Mar 2000 20:12:28 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Bootable version?

To anyone with a recent bootable version of jJOS/decaf:

JOS/GRUB:
Could you please upload a .tgz file so that other members can GRUB-boot JOS
without compiling? Some of us don't have Linux working (yet) or don't have
CVS working (yet). But we'd like to see how JOS has grown since October.

JOS/Etherboot:
Could you please upload a .tgz file, too?

Thanks,




From ryan@whitewolf.com.au Fri, 17 Mar 2000 12:46:44 +1100
Date: Fri, 17 Mar 2000 12:46:44 +1100
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Kernel] checkPendingNotifies

"Todd L. Miller" wrote:

>         In scheduler::checkPendingNotifies(), the CVS version (I believe
> the copy I'm looking at is the recent one), does anyone else find it odd
> that the terminating condition is (pnip->myNext != NULL) yet pnip -- so
> far as I can tell -- is never changed?

You can view the CVS version of the file through cvsweb:

	http://www.jos.org/cvsweb.cgi/JJOS/common/decaf/scheduler.cc

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From tmiller@haverford.edu Thu, 16 Mar 2000 21:24:44 -0500 (EST)
Date: Thu, 16 Mar 2000 21:24:44 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] checkPendingNotifies

> You can view the CVS version of the file through cvsweb:
> 
> 	http://www.jos.org/cvsweb.cgi/JJOS/common/decaf/scheduler.cc

	oh, thanks!  That'll come in handy -- I looked at it and the
apparent problem is (still) there.  I can't figure out why decaf didn't
get hit with an infinite loop.  (Unless maybe remove() NULLs the removed
item?)

-_Quinn




From Corrado.Santoro@IIT.UNICT.IT Fri, 17 Mar 2000 10:14:07 +0100
Date: Fri, 17 Mar 2000 10:14:07 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Kernel] Bootable version?

On Fri, 17 Mar 2000, Gilbert Carl Herschberger II wrote:
> To anyone with a recent bootable version of jJOS/decaf:
> 
> JOS/GRUB:
> Could you please upload a .tgz file so that other members can GRUB-boot JOS
> without compiling? Some of us don't have Linux working (yet) or don't have
> CVS working (yet). But we'd like to see how JOS has grown since October.
> 
> JOS/Etherboot:
> Could you please upload a .tgz file, too?
> 

You can use my JOS download webpage:
http://osweb.iit.unict.it/JOS/download.html

It contains the tgz files you need.
Please let me know if they works correctly.

Cheers.
-Corrado.

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://osweb.iit.unict.it/ARCA
======================================================




From gchii@mindspring.com Fri, 17 Mar 2000 09:20:54 -0500
Date: Fri, 17 Mar 2000 09:20:54 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Bootable version?

At 10:14 AM 3/17/00 +0100, Corrado Santoro <Corrado.Santoro@IIT.UNICT.IT>
wrote:
>On Fri, 17 Mar 2000, Gilbert Carl Herschberger II wrote:
>> To anyone with a recent bootable version of jJOS/decaf:
>> 
>> JOS/GRUB:
>> Could you please upload a .tgz file so that other members can GRUB-boot JOS
>> without compiling? Some of us don't have Linux working (yet) or don't have
>> CVS working (yet). But we'd like to see how JOS has grown since October.
>> 
>> JOS/Etherboot:
>> Could you please upload a .tgz file, too?
>> 
>
>You can use my JOS download webpage:
>http://osweb.iit.unict.it/JOS/download.html

Excellent! Thank you. Very good work. I like it.

>It contains the tgz files you need.
>Please let me know if they works correctly.

I'm downloading them now...




From Corrado.Santoro@IIT.UNICT.IT Fri, 17 Mar 2000 16:10:23 +0100
Date: Fri, 17 Mar 2000 16:10:23 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Kernel] checkPendingNotifies

Todd,
I've looked at the code and I've found something interesting...
I think you're right... something like
	pnip = pnip->myNext
seems to be required....

On Fri, 17 Mar 2000, Todd L. Miller wrote:
> In scheduler::checkPendingNotifies(), the CVS version (I believe
> the copy I'm looking at is the recent one), does anyone else find it odd
> that the terminating condition is (pnip->myNext != NULL) yet pnip -- so
> far as I can tell -- is never changed?  Could someone who's got an intact
> CVS tree point the debugger at this and figure out why the loop
> terminates?  (Is my copy of scheduler.cc right?  Are the jbSLL items not
> set up right, e.g. myNext is always NULL?  Is the list of pending notifies
> always empty (despite addPendingNotify() being called from threadable.cc?)  
> Have we, for some reason, only ever had a single thread in the pending
> queue?)  I'm asking because I just finished moving that code to the 'new'
> scheduler, and realized, contrary to the comment, that it never did walk
> the list, and I wanted to find out what was going on.  Thanks.
> 
> -_Quinn
> 
> 
> 
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel
--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://osweb.iit.unict.it/ARCA
======================================================




From gchii@mindspring.com Fri, 17 Mar 2000 15:45:06 -0500
Date: Fri, 17 Mar 2000 15:45:06 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Making progress!

Once upon a time, my CVS snapshots had a big problem. They contained text
files in DOS rather than Linux/UNIX format. As you might know, jJOS/decaf
does not compile on DOS platform!

I think this problem has been fixed. Please take a look at new module
snapshots for JOS 1e.

One big .tgz file:
<URL:http://www.jos.org/redist/mirror/jos1e-module-2.tgz>

A .zip file for each module:
<URL:http://www.jos.org/redist/mirror/jos1e-module-JJOS-2.zip>
<URL:http://www.jos.org/redist/mirror/jos1e-module-jos-2.zip>
<URL:http://www.jos.org/redist/mirror/jos1e-module-projects-2.zip>

-----

JJOS does not compile cleanly on my machine. My C/C++ compiler does not
recognise C++ templates. :(

It might compile cleanly on yours. The make files, .h and .cc files are in
UNIX text file format.

-----

Personally, I can't download them directly from JOS CVS to my Linux box. I
must use my Windows machine with CVS. Only my Microsoft Windows 95 machine
is connected to the Internet. With archives (.jar, .tgz and .zip), this is 

I'm using jCVS 4.7.5 on Microsoft Windows 95 to download files from JOS
CVS. With the advice from Tim Endres <time@trustice.com>, I have been able
to download text files today using the UNIX line separator.




From gchii@mindspring.com Fri, 17 Mar 2000 16:20:01 -0500
Date: Fri, 17 Mar 2000 16:20:01 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

I've been thinking about devices and mapping them with a URI. I think
hardware is a digital resource, too. If we use a device: scheme, we can ask
for all kinds of devices through the BCNI (and Smart API).

If I have a Modem interface called jos.device.Modem, I can "open" a
connection to my modem with a URI like this:

bcni:jos.device.Modem?port=0

or

device:Modem?port=0

The device: scheme maps a request through BCNI to create a JVM-specific class.

If I have a Keyboard interface called jos.device.Keyboard, I can "open" a
connection to my keyboard with a URI like this:

device:Keyboard?language=en

If I have a ParallelPort interface called jos.device.ParallelPort, I can
"open" a connection to my parallel port with a URI like this:

device:ParallelPort?port=0

If I have a CommPort interface called jos.device.CommPort, I can "open" a
connection to my comm port with a URI like this:

device:CommPort?port=0

Of course, these are limited resources. Following in the tradition of BCNI
(and Smart API), null is returned when a device is already in use.

  public void example() {
    URI uri = new URI( "device:Modem?port=0" );
    Modem m = (Modem) uri.getObject();
    if ( m == null ) {
      println( "Modem is busy." );
      return;
    }
    :
  }

While "devices" are not exactly JVM-specific classes, they are below the
line in a user process environment.




From gchii@mindspring.com Fri, 17 Mar 2000 17:46:59 -0500
Date: Fri, 17 Mar 2000 17:46:59 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JOS Installation

At 11:34 PM 3/7/00 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>You keep giving a 4 MB figure for the distribution size -- does
>that include the (required) class library (uncompressed zipfile)?

The binary editions created by Corrado Santoro
<Corrado.Santoro@IIT.UNICT.IT> are 4MB, more or less. The josbin-1e.tar.gz
contains jjos-nbi. And, jjos-nbi definitely includes all those classes.

Based on size alone, I'd guess that josgrub-1e.tar.gz contains jjos-grub
and jjos-grub includes all those classes. But, I don't know for sure.

Somewhere in the build process, classes.zip is "linked" to jjos-nbi and
jjos-grub. I think an executable is concatinated with classes.zip to create
them.

Let's look ahead. Should we perform the "concatination" step before or
after the files are distributed? If this step is performed before, everyone
must test the same classes at the same time. That might not be a bad idea
for now.

On the other hand, concatination is eay. The cat command is widely
available. This step could be performed *after* the files are distributed.
Anyone could replace classes.zip with their own experimental classes. We
could jump to parallel development. Different people can test different
subsystem at the same time.

Maybe the development of JOS-specific and decaf-specific classes should
move to a CLASSES module in JOS CVS. By creating a binary distribution of
jJOS/decaf, we can open up the development of classes to more Java
programmers. Many hands may lighten the load. But we can't do it
prematurely either.




From tmiller@haverford.edu Fri, 17 Mar 2000 18:57:59 -0500 (EST)
Date: Fri, 17 Mar 2000 18:57:59 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Installation

> The binary editions created by Corrado Santoro
> <Corrado.Santoro@IIT.UNICT.IT> are 4MB, more or less. The josbin-1e.tar.gz
> contains jjos-nbi. And, jjos-nbi definitely includes all those classes.

	The 1.1.8 JDK classes.zip I've got is 9122642 bytes, so I guess
Corrado is using a different version.  Whatever works.

> Based on size alone, I'd guess that josgrub-1e.tar.gz contains jjos-grub
> and jjos-grub includes all those classes. But, I don't know for sure.

	jjos-grub should not contain the classes; they're loaded as a GRUB
module doing GRUB boot-up; the tar file may very well have the finished
jjos.zip in it.

> Somewhere in the build process, classes.zip is "linked" to jjos-nbi and
> jjos-grub. I think an executable is concatinated with classes.zip to create
> them.

	The NBI format, IIRC, is a bit more complicated than that, but I
could be wrong; at any rate, the generation of jjos-nbi is handled by
mknbi-jjos, which JM hacked up.  jjos-grub is strictly an ELF binary.

-_Quinn




From gchii@mindspring.com Fri, 17 Mar 2000 19:53:36 -0500
Date: Fri, 17 Mar 2000 19:53:36 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] What does JOS look like?

Here is what JOS looks like on my machine. The "hardware" cursor always
stays at line 3, column 1. For sake of discussion, the first line at the
top of the screen is line 1.

[1] jJOS/decaf

[2] Processor type: "CyrixInstead"

[3] A20 OK, loading decaf...

[4] process_args("arch/i386/nativecode/jjos-binary  init arg0 arg1")

[5] argvlocal[00000000] = arch/i386/nativecode/jjos-binary

[6] argvlocal[00000001] = init

[7] argvlocal[00000002] = arg0

[8] argvlocal[00000003] = arg1

[9] bailing out on #00000004

[10] init for jJOS/decaf, version 0.2

[11] init: generating keyboard driver...

[12] init: initializing keyboard driver...

[13] init: generating console daemon...

[14] init: initializing console daemon...

-----

Wow! This is the first time that the keyboard worked for me. I noticed that
key combinations aren't being interpreted as I expected. For example, A,
Alt+A and Control+A is printed as 'a'. So, we need a terminal application
for JOS.

-----

We must have a mechanism to load classes dynamically. There are lots of
classes that do not and should not go inside classes.zip.

When booting with Etherboot, I would like to use the network. If I have
java.sql in a package file called /jpkg/java.sql.package on my HTTP
service, JOS should be able to download it using the java.net package.

When booting with GRUB, I would like to load additional package files from
the /jpkg directory. It seems that GRUB might be less complex. It might use
a class that reads sectors from a disk. If such a class were added to
classes.zip, a program could use it to read additional packages. If code
for this class were compiled directly into jJOS/decaf, it could load
classes.zip.

-----

For asynchonous I/O, each device has a corresponding listener interface.
The run() method might run a device until it is closed. I think we might
need both a low-level keyboard class and a high-level keyboard class. The
low-level class should be jos.device.keyboard (right?) The high-level class
could be org.jos.device.Keyboard. Here is more about a asynchronous
user-level keyboard driver:

// Shell.java
import org.jos.device.Keyboard;
import org.jos.device.KeyboardEvent;
public class Terminal
    implements KeyboardListener {
  private static final char LF = '\n';
  public Terminal() {
  }
  public void run() {
    String s = "bcni:org.jos.device.Keyboard";
    keyboard = (Keyboard) Factory.getObject( s );
    if ( keyboard == null ) {
      return;
    }
    keyboard.setListener( this );
    keyboard.run();
  }
  public void onKey( Key v ) {
    if ( v.equals( Key.ctrlC ) ) {
      keyboard.close();
    }

    print( v.toChar() );
  }
  public void print( String v ) {
    int iMax = v.length();
    for ( int i = 0; i < iMax; i++ ) {
      char ch = v.charAt( i );
      if ( ch == BS ) {
        gotoxy( row, column-- );
        continue;
      }
      if ( ch == LF ) {
        gotoxy( row++, (column = 0) );
        continue;
      }
      gotoxy( row, column++ );
      putch( ch );
    }
  }
  public void println( String v ) {
    print( v + LF );
  }
  private Keyboard keyboard;
}




From gchii@mindspring.com Fri, 17 Mar 2000 20:15:18 -0500
Date: Fri, 17 Mar 2000 20:15:18 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JOS Installation

At 06:57 PM 3/17/00 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	The 1.1.8 JDK classes.zip I've got is 9122642 bytes, so I guess
>Corrado is using a different version.  Whatever works.

Starting with rt.jar or classes.zip from Java 1, you can safely remove the
JavaDoc application, the javac application, and some of the un-used,
un-necessary packages. Here are a few packages that you can't use (yet).

java.applet
java.awt.*
java.beans
java.rmi.*
java.sql
sun.applet.*
sun.awt.*
sun.beans.*
sun.jdbc.odbc
sun.rmi.*

And, here are some of the packages you can't use without a TCP/IP stack:

java.net
sun.net.*

If you're not going to use them, why should you load them? If you have a
machine with 8MB+, you should be able to load and run JOS for a few
seconds. Our recommendation will be 16MB+ of RAM.

Consumers do not want to load packages they don't use. Consumers do not
want JavaDoc in their toaster. The rt.jar and classes.zip architecture
doesn't work for Sun either.

Regardless, Sun Microsystems frowns upon anyone removing *any* class from
rt.jar or classes.zip.

JOS should not carry the JavaDoc application around in its core classes,
should it? JOS should not carry all those classes that use JNI-based native
methods, should it? Ultimate JOS should load packages on demand, delaying
the load from disk or network service until they are actually used. We are
not required to use it.




From gchii@mindspring.com Fri, 17 Mar 2000 20:24:25 -0500
Date: Fri, 17 Mar 2000 20:24:25 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JDK 1.1.6 vs. JDK 1.1.8

The Java platforms are not as far apart as Sun Microsystems might believe.
As far as a virtual machine is concerned, bytecode is bytecode. The beauty
of the Java virtual machine architecture is its independence from class
design. Most of a Java "platform" comes from rt.jar or classes.zip.

For example, I should be able to plug classes.zip from JDK 1.1.6 into
decaf. I can run all my applications that depend on that. Then, I can
switch to classes.zip from JDK 1.1.8. I can run all my application that
depend on that.

Bytecode is bytecode. How much bytecode you put in your custom classes.zip
is up to you.




From tmiller@haverford.edu Fri, 17 Mar 2000 21:25:55 -0500 (EST)
Date: Fri, 17 Mar 2000 21:25:55 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Installation

	When we complete the move to Kore/Classpath, etc, we can produce a
'core' JOS (minimum necessary for finding more classes) relatively
easily.  Until then, I haven't thought it worth my time.

-_Quinn




From tmiller@haverford.edu Fri, 17 Mar 2000 21:38:04 -0500 (EST)
Date: Fri, 17 Mar 2000 21:38:04 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] What does JOS look like?

> Wow! This is the first time that the keyboard worked for me. I noticed that
> key combinations aren't being interpreted as I expected. For example, A,
> Alt+A and Control+A is printed as 'a'. So, we need a terminal application
> for JOS.

	*shrug* The console driver(s) are still about as basic as they
get, that is, they ignore the (available) ALT/CTRL information.  On the
other hand, your build may not to be up-to-date; v1.3 of the i386 build's
platform/driver/console.java has support for moving the hardware cursor.

	For I/O we currently have a two-teir system: jos.platform.iodevice
and jos.platform.driver.iodevice, where platform.iodevice is the
abstraction of the device we wish to present considering it as part of the
JOS platform.  Non-platform devices could very well be accessed as you've
suggested previously (URIs).  driver.iodevice implements the platform
interface (superclass) and either runs or makes calls to run the
device.  It is set up as an event-based system, with the exception of
interrupts, whose handlers are run in their own un-interruptable threads
-- where it's strongly recommended that the handleInterrupt() code do the
bare minimum necessary to take h/w timeouts into account and let the rest
of the processing and event generation be handled by some other thread
which it wakes up after handling the interrupt.

-_Quinn




From Alexis Petrounias Sat, 18 Mar 2000 17:05:50 +0200
Date: Sat, 18 Mar 2000 17:05:50 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Gilbert Carl Herschberger II wrote:

> If I have a Modem interface called jos.device.Modem, I can "open" a
> connection to my modem with a URI like this:
> 
> bcni:jos.device.Modem?port=0

I don't really like the scheme, because it is not the normal way a URI
works. The above URI actually does not point to a device, but merely
informs how to search for a device.

The above URI could *point* to a modem device like this:

for the serial port 1,

bnci:modem://localhost/serial/1/

or

bnci:modem://localhost/pci/0F4/

if the modem is internal on the PCI bus...

> device:Modem?port=0

The parameter indicator question mark ('?') should, IMHO, be used for
parametric information only, such as:


bnci:modem://localhost/serial/1/?maxspeed=57600&parity=none

> device:ParallelPort?port=0

Again, this could be like:

device://localhost/devices/ports/parallel/0/?bidirectorial=true

for isntance...



-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From gchii@mindspring.com Sat, 18 Mar 2000 14:24:06 -0500
Date: Sat, 18 Mar 2000 14:24:06 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Install with GRUB

To anyone with a GRUB-bootable diskette:

I understand that I must use two commands to create a boot disk:

$ dd if=stage1 of=/dev/fd0 bs=512 count=1 
$ dd if=stage2 of=/dev/fd0 bs=512 seek=1

I tried to download "stage1" and "stage2" from
<URL:http://www.triptych.freeserve.co.uk/grub/index.html>, but without
success. Could you archive the stage1 and stage2 files and distribute them
as an archive?




From tmiller@haverford.edu Sat, 18 Mar 2000 14:48:36 -0500 (EST)
Date: Sat, 18 Mar 2000 14:48:36 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] dynamic_cast<>

	I was looking at 3rd Stroustrup for something completely unrelated
and happened to stumble across 'dynamic_cast<>' -- which I hadn't seen
used anywhere in the jJOS/decaf code.  Is dynamic_cast<> not supported
widely enough to use, or is/was there some other reason for not using
it?  (problems on the i386 build?)

-_Quinn

(and yes, I'll try to read the whole thing sometime soon...)




From gchii@mindspring.com Sat, 18 Mar 2000 15:14:15 -0500
Date: Sat, 18 Mar 2000 15:14:15 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

At 05:05 PM 3/18/00 +0200, Al <Alexis Petrounias> wrote:
>I don't really like the scheme, because it is not the normal way a URI
>works. The above URI actually does not point to a device, but merely
>informs how to search for a device.

I propose a system-wide device factory. I propose that we can treat
JVM-specific classes and devices in a uniform way. I'm sorry you don't like
the scheme. Oh well, it was my first attempt to map devices independently
from the traditional ideas of a file subsystem.

Do you like that idea of a system-wide device factory?

Do you like the idea that a URI is used to identify devices? If so, we can
refine the scheme through experimentation.

I was thinking this URI should specify the interface you would like to use.
The same interface might be used for all serial ports. Like BCNI, it would
be much easier to finish this project if there is a direct link between a
URI and the JOS Platform API.

Properties can be set before or after a device is returned. Either way a
device is returned. While the device: scheme can set properties before, the
bcni: scheme requires you to set properties after.

>The above URI could *point* to a modem device like this:
>
>for the serial port 1,
>
>bnci:modem://localhost/serial/1/

Maybe you meant something like "device:modem://localhost/serial/1/". The
bcni: scheme is a bridge to the BCNI factory. Both the bcni: scheme and
factory require the name of a Java interface. It has no paths. It has only
an interface name.

>The parameter indicator question mark ('?') should, IMHO, be used for
>parametric information only, such as:
>
>bnci:modem://localhost/serial/1/?maxspeed=57600&parity=none

This is good. I agree that any program that wants to set parity, bits and
speed should use the query string. Any parameter set in the query string
should be a property of the device. If you use maxspeed=57600, the device
defines a getMaxSpeed() method that returns 57600. If it is capable of
changing a property after it is created, a device defines a setMaxSpeed()
method, too.

Once a modem device is created, port is one of its properties. Since port
is a property, I put it in the query string with all of the other
properties. In general, I would prefer to put port in a query string
because there are many devices without a port.

We disagree on the concept of path. Devices should be mapped independently
from the traditional ideas of a file subsystem, like path.

>device://localhost/devices/ports/parallel/0/?bidirectorial=true

Look! See how easy it would be to set properties of a device with a URI.
After a device is created, you change its properties with methods.

Host and port should be optional, not required. At first, none of these
devices are capable of distribution. They are always local host. A device:
scheme could start out like this:

'device:' [ '//' host [ ':' port ] ]

I do not propose a network-wide device factory. I cannot create distributed
devices at this point in the start-up sequence. Without TCP/IP, we could
not possibly connect to another host. I propose a local URI because we
don't have a network. Like bcni: scheme, the device: scheme would do well
to specify the interface it wants, wouldn't it?

'device:' [ '//' host [ ':' port ] ] interfacename [ '?' querystring ]

I asked myself this question: If we already have the bcni: scheme, do we
need a device scheme? I think the answer is 'Yes, we do.' The device:
scheme could manage additional parameters/properties on a device by device
basis. This could be very flexible.

Once we see the similarity between JVM-specific classes and devices,
devices can be designed and used in all kinds of Java programs.




From Alexis Petrounias Sun, 19 Mar 2000 09:29:44 +0200
Date: Sun, 19 Mar 2000 09:29:44 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Gilbert Carl Herschberger II wrote:

> Do you like that idea of a system-wide device factory?

I do, and I also support that an operating system must be as wide as
possible. The more generalized information the underlying OS can give,
the more detailed processing of this information can be achieved at
higher levels of execution. Don't we try to do the same thing with the
kernel, that is, make the use of C code as little as possible, such that
it supplies only the absolutely necessary information for a JVM to run,
and then the rest is done in the higher-level language Java?

> Do you like the idea that a URI is used to identify devices? If so, we
> can refine the scheme through experimentation.

I love the idea of using URI for pointing to *anything,* as URI are very
scalable and dynamic in doing just that: pointing. I use a sort of URI
for my Registry API, for example. The file system will use something
like that. Browsers and network tools will use them. Why not make
everything pointable by URI's, and then have a central engine that reads
the URI, and appropriately initializes the correct managers, factories
and transport protocols?

> > bnci:modem://localhost/serial/1/
> 
> Maybe you meant something like "device:modem://localhost/serial/1/".
> The bcni: scheme is a bridge to the BCNI factory. Both the bcni:
> scheme and factory require the name of a Java interface. It has no
> paths. It has only an interface name.

Yes, you are right, I have no idea how BNCI works, but the "device:"
protocol is what I was talking about. I understand that if BNCI uses
class names, then the URI's should be the way you propose. Of course,
have in mind, that they are not truly URI, they are simply arguments to
the BNCI interpreter, that merely *look* like URI's... The purpose of a
URI is to map a path to location, right?

> > bnci:modem://localhost/serial/1/?maxspeed=57600&parity=none
> 
> This is good. I agree that any program that wants to set parity, bits
> and speed should use the query string. Any parameter set in the query
> string should be a property of the device. If you use maxspeed=57600,
> the device defines a getMaxSpeed() method that returns 57600. If it is
> capable of changing a property after it is created, a device defines a
> setMaxSpeed() method, too.

If all devices are Beans, then this would be trivial to implement. I
like this idea very much, and I think that's why Sun put a lot of effort
in Beans, because they are so manageable.

> In general, I would prefer to put port in a query string because there
> are many devices without a port.

If the URI points *generally* to a serial port, then yes, the port
should be placed in the query section. But the URI I wrote points
*directly* at serial port #1.

> We disagree on the concept of path. Devices should be mapped
> independently from the traditional ideas of a file subsystem, like
> path.

Why? All devices on a computer, at least contemporary computers, are
linked together on buses and through ports. We can definitely map any
device on a computer via a path, if this path begins with the local
computer, mainly, the motherboard. Since everything is on the
motherboard, one way or another, then everything can be mapped starting
at the motherboard...

> 'device:' [ '//' host [ ':' port ] ]

I don't think we need the port in such URI's, because they are not
mapping to a server/service on the machine, they are merely mapping to a
device. The interpreter will not *contact* localhost, it will only know
how to find the requested device. Only in the case of remote devices may
a port be necessary, and then we would have to decide which privileged
port JOS will use for the "Network Device Manager."

> I do not propose a network-wide device factory. I cannot create
> distributed devices at this point in the start-up sequence. Without
> TCP/IP, we could not possibly connect to another host. I propose a
> local URI because we don't have a network.

Naturally, the interpreter of the device URI's will default to
"localhost" if no host is specified. And if a host is specified other
than localhost, then it can throw something like
"ServiceUnavailableException" or "RemoteDeviceUnavailableException" or
equivalent. When devices are made distributed, then these exceptions
will not be thrown any more, but programmers will not have to change
their code in order to access this future feature.

> Like bcni: scheme, the device: scheme would do well to specify the
> interface it wants, wouldn't it?
> 
> 'device:' [ '//' host [ ':' port ] ] interfacename [ '?' querystring ]
> 
> I asked myself this question: If we already have the bcni: scheme, do
> we need a device scheme? I think the answer is 'Yes, we do.' The
> device: scheme could manage additional parameters/properties on a
> device by device basis. This could be very flexible.

It can be very flexible if we can use a method such as "getDevice(uri)"
which returns a device and then we are free to play with the device as
we wish. The last URI you wrote I like a lot... I was thinking of
possibly something like this:

bnci:jos.device.Modem:device://localhost/ports/serial/1/?maxspeed=...

The device manager returns the raw device, and bnci converts it into the
specified "jod.device.Modem" class.

Since more types of devices than modems can be attached to the serial
port, the device manager can only return the raw version of the device:
the port itself.

Maybe, during JOS start-up, a mapping facility can create shortcuts,
such as:

device://localhost/mapped/modem0/?maxspeed=...

is equivalent to:

bnci:jos.device.Modem://localhost/ports/serial/1/?maxspeed=...

What do you think?

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From gchii@mindspring.com Sun, 19 Mar 2000 10:31:46 -0500
Date: Sun, 19 Mar 2000 10:31:46 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

I applaud your comments. I salute you. An operating system must be as
wide-open and future-oriented as possible. The more generalized it is the
better I like it. I want a new OS.

At 09:29 AM 3/19/00 +0200, Al <Alexis Petrounias> wrote:
>I love the idea of using URI for pointing to *anything,* as URI are very
>scalable and dynamic in doing just that: pointing. I use a sort of URI
>for my Registry API, for example. The file system will use something
>like that. Browsers and network tools will use them. Why not make
>everything pointable by URI's, and then have a central engine that reads
>the URI, and appropriately initializes the correct managers, factories
>and transport protocols?

Everything's a digital resource, right? So far, we have two "central"
engines developed with JOS in mind. These are URI-based object factories.

The BCNI factory is intended for one instance per virtual machine. Each
virtual machine can have a unique configuration of BCNI. It supplies
JVM-specific classes. It is one system-wide digital resource factory shared
by all processes. From this discussion, devices are system-wide digital
resources and might fall into the BCNI engine.

The Smart API factory is intended for one instance per process. Each
process can have a unique configuration of Smart API. Smart API is
connected to BCNI through the bcni: scheme. If your Smart API is configured
with the bcni: scheme, you can get system-wide and process-wide resources
from one central engine.

>It can be very flexible if we can use a method such as "getDevice(uri)"
>which returns a device and then we are free to play with the device as
>we wish. The last URI you wrote I like a lot... I was thinking of
>possibly something like this:
>
>bnci:jos.device.Modem:device://localhost/ports/serial/1/?maxspeed=...

This is better than what I had in mind. Although I'd rearrange it slightly,
this is the essence of the uniform device identifier. Just as you said, a
serial device is connected to a modem. Devices can be chained. For a
moment, let's think about what is possible, not what is popular.

A device: scheme should map "modem:" to "bcni:jos.device.Modem". When you
used the modem: subscheme, you're asking for modem interface, not a serial
port interface.

IF a modem is connected to serial port 1, I could write this:

device:modem://localhost/ports/serial/1?maxspeed=...

IF a modem is connected to USB port 1, I could write this:

device:modem://localhost/ports/usb/1?maxspeed=...

Have you ever seen a modem connected to a parallel port? It is possible,
but not popular. IF a modem is connected to a parallel port 1, I could
write this:

device:modem://localhost/ports/parallel/1?maxspeed=...

>The device manager returns the raw device, and bnci converts it into the
>specified "jod.device.Modem" class.

I see it the other way around. BCNI returns a system-wide device and the
modem: sub-scheme converts it into a modem interface.

We have not yet talked about a device manager. We have not yet talked about
how system-wide devices are activated, how the device: scheme is
configured, how the central engine makes certain that only one application
has a port open at a time.

>Since more types of devices than modems can be attached to the serial
>port, the device manager can only return the raw version of the device:
>the port itself.

Exactly. That is why the serial port you specify by path is different than
the scheme that specifies the interface.

>Maybe, during JOS start-up, a mapping facility can create shortcuts,
>such as:
>
>device://localhost/mapped/modem0/?maxspeed=...
>
>is equivalent to:
>
>bnci:jos.device.Modem://localhost/ports/serial/1/?maxspeed=...

During JOS start-up, the modem: sub-scheme must be plugged into the device:
scheme factory. The serial: sub-scheme must be plugged in, too.

To get at the raw serial port, you might use a URI like this:

device:serial://localhost/ports/serial/1/?maxspeed=...

>What do you think?

I think we're making progress. In fact, we're close enough for the
following sub-projects:

1. Creating device interfaces

Someone needs to populate a package with examples of device-related
interfaces. The most important part of this sub-project is the interface
names, not their methods. Sample methods are thought-provoking. Methods
must be refined over time. Starting with interfaces we have already named:

ParallelPort
SerialPort
Modem

2. Creating the device: scheme and its corresponding factory

We need a smart factory that interprets a URI for the device: scheme. Like
any smart factory, it must use a separate plug-in controller for each
sub-scheme.

3. Creating basic implementations

For each interface, a Java programmer should create a basic implementation
of the interface. The interface and implementation must be kept separate in
order for this to work. The basic implementation could be abstract like we
talked about before.

package org.jos.device;
public interface Modem

package decaf.device;
public abstract class BaseModem
    implements Modem
public class BasicModem
    extends BaseModem

package usrobotics.device;
public class USRoboticsModem
    extends BaseModem

package practicalperipherals.device;
public class PracticalPeripheralsModem
    extends BaseModem

For example, it seems to me that Modem has-a SerialPort. Or rather, a Modem
has-a port. A port might be implemented as a real object.

public interface Modem {
  public Port getPort();
  public void setPort( Port v );
}

Then, all kinds of ports could extends the Port interface:

public interface Port {
  public int getID();
  public void close();
}

And we could easily create a port factory based on your paths:

Port s1 = getPort( "/ports/serial/1" );
Port s2 = getPort( "/ports/serial/2" );
Port usb1 = getPort( "/ports/usb/1" );
Port usb2 = getPort( "/ports/usb/2" );
Port usb3 = getPort( "/ports/usb/3" );
Port usb4 = getPort( "/ports/usb/4" );
Port p1 = getPort( "/ports/parallel/1" );
Port p2 = getPort( "/ports/parallel/2" );

AND the port factory would only provide ports that actually exist in
hardware. The exact kind of port must be determined by instanceof. In other
words, the port factory can be automatically configured upon startup. The
port factory can keep track of which ports are "busy".

There should be a URI for a port factory itself. When you ask for port
factory status, it shows which ports you have and which ports are busy. The
port factory is an example of a system-wide factory. It should be plugged
into BCNI.

There should be a URI for a device factory itself. If the port factory is
system wide, a device factory does not need to be. A device factory uses a
port factory. If the device factory is process-wide, it can keep track of
ports used by a process. It can close all ports used by a process when a
process is killed by the operating system.




From gchii@mindspring.com Sun, 19 Mar 2000 11:01:58 -0500
Date: Sun, 19 Mar 2000 11:01:58 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Systematic

Building something as complicated as an operating system is hard work.
Experience has shown that more work gets done when there is something to
run. I enjoy the JOS binary distribution created by Corrado Santoro
<Corrado.Santoro@IIT.UNICT.IT> because there is something I can run.

Who knew exactly how complicated it would be?

Some people are convinced that the JOS Project is the first example of a
next generation of operating system. This kind of operating system is
scalable on a spectrum the software industry has never seen before. JOS is
capable of providing a operating system for sub-minature consumer devices,
a personal workstation and a server farm. Linux and Windows are not capable
of scaling to this extreme. It scales better than Java.

This project has had more than its fair share of setbacks. We moved our
mailing lists. We have lost source code. We have lost enthusiatic but
impatient members. We temporarily lost our Wiki service. We had
intermittent shutdown of our CVS service. Each setback tends to discourage
members from working hard.

There are many reasons to be encouraged. JOS Binary Distribution is ready.
CVS is up. (A recent snapshot is available if it ever goes down.) We have
JOS Wiki again, thanks to www.metamech.com. Source Server should be
replaced by static WebSource pages. We are systematically working through
each technical problem. In spite of any critics, the project is making
progress.

As an open-source project, it is hard work by a lot of people. What is our
next step? Where are we going? What do we need to concentrate and focus on?

My gift is wasted if you can't open it. If you can't run what I wrote, it
is of no benefit to you. Our first priority is always running what we have.
There are two parts to running what we have: distribution and installation.

We must pave the road from the desk of a developer to the desk of the user.
It must be easy for the developer to publish a product. It must be easy for
a user to download it. Distribution is hard work. But without distribution,
nobody knows what you're working on because they can't run it.

Once a product has been distributed, it is necessary for a user to install
it. The worst case scenario is when a user thinks your product is horrible
because they couldn't configure it to run on their equipment. All the work
in programming, distribution and installation is wasted if a user can't use
it.

Our most important users right now are members of the JOS Project. Members
have been reach out to other members. Many have helped to get JOS up and
running on other member's equipment. I thank you.

We can look forward to more members. We can look forward to others
contributing appropriate source code and documentation to the JOS project.
More members are going to make meaningful contributions to this project. We
should approach this systematically.

What have you accomplished? Where have you succeeded? Encourage other
members by looking backward a little to see how far you've come. Others
will follow.




From tmiller@haverford.edu Sun, 19 Mar 2000 12:43:29 -0500 (EST)
Date: Sun, 19 Mar 2000 12:43:29 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Systematic

> As an open-source project, it is hard work by a lot of people. What is our
> next step? Where are we going? What do we need to concentrate and focus on?

	My near-term (which keeps getting further and further away, for
which I tender my apologies) goal is to finish the decaf rewrite, which is
a two part task.  First, to finish re-implementing the common/decaf
codebase (all 15,000 lines, or so, of it) so as to allow the second task,
which is to write the JVM-specific classes required by the
[classpath|Kore] library.  This will have obvious benefits.

	My focus is on infrastructure, but that's not necessarily what we
should be focusing on.  We could claim success -- that Java works well for
system programming -- just by being a *nix clone.  But then why work on
JOS, if the Linux (*BSD, etc), already get the job done so well?  JOS must
push for more, to be, as Gilbert phrases it, "a next generation OS."  We
must know what it means to do more, or do better.  An OS by itself,
however, is useless -- it's what the JOS-specific applications can do that
will set JOS apart, make it a success.  An application that conclusively
demonstrated the power of JOS could also be our 'killer app;' so the
question is, what 'impossible' application do you want to use (write)?  My
question is, then, what makes it 'impossible'?  What kind of infastructure
does that application need?  I have a few ideas of my own, but I'm still
thinking them through*.

	Shorter-term, though, a telnet client and server would be a good
goal in terms of technology demonstration.  It would require (i386 build):
booting, physical device recognition/driver installation (NIC, keyboard,
monitor), virtual device/driver installation (TCP/IP stack, virtual
consoles/terminals), a login facility, a shell, and quite possibly more.

-_Quinn

* Like the idea of a windowing system.  IIRC, the goal of a windowing
system is to make 'the computer' easier to use, more accessible.  I'm
looking at the question(s) of what makes a command-line interface hard to
use, whether that would be true for all text-based interfaces, if after
going graphical, you in fact want or need windows, if they're not some
sort of design artifact.

	Bearing in mind that the goal of any computer system is to
manipulate data (which includes its transmission and receival, that is,
communication), what about text (which is, after all, still the primary
method for representing data) is so difficult?  This is not to imply that
graphics aren't useful -- for graphics applications, they're more or less
a necessity, and the same for the web, a function which many regard as
integral to any computer -- but that even if re-analyzing the question
does not lead one to a new paradigm, it will be worthwhile for the
understanding gained of the current (WIMP) paradigm.

	The windowing system is not what makes 'the computer' easier to
use; it's what it enables applications to do and how it governs the user's
interactions with those applications.  The X window-manager /
display-manager separation reflects a clear understanding of
tthe latter; the KParts & Bonobo projects reflect a clear understanding of
the former, enabling applications to do things that would otherwise be
probitively difficult or expensive.

	So what are windows for?  You don't need them to display data,
though calling the abstraction to which an application draws a window may
be worthwhile.  I can only think of two reasons: the first is to make
obvious the boundary from one rule-set to another.  (That is, a text
editor and a graphics editor operating on a picture of that text editor do
vastly differently things.)  The second is to mark a boundary so that that
boundary may be adjusted -- window moving, iconization, maximization,
window-shading, etc.  Then ask the question: what happens when all
applications operate on frames in an WM-maintained document or stack of
documents?  Suddenly things look very different...




From Alexis Petrounias Mon, 20 Mar 2000 00:29:05 +0200
Date: Mon, 20 Mar 2000 00:29:05 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Gilbert Carl Herschberger II wrote:

> IF a modem is connected to serial port 1, I could write this:
> 
> device:modem://localhost/ports/serial/1?maxspeed=...

Actually, this could be even better... The above URI point to the serial
port, not the device *attached* to the serial port. Why not use this,
instead:

modem:device://localhost/ports/serial/1/attached?maxspeed=...

Take note of the alternating modem:device beginning of this URI...

> The device manager returns the raw device, and bnci converts it into
> the specified "jod.device.Modem" class.

If the JOS specific interpreter of these URI's is told that the "modem:"
protocol means "turn the object returned from device: into an object of
type jos.devices.Modem" then this would work.

Thus, for a VERY custom device, you could use this:

com.mycompany.devices.CardioPulseMeter:device://localhost/...

of you can set up and use custom drivers:

com.3com.modems.56KVoiceFaxModem:modem:device://localhost/...

What do you think?

> Since more types of devices than modems can be attached to the serial
> port, the device manager can only return the raw version of the
> device: the port itself.

That is only if you wish the URI to return a fully expressed device. You
may have defined protocols such as "modem:" that knows to convert the
device attached to the port into a modem object, and you may just have a
simple, raw device, which you can query, and then determine what it is.
But you should also have access to the port itself, independently. For
example, if I wish to set the maximum speed for the serial port, I have
to tell this to the serial port, *not* the attached device...

> To get at the raw serial port, you might use a URI like this:
> 
> device:serial://localhost/ports/serial/1/?maxspeed=...

Once again, I think "serial:" should be *before* "device:" But anyway:

In this case, every "sub directory" of the URI will in reality also
signify a protocol. Such as:

com.custom.CustomModem:modem:serial:device://localhost/ports/serial/1/attached?maxspeed=...

> Starting with interfaces we have already named:
> 
> ParallelPort
> SerialPort
> Modem

We can post a list of proposed device names, and have people comment on
device names which they don't like, while also adding their own proposed
device names. These device names should be as general as possible, and
should follow the typical class naming schemes we have accepted in JOS a
(or two?) year ago. Something like starting with a capital, using full
words, etc..

Things like:

Keyboard?keycount=104&functionkeys=true&layout=us-ascii
PointingDevice?commandcount=4
Mouse?buttoncount=3&wheel=true
ISDNAdapter?lines=2&dataline=true
EthernetAdapter?baud=100&encrypted=true
Monitor?toomanyparameters=very_true  :)
etc..

An apparent issue is: do we add the word "Device" after these things?

> Like any smart factory, it must use a separate plug-in controller for
> each sub-scheme.

Apparently... Any piece of software must come in changeable modules. If
that cannot happen, it has the fate and performance of things like
Solaris, Windows, OS/2, etc... Look at Linux: everybody can put his
little piece inside, and thus everybody (almost, other story) is happy.

> For example, it seems to me that Modem has-a SerialPort. Or rather, a
> Modem has-a port. A port might be implemented as a real object.

The port is also on an I/O controller (which could very well be custom,
as most modern motherboards provide EPROM), which is on a PCI bus (or on
whatever bus Macs use), which is on the motherboard.

> public interface Modem {
>   public Port getPort();
>   public void setPort( Port v );
> }

What happens if the Modem is on a PCI slot? Maybe the modem should not
be responsible for knowing what port it's attached to, rather, the port
knowing what modem is attached to it?

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From Alexis Petrounias Mon, 20 Mar 2000 00:41:09 +0200
Date: Mon, 20 Mar 2000 00:41:09 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Systematic

"Todd L. Miller" wrote:

>         So what are windows for?  You don't need them to display data,
> though calling the abstraction to which an application draws a window
> may be worthwhile.  I can only think of two reasons: the first is to
> make obvious the boundary from one rule-set to another.  (That is, a
> text editor and a graphics editor operating on a picture of that text
> editor do vastly differently things.)  The second is to mark a
> boundary so that that boundary may be adjusted -- window moving,
> iconization, maximization, window-shading, etc.  Then ask the
> question: what happens when all applications operate on frames in an
> WM-maintained document or stack of documents?  Suddenly things look
> very different...

People are used to working with books, papers and a small device (pen in
the real world, mouse in the virtual world). Windows (ehm... Frames :) )
help users in the sense that the computer is more approachable. You
can't expect someone to change from swapping papers and books (Frames)
to start telling the machine what to do with a command line.

Naturally, everybody HATES to use a mouse, but there is nothing
realistically better yet other than the mouse. I would prefer if I could
use speech to tell my computer what to do, I would prefer to be able to
merely think of what I want my computer to do, actually, I would prefer
not to have to even think that it is a computer and it has to do
something, I just want that something done, one way or another... But
until such biotechnology is designed and available to the general
public, mouse navigated and operated Frames are the most common and well
known way of communicating with an application.

They are the closest thing to the real world applications can offer in
terms of human computer interaction.

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From tmiller@haverford.edu Sun, 19 Mar 2000 19:22:59 -0500 (EST)
Date: Sun, 19 Mar 2000 19:22:59 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Systematic

> mouse navigated and operated Frames are the most common and well
> known way of communicating with an application.

	This does not, however, mean that it's /best/ way.

> They are the closest thing to the real world applications can offer in
> terms of human computer interaction.

	The real world metaphor is usually not the one you want to use in
designing an application, and many people fail to remember this.  (See
http://www.iarchitect.com/mshame.htm for a few examples of why.)  In
general, my computer can do things myRealWorldObject can only dream
of, and make possible things easier.  Playlists are a good example of the
latter, where one can drag & drop song titles to order them, something, so
far as I'm aware, that one can't do even on the rare stereos that /have/
playlists.  With respect to the former, nobody would dream of writing a
text editor today with the functionality of only a typewriter, because
there are so many things the computer can do that the typewriter can't.
The same for spreadsheets; the same for (e)mail applications.

	Realism in games serves two purposes: one is to render things
recognizable, and the other is to provide a set of rich and consistent
interactions among those things in the game.  That is, an accurate
simulation allows for and limits you to the range of real-world
interactions.  For shooters, the rules are typically bent (impossibly good
armor) to flatten the learning curve and prolong the game, but such bends
don't alter the expectation that jumping off a bridge will cause you to
fall.  For adventure games set in the here-and-now, a fully accurate
simulation would the Holy Grail; the designers would then set the scene
and the game would almost write itself.  (Not that a fully realistic scene
of any size is /easy/ to set, but anyway...)

	So realism doesn't sound too bad.  But let's look at two
things: the flip-side of games and applications.  The flip-side of games
is quite simple: the extent of your (kinesthetic) interaction is the
keyboard & mouse, and possibly a joystick/wheel/pedals.  For shooters,
where you're running all the time and carrying eighty pounds of gun and
ammo, this limit to the kinesthetics is a Good Thing.  For the adventure
game, it's probably not, because it makes it that much more difficult for
the player to manipulate the enviroment.  (That is, most interface design
in adventure gaming is an attempt to make what limited interactions are
available as easy and 'intuitive' -- consistent -- as
possible.)  Similarly for applications.  For many big problems, I prefer
the hardcopy & table route, simply because my monitor isn't large enough
to display as much information as I want simultaneously.  There is no way,
(at least on /my/ system) to flip through a document and see a full page
at a time; to organize those pages such that the ones I need to reference
are no more than a shift of eye focus away; to incorporate a
(reference) book as one of those reference pages; and so on.  On the other
hand, copying and pasting between the documents on the table is so
time-consuming as to be effectively impossible; I won't hear a beep when I
mis-balance my parentheses; I can't add a column of numbers up by writing
'=ADD(A1,A10)' at the bottom; and so on.

	To repeat myself: my computer can do things the 'Real World'
can't, and vice-versa.  I can interact with the 'Real World' in many more
ways than I can with the computer, to the detriment, usually, of the
computer.  Generally, the mouse and keyboard themselves are not 'Real
World'-intuitive objects.  The sense of an interface being intuitive is
that it's consistent enough that you can predict how to do something, what
will happen when you do it, and that everything you might want to do is
allowed.  That is, single-instance cut/copy/paste is not and more or less
intuitive than a stack or queue-based cut/copy/paste -- it's just simpler,
in that there are fewer things to predict.  (Now that I think about it, a
queue-based cut/copy/paste could come in really handy...)

	The goal of standardization in an interface is to reduce the
number of rules you need to know in order to predict (know) what happens
when; once you've learned 'minimize', 'maximize', 'restore', 'close', and
'iconify' for one window, you've learned it for all of them.  There is
less to predict.  (This is why people don't like windows with non-standard
controls -- it adds more things to know.)  This is an argument for using
the standard WIMP metaphor; the question is if there is another metaphor
whose ruleset is sufficiently smaller to make it worthwhile.  An example:
I, personally, find having three mouse buttons much better than one (or
two), because the meaning of each button is more narrowly defined (and
that the sum of those three narrow definitions is larger than the sum of
the wider one or two button definitions).  Apple seems to think that the
conceptual simplicity of having a /single/ action is worth the
complications of having that action potentially mean many things.  
Because Apple's single button mouse has fewer actions, it's more intuitive
in the sense of having fewer rules governing its usage; conversely it
could also be argued that increasing the number of ways in which one can
interact with things -- (possibly reducing the rules per action) -- is a
trade-off of sufficient importance in allowing one to do more things --
'everything that you might want to do' -- to be worthwhile.  (For example,
and leaving aside for the moment the question of whether or not
context-sensitive menus are intuitive -- is it more intuitive to access a
CSM with a mouse button which (almost) never means anything else, or with
and action -- click and hold -- which means different things depending on
if you move the mouse or not?

	Most of the burden of intuitive interface rests with the
application, rather than the operating system; as I said before, a
function of the operating system (interface) is to allow applications to
do 'Good Things' w.r.t. to interfaces.  (The other primary purpose is to
make things easier/better for the application programmer -- the display
server, the window manager, the 'everything is a file' abstraction, etc --
are enablers of better applications by upping the level of
abstraction; the idea of embedding is similar, that only applications
whose goal is to do X need to be concerned with how to do X -- that if
doing X is part of an application, how X is done is not terribly
important.  (X, for example, being to display a jpeg file.))

	I just said that most of the burden of intuitive interface rests
with the application, which is certainly true with current WIMPs, but may
not be true in general.  It could be argued that in a system with ONLY
embedded applications that the largest part of the interface rests with
the OS component which provides the thing(s) in which to embed.  Other
configurations may be possible; it's not unreasonably to difficult to
envision a system where every part of every UI is scripted by the user, so
that the burden of intuitive design falls to him (her).

	In sum: shouldn't a next-generation OS have a next-generation
interface?

-_Quinn

P.S.  Regarding the ideal interfaces you suggested -- I believe that all
of them are AI-complete problems, at the least...






From Corrado.Santoro@IIT.UNICT.IT Mon, 20 Mar 2000 17:05:14 +0100
Date: Mon, 20 Mar 2000 17:05:14 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Kernel] JOS Installation

On Sat, 18 Mar 2000, you wrote:
>
> 	The 1.1.8 JDK classes.zip I've got is 9122642 bytes, so I guess
> Corrado is using a different version.  Whatever works.

Hi all,
I'm using the jjos.zip file produce by the compiling process
(arch/i386/bytecode/jjos.zip). The JJOS/GRUB downloadable image I've produced
includes both jjos-grub and jjos.zip. I've also tested these images with my
GRUB boot diskette and all works right!

Gilbert, concerning GRUB, I've downloaded the bootable image from the URL
provided (the same you're using), and it works fine.
What is your problem exactly ?

-Corrado.

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://osweb.iit.unict.it/ARCA
======================================================




From cmall@Holly.colostate.edu Mon, 20 Mar 2000 13:50:49 -0700
Date: Mon, 20 Mar 2000 13:50:49 -0700
From: KC cmall@Holly.colostate.edu
Subject: [JOS-Kernel] I'm writing a report

Hay,
      I'm writing a report about JOS and I was wondering if any of you
could possibly tell me (or guess, I understand that the operating system
isn't complete yet but any information would be helpful) how you would
rate (on a scale of 1 to 10) JOS on three criteria?  I'm trying to
figure out how Java operating systems will compare to operating systems
now on the basis of efficiency (i.e. overall speed including efficient
resource allocation, efficient interrupt handling, and good response
time of various kernel and systems routines), security and protection
(for both the user and the operating system), and user convenience and
response time.  Thanks!

-KC




From gchii@mindspring.com Mon, 20 Mar 2000 22:01:49 -0500
Date: Mon, 20 Mar 2000 22:01:49 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JOS Installation

At 05:05 PM 3/20/00 +0100, Corrado Santoro <Corrado.Santoro@IIT.UNICT.IT>
wrote:
>Gilbert, concerning GRUB, I've downloaded the bootable image from the URL
>provided (the same you're using), and it works fine.
>What is your problem exactly ?

My exact problem is this: I have two stupid browsers. They refuse to
download any file that has no extension. I click on a link they do nothing,
nothing at all, not even an error message. With "unknown" extensions, I
usually get a dialog box prompting me to save the file. I don't believe it
is a problem with the website or link.

If stage1 and stage2 were added to an archive, such as stage1and2.tgz or
stage1and2.zip, I could download it and extract these files.

-----

I hadn't thought of it before. A JOS program can do this, can't it? It
might be time to role my own download-to-disk program. While a JOS program
might help me here and now, am I going to be the only one with a stupid
browser?

Can we automate the process of creating a JOS boot disk? It is feasible to
write a JOS program that creates a JOS boot disk. You can choose between
GRUB and Etherboot. For Etherboot, you can choose your network interface
card from a Choice component. In fact, we can write this so that it
downloads the latest Etherboot NIC files or downloads the stage1 and stage2
files from the www.jos.org server.

Step 1. Insert a blank diskette.
Step 2. Run the JOS Boot Disk program.
Step 3. Choose GRUB or Etherboot.
Step 4. If Etherboot, choose your network interface card.
Step 5. Press the Run button.

Result: The JOS Boot Disk program creates a boot disk.

Since the JOS Boot Disk program would be a platform-independent, you can
create a JOS Boot Disk from both Linux and Windows (and eventually JOS).




From gchii@mindspring.com Mon, 20 Mar 2000 21:40:31 -0500
Date: Mon, 20 Mar 2000 21:40:31 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

Thank you so much for your contribution to this discussion. Before this, I
couldn't see how devices and the I/O streams are very much alike. After all
this, one multiple stage object factory *is* the same as any other.

I put all devices under a device: scheme. Individual devices should be
sub-schemes, right? Here is one subscheme I would like to try:

"device:ram:?size=0xFF"

and

"device:ram:?start=0x0CC00&end=0xCCFF"

and

"device:ram:?start=0xCC00&size=0xFF"

In Java, this URI might return a byte array. Since memory is a limited
digital resource, it can be used if no other process is using it. If any
part of memory start to finish has already been allocated, the device
factory must return null.

At 12:29 AM 3/20/00 +0200, Al <Alexis Petrounias> wrote:
>Actually, this could be even better... The above URI point to the serial
>port, not the device *attached* to the serial port. Why not use this,
>instead:
>
>modem:device://localhost/ports/serial/1/attached?maxspeed=...
>
>Take note of the alternating modem:device beginning of this URI...

I understand your point. There must be symetry between the schemes and the
kind of objects it can produce. If we are creating a serial port, we should
have a serial port subscheme. From previous experience with the global
nature of URIs, I would put this whole discussion under a device: scheme.
It might be something like this:

port://localhost/ports/serial/1/attached?maxspeed=...
and
modem:port://localhost/ports/serial/1/attached?maxspeed=...

or

device:port://localhost/ports/serial/1/attached?maxspeed=...
and
device:modem:port://localhost/ports/serial/1/attached?maxspeed=...

While working on the Smart API for I/O streams, I discovered a powerful
concept of scheme chaining. Let me explain it here from a classic example.
To create a buffered, data input stream, we typically write code something
like this:

  public void example1() {
    String n = "example.txt";
    FileInputStream is = new FileInputStream( n );
    BufferedInputStream bis = new BufferedInputStream( is );
    DataInputStream dis = new DataInputStream( bis );
  }

From the first release of the Smart API, it supported scheme chaining, or
putting schemes together by repeatedly going back to the factory. Scheme
chaining is both powerful and flexible. It gets a program exactly what it
wants in a very dense URI. This is the Smart API equivalent for example1():

  public void example2() {
    URI uri = new URI( "in:data:buffer:file:example.txt" );
    DataInputStream dis = (DataInputStream) uri.getObject();
  }

The in: scheme directs a request to the input stream factory. Each scheme
in the chain recursively uses the input stream factory. An input stream
factory returns any class derived from java.io.Inputstream. Subschemes know
how to convert from InputStream to the desired type.

"in:file:example.txt" -> InputStream (FileInputStream)
"in:buffer:file:example.txt" -> InputStream (BufferedInputStream)
"in:data:buffer:file:example.txt" -> InputStream (DataInputStream)

Likewise, I have become convinced that scheme chaining would work with
devices. If one scheme expects a certain kind of interface from another
scheme, we can use scheme chaining.

"device:port:/ports/serial/1" -> Port (SerialPort)
"device:modem:port:/ports/serial/1" -> Modem (USRoboticsModem)

>If the JOS specific interpreter of these URI's is told that the "modem:"
>protocol means "turn the object returned from device: into an object of
>type jos.devices.Modem" then this would work.

With scheme chaining, the "modem:" protocol means exactly that. It does
whatever it takes to convert the object created by the chain into an object
that implements "jos.device.Modem".

>Thus, for a VERY custom device, you could use this:
>
>com.mycompany.devices.CardioPulseMeter:device://localhost/...
>
>of you can set up and use custom drivers:
>
>com.3com.modems.56KVoiceFaxModem:modem:device://localhost/...
>
>What do you think?

Yes, something like that. Potentially, a subscheme can accept an arbitrary
class name and figure out the necessary conversion. On the other hand, we
have to return an object. This is an object factory. It returns an instance
of java.lang.Object or null. After it is created, an object must be cast to
an appropriate type.

  public Object getObject();

For example, special features of a 3com driver won't work with a Hayes
modem. If you really want to use the special features of
com.3com.modems.56KVoiceFaxModem, you might need to use the instanceof
operator, like this:

URI uri = new URI( "modem:port://localhost/ports/serial/1" );
56KVoiceFaxModem modem = (56KVoiceFaxModem) uri.getObject();

>> Since more types of devices than modems can be attached to the serial
>> port, the device manager can only return the raw version of the
>> device: the port itself.
>
>That is only if you wish the URI to return a fully expressed device. You
>may have defined protocols such as "modem:" that knows to convert the
>device attached to the port into a modem object, and you may just have a
>simple, raw device, which you can query, and then determine what it is.
>But you should also have access to the port itself, independently. For
>example, if I wish to set the maximum speed for the serial port, I have
>to tell this to the serial port, *not* the attached device...

Hmm. This crosses over to system information. This is a good idea. It might
be possible for many processes at the same time to query the device
subsystem. Opening a device for exclusive use is not the only possible
function of a device factory. How do you find out the maximum speed of
serial port 1? How do you find out what is really attached to serial port 1?

The ports themselves are detected by JOS at start-up. The system-wide
configuration of a JOS machine must explain to JOS what it is exactly
that's attached. Where does the system-wide configuration come from? You
can type it in manually. That is the classic way. You can run a probe to
let the machine try to figure out what is attached. A probe does not have
to be build into an operating system. It only needs to show you what you
need to type in manually. A modem probe can be sold separately.

>> To get at the raw serial port, you might use a URI like this:
>> 
>> device:serial://localhost/ports/serial/1/?maxspeed=...
>
>Once again, I think "serial:" should be *before* "device:" But anyway:

I think device: should be a major scheme. I start a device URI with device:
to keep it separate from other major URI schemes like desktop:, fpt:,
http:, in:, out: jdbc:, mailto:, x-registry:, applet: and servlet:.

>In this case, every "sub directory" of the URI will in reality also
>signify a protocol. Such as:
>
>com.custom.CustomModem:modem:serial:device://localhost/ports/serial/1/attac
hed?maxspeed=...
>

I don't understand.

>> Starting with interfaces we have already named:
>> 
>> ParallelPort
>> SerialPort
>> Modem
>
>We can post a list of proposed device names, and have people comment on
>device names which they don't like, while also adding their own proposed
>device names. These device names should be as general as possible, and
>should follow the typical class naming schemes we have accepted in JOS a
>(or two?) year ago. Something like starting with a capital, using full
>words, etc..

Excellent idea!

>Things like:
>
>Keyboard?keycount=104&functionkeys=true&layout=us-ascii
>PointingDevice?commandcount=4
>Mouse?buttoncount=3&wheel=true
>ISDNAdapter?lines=2&dataline=true
>EthernetAdapter?baud=100&encrypted=true
>Monitor?toomanyparameters=very_true  :)
>etc..

And maybe RAM, MemoryManager, DMAChannel, Floppy, CDROM, GraphicsTablet,
LightPen, TouchScreen.

>An apparent issue is: do we add the word "Device" after these things?

When these interfaces are already part of the org.jos.device package,
adding the word "Device" is mostly redundent and, in general, should not be
used. Exceptions are allowed, such as PointingDevice.

>> Like any smart factory, it must use a separate plug-in controller for
>> each sub-scheme.
>
>Apparently... Any piece of software must come in changeable modules. If
>that cannot happen, it has the fate and performance of things like
>Solaris, Windows, OS/2, etc... Look at Linux: everybody can put his
>little piece inside, and thus everybody (almost, other story) is happy.

Plug-ins are a good thing. Never before has an operating system had so many
plug-ins as JOS. The general Java architecture makes everything a plug-in.

>What happens if the Modem is on a PCI slot? Maybe the modem should not
>be responsible for knowing what port it's attached to, rather, the port
>knowing what modem is attached to it?

We have to throw system-wide configuration into this somewhere. JOS doesn't
know for sure it has a PCI slot until start-up. If it depends on a
persistent system-wide configuration, that might expect to find a modem on
a PCI slot. If it probes for a modem, that might find a modem on a PCI
slot. If JOS known that it's a modem, I should be able to tell it manually
and use the modem without restarting my computer.

As a diagnostic tool, I look forward to using the Universal Browser with
the device: scheme. It looks like we can create a Device Browser. I should
be able to type in "device:port:/ports/serial/1" and my browser should show
me (1) if it exists, and (2) its current status. For example, I should be
able to use a browser to quickly determine which process (if any) is
currently using my modem.




From tmiller@haverford.edu Mon, 20 Mar 2000 23:07:34 -0500 (EST)
Date: Mon, 20 Mar 2000 23:07:34 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Device as a digital resource

	As long as we're using URI's to request devices, why not use URI's
to provide them?  There are two ways of doing this: a file read on startup
which would be a list a URI's representing devices-by-classname known to
exist on the machine, which a reader process would parse and post,
line-by-line, to the device factory.  By post, I mean something along the
lines of:

...
while ( enumerationOfDeviceList.hasMoreElements() ) {
	/* need to trap errors */
	String deviceURI = (String)enumerationOfDeviceList.nextElement();
	systemWideSmartFactory.addControllerFor( deviceURI );
	}
...

so that every driver listed in the startup device-list would be created
(initialized) in order and registered with the system-wide SmartFactory.

	Of course, one or more of the devices in the list could be, say,
"probeForSerialPortsByIRQ" and would, in its constructor, either post the
results of its probe (controller subclasses which return themselves on 
getObject()) or itself be a factory which would return those driver
instances which it created while probing.  That way, drivers could be
controlled in a unified way by the admin.  Also, since drivers
constructors can themselves call getObject() and addControllerFor(), if a
device in the list requires some other device which isn't available, it
can ask for it to be created; that is, the tree could be constructed
bottom-up.  (I think.  There may be problems with this that I'm unaware
of.)

	Actually, a third method is necessary -- supplying driver names on
the 'command line' to the kernel, so that you don't have to hard-code the
driver(s) used to access the harddrive to read the file to parse to
generate the device tree.  (You should also be able to replace drivers on
the fly, though this would entail support in the driver being replaced in
most cases -- because many drivers are persistent in the sense that
replacing a driver in the Factory does not replace instances of that
driver that may well be cached by an application or system process.)

	If you've already covered this in a prior email, my apologies for
not reading closely enough.

-_Quinn






From tmiller@haverford.edu Mon, 20 Mar 2000 23:11:37 -0500 (EST)
Date: Mon, 20 Mar 2000 23:11:37 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] JOS Installation

> My exact problem is this: I have two stupid browsers. They refuse to
> download any file that has no extension. I click on a link they do nothing,
> nothing at all, not even an error message. With "unknown" extensions, I
> usually get a dialog box prompting me to save the file. I don't believe it
> is a problem with the website or link.

	Command-line ftp doesn't work?

> Since the JOS Boot Disk program would be a platform-independent, you can
> create a JOS Boot Disk from both Linux and Windows (and eventually JOS).

	Hey, go for it.  That would be a rather cool program to have,
actually.  (And it shouldn't be too hard to write, either.)  Extensions
that come immediately to mind are also downloading a given revision of the
files necessary for either boot method,
e.g. jos-etherboot-binary-distribution.tgz (or whatever) or
jos-grub-binary-distribution.tgz (or whatever).  Does, BTW, anyone know if
GRUB supports FAT partitions for module/kernel loading?  At any rate, the
program could supply the pathnames of the relevant files for each method
and instructions for the rest of the boot process...

-_Quinn




From Corrado.Santoro@IIT.UNICT.IT Tue, 21 Mar 2000 10:21:31 +0100
Date: Tue, 21 Mar 2000 10:21:31 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Kernel] JOS Installation

On Tue, 21 Mar 2000, you wrote:
> At 05:05 PM 3/20/00 +0100, Corrado Santoro <Corrado.Santoro@IIT.UNICT.IT>
> wrote:
> >Gilbert, concerning GRUB, I've downloaded the bootable image from the URL
> >provided (the same you're using), and it works fine.
> >What is your problem exactly ?
> 
> My exact problem is this: I have two stupid browsers. They refuse to
> download any file that has no extension. I click on a link they do nothing,
> nothing at all, not even an error message. With "unknown" extensions, I
> usually get a dialog box prompting me to save the file. I don't believe it
> is a problem with the website or link.
> 
> If stage1 and stage2 were added to an archive, such as stage1and2.tgz or
> stage1and2.zip, I could download it and extract these files.
> 
> -----
> 
> I hadn't thought of it before. A JOS program can do this, can't it? It
> might be time to role my own download-to-disk program. While a JOS program
> might help me here and now, am I going to be the only one with a stupid
> browser?
> 
> Can we automate the process of creating a JOS boot disk?

Gilbert,
I think this is a good idea. Meanwhile, I've posted a .tar.gz file in my JOS
binary web pages which contains the binaries for GRUB and a shell script which
creates the GRUB boot diskette.

I hope this will help all the JOS people.

-Corrado

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://osweb.iit.unict.it/ARCA
======================================================




From George.Marrows@Smallworld.co.uk Tue, 21 Mar 2000 09:29:38 -0000
Date: Tue, 21 Mar 2000 09:29:38 -0000
From: George.Marrows@Smallworld.co.uk George.Marrows@Smallworld.co.uk
Subject: [JOS-Kernel] JOS Installation

> Does, BTW, anyone know if GRUB supports FAT partitions for module/kernel
loading?

Yes it does, both FAT16 and FAT32. However, I think you have to use mangled
8.3 filenames rather than long filenames.

Incidentally, if you get the GRUB command prompt and type

kernel=(hd0,

and then hit TAB, you'll get a list showing the partitions on disk hd0 and
also the type of filesystem on each. This works for module as well.

-- George

> -----Original Message-----
> From:	Todd L. Miller [SMTP:tmiller@haverford.edu]
> Sent:	Tuesday, March 21, 2000 4:12 AM
> To:	kernel@jos.org
> Subject:	Re: [JOS-Kernel] JOS Installation
> 
> > My exact problem is this: I have two stupid browsers. They refuse to
> > download any file that has no extension. I click on a link they do
> nothing,
> > nothing at all, not even an error message. With "unknown" extensions, I
> > usually get a dialog box prompting me to save the file. I don't believe
> it
> > is a problem with the website or link.
> 
> 	Command-line ftp doesn't work?
> 
> > Since the JOS Boot Disk program would be a platform-independent, you can
> > create a JOS Boot Disk from both Linux and Windows (and eventually JOS).
> 
> 	Hey, go for it.  That would be a rather cool program to have,
> actually.  (And it shouldn't be too hard to write, either.)  Extensions
> that come immediately to mind are also downloading a given revision of the
> files necessary for either boot method,
> e.g. jos-etherboot-binary-distribution.tgz (or whatever) or
> jos-grub-binary-distribution.tgz (or whatever).  Does, BTW, anyone know if
> GRUB supports FAT partitions for module/kernel loading?  At any rate, the
> program could supply the pathnames of the relevant files for each method
> and instructions for the rest of the boot process...
> 
> -_Quinn
> 
> 
> _______________________________________________
> Kernel maillist  -  Kernel@jos.org
> http://jos.org/mailman/listinfo/kernel



From gchii@mindspring.com Tue, 21 Mar 2000 08:14:49 -0500
Date: Tue, 21 Mar 2000 08:14:49 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] JOS Installation

At 10:21 AM 3/21/00 +0100, Corrado Santoro <Corrado.Santoro@IIT.UNICT.IT>
wrote:
>Gilbert,
>I think this is a good idea. Meanwhile, I've posted a .tar.gz file in my JOS
>binary web pages which contains the binaries for GRUB and a shell script
which
>creates the GRUB boot diskette.

Thank you, Corrado! I'll look into it right away.

A shell script is a good interim solution for everyone with Linux, everyone
that can run a shell script. I have Linux. I'll be able to use it right away.

Does anyone have a corresponding shell script for Etherboot?

>I hope this will help all the JOS people.

I believe it will. Thanks again,




From Alexis Petrounias Tue, 21 Mar 2000 16:26:25 +0200
Date: Tue, 21 Mar 2000 16:26:25 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Gilbert Carl Herschberger II wrote:

> I put all devices under a device: scheme. Individual devices should be
> sub-schemes, right? Here is one subscheme I would like to try:
> 
> "device:ram:?size=0xFF"
> 
> and
> 
> "device:ram:?start=0x0CC00&end=0xCCFF"
> 
> and
> 
> "device:ram:?start=0xCC00&size=0xFF"
> 
> In Java, this URI might return a byte array.

Have in mind that the URI's agive don't return a byte array, they return
a device object. I think you should alternate the protocols used.
Instead of:

	device:ram://localhost/rambus?offset=0x0&length=0xFF

you want:

	ram:device://localhost/rambus?...

And if you want that to return a byte array, you should also do this:


	byte[]:ram:device://localhost/rambus?...


But if you are going to convert a device into a device of type RAM, then
you have to place the "ram:" protocol before the "device:" protocol,
just like zip files:


jar:zip:http://localhost/hda1/home/personal.jar


> Since memory is a limited digital resource, it can be used if no other
> process is using it. If any part of memory start to finish has already
> been allocated, the device factory must return null.

Of course, this goes for example's sake only, e? I don't think arbitrary
memory access is exactly what we want in our security manifesto! :)

> Likewise, I have become convinced that scheme chaining would work with
> devices. If one scheme expects a certain kind of interface from
> another scheme, we can use scheme chaining.
> 
> "device:port:/ports/serial/1" -> Port (SerialPort)
> "device:modem:port:/ports/serial/1" -> Modem (USRoboticsModem)

I still think that the port should not be able to be converted into a
Modem. I think that the URI should end with /ports/serial/1/device? or
something equivalent, to distringuish it from the port itself.

> URI uri = new URI( "modem:port://localhost/ports/serial/1" );
> 56KVoiceFaxModem modem = (56KVoiceFaxModem) uri.getObject();

Yes, I really like this! This lets programmers tap into a device from
wherever in their code, and it lets the System handle things centrally
with stable and concentrated security. If there is not other way to
access a physical device on JOS (and virtual devices) other than the
Device interpreter, there is a lot of power behind. A lot of
manageability. This sound very nice...

> How do you find out the maximum speed of serial port 1?

There may be information in the chipset, the BIOS or the whatever. There
may be manual information by the user. Alas, there is the default and
safe assumption of 19200... There is no certain way really, not yet, and
definitely not with all existing serial ports.

> How do you find out what is really attached to serial port 1?

Same as above... You may guess that the PS/2 port connects to either a
Keyboard or a pointing device. You can search serial ports for modems
and null cables. You can search the parallel port for printers, cameras
and scanners. But you can't *always* know for certain what you are
dealing with. No possible way.

> The ports themselves are detected by JOS at start-up.

The devices attached to the ports could also be detected, if we have the
drivers for them. It depends. The more JOS, the more devices will be
detected. Other devices will not function until drivers are installed.

> I think device: should be a major scheme.

I see how you mean this. "device:" will not be treated like the rest of
the protocols, it will just signify that the rest of the protocols will
be "transformation" protocols of the returned object. The "device:" is
there just to help the system know that this URI is intended for the
device manager.

> When these interfaces are already part of the org.jos.device package,
> adding the word "Device" is mostly redundent and, in general, should
> not be used. Exceptions are allowed, such as PointingDevice.

Yeah, I see your point, but what about things like:


jos.system.security.JOSSecurityManager


We could leave out the "JOS" part, since it's in package jos., but it
would confuse programmers. Another example: JFrame could very well be
Frame, since it's not in the java.awt. package, but things are clearer
when that J is in front... The same could apply to JOS. I donno.

> The general Java architecture makes everything a plug-in.

Very true. With the capabilities of reflecting on interface class files,
I don't think there is actually a way to *stop* things from being
plug-ins! :)

> If JOS known that it's a modem, I should be able to tell it manually
> and use the modem without restarting my computer.

But this is JOS, not the modem... I don't think the Modem should know
where it is (PCI or serial), I think only the device manager should.

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From Alexis Petrounias Tue, 21 Mar 2000 16:29:03 +0200
Date: Tue, 21 Mar 2000 16:29:03 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

"Todd L. Miller" wrote:

> <snip> -- because many drivers are persistent in the sense that
> replacing a driver in the Factory does not replace instances of that
> driver that may well be cached by an application or system process.)

Applications or system processes will not have access to the driver, nor
the device itself. They will merely have access to an object which
interfaces this device with the JOS kernel and core. The application
only knows it has a Modem object, it does not know the name of the
driver or the manufacturer of the driver... The driver can change (not
the device - the driver) and the application should be able to just
continue using the device with the Modem object (or whatever device it
is).


-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From Alexis Petrounias Mon, 20 Mar 2000 12:31:17 +0200
Date: Mon, 20 Mar 2000 12:31:17 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Systematic

"Todd L. Miller" wrote:

> > mouse navigated and operated Frames are the most common and well
> > known way of communicating with an application.
> 
>         This does not, however, mean that it's /best/ way.

Definitely not, see below:

>         The real world metaphor is usually not the one you want to use
> in designing an application, and many people fail to remember this.
>  (See http://www.iarchitect.com/mshame.htm for a few examples of why.)
>  In general, my computer can do things myRealWorldObject can only
> dream of, and make possible things easier.  Playlists are a good
> example of the latter, where one can drag & drop song titles to order
> them, something, so far as I'm aware, that one can't do even on the
> rare stereos that /have/ playlists.  With respect to the former,
> nobody would dream of writing a text editor today with the
> functionality of only a typewriter, because there are so many things
> the computer can do that the typewriter can't.

Ah, you have misunderstood my words... I do not mean that we should
strive to make application mimic real world object, I am saying that the
*interface* to applications should be the best possible blending into
the real world. Speech is better than gestures (mouse), which in turn is
better than typing. Until natural language is understood by computers,
the mouse is the next best thing (IMHO, of course!)

> <snip> I can't add a column of numbers up by writing '=ADD(A1,A10)' at
> the bottom; and so on.

That's why we need media that with the same effort as typing
'=ADD(A1,A10)' give more information. The combination of a monitor and a
mouse gives hundreds of times more information than a keyboard alone, e?

> The sense of an interface being intuitive is that it's consistent
> enough that you can predict how to do something, what will happen when
> you do it, and that everything you might want to do is allowed.

Precisely... Would it not be nice to find yourself in a VR world where
you can literally stick your finger in between the columns, and make
space for an extra column?

> (Now that I think about it, a queue-based cut/copy/paste could come in
> really handy...)

True, does any one know of an OS or clipboard manager that can do this?
Just by the way.

> Because Apple's single button mouse has fewer actions, it's more
> intuitive in the sense of having fewer rules governing its usage;
> conversely it could also be argued that increasing the number of ways
> in which one can interact with things -- (possibly reducing the rules
> per action) -- is a trade-off of sufficient importance in allowing one
> to do more things -- 'everything that you might want to do' -- to be
> worthwhile.

Hmm... If you think of the mouse as an extension of your hand when you
are using it, though, and say your hand has all five fingers, then could
you not be very comfortable with five buttons. OK, maybe since the
nerves of the palm are complicated we need a neurologist to tell us
whether two or three buttons are useful, but you get what I mean, right?

>  (For example, and leaving aside for the moment the question of
> whether or not context-sensitive menus are intuitive -- is it more
> intuitive to access a CSM with a mouse button which (almost) never
> means anything else, or with and action -- click and hold -- which
> means different things depending on if you move the mouse or not?

I believe that if you can associate click-and-hold with imminent
drag-and-drop, then this would work universally, for all components of a
UI that are mobile.

>         Most of the burden of intuitive interface rests with the
> application, rather than the operating system;

Yet, as engineers of an operating system with its UI, we must help users
by promoting a *consistent* UI across all applications. Is there anybody
reading this e-mail that has not had at least a little trouble using
WinAmp controls? Is there anybody here who could predict from start what
each WinAmp control did? WinAmp is a fantastic application, but its UI
is *very* complicated. Contrary to that, I can't say I ever had trouble
guessing what each button does on the Netscape toolbar, and Netscape is
a fantastic application as well...

Fortunately, Sun has provided a few neat and - possibly - beautiful
defaults for component structure, and look & feel. I think it is a very
good idea, and it is an idea which we have already seen the consequences
of its absence in Linux... True, the graphical UI will eventually be
selected arbitrarily, but Sun's Swing is so general and serves so many
people that I believe would be extremely useful as the default UI of JOS
and all Java applications.

>         In sum: shouldn't a next-generation OS have a next-generation
> interface?

It should have a stable and familiar interface to help first time users,
at least. But this is not the core part of the OS, it's the core part of
its environment. Ages ago there were several discussions on having JOS
load an "jos.ui.graphical.environment.Environment" class during startup,
which will provide the hard peers for graphics (on a Screen object).
Inside that environment a "jos.ui.graphical.GraphicalShell" can be
loaded, something like Finder on the Mac and Explorer on Windows.

> P.S.  Regarding the ideal interfaces you suggested -- I believe that
> all of them are AI-complete problems, at the least...

Unfortunately, they are... But that's the beauty of designing them!

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From tmiller@haverford.edu Tue, 21 Mar 2000 11:30:54 -0500 (EST)
Date: Tue, 21 Mar 2000 11:30:54 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Device as a digital resource

> The driver can change (not the device - the driver) and the
> application should be able to just continue using the device with the
> Modem object (or whatever device it is).

	Okay, so there's another of level indirection in here that I
missed.  That is, Controller.getObject() may well return itself, but the
Controller for a Device is the only object in the system which keeps a
driver reference?)

-_Quinn




From Alexis Petrounias Tue, 21 Mar 2000 18:38:32 +0200
Date: Tue, 21 Mar 2000 18:38:32 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

"Todd L. Miller" wrote:

>         Okay, so there's another of level indirection in here that I
> missed.  That is, Controller.getObject() may well return itself, but
> the Controller for a Device is the only object in the system which
> keeps a driver reference?)

I have absolutely no idea, as nobody else has either. We have not
discussed this issue. I am just certain that it will be considered
insane to allow applications raw access to hardware - it's just
completely opposite to all aims of Java's abstraction and inherent
security features. System components must have access to devices, but
they will be JOS specific, and could thus implement an interface for
informing them when a device has changed status. Something like this:


package jos.system.device;

public interface DeviceListener extends EventListener {

	public void deviceConnected(Device device);
	public void deviceDisconnected(Device device);
	public void deviceStatusChanged(Device device, String name,
	                                              Object newvalue);

}

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From Matt.Albrecht@trilogy.com Tue, 21 Mar 2000 11:01:30 -0600
Date: Tue, 21 Mar 2000 11:01:30 -0600
From: Matt.Albrecht@trilogy.com Matt.Albrecht@trilogy.com
Subject: [JOS-Kernel] Device as a digital resource

Ah, the lurker returns...  Please pardon my ramblings.




>I put all devices under a device: scheme. Individual devices should be
>sub-schemes, right? Here is one subscheme I would like to try:
>
>"device:ram:?size=0xFF"
>
>and
>
>"device:ram:?start=0x0CC00&end=0xCCFF"
>
>and
>
>"device:ram:?start=0xCC00&size=0xFF"
>
>In Java, this URI might return a byte array. Since memory is a limited
>digital resource, it can be used if no other process is using it. If any
>part of memory start to finish has already been allocated, the device
>factory must return null.

This means that now the device factory must handle the registration and
allocation of *every* device.  Wouldn't it be easier, in that respect, to
have the device schemes register themselves with "device:", then the
individual schemes themselves handle the allocation?

In this respect, the individual scheme specifies several things:

1. The class which is returned (which must be a subclass/interface of
Device)
2. If it's a limited resource, then a null may be returned if the resource
has already been allocated.

But wouldn't it be "nicer" if, instead of returning null, it returns an
error message describing what's wrong with the request, such as "out of
bounds memory allocation", or "XYZ has already allocated that resource",
and so on.

Also, how would one deallocate the resource?  Would this need to be
specified in the finalize method of the resource's returned object?  What
if the particular JVM that allocated this resource crashed, would the
resource then be unavailable to everyone, requiring a reboot?  These
questions aren't just limited to your particular implementation; they are
serious things to consider for any system.

Don't get me wrong.  This feels to me to be one of the best solutions to
device allocation I've seen.

Some other things to consider.  How would a program discover which devices
are available?  How would the admin then configure these devices so that
they are setup correctly?  I.e. how would you tell
"device:sound://localhost/1" to use DMA channel 1 instead of channel 3?
Then again, how would you know that there aren't more than one sound card
available on localhost?

Perhaps I'm looking at the problem in the wrong direction.  The URI here
would be the way for the programs to allocate a resource.  Some other
technique would be needed to discover the devices available, and possibly
another to configure them (a bean resource would be very handy here).

>>What happens if the Modem is on a PCI slot? Maybe the modem should not
>>be responsible for knowing what port it's attached to, rather, the port
>>knowing what modem is attached to it?
>
>We have to throw system-wide configuration into this somewhere. JOS
doesn't
>know for sure it has a PCI slot until start-up. If it depends on a
>persistent system-wide configuration, that might expect to find a modem on
>a PCI slot. If it probes for a modem, that might find a modem on a PCI
>slot. If JOS known that it's a modem, I should be able to tell it manually
>and use the modem without restarting my computer.

Here we come down to how much configuration of the device should be done by
the programmer, as opposed through internal setup.  Does the programmer
really need to know whether modem A is on a serial port or a USB port?  The
programmer should be able to find all the modems, and discover what are
their properties (such as maximum speed, and various possible bit settings
- I've known some bad modems in my day that could only be set to
odd-parity), and then select the best fit.  Another possibility would be to
send a template to the device:modem scheme for it to return the best fit.

We must not go overboard on this URI schema.  We need to keep it simple.
Would you want to have to type in
"in:data:buffer:file:fat16:hdd://1?cylinders=255&tracks=65535&file=external.txt"?

 The "file:" scheme automatically maps the given file to the internal
device registry, whether the file be on a remote machine, a RAM disk, or on
a hard-drive.

>
>As a diagnostic tool, I look forward to using the Universal Browser with
>the device: scheme. It looks like we can create a Device Browser. I should
>be able to type in "device:port:/ports/serial/1" and my browser should
show
>me (1) if it exists, and (2) its current status. For example, I should be
>able to use a browser to quickly determine which process (if any) is
>currently using my modem.

This may be a good place to add our diagnostic tools and configuration
tools.  But how do we do this?  Do we add another scheme, such as
"config:device:port:/ports/serial/1", or do we add it to the path:
"device:port:/ports/serial/1/config"?  I dunno.

-Matt






From Matt.Albrecht@trilogy.com Tue, 21 Mar 2000 11:12:36 -0600
Date: Tue, 21 Mar 2000 11:12:36 -0600
From: Matt.Albrecht@trilogy.com Matt.Albrecht@trilogy.com
Subject: [JOS-Kernel] Device as a digital resource

I like your idea of initializing the device tree.



>          Actually, a third method is necessary -- supplying driver names
on
>the 'command line' to the kernel, so that you don't have to hard-code the
>driver(s) used to access the harddrive to read the file to parse to
>generate the device tree.  (You should also be able to replace drivers on
>the fly, though this would entail support in the driver being replaced in
>most cases -- because many drivers are persistent in the sense that
>replacing a driver in the Factory does not replace instances of that
>driver that may well be cached by an application or system process.)

I personally prefer the JavaOS for Business solution to this: instead of
giving an exact reference to the device when asked for, the device factory
instead returns a handler.  When the device itself is removed, it sends a
signal to all registered handlers telling them that the device is being
removed.  We could have a similar option for swapping devices.

>-_Quinn

-Matt


_______________________________________________
Kernel maillist  -  Kernel@jos.org
http://jos.org/mailman/listinfo/kernel








From Alexis Petrounias Tue, 21 Mar 2000 19:29:01 +0200
Date: Tue, 21 Mar 2000 19:29:01 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Matt.Albrecht@trilogy.com wrote:

> But wouldn't it be "nicer" if, instead of returning null, it returns
> an error message describing what's wrong with the request, such as
> "out of bounds memory allocation", or "XYZ has already allocated that
> resource", and so on.

A DeviceAllocationException can be thrown, and it can be subclassed like
this:

ParameterIncorrectException extends DeviceAllocationException {

	public String getParameterName();
	public Object getParamterValue();

}

ParameterOutOfRangeException extends ParameterIncorrectException {

	public String getParameterValueRange();

}

etc..


> Also, how would one deallocate the resource?

How about:

Device.close();

or

Device.deallocate();

?

Or, maybe:

URI uri =
   new URI("device:modem:port://localhost/ports/serial/1/attached");

Modem modem = (Modem) DeviceManager.getDevice(uri);


modem.doSomething(parameter...);

DeviceManager.deallocate(modem);

> What if the particular JVM that allocated this resource crashed, would
> the resource then be unavailable to everyone, requiring a reboot?

Will the hardware crash or the software crash?

> Some other things to consider.  How would a program discover which
> devices are available?

DeviceManager.listBuses();
DeviceManager.listPorts();
DeviceManager.listPhysicalDevices();
DeviceManager.listVirtualDevices();
DeviceManager.listDevices();

and most important of all:

DeviceManager.listDevices(String type);

>  How would the admin then configure these devices so that they are
> setup correctly?  I.e. how would you tell "device:sound://localhost/1"
> to use DMA channel 1 instead of channel 3?

"localhost/1" does not point to a device. Maybe something like this:

URI uri = new URI("device://localhost/bus/pci/4/attached");
String type = DeviceManager.resolveDeviceType(uri);

The resolve will be a probe with information regarding known device
types. If the device type is unknown, by definition, we don't have a
driver for it.

After you resolve it, you can use the Bean architecture to call methods
such as:

getDMAChannel();
setDMAChannel(1);

> Then again, how would you know that there aren't more than one sound card
> available on localhost?

JOS startup is responsible for probing the motherboard for everything
connected to it. If JOS cannot find something, the application simply
cannot use it.
 
> Perhaps I'm looking at the problem in the wrong direction.  The URI
> here would be the way for the programs to allocate a resource.

No, I think the URI is a way of grabbing an interface to a device. Then,
that interface can be used to allocate whatever can be allocated.
Certain things cannot be allocated, right?

> Here we come down to how much configuration of the device should be
> done by the programmer, as opposed through internal setup.  Does the
> programmer really need to know whether modem A is on a serial port or
> a USB port?

No, but he should be able to know if he wishes to. The JOS programmer
*must* be able to know that, though ;-)

> Would you want to have to type in
> "in:data:buffer:file:fat16:hdd://1?cylinders=255&tracks=65535&file=external.txt"?

No, this is long to type, but that's why JOS can map certain things
during start up. Of course, I do want to be *able* to type the above
thing. The "file:" protocol will be actually a shortcut to:

in:file:device:hdisk:ide://localhost/bus/ide/1/a/1/filesystem?path=...


Nor will I have to type anything to allocate memory, I can just do it
this way:

String string = new String("Hello!");

just as:

File file = new File("filname.ext");

> This may be a good place to add our diagnostic tools and configuration
> tools.  But how do we do this?  Do we add another scheme, such as
> "config:device:port:/ports/serial/1", or do we add it to the path:
> "device:port:/ports/serial/1/config"?  I dunno.

The device finder and manager should return devices. We could do this:

Modem modem = (Modem)DeviceManager.getDevice(...);

DeviceConfiguration config = modem.getConfiguration();

config.setParameter(..., ...);

etc.

What do you think?

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From Alexis Petrounias Tue, 21 Mar 2000 19:32:09 +0200
Date: Tue, 21 Mar 2000 19:32:09 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Matt.Albrecht@trilogy.com wrote:

> I personally prefer the JavaOS for Business solution to this: instead
> of giving an exact reference to the device when asked for, the device
> factory instead returns a handler.  When the device itself is removed,
> it sends a signal to all registered handlers telling them that the
> device is being removed.  We could have a similar option for swapping
> devices.

And also, have in mind that a swappable disk does not mean an altogether
change of device, e?

Consider the following:


device:zipdrive:scsi://localhost/bus/scsi/6/attached

and

device:zipdrive:scsi//localhost/bus/scsi/6/attached/disk


The first URI points to the Zip drive itself, the second to the disk
*inside* the Zip drive.

Both should be accessed separately, if so desired. Otherwise, the object
SCSIZipDrive could have a method isMounted() as part of a MountableMedia
interface.

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From tmiller@haverford.edu Tue, 21 Mar 2000 21:28:16 -0500 (EST)
Date: Tue, 21 Mar 2000 21:28:16 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Device as a digital resource

> I personally prefer the JavaOS for Business solution to this: instead of
> giving an exact reference to the device when asked for, the device factory
> instead returns a handler.  When the device itself is removed, it sends a
> signal to all registered handlers telling them that the device is being
> removed.  We could have a similar option for swapping devices.

	A Controller which has the only reference to a device driver would
be one of these handlers, no?  In general, to respond to your concern
about complicated URIs, it would the responsibility of a given Controller
to recongnize more abstract forms.  Protocols like file: are higher-level
protocols that shouldn't do any work on their own, but request services
from lower-level protocols like filesystem:, which in turn operates on
device:s like harddrive: or network:.  file: would post requests like
'filesystem:///', and then ask filesystem_root for the filesystem object
representing /mnt -- e.g. filesystem_root.getFS( "mnt" ); -- and then
NFSmount, and finally getFile( "myFile" ); -- which the NFS
filesystem: would implement by asking for network: device at some point.

-_Quinn







From tmiller@haverford.edu Tue, 21 Mar 2000 21:34:27 -0500 (EST)
Date: Tue, 21 Mar 2000 21:34:27 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Systematic

> Ah, you have misunderstood my words... I do not mean that we should
> strive to make application mimic real world object, I am saying that the
> *interface* to applications should be the best possible blending into
> the real world. Speech is better than gestures (mouse), which in turn is
> better than typing. Until natural language is understood by computers,
> the mouse is the next best thing (IMHO, of course!)

	As an aside, research being done in "multimodal" interfaces
suggest that speech is almost only useful when combined with a 'gestural
interface' (either a mouse, a touchscreen, or some other higher-tech
solution like real-time video analysis), because there is no consistent
naming for on-screen objects between people, between a person's different
sessions using the computer, and in many cases, after shifting between
tasks.  The gesture is necessary for selection.  This suprised a great
many of the researchers, who were only expecting problems in determining
pronoun references (though gestural input helps here, too).  (As another
aside, since I can type an order of magnitude faster than I can talk, I'm
likely to keep using the keyboard long past when speech recognition is
effective.  Also, it's easier to shift a finger over and hit backspace (or
ctrl-h/ctrl-d, whatever) then speak corrections, for me, anyway.)

	"the interface should to applications should be the best possible
blending into the real world" is a good way of phrasing it -- though one
must be careful to remember that applications are not 'real'.  One
interesting idea -- inspired by the smalltalk(IIRC)-based 'reality
toolkit' demonstration -- is to give interface elements inertia, and
redefine mouse motions to be accelerations, so that you could 'fling'
windows into the corners or push them out of the way without having to
worry about placing them exactly.  Other elements of the reality toolkit
would be worth investigating also; especially if 'require' applications to
be JavaBeans, it shouldn't be too hard to set up controller/reciever links
between applications in an intuitive fashion with more precision than just
pipes.  (Although this would probably be more useful with application
components, given how large and tightly-bound most graphical applications
are.)  I guess we'll find out :)

-_Quinn






From gchii@mindspring.com Wed, 22 Mar 2000 09:47:45 -0500
Date: Wed, 22 Mar 2000 09:47:45 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

At 04:26 PM 3/21/00 +0200, Al <Alexis Petrounias> wrote:
>Of course, this goes for example's sake only, e? I don't think arbitrary
>memory access is exactly what we want in our security manifesto! :)

Security is precisely the reason why I brought up this example. First,
understand that any request can be denied. An object is returned only if a
request is appropriate. A subsystem determines if a request is appropriate.
If an arbitrary request is denied, null is returned or an exception is
thrown. It is the same is any request for RAM.

For non-shared RAM, an object has exclusive access to a block of RAM. If
one object has already opened a block of ram, no other object can open the
same block. For shared RAM, many objects can access the same block.

Arbitrary memory access is essencial part of writing a device driver. A
video driver must access the video buffer. A serial port driver must access
the I/O buffer for the port. An IDE driver must access the I/O buffer for a
drive.

A system process should be granted an arbitrary request for memory. Today,
JOS is implemented only as a system process. JOS has arbitrary and
*unsecure* memory access. That's how we are able to poke characters into
the video buffer.

A ram: sub-scheme must be carefully programmed to enforce appropriate
rules. All of the rules for RAM might be centralized, concentrated into a
URI-aware memory manager. In general, a system process must not use RAM
that contains the kernel or virtual machine.

Everything is a digital resource. RAM is a digital resource, too. This is
not a wildly irresponsible idea. It is not just for the sake of an example.
It shows that memory allocation might interact peacefully with a uniform
device identifier.

Would your program like to examine the current '486 interrupt table? Use a
URI like this:

device:ram:?start=0&end=0x100&access=readonly

In a Java standard class library, there is no read-only byte array. And
yet, this is vital to the function of an operating system. A custom virtual
machine, like decaf, could implement it by adding a read-only property to
the byte array class.

The Java standard class library was not written with the expressed goal of
building a world-class operating system. Maybe the ram: subscheme should
not return a byte array directly. Maybe it should return a MemoryBlock that
has a read-only property.

public interface MemoryBlock {
  public boolean isReadOnly();
  public byte getByte( int index );
  public void setByte( int index, byte v );
}




From gchii@mindspring.com Wed, 22 Mar 2000 09:15:22 -0500
Date: Wed, 22 Mar 2000 09:15:22 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

At 11:30 AM 3/21/00 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	Okay, so there's another of level indirection in here that I
>missed.  That is, Controller.getObject() may well return itself, but the
>Controller for a Device is the only object in the system which keeps a
>driver reference?)

So, there are two things going on here at the same time. As you point out,
we misses a step. Indirection -- between a user process and a low-level
device -- might be required because of class loaders and threads.

Both class and class loader are significant in casting and using the
instanceof operator. Carefullly consider the following snippet:

  public void example() {
    String s = "org.jos.device.Port";
    Object o = Factory.getObject( s );
    if ( !o instanceof Port ) {
      return;
    }
    Port p = (Port) o;
    :
  }

If two class loaders are involved, this snippet will never work. A user
process always has a custom class loader, so that classes used by a user
process can be garbage collected when a process dies. The device factory is
system-wide with its own custom class loader. A low-level device is
guaranteed *not* to be on the same class loader as a user process.

A user process always has its own thread, so that its bytecode can be
interpreted asynchronously from all other threads. The device factory is
part of the system process. A system process has its own thread. Each
device might need to have its own private thread for double-buffered I/O. A
high-level device runs off the user process thread.

A high-level device communicates with a low-level device through
inter-process communication (IPC). Inter-process communication is required
to break through the persistence barrier that makes all processes independent.

A low-level Port is created in a system process. The low-level device
manager must make sure that only one low-level Port at a time for each port
in hardware.

An IPC channel is opened between this object and a high-level Modem created
in a user process. A user process can do whatever it wants with the
low-level Port through an IPC channel.

In fact, the low-level port is a JVM-specific class. Any modem that uses a
port is not a JVM-specific class. Therefore, there must be at least two
packages for our JOS device project: decaf.device and org.jos.device

Starting with org.jos.device, we should build generic device drivers that
work with any distribution of JOS. Any JOS-specific application uses these
generic device drivers. We would have a Port interface, etc.

For the decaf virtual machine only, we would have decaf.device. A BCNI
factory for decaf would return an instance of GenericPort when asked for a
Port.

When any device needs to use a serial port, it uses a serial port. Any
device can use a serial port. Here is what a port and port listener might
look like:

// Port.java
package org.jos.device;
public interface Port {
  public int getID();
  public PortListener getListener();
  public void setListener( PortListener v );
  public void run();
  public void write( byte[] v );
  public void close();
}

// PortListener.java
package org.jos.device;
public interface PortListener {
  public void onRead( byte[] v );
  public void onClose();
}

Since a byte array passes easily through a persistence barrier, a generic
port can be used by all kinds of devices. This is must better than anything
I've seen from other operating systems. Here is my first attempt at a
generic port:

// GenericPort.java
package decaf.device;
public class GenericPort
    implements Port {
  GenericPort( int v ) {
    id = v;
  }
  public PortListener getListener() {
    return listener;
  }
  public void setListener( PortListener v ) {
    listener = v;
  }
  public void run() {
    synchronized( flag ) {
      flag = Flag.RUNNING;
    }

    for (;;) {
      synchronized( flag ) {
        if ( flag == Flag.CLOSED ) {
          break;
        }
      }

      for ( int i = 0; i < SIZE; i++ ) {
         int b = queue.read();
         if ( b < 0 ) {
           if ( i == 0 ) {
             Thread.yeild();
             break;
           }

           byte[] temp = new byte[ i ];
           System.arraycopy( buffer, 0, temp, 0, i );
           listener.onRead( temp );
           break;
         }

         buffer[ i ] = (byte) i;
      }
    }
  }
  public void write( byte[] v ) {
    int iMax = v.length;
    for ( int i = 0; i < iMax; i++ ) {
      queue.write( v[ i ] );
    }
  }
  public void close() {
    synchronized( flag ) {
      flag = Flag.CLOSED;
    }
  }
  private Flag flag = Flag.IDLE;
  private int id;
  private PortListener listener;
  private byte[] buffer = new byte[ SIZE ];
  private EventQueue queue;
}




From gchii@mindspring.com Wed, 22 Mar 2000 10:55:14 -0500
Date: Wed, 22 Mar 2000 10:55:14 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

At 11:01 AM 3/21/00 -0600, Matt.Albrecht@trilogy.com wrote:
>This means that now the device factory must handle the registration and
>allocation of *every* device.  Wouldn't it be easier, in that respect, to
>have the device schemes register themselves with "device:", then the
>individual schemes themselves handle the allocation?

A device factory is a smart factory, a factory that supports plug-ins. A
smart factory dispatches a request to individual plug-ins, called controllers.

A device factory corresponds to a major device: scheme. Each sub-scheme
must have its own controller. All of the URIs that start with device: are
dispatched to the device factory. In turn, the device factory dispatches a
request to each controller, until a controller returns an object (non-null)
or there are no more controllers.

This architecture is recursive. A device factory is a controller, too. It
plugs into the Smart API. The runtime configuration of the Smart API
becomes a tree of controllers.

Plug-in are added through custom configuration. The whole Smart API is
future-oriented. Any URI scheme imaginable can be plugged into the Smart
API if it implements the well-known Controller interface.

>In this respect, the individual scheme specifies several things:
>
>1. The class which is returned (which must be a subclass/interface of
>Device)

Exactly! Each scheme, controlled by a controller, specifies which class(es)
are returned by the scheme. The class: scheme always returns an instance of
java.lang.Class (or null).

class:java.awt.Button -> java.awt.Class

A schemes might return instances of more than one class. The object: scheme
returns an instance of *any* class:

object:java.awt.Button -> java.awt.Button

>2. If it's a limited resource, then a null may be returned if the resource
>has already been allocated.

Null is returned for any number of reasons, such as (1) a limited resource
that has reached its limit, (2) a non-sensical request (malformed URI), (3)
a controller is missing, or (4) an inappropriate request as determined by
security.

Imagine a scheme that allows up to five simultaneous TCP/IP connections.
When a program requests the sixth connection, null is returned instead.

The jdbc: scheme has been implemented in the Smart API. If you use a jdbc:
URI, you'll get an instance of java.sql.Connection (or null).

The Smart API is backward compatible. Imagine asking for a jdbc: connection
while using a virtual machine from Java 0 (JDK 1.02). Don't worry. The
Smart API does not crash. The controller for the jdbc: scheme cannot be
instantiated at all because the java.sql package is missing. Every jdbc:
request is denied because its controller is missing.

You can have anything you want. The device factory is a plug-in. It is
optional. Imagine you come to distrust the device: scheme entirely. You
can't get it to work in your environment. Simply re-configure the Smart API
to skip the device factory. Every device: request is denied because its
controller/factory is missing.

>But wouldn't it be "nicer" if, instead of returning null, it returns an
>error message describing what's wrong with the request, such as "out of
>bounds memory allocation", or "XYZ has already allocated that resource",
>and so on.

For BCNI and Smart API, no exception should be thrown by a controller or
factory. This has been a difficult architectural decision. In a multiple
stage factory, null can be returned much faster than an exception. Throwing
an exception complicates every Smart API interface. It complicates
interprocess communication.

A smart factory is optimistic. It uses the getObject() method exclusively.
It does not use acceptURI() to find a controller. From the first controller
installed to the last, a smart factory calls getObject() for each
controller until (1) an object is returned (non-null) or (2) there are no
more controllers.

>Also, how would one deallocate the resource?  Would this need to be
>specified in the finalize method of the resource's returned object?  What
>if the particular JVM that allocated this resource crashed, would the
>resource then be unavailable to everyone, requiring a reboot?  These
>questions aren't just limited to your particular implementation; they are
>serious things to consider for any system.

After a resource has been "opened" by the URI-based subsystem, we need a
corresponding way to "close" it. I expected that objects would implement a
close() method. The close() method cannot fail. This would be consistent
with work that has already been done on asynchronous I/O. (And a finalize()
method should invoke close().)

>Don't get me wrong.  This feels to me to be one of the best solutions to
>device allocation I've seen.

I agree. I like it for both political and technical merits. I like this as
a political solution because a loosely orgazized international group of
programmers can work in parallel on each sub-scheme and its corresponding
controller. It does not require centralized control over schemes,
controllers and their corresponding devices. It does not require a
standards body. It is a bazzaar, not a cathedral.

I like it as a technical solution because it is built to last. It has a
very long shelf life.

I like it because it is easy to develop. It is easy to build. We implement
something simple that works and build upon it. It is both backward
compatible and future-oriented. Any old scheme can expanded with new
features. Any new scheme can depend on existing ones.

I like it because it is flexible. The entire URI is a character array,
which easily passes through a persistence barrier. A URI is easy to store.
A URI is easy to enter at the keyboard. A URI is easy to pass from one
process to another.

>Some other things to consider.  How would a program discover which devices
>are available?  How would the admin then configure these devices so that
>they are setup correctly?  I.e. how would you tell
>"device:sound://localhost/1" to use DMA channel 1 instead of channel 3?
>Then again, how would you know that there aren't more than one sound card
>available on localhost?

Think about this: a search for URLs requires a search engine. It is not
feasible to ask the Internet for a list of all valid URLs. Likewise, a
local search engine would provide a human-readable list of matching device
URIs.

>Perhaps I'm looking at the problem in the wrong direction.  The URI here
>would be the way for the programs to allocate a resource.  Some other
>technique would be needed to discover the devices available, and possibly
>another to configure them (a bean resource would be very handy here).

I agree. We should be talking about two compatible mechanisms here. We need
a mechanism to discover and configure devices. We need another mechanism to
open an existing device.

>This may be a good place to add our diagnostic tools and configuration
>tools.  But how do we do this?  Do we add another scheme, such as
>"config:device:port:/ports/serial/1", or do we add it to the path:
>"device:port:/ports/serial/1/config"?  I dunno.

Yes! I like the idea of a config: scheme. There are always default
properties for a device. Default properties must be persistent. A config:
scheme interacts with a system-wide persisent data registry. To explain to
JOS that its IP address must be 5.5.5.120, you could ask for an IP
configuration object.

  public void example() {
    URI uri = "config:ip:";
    Configuration config = (Configuration) uri.getObject();
    config.setAddress( "5.5.5.120" );
  }

The IP configuration object must store its default properties somewhere.
That is what a system-wide registry and data registry interface is for.

  public void setAddress( String v ) {
    URI uri = "x-registry:system:/network/ip";
    PersistentRegistry r = (PersistentRegistry) uri.getObject();
    r.setString( "Address", v );
    r.close();
  }

When configuring a device through the config: scheme, such changes are
persistent. They will return even if you restart JOS.

Transient properties for a device are set through the device: scheme. These
properties are not persistent. They disappear as soon as you close a device.




From gchii@mindspring.com Wed, 22 Mar 2000 11:32:04 -0500
Date: Wed, 22 Mar 2000 11:32:04 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

At 07:29 PM 3/21/00 +0200, Al <Alexis Petrounias> wrote:
>Will the hardware crash or the software crash?

Yes. Just the other day, I was working on a laptop with a dial-up TCP/IP
connection. Suddenly, the system froze. There was no message. There was no
explanation. It just froze. I restarted the computer and was unable to get
re-connected. It took another person to point out that I had accidentally
unplugged the telephone cable while leaning on it with my elbow. I has
broken off the RJ-11 connector.

I want a new OS. I want a robust system that (1) does not freeze up when
the modem looses a connection, and (2) offers some explanation for why the
PPP connection went down. It should display a message such as "check your
telephone or modem cable", shouldn't it?

Both inside and outside the laboratory, there are a lot of things that can
and do go wrong. This is why modern languages use exception-style programming.

When you "crash" a car, part of it might be temporarily out of service.
When you "crash" a party, a few people attend without invitation. Something
has "crashed" when it no longer performs all of its intended function.
Every exception that's thrown is a crash in miniature.

The "crash" issue is different than the "automatic crash recovery" issue. A
keyboard "crashes" when it's unexpectedly unplugged. Typically, a non-USB
keyboard does not have automatic crash recovery. Plug it back in and it
still doesn't work.

A computer needs power. It "crashes" when its power cable is unexpectedly
unplugged.

A network interface card "crashes" when its network cable is unexpectedly
unplugged.

A mouse "crashes" when it's unexpectedly unplugged.

A modem or fax machine "crashes" when its telephone or serial cable or USB
cable is unexpectedly unplugged.

A printer or scanner "crashes" when its parallel cable or USB cable is
unexpectedly unplugged.

A classic virtual machine "crashes" when an Error is thrown. Look at the
following code:

  public void example() {
    throw new Error();
  }

A kernel "crashes" when it unexpectedly runs out of memory and has no
virtual memory manager. A kernel "crashes" when virtual memory unexpectedly
runs out of free disk space. A kernel "crashes" when a swap particition
unexpectedly becomes corrupt or lost by a physical defect in a hard drive.

When application software is defective, it can "crash" an application. When
system software is defective, it can "crash" a kernel.

I am sure that they crash because both hardware and software sometimes do
not perform their intended function. All these things have crashed in front
of me. And for most, it has happened more than once.




From gchii@mindspring.com Wed, 22 Mar 2000 11:46:40 -0500
Date: Wed, 22 Mar 2000 11:46:40 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

At 07:32 PM 3/21/00 +0200, Al <Alexis Petrounias> wrote:
>device:zipdrive:scsi://localhost/bus/scsi/6/attached
>
>and
>
>device:zipdrive:scsi//localhost/bus/scsi/6/attached/disk
>
>
>The first URI points to the Zip drive itself, the second to the disk
>*inside* the Zip drive.

Oh, I see where you might be going. You're looking for something like the
/dev subdirectory on Linux/UNIX. Would you like every device to have a node
in the file subsystem?

If so, the file: and in: schemes returns an instance of InputStream. The
out: scheme returns an instance of OutputStream. Today, all these URIs work
on virtual machines for Linux.

To open a floppy disk device:

file://localhost/dev/fd0
in:file:/dev/fd0
out:file:/dev/fd0

To open a hard drive device:

file://localhost/dev/hd0
in:file:/dev/hd0
out:file:/dev/hd0

To open a tty: device:

file://localhost/dev/tty0
in:file:/dev/tty0
out:file:/dev/tty0

The file: scheme is a major scheme. Experience has shown that host and port
should have been an optional part of the file: scheme. Both host and port
are optional for the in: and out: schemes. For example, use these URI to
open a file in the current directory:

in:file:example.txt -> java.lang.InputStream
out:file:example.txt -> java.lang.OutputStream




From tmiller@haverford.edu Wed, 22 Mar 2000 13:05:13 -0500 (EST)
Date: Wed, 22 Mar 2000 13:05:13 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Device as a digital resource

> In a Java standard class library, there is no read-only byte array. And
> yet, this is vital to the function of an operating system. A custom virtual
> machine, like decaf, could implement it by adding a read-only property to
> the byte array class.

	That's actually a really good idea.  I'll think about adding it to
mappedByteArray.

-_Quinn




From Matt.Albrecht@trilogy.com Wed, 22 Mar 2000 12:24:13 -0600
Date: Wed, 22 Mar 2000 12:24:13 -0600
From: Matt.Albrecht@trilogy.com Matt.Albrecht@trilogy.com
Subject: [JOS-Kernel] Device as a digital resource




Gilbert wrote:
>At 11:01 AM 3/21/00 -0600, Matt.Albrecht@trilogy.com wrote:
>>But wouldn't it be "nicer" if, instead of returning null, it returns an
>>error message describing what's wrong with the request, such as "out of
>>bounds memory allocation", or "XYZ has already allocated that resource",
>>and so on.
>
>For BCNI and Smart API, no exception should be thrown by a controller or
>factory. This has been a difficult architectural decision. In a multiple
>stage factory, null can be returned much faster than an exception.
Throwing
>an exception complicates every Smart API interface. It complicates
>interprocess communication.

Ok.  How about if we return a "container" object, which is an instance of
what needs to be returned, but actually contains an error message?

So, we could have, say, a RAM controller which is actually an error
wrapper.  If the user tried to access an area of memory in which they don't
have the security permissions, (say) a RamDeviceErrorController is
returned.  Any access to it's methods would either throw an exception, or
do nothing, or print to a log file, or any other countless possibilities.
This way, the programmer still will not be able to access the requested
device, but errors can still be found.

Perhaps there's another way?  If we re-do the URI structure, perhaps we
could do it in such a way that error messages can be stored internally:
     public void example()
     {
          URI uri = "ram:device://localhost/iobus?start=0x220&end=0x22f";
          RamDevice ram = (RamDevice) uri.getObject();
          if (ram == null)
          {
               System.err.println("Got an error:" + uri.getErrorMessage()
);
               return;
          }
          ...
     }


>>Also, how would one deallocate the resource?  Would this need to be
>>specified in the finalize method of the resource's returned object?  What
>>if the particular JVM that allocated this resource crashed, would the
>>resource then be unavailable to everyone, requiring a reboot?  These
>>questions aren't just limited to your particular implementation; they are
>>serious things to consider for any system.
>
>After a resource has been "opened" by the URI-based subsystem, we need a
>corresponding way to "close" it. I expected that objects would implement a
>close() method. The close() method cannot fail. This would be consistent
>with work that has already been done on asynchronous I/O. (And a finalize
()
>method should invoke close().)

But, if the JVM crashes (say, a kernel function core dumps), then the
finalize() never gets called.  That process which allocated the controller
is dead.  The only way around this is to make the controller a system
shared object, which may not be that far off if the system shared resource
created the controller.

Perhaps this is for a larger scope.  If a system shared object creates
another object, what memory space is that created object in?  From what
I've gleaned from learning about JVM GCing, every shared object needs to
have all its created objects in the same memory space.  But then, if the
controller creates objects specific for its current JVM process... What
kind of mess is this?








From tmiller@haverford.edu Wed, 22 Mar 2000 13:37:16 -0500 (EST)
Date: Wed, 22 Mar 2000 13:37:16 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Device as a digital resource

> For BCNI and Smart API, no exception should be thrown by a controller or
> factory. This has been a difficult architectural decision. In a multiple
> stage factory, null can be returned much faster than an exception. Throwing
> an exception complicates every Smart API interface. It complicates
> interprocess communication.

	It should be possible, on the other hand, to generate an
error: scheme that returns the error/exception/problem associated with a
particular URI; it would be entirely optional for each Controller to
recognize error: requests that correspond to URIs for which it has
responsibility.  The idea is similar to UNIX's errno.  e.g. you start at
the root of the tree with an "error:device:ram://?start=0&end=0x100" and
recursively look for a Controller willing to return an error about
device:ram -- presumably, the one which returns objects about device:ram.

> After a resource has been "opened" by the URI-based subsystem, we need a
> corresponding way to "close" it. I expected that objects would implement a
> close() method. The close() method cannot fail. This would be consistent
> with work that has already been done on asynchronous I/O. (And a finalize()
> method should invoke close().)

	OTOH, finalize() isn't, AFAIK, gauranteed to be called when an
object is garbage-collected, but the more paranoid factories may well
implement reference-counting in their returned objects.  (Device objects,
AFAIK, will never form cycles, so reference-counting should work
well.  This needs more thought, though.)

> >Don't get me wrong.  This feels to me to be one of the best solutions to
> >device allocation I've seen.

	Right on, and for the reasons GCHII gave.

-_Quinn




From Alexis Petrounias Wed, 22 Mar 2000 21:19:34 +0200
Date: Wed, 22 Mar 2000 21:19:34 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Gilbert Carl Herschberger II wrote:

> For non-shared RAM, an object has exclusive access to a block of RAM.
> If one object has already opened a block of ram, no other object can
> open the same block.

The system and the garbage collector will need to have access to it...
And what if a custom garbage collector is implemented? What if a
profiling utility is to be used? What if the user wants to allow
arbitrary memory access? He can do it with native code now, why not be
able to do it on JOS? How will security be implemented there? This is a
VERY important matter, and until the security mechanism of this scheme
is resolved and tested, arbitrary memory access should not be
implemented, not even for trusted code.

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From Alexis Petrounias Wed, 22 Mar 2000 21:26:05 +0200
Date: Wed, 22 Mar 2000 21:26:05 +0200
From: Al Alexis Petrounias
Subject: [JOS-Kernel] Device as a digital resource

Gilbert Carl Herschberger II wrote:

> Oh, I see where you might be going. You're looking for something like
> the /dev subdirectory on Linux/UNIX. Would you like every device to
> have a node in the file subsystem?

No, not at all. Actually, I hate the way Linux handles filesystems.
Files on a disk simply have nothing to do with devices. I can only think
of the filesystem as an extension to the device called "hard disk." I
cannot understand why /dev is a subdirectory! It is only a subdirectory
in a tree describing the computer hardware, *NOT* the filesystem!

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From gchii@mindspring.com Wed, 22 Mar 2000 15:18:53 -0500
Date: Wed, 22 Mar 2000 15:18:53 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Device as a digital resource

At 09:26 PM 3/22/00 +0200, Al <Alexis Petrounias> wrote:
>Gilbert Carl Herschberger II wrote:
>
>> Oh, I see where you might be going. You're looking for something like
>> the /dev subdirectory on Linux/UNIX. Would you like every device to
>> have a node in the file subsystem?
>
>No, not at all. Actually, I hate the way Linux handles filesystems.
>Files on a disk simply have nothing to do with devices. I can only think
>of the filesystem as an extension to the device called "hard disk." I
>cannot understand why /dev is a subdirectory! It is only a subdirectory
>in a tree describing the computer hardware, *NOT* the filesystem!

I am glad to hear this. Like you, I dislike the way Linux handles devices.
Why is /dev a subdirectory? Linux is working from a 30+ year old design.
The design was invented before the world wide web and the invention of a
scheme-based resource identifier. The Linux community is looking for a
solution. They are working on more dynamic /dev directory, so that devices
are assigned as needed. They won't be assigned only when the kernel is
compiled.

Just like all other operating systems, JOS has to break through this
paradox. A few devices, like RAM, must exist before a file subsystem. And
since a device, like VMM, might use the file subsystem, a file subsystem
must exist before most devices.

Resource-oriented thinking dominates the software industry today.
Everything's a resource in resource-oriented thinking. I believe the device
subsystem has greatest priority. A device subsystem is required. A file
subsystem is not. With a URI scheme, devices can use other devices; but,
they cannot use the file subsystem. After the device subsystem has been
created, the file subsystem is created using previously existing devices.

When blocks of data are read by the BIOS from a floppy, it is
resource-oriented. When blocks of data are read by GRUB from a hard drive,
it is resource-oriented. When blocks of data are read by Etherboot from a
BOOTP/TFTP service, it is resource-oriented. When package files are read by
a primordial class loader, it is resource-oriented. There is no OS file
subsystem yet.

File-oriented thinking dominated the software industry until 1996.
Everything's a file in file-oriented thinking. In classic architecture
prior to JOS, the operating system is in a rush to get to the file
subsystem as fast as it possibly can. In Linux, the file subsystem exists
first. It is compiled into the kernel. It exists before any devices. At
first, only a placeholder is used for a devices in the /dev directory.
Then, any device can use the file subsystem because it already exists.

Because the file subsystem needs devices to read files, additional devices
are plugged into the file subsystem as they become available. Nodes of the
file subsystem are mounted.

For Linux compatibility, a file subsystem might return a device as an I/O
stream from the /dev directory.




From tmiller@haverford.edu Wed, 22 Mar 2000 16:10:16 -0500 (EST)
Date: Wed, 22 Mar 2000 16:10:16 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] Device as a digital resource

> Perhaps this is for a larger scope.  If a system shared object creates
> another object, what memory space is that created object in?  From what
> I've gleaned from learning about JVM GCing, every shared object needs to
> have all its created objects in the same memory space.  But then, if the
> controller creates objects specific for its current JVM process... What
> kind of mess is this?

	To a GC, memory is a directed graph with (in our case) a single
source node.  There is no reason to distinguish between memory spaces with
addressing changes if the programmer can't arbitrarily access memory --
that is, they can only chase pointers created by the system.  The insight
that Java memory spaces are disjoint unless the parent process
deliberately maintains a pointer into its child is what underlies the
decaf process model.  The question of which memory space an object is in
isn't the question to ask -- it's which subset of the graph that object is
accessible from.  If a JVM crashes (suppose we can tell this), we re-trace
the tree from the root, excluding the pointer to that JVM -- anything that
doesn't match up is garbage, and all references into it (another graph
traversal) are illegal and need to marked/handled as such.  (e.g. IPC
references must be weak, because it's in the spec that they can throw
exceptions on access, whereas strong references can not.  (Actually, we
need a fourth class, IPC pointers, where they're treated in Java as weak
but by the GC as strong, so that we don't accidentally reap things people
are expecting to be persistent.)  I think that this model generates better
error handling in multi-process code.)

	What this means is that a shared object is pointed to from more
than one (potentially disjoing) subgraphs.  'Where' in memory the returned
object it produces is located depends entirely on whether or not the
producer maintains a reference to it; if it does, the return object is
located in the 'higher'/'larger' subgraph of the shared object.  That is,
if the consumer blows up and dies, the produced object is still 'live;' if
the producer doesn't maintain a reference, the object dies.  For the
former, the object or the parent ought to get an exception (on the next
access) noting that one of its parents has died; for the latter, the
produced object really needs to be finalize()d...  jJOS/decaf, can if,
necessary, (I think!) make /stronger/ conditions on finalize() than the
spec w/o contradicting it.

-_Quinn




From gchii@mindspring.com Wed, 22 Mar 2000 20:51:05 -0500
Date: Wed, 22 Mar 2000 20:51:05 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] About dd on Linux

The mkboot shell script uses the dd command twice:

dd if=stage1 of=/dev/fd0 bs=512 count=1
dd if=stage2 of=/dev/fd0 bs=512 seek=1

Please let me know if I understand the purpose of dd correctly. The block
size is 512 bytes because bs=512. Line 1 writes out exactly one block of
stage1. Line 2 skips ahead 1 block in /dev/fd0 and writes out the rest of
stage2.

Alternative 1.
Doesn't this do the same thing?

dd if=stage1 of=grub-boot bs=512 count=1
dd if=stage2 of=grub-boot bs=512 seek=1
cat grub-boot > /dev/fd0

Alternative 2.
If stage1 is exactly 512 bytes, doesn't this do the same thing?

cat stage1 + stage2 > /def/fd0

About JOS
We need an equivalent dd program in JOS, don't we? Imagine this:

dd if=http://www.jos.org/redist/mirror/stage1 of=/dev/fd0 bs=512 count=1
dd if=http://www.jos.org/redist/mirror/stage2 of=/def/fd0 bs=512 seek=1




From cmall@Holly.colostate.edu Wed, 22 Mar 2000 19:50:35 -0700
Date: Wed, 22 Mar 2000 19:50:35 -0700
From: KC cmall@Holly.colostate.edu
Subject: [JOS-Kernel] HAY I'm writing a report

Hay,
      I'm writing a report about JOS and I was wondering if any of you
could possibly tell me (or guess, I understand that the operating system

isn't complete yet but any information would be helpful) how you would
rate (on a scale of 1 to 10) JOS on three criteria?  I'm trying to
figure out how Java operating systems will compare to operating systems
now on the basis of efficiency (i.e. overall speed including efficient
resource allocation, efficient interrupt handling, and good response
time of various kernel and systems routines), security and protection
(for both the user and the operating system), and user convenience and
response time.  Thanks!

-KC






From tmiller@haverford.edu Thu, 23 Mar 2000 00:38:22 -0500 (EST)
Date: Thu, 23 Mar 2000 00:38:22 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Kernel] HAY I'm writing a report

	Efficiency is likely to be lower than most; security & protection
higher; user convenience very high, with response time about
average.  These are all the wildest of guesses.

-_Quinn




From jewel@pixie.co.za Thu, 23 Mar 2000 05:19:11 -0200 (GMT+2)
Date: Thu, 23 Mar 2000 05:19:11 -0200 (GMT+2)
From: jewel@pixie.co.za jewel@pixie.co.za
Subject: [JOS-Kernel] HAY I'm writing a report

> 	Efficiency is likely to be lower than most; security & protection
> higher; user convenience very high, with response time about
> average.  These are all the wildest of guesses.

Like Quinn says, it's impossible to predict. Performance can differ hugely
depending on the implementation and hardware support for certain java
features. 

With aggressively staticly or dynamically compiled code the user should
ultimately see little difference between a C++ GUI application running on
a traditional OS and a java app running on a Java OS. 

Security can potentially be much tighter due to VM and the ability to
sandbox applications. 

John





From Corrado.Santoro@IIT.UNICT.IT Thu, 23 Mar 2000 16:56:39 +0100
Date: Thu, 23 Mar 2000 16:56:39 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Kernel] About dd on Linux

On Thu, 23 Mar 2000, you wrote:
> The mkboot shell script uses the dd command twice:
> 
> dd if=stage1 of=/dev/fd0 bs=512 count=1
> dd if=stage2 of=/dev/fd0 bs=512 seek=1
> 
> Please let me know if I understand the purpose of dd correctly. The block
> size is 512 bytes because bs=512. Line 1 writes out exactly one block of
> stage1. Line 2 skips ahead 1 block in /dev/fd0 and writes out the rest of
> stage2.
> 
> Alternative 1.
> Doesn't this do the same thing?
> 
> dd if=stage1 of=grub-boot bs=512 count=1
> dd if=stage2 of=grub-boot bs=512 seek=1
> cat grub-boot > /dev/fd0
> 
> Alternative 2.
> If stage1 is exactly 512 bytes, doesn't this do the same thing?
> 
> cat stage1 + stage2 > /def/fd0
> 

Both the alternatives seem to be right. I'll try them....

-Corrado

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://osweb.iit.unict.it/ARCA
======================================================




From Matt.Albrecht@trilogy.com Thu, 23 Mar 2000 09:32:42 -0600
Date: Thu, 23 Mar 2000 09:32:42 -0600
From: Matt.Albrecht@trilogy.com Matt.Albrecht@trilogy.com
Subject: [JOS-Kernel] HAY I'm writing a report

KC,

Personally, I'm not sure if any of these points are valid.  And I have
(semi) logical reasons to back this statement up (all IMHO).

First of all, the current JOS stage is in developing the kernel and JVM.
We've just really broken ground on going into the actual architecture.  So
at this point there isn't much of an OS to speak of.

Since there isn't much of an OS, I feel that the project isn't as
interested in performance and usability, as it is with creating a new
paradigm shift in how people think and design OSs.  With Java as our base
language, we have an unparalleled basis for extensibility and object
design.  Unfortunately, we are needing to extend the ideas set forth in the
Java specifications, such as multiple processes support, and all its
related baggage.

Once a foundation has been established, then everything else can fall into
place.  Thus, I feel that with most of issues you bring forth (security,
protection, resource allocation, etc),  80% of that depends upon the design
framework we're developing now.

But that doesn't mean that we won't be interested in performance and
usability.

When one first hears that we're developing an OS built on Java, many people
assume that it will be too slow.  Especially since many OS kernels are
built in highly optimized native code.  But, since we need to host our Java
Operating System on a machine in order for the architecture to work, we'll
have native code underneath everything.  One of the primary goals of JOS is
to minimize that underlying native code, to make it as cross-platform
generic as possible.  So, in some cases we can move things from the Java
layer down to the native kernel layer.  But other optimization techniques
exist, such as pre-compiling the base OS Java code, and optimizing the Java
code itself.  All in all, I don't think that performance will be a problem
if enough time is spent.

For security, if we keep to the current Java model, but allow for
per-process selection of the security model, as well as system-wide
resource security including per-user level scrutiny, we should have a good
foundation for making UNIX level protection or better.

User convenience is based upon how well our tools are designed.  With a gui
and XML, we have the ability to do an excellent job supporting both the
UNIX / text lovers with the Windows / gui users.

"You too can help tomorrow become a better today!"
-Matt




                                                                                                                       
                    KC                                                                                                 
                    <cmall@Holly.colo        To:     kernel@jos.org                                                    
                    state.edu>               cc:                                                                       
                    Sent by:                 Subject:     [JOS-Kernel] HAY I'm writing a report                        
                    kernel-admin@jos.                                                                                  
                    org                                                                                                
                                                                                                                       
                                                                                                                       
                    03/22/2000 08:50                                                                                   
                    PM                                                                                                 
                    Please respond to                                                                                  
                    kernel                                                                                             
                                                                                                                       
                                                                                                                       



Hay,
      I'm writing a report about JOS and I was wondering if any of you
could possibly tell me (or guess, I understand that the operating system

isn't complete yet but any information would be helpful) how you would
rate (on a scale of 1 to 10) JOS on three criteria?  I'm trying to
figure out how Java operating systems will compare to operating systems
now on the basis of efficiency (i.e. overall speed including efficient
resource allocation, efficient interrupt handling, and good response
time of various kernel and systems routines), security and protection
(for both the user and the operating system), and user convenience and
response time.  Thanks!

-KC




_______________________________________________
Kernel maillist  -  Kernel@jos.org
http://jos.org/mailman/listinfo/kernel








From gchii@mindspring.com Thu, 23 Mar 2000 19:54:41 -0500
Date: Thu, 23 Mar 2000 19:54:41 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] HAY I'm writing a report

At 09:32 AM 3/23/00 -0600, Matt.Albrecht@trilogy.com wrote:
>First of all, the current JOS stage is in developing the kernel and JVM.
>We've just really broken ground on going into the actual architecture.  So
>at this point there isn't much of an OS to speak of.

Excellent point. It takes time to break new ground. Unlike the Linux
project, which fully immitated a well-known 30+ year old design for its
first 5 years, our operating system is all new. It has nothing to immitate.

>Since there isn't much of an OS, I feel that the project isn't as
>interested in performance and usability, as it is with creating a new
>paradigm shift in how people think and design OSs.

I feel the same way.

"Do it once." When you're doing something that has never been done before,
it doesn't matter so much how fast it is.

"Do it right." Once we have something to use, we will be increasingly
concerned about usability. We can address the usability of something that
doesn't exist yet.

"Do it again." And then comes speed. Once we have something that's easy to
use, we will be increasingly concerned about efficiency. As more people use
the operating system (and operating systems like it), optimization of the
underlying operating system will have the greatest impact on a
bytecode-based architecture. A little tweak of one function in a virtual
machine might have huge impact on all applications across the board.
Because JOS is meant to be portable, that optimization will be available
across many platforms.

Much of the architecture is volatile at this point, and should be. We are
doing research. We want to find out how many options we have. We want to
pick the option that seems to be the most promising. As real code is
written and used, the architecture will stablize.

I feel that the project has set its priorities around choice, flexibility
and reliability. I want a new OS because my old one offers me no choice. I
want a new OS because my old one is as flexible as, well, concrete. I want
a new OS because my old one crashes two or three times each day, always at
the worst possible moment.

If we have choice, flexibility and reliability, all these other things will
follow. Choice must be reflected throughout the design of an operating
system. Instead of switching from one operating system to another, JOS will
let you plug-in the subsystem that's right for you. While one person might
be willing to risk a system crash and plug-in a super-fast file subsystem,
another might be more conservative and plug-in a slightly slower file
subsystem that almost never crashes. Either way, you don't have to leave
JOS to get what you want.

When it comes to the visual impact of the operating system, JOS is like no
other. While one person might enjoy a shell, browser or desktop that looks
like the operating system they grew up with, another might enjoy the new
universal browser. Either way, you don't have to leave JOS to get what you
want.

This is a research project. We are learning skills by one of the greatest
challenges known to a technician: building an operating system. It is the
most difficult work because most of the work an operating system will do is
unknown and unknowable by the people who build it. An operating system
determines what is easy and what is difficult for other programmers to build.

The product of research is knowledge. What is the worst case scenario? The
worst case imaginable is that nobody learns to appreciate JOS -- except me.
Oh, well. I will have met more interesting people across the globe than
otherwise. I will have more strength in programming, writing, design and
architecture than otherwise. I will have learned more about the strengths
and weaknesses of Java than otherwise. I will have taught myself more about
putting a complete system together than otherwise.

What is the best case scenario? JOS is slow and everybody knows it. Then,
people from across the globe begin to contribute their choice of
optimization. At first, the optimizations trickle in. And then it's a
flood. Everybody celebrates as the most flexible and reliable operating
system becomes the fastest operating system. Look at all the Java
applications it will run!

The opposite has been done. It has been done repeatedly. A stupid operating
system (SOS) is really fast but offers you no choice, no flexibility and no
reliability. I don't want that, do you?




From gchii@mindspring.com Fri, 24 Mar 2000 08:03:00 -0500
Date: Fri, 24 Mar 2000 08:03:00 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] HAY I'm writing a report

At 09:32 AM 3/23/00 -0600, Matt.Albrecht@trilogy.com wrote:
>First of all, the current JOS stage is in developing the kernel and JVM.
>We've just really broken ground on going into the actual architecture.  So
>at this point there isn't much of an OS to speak of.

Excellent point. It takes time to break new ground. Unlike the Linux
project, which fully immitated a well-known 30+ year old design for its
first 5 years, our operating system is all new. It has nothing to immitate.

>Since there isn't much of an OS, I feel that the project isn't as
>interested in performance and usability, as it is with creating a new
>paradigm shift in how people think and design OSs.

I feel the same way.

"Do it once." When you're doing something that has never been done before,
it doesn't matter so much how fast it is.

"Do it right." Once we have something to use, we will be increasingly
concerned about usability. We can address the usability of something that
doesn't exist yet.

"Do it again." And then comes speed. Once we have something that's easy to
use, we will be increasingly concerned about efficiency. As more people use
the operating system (and operating systems like it), optimization of the
underlying operating system will have the greatest impact on a
bytecode-based architecture. A little tweak of one function in a virtual
machine might have huge impact on all applications across the board.
Because JOS is meant to be portable, that optimization will be available
across many platforms.

Much of the architecture is volatile at this point, and should be. We are
doing research. We want to find out how many options we have. We want to
pick the option that seems to be the most promising. As real code is
written and used, the architecture will stablize.

I feel that the project has set its priorities around choice, flexibility
and reliability. I want a new OS because my old one offers me no choice. I
want a new OS because my old one is as flexible as, well, concrete. I want
a new OS because my old one crashes two or three times each day, always at
the worst possible moment.

If we have choice, flexibility and reliability, all these other things will
follow. Choice must be reflected throughout the design of an operating
system. Instead of switching from one operating system to another, JOS will
let you plug-in the subsystem that's right for you. While one person might
be willing to risk a system crash and plug-in a super-fast file subsystem,
another might be more conservative and plug-in a slightly slower file
subsystem that almost never crashes. Either way, you don't have to leave
JOS to get what you want.

When it comes to the visual impact of the operating system, JOS is like no
other. While one person might enjoy a shell, browser or desktop that looks
like the operating system they grew up with, another might enjoy the new
universal browser. Either way, you don't have to leave JOS to get what you
want.

This is a research project. We are learning skills by one of the greatest
challenges known to a technician: building an operating system. It is the
most difficult work because most of the work an operating system will do is
unknown and unknowable by the people who build it. An operating system
determines what is easy and what is difficult for other programmers to build.

The product of research is knowledge. What is the worst case scenario? The
worst case imaginable is that nobody learns to appreciate JOS -- except me.
Oh, well. I will have met more interesting people across the globe than
otherwise. I will have more strength in programming, writing, design and
architecture than otherwise. I will have learned more about the strengths
and weaknesses of Java than otherwise. I will have taught myself more about
putting a complete system together than otherwise.

What is the best case scenario? JOS is slow and everybody knows it. Then,
people from across the globe begin to contribute their choice of
optimization. At first, the optimizations trickle in. And then it's a
flood. Everybody celebrates as the most flexible and reliable operating
system becomes the fastest operating system. Look at all the Java
applications it will run!

The opposite has been done. It has been done repeatedly. A stupid operating
system (SOS) is really fast but offers you no choice, no flexibility and no
reliability. I don't want that, do you?




From gchii@mindspring.com Fri, 24 Mar 2000 08:34:05 -0500
Date: Fri, 24 Mar 2000 08:34:05 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] About dd on Linux

At 04:56 PM 3/23/00 +0100, Corrado Santoro <Corrado.Santoro@IIT.UNICT.IT>
wrote:
>Both the alternatives seem to be right. I'll try them....

Thanks! I look forward to your reply.




From cmall@Holly.colostate.edu Fri, 24 Mar 2000 13:38:43 -0700
Date: Fri, 24 Mar 2000 13:38:43 -0700
From: KC cmall@Holly.colostate.edu
Subject: [JOS-Kernel] Thank you

Hay,
      Thanks to everyone that responded to my e-mail and helped with my
report!  You were a huge help, I can't thank you enough, and I wish I
could repay you (all I have to offer is the final draft of my report
when it's done but it's not the best).  Thanks again, bye!

-KC




From gchii@mindspring.com Sun, 26 Mar 2000 10:41:22 -0500
Date: Sun, 26 Mar 2000 10:41:22 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Kernel] Common Server Interface (CSI)

Lomna Losgann wrote Common Server Interface (CSI) and Amairgin HTTPd. I was
unable to find an e-mail address or website within the source code.

The original CSI source was written into a package called "CSI" and used by
Amairgin HTTPd. Later, it was uploaded to Source Server. But it was
inserted into "org.jos.experimental".

So that CSI and Amairgin HTTPd might be recompiled, I modified the source
code to match each package with its Source Server directory. The modified
source code has been published here:

<URL:http://www.jos.org/redist/csi-0.4/>
<URL:http://www.jos.org/redist/amairgin-0.10/>




From iainshigeoka@yahoo.com Tue, 7 Mar 2000 10:10:35 -0600
Date: Tue, 7 Mar 2000 10:10:35 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Kernel] CVS

On 7 Mar 00, at 20:41, Hilary Cheng wrote:

>     Could we use sourceforge instead of current CVS Jos one ? Since
> it seems that JOS one is not so stable.

We are going to do so soon.  Because of the massive re-org of the 
code during the rewrites, I think we had decided to hold off until the 
sources stabilize a bit.  Then check in the code "fresh" and start 
with a clean cvs tree.  

If the code is at that point now, let me know. I've already got the jos 
project opened at SourceForge and basically just need to add the 
core developers to the developers list for the project so they can 
start commiting files to cvs.

I think we'll be keeping the list of core developers very small.  
SourceForge has a nice feature which allows other developers to 
submit patches to a Patch Manager where the core developers can 
review patches, and commit them to the main cvs source 
repository.  So many can contribute, but the chaos is kept to a 
minimum.

-iain





From bill@xenom.dhs.org Fri, 17 Mar 2000 12:56:55 -0500 (EST)
Date: Fri, 17 Mar 2000 12:56:55 -0500 (EST)
From: Derek N. bill@xenom.dhs.org
Subject: [JOS-Kernel] Thanks Guys

Thanks a bunch for answering my wuestions guys. My JOS machine is all set
up and I'm gonna start contributing to the Kernel Dev Crew soon.

Bye.
Derek.






