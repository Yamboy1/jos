From gchii@mindspring.com Sat, 31 Jul 1999 16:34:46 -0400
Date: Sat, 31 Jul 1999 16:34:46 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] SmartAPI - Release 1b

See the SmartAPIPages on Wiki.

This release of SmartAPI provides the very first release of a plain text
browser. The plain text browser provides a command line for the smart
object factory.

- The URI class has acceptURI() and getObject(). This makes it possible to
do this: CustomClass t = (CustomClass) new URI( s ).getObject();

- A working version of RegistryIterator. It shows great potential.
- PlainTextBrowser uses RegistryIterator to browse registries.

The PlainTextBrowser is a registry browser, because the smart object
factory can create registries. If we can start with a registry browser, we
can build the registry browser into a registry editor. So, how do you read
a list of keys and types from a registry iterator and dynamically create a
"property editor"? Any volunteers?

The StringRegistry implementation makes browsing easy because it converts
most types of data to a string. We could start with a StringRegistryEditor.
When you click on a key or value, the string-type property editor should
become visible.

What about saving? Some URIs have no output stream. In this case, File |
Save As.. could select another URI for saving changes.




From digigod@earthling.net Sat, 31 Jul 1999 16:43:34 -0700
Date: Sat, 31 Jul 1999 16:43:34 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

JOS needs a GSI (or something similiar) to be truly flexible, but what
goes into it?

I think we could have two abstract classes, a ScriptLoader class that
acts like a ClassLoader, except it creates Script objects.

ScriptLoader would be given the data and it would parse the script or
load the bytecode (or decide which to do in some cases) Im guessing
parsing would be handled sepreatley, but thats up to the implementation.
the Script would be an abstract super class encapsulating the Script, it
would probably have an abstract method interpret() or someting like it.

most Scripting languages let you create language elements in the host
language, here we would have an interface Scriptable with the method
ScriptInfo getScriptInfo(), ScriptInfo would be just like BeanInfo, it
would be up to the language how to handle these of course.

this is just a basic outline of what we need, I think we should work on
this. what else do we need? how would we do it? how have others done it? 

we need to make it as flexible as possible, allowing scripts to be run
as applications and in applications in a standard way so they dont even
have to be aware of the language being used. we also need to make it
easy to make proxy support for all the scripting languages that already
have Java libraries
(http://grunge.cs.tu-berlin.de/~tolk/vmlanguages.html). it should handle
interpreted and compiled scripts the same.

any thoughts?

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From al@outworld.org Sun, 01 Aug 1999 10:49:51 +0300
Date: Sun, 01 Aug 1999 10:49:51 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

DigiGod Q Frasché wrote:

> I think we could have two abstract classes, a ScriptLoader class that
> acts like a ClassLoader, except it creates Script objects.


We can follow the general idea behind the ClassLoader, and have
something like this:


ScriptClassLoader
ScriptClass
ScriptMethod
ScriptField
ScriptConstructor
...

It could be in: [org.jos.lang.ref.script.*] or something...

> what else do we need? how would we do it? how have others done it?

JavaScript 1.2 seems to be able to create and access almost anything
inside Netscape... Why don't we follow their API? (I mean - copy their
API to reflect on Java and JOS specifically).

> compiled scripts the same.

Could you please elaborate on this? Thanks!


-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From digigod@earthling.net Sun, 01 Aug 1999 05:24:57 -0700
Date: Sun, 01 Aug 1999 05:24:57 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

Al wrote:
> We can follow the general idea behind the ClassLoader, and have
> something like this:
> 
> ScriptClassLoader
> ScriptClass
> ScriptMethod
> ScriptField
> ScriptConstructor

the problem with this is that it would assume a OO script, and
ScriptClassLoader makes me think your making a ClassLoader that creates
a Java class from a script, and I rarely use OO scripting languages

> It could be in: [org.jos.lang.ref.script.*] or something...

org.jos.gsi or org.jos.script seems more natural
 
> JavaScript 1.2 seems to be able to create and access almost anything
> inside Netscape... Why don't we follow their API? (I mean - copy their
> API to reflect on Java and JOS specifically).

like a DOM but for the OS? 
 
> Could you please elaborate on this? Thanks!

I mean that there are two types of scripts, those that are text (the
script is run from source) and those that are binary (the script is
compiled into a language-specific bytecode) and some that are both (id
est, LUA can be run both from the script or the compiled form).

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From al@outworld.org Sun, 01 Aug 1999 15:30:27 +0300
Date: Sun, 01 Aug 1999 15:30:27 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

DigiGod Q Frasché wrote:

> Al wrote:
> > We can follow the general idea behind the ClassLoader, and have
> > something like this:
> >
> > ScriptClassLoader
> > ScriptClass
> > ScriptMethod
> > ScriptField
> > ScriptConstructor
> 
> the problem with this is that it would assume a OO script, and
> ScriptClassLoader makes me think your making a ClassLoader that
> creates a Java class from a script, and I rarely use OO scripting
> languages

Well, the script can be contained inside a Script object, and if it is
*not* OO, then the default Method would simply be "invoke()" or
"execute()" or "run()" or something. But it would be nice to encapsulate
scripts, even if they don't know what an Object is.

> > JavaScript 1.2 seems to be able to create and access almost anything
> > inside Netscape... Why don't we follow their API? (I mean - copy
> > their API to reflect on Java and JOS specifically).
> 
> like a DOM but for the OS?

Yup.

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From digigod@earthling.net Sun, 01 Aug 1999 05:43:27 -0700
Date: Sun, 01 Aug 1999 05:43:27 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

Al wrote:
> Well, the script can be contained inside a Script object, and if it is
> *not* OO, then the default Method would simply be "invoke()" or
> "execute()" or "run()" or something. But it would be nice to encapsulate
> scripts, even if they don't know what an Object is.

ScriptLoader
Script
Script.Object --points to anything in a script, a variable, a class, a
function, whatever... can contain other Script.Object's

these names are less assuming, I also think this design is more generic
(but thats the goal)

Script.Object could just be a regualr inner class, but if we decide you
should be able to make them without Script's "approval" we can make it
toplevel (if you make an inner class "static" it beomces a top-level
inner class, you can create it like any other class: var = new
Script.Object();)
 
> Yup.

I suggested this earlier (old mailing lists even, I think). its a good
idea.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From whooops@gmx.de Sun, 01 Aug 1999 16:22:29 +0000
Date: Sun, 01 Aug 1999 16:22:29 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

DigiGod Q Frasché wrote:

> > JavaScript 1.2 seems to be able to create and access almost anything
> > inside Netscape... Why don't we follow their API? (I mean - copy their
> > API to reflect on Java and JOS specifically).
> 
> like a DOM but for the OS?

Actually the Java-JavaScript interaction is done by LiveConnect
('http://developer.netscape.com/docs/manuals/communicator/jsguide4/livecon.htm'),
which is implemented in Mozillas pure Java JavaScript 1.4 engine Rhino
('http://www.mozilla.org/rhino'). Using it you can directly script Java, much
like BeanShell.
DOM? You're trying to reinvent the registry.

Regards, Mark



From digigod@earthling.net Sun, 01 Aug 1999 07:19:09 -0700
Date: Sun, 01 Aug 1999 07:19:09 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

Mark Andreas Meyer wrote:
> Actually the Java-JavaScript interaction is done by LiveConnect
> ('http://developer.netscape.com/docs/manuals/communicator/jsguide4/livecon.htm'),
> which is implemented in Mozillas pure Java JavaScript 1.4 engine Rhino
> ('http://www.mozilla.org/rhino'). Using it you can directly script Java, much
> like BeanShell.
> DOM? You're trying to reinvent the registry.

ok so we make a generic LiveConnect (OpenConnect?) type infrastructure
for those scripting langs that support it (it should be able to throw an
UnsupportedOperationException rather than create a Script.Object
reflection, um, thing). REBOL doesnt allow communication with another
language, for example, so it should just have Script.execute() no
getObject(String name) (or whatever).

by DOM I only meant a way of accessing all the elements like in
LiveConnect, I dont understand how thats reinventing the registry
(which, as long as were talking about it, should be accessible by a
script; assuming proper access)

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Sun, 01 Aug 1999 08:12:08 -0700
Date: Sun, 01 Aug 1999 08:12:08 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI

I created a GenericScriptingInterface page on Wiki, check it out. 

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From whooops@gmx.de Sun, 01 Aug 1999 17:53:03 +0000
Date: Sun, 01 Aug 1999 17:53:03 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] GSI (GenericScriptingInterface)

DigiGod Q Frasché wrote:

> ok so we make a generic LiveConnect (OpenConnect?) type infrastructure
> for those scripting langs that support it (it should be able to throw an
> UnsupportedOperationException rather than create a Script.Object
> reflection, um, thing). REBOL doesnt allow communication with another
> language, for example, so it should just have Script.execute() no
> getObject(String name) (or whatever).
> 
> by DOM I only meant a way of accessing all the elements like in
> LiveConnect, I dont understand how thats reinventing the registry
> (which, as long as were talking about it, should be accessible by a
> script; assuming proper access)

Well, that's somewhat complicated, e.g. JavaScript is able to extend Java
classes. IMO the best solution is to translate the script into bytecode and
let the result class implement a Script interface, by that you can access
fields, etc. and that throws 'UnsupportedEcxeption's. For execution simply
instantiate the result class.
... the Script impl could be a proxy to an interpreter.

Regards, Mark



From gchii@mindspring.com Sun, 01 Aug 1999 20:55:02 -0400
Date: Sun, 01 Aug 1999 20:55:02 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Fourth Generation

When we build JOS on top of Java, we are building a very high-level third
generation system. It is fully object-oriented. It is powerful. But, it is
still third generation because it uses the lines-of-code model to build
programs. It is still third generation because it uses a separate step to
compile bytecode.

Sure, we need more third generation compilers. We need javac-like tools to
build bytecode from many programming languages. This is not "generic
scripting".

Generic scripting is supposed to be interpreted. That's the point. A
generic scripting interface should support all kinds of interpreters. These
interpreters do not need a separate step to compile bytecode. Many
scripting languages use a plain-text file as a container for statements.
Like Linux, the first "statment" in a source code file should be the name
(alias) of its interpreter.

On the other hand, we can build a mid-level fourth generation system by
combining the bean property inspector, registry-based persistence, and a
generic scripting interface. A bean property inspector allows a interaction
between an end-user and their component configuration. Registry-base
persistence makes it possible to swap compatible components in a very
flexible manner. The generic scripting interface should not be another
version of Java.

A mid-level fourth generation language provide mechanisms for configuring
visual and non-visual components. It provides a non-programming view of an
application. Configuration is non-sequential. Designing visual components
is non-sequential.

For a sequential "procedure", a fourth generation language must provide
fill-out-a-form approach. Each "statement" in a program is a registry node.
There are zero or more "parameters" to each statement, or properties of a
node.

A cousin of the registry editor lets you paste together your own
"procedures". This is pre-programmed with one form for each method. That's
a lot of forms, right? Using a bean property inspector, each form is
generated on-the-fly. The forms are not stored as bytecode. They are stored
as registry nodes inside a large registry.

One of the problems with fourth generation languages is the problem of too
many user-defined types. In order to fully support a fourth generation
language, the mechanism must embrace all user-defined types. Additional
forms are added as a "procedure" has "parameters".

How does JOS support user-defined types? A user-defined type can be passed
as a parameter to a procedure by URI. You type in the stringified name of a
digital resource. The SmartAPI makes it easy to pass any object to a
procedure by reference. That's why the SmartAPI and registry are important
to me.

This is a big opportunity for the JOS community. Only a few have ventured
this far into the fourth generation. When we write JOS tools in a fourth
generation "language", it only takes a few people to write the whole OS.




From gchii@mindspring.com Sun, 01 Aug 1999 21:22:54 -0400
Date: Sun, 01 Aug 1999 21:22:54 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] java.net.URL and file:

java.net.URL doesn't match RFC2396. The colon (:) is reserved and the
backslash (\) is unwise.

When I use the file: protocol on Windows 95, java.net.URL does not work
with a platform-independent name. It doesn't handle any escaped characters
(like %3a). While "file:/C|/windows/win.ini" does not work,
"file:/C:\windows\win.ini" does!

"file:/C|/windows/win.ini" is a valid URL, right? Try it. It doesn't work.
Besides, it doesn't throw a java.net.MalformedURLException either.

"mailto:gchii@mindspring.com?subject=JOS" is a valid URL, right? I haven't
been able to get it to work.

java.net.URL throws a MalformedURLException whenever I use an applet:
protocol. Isn't "applet:org.jos.demo.DemoApplet?option=1" a valid URL? It
should be.

How do you add new protocols to java.net.URL? Is there documentation on this?

I found a java.net.URLEncoder class. It has a method to encode a URL; but,
no method to decode one. It highlights both the encoding of spaces to plus
(+) and the escaping of illegal characters.




From digigod@earthling.net Sun, 01 Aug 1999 18:26:15 -0700
Date: Sun, 01 Aug 1999 18:26:15 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Fourth Generation

Gilbert Carl Herschberger II wrote:
> Sure, we need more third generation compilers. We need javac-like tools to
> build bytecode from many programming languages. This is not "generic
> scripting".

thats not what I said...
 
> Generic scripting is supposed to be interpreted. That's the point. A
> generic scripting interface should support all kinds of interpreters. These
> interpreters do not need a separate step to compile bytecode. Many
> scripting languages use a plain-text file as a container for statements.
> Like Linux, the first "statment" in a source code file should be the name
> (alias) of its interpreter.

exactly, but some scripting languages compile to bytecode to (not Java
bytecodes), some require it be like this some can run text script or
binary code, thats not up to us. its up to the person making the
interpreter.

you do bring up the question of how scripts know what interprter to use,
MIME is the best solution I can think of

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Sun, 01 Aug 1999 18:29:50 -0700
Date: Sun, 01 Aug 1999 18:29:50 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] java.net.URL and file:

Gilbert Carl Herschberger II wrote:
> java.net.URL doesn't match RFC2396. The colon (:) is reserved and the
> backslash (\) is unwise.
> 
> When I use the file: protocol on Windows 95, java.net.URL does not work
> with a platform-independent name. It doesn't handle any escaped characters
> (like %3a). While "file:/C|/windows/win.ini" does not work,
> "file:/C:\windows\win.ini" does!
> 
> "file:/C|/windows/win.ini" is a valid URL, right? Try it. It doesn't work.
> Besides, it doesn't throw a java.net.MalformedURLException either.

its not malformed, it should throw a UnknownURLException...
 
> "mailto:gchii@mindspring.com?subject=JOS" is a valid URL, right? I haven't
> been able to get it to work.
> 
> java.net.URL throws a MalformedURLException whenever I use an applet:
> protocol. Isn't "applet:org.jos.demo.DemoApplet?option=1" a valid URL? It
> should be.

as far as I know its valid
 
> How do you add new protocols to java.net.URL? Is there documentation on this?

I think you need to subclass URLConnection, HotJava does it; its a place
to start anyway...
 
> I found a java.net.URLEncoder class. It has a method to encode a URL; but,
> no method to decode one. It highlights both the encoding of spaces to plus
> (+) and the escaping of illegal characters.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From al@outworld.org Tue, 03 Aug 1999 00:29:11 +0300
Date: Tue, 03 Aug 1999 00:29:11 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] JavaScript in Java

How about Rhino from Mozilla?

http://www.mozilla.org/js/rhino/

Their API can control things in the local environment, that is, the
browser. What if the local environment was JOS?


-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From digigod@earthling.net Mon, 02 Aug 1999 17:22:54 -0700
Date: Mon, 02 Aug 1999 17:22:54 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] JavaScript in Java

Al wrote:
> How about Rhino from Mozilla?
> 
> http://www.mozilla.org/js/rhino/
> 
> Their API can control things in the local environment, that is, the
> browser. What if the local environment was JOS?

familiar with rhino (downloaded it but havent looked at it yet), but I
want more then just JavaScript; I want any scripting language to run in
JOS. a GSI wrapper of Rhino would probably the first thing after we get
a design down...

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From whooops@gmx.de Tue, 03 Aug 1999 02:57:26 +0000
Date: Tue, 03 Aug 1999 02:57:26 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] JavaScript in Java

Hi.
How does Microsoft handle this issue in their Scripting Host? If it's a good
concept let's steal it ;)

Regards, Mark



From hilarycheng@usa.net Tue, 3 Aug 1999 09:58:55 +0800
Date: Tue, 3 Aug 1999 09:58:55 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Arch] JavaScript in Java

Hi,

except Rhino, there are several scripts language that Implements in Java.
We can gather each Scripts Language Pros and Cons. So we can create a
Generic One For All
Scripts.

1. Rhino
2. Fesi -- http://home.worldcom.ch/~jmlugrin/fesi/index.html
3. WebL --
http://www.research.digital.com/SRC/personal/Krishna_Bharat/WebArcheology/We
bL.html
4. JPhyton

Regards,

Hilary




>Al wrote:
>> How about Rhino from Mozilla?
>>
>> http://www.mozilla.org/js/rhino/
>>
>> Their API can control things in the local environment, that is, the
>> browser. What if the local environment was JOS?
>
>familiar with rhino (downloaded it but havent looked at it yet), but I
>want more then just JavaScript; I want any scripting language to run in
>JOS. a GSI wrapper of Rhino would probably the first thing after we get
>a design down...
>
>Cheers,
>DigiGod
>_________________________
>DigiGod@earthling.net
>AIM:DigiGod 86
>_________________________
>Quote of the Moment:
>        No, I'm Canadian. It's like an American, but without a
>        gun.
>              -Dave Foley
>_________________________
>Prank of the Moment:
> Using the conferencing feature of your office phone, dial
> one Induhvidual, then while it's ringing dial another and
> conference them together. Put your own phone on mute
> and listen to see how long they'll make small talk before
> figuring out that neither one placed the call.
>O-
>
>_______________________________________________
>Arch maillist  -  Arch@jos.org
>http://jos.org/mailman/listinfo/arch
>




From al@outworld.org Tue, 03 Aug 1999 13:11:37 +0300
Date: Tue, 03 Aug 1999 13:11:37 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] JavaScript in Java

Mark Andreas Meyer wrote:

> How does Microsoft handle this issue in their Scripting Host? If it's
> a good concept let's steal it ;)

Microsoft can't possibly have a good concept. If it is any good, we
should steal it from where they stole it too, it won't contain any hype
that way...


Although being able to run all scripting languages is useful, I strongly
believe that we should include a higher, more standard language such as
JavaScript to be part of the actual integrated system.

For example, shell scripts on Linux handle a few things, .INF files on
Windows handle a few things, well, we can also have .JS files in JOS
handle a few things.

Or maybe if we can tweak the Script Context and extend it like this:

org.jos.scripting.Context
|
+ - - org.jos.scripting.js.JSContext
+ - - org.jos.scripting.python.PContext;
+ - - prg.jos.scripting.tcl.TCLContext;
+ - - ...




-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From digigod@earthling.net Tue, 03 Aug 1999 06:52:39 -0700
Date: Tue, 03 Aug 1999 06:52:39 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] JavaScript in Java

Al wrote:
> Although being able to run all scripting languages is useful, I strongly
> believe that we should include a higher, more standard language such as
> JavaScript to be part of the actual integrated system.
> 
> For example, shell scripts on Linux handle a few things, .INF files on
> Windows handle a few things, well, we can also have .JS files in JOS
> handle a few things.
> 
> Or maybe if we can tweak the Script Context and extend it like this:
> 
> org.jos.scripting.Context
> |
> + - - org.jos.scripting.js.JSContext
> + - - org.jos.scripting.python.PContext;
> + - - prg.jos.scripting.tcl.TCLContext;
> + - - ...

definitley, we should include the big ones (or just javascript and let
them "install on demand" the rest as they go")

but in the scheme I have going it would be more like:

org.jos.gsi
 |
 +-org.jos.gsi.javscript.ECMAScript
 |
 +-org.jos.gsi.python.PythonScript
 |
 +-org.jos.gsi.tcl.TCLScript

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From whooops@gmx.de Tue, 03 Aug 1999 16:24:42 +0000
Date: Tue, 03 Aug 1999 16:24:42 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] JavaScript in Java

Al wrote:

> Although being able to run all scripting languages is useful, I strongly
> believe that we should include a higher, more standard language such as
> JavaScript to be part of the actual integrated system.
> 
> For example, shell scripts on Linux handle a few things, .INF files on
> Windows handle a few things, well, we can also have .JS files in JOS
> handle a few things.

Configuration is done by the registry.

Regards, Mark



From digigod@earthling.net Tue, 03 Aug 1999 07:01:33 -0700
Date: Tue, 03 Aug 1999 07:01:33 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] JavaScript in Java

Mark Andreas Meyer wrote:
> Configuration is done by the registry.

we should have a GSI->Registry thing so you can build a registry from a
script (which in some cases could be handy)

one of the purposes of LUA, for example, is to make dynamic
user-editable configuration. one of the neat things about this is in
langs with functions as first class variables a Registry could contain
functions as entries in the form of a Script.Element...

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From al@outworld.org Tue, 03 Aug 1999 17:18:33 +0300
Date: Tue, 03 Aug 1999 17:18:33 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] JavaScript in Java

Mark Andreas Meyer wrote:

> Configuration is done by the registry.

Of course, and the set of commands issued to the registry we call a
script, right?


-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From whooops@gmx.de Tue, 03 Aug 1999 17:06:42 +0000
Date: Tue, 03 Aug 1999 17:06:42 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] JavaScript in Java

Hi.

Please define what a GSI is good for and what it will do. I don't think that
GSI should go beyond a way to invoke an interpreter and a registry for these
interpreters. Everything else should be over to the implementation.

Regards, Mark.



From digigod@earthling.net Tue, 03 Aug 1999 07:45:39 -0700
Date: Tue, 03 Aug 1999 07:45:39 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] JavaScript in Java

Mark Andreas Meyer wrote:
> Please define what a GSI is good for and what it will do. I don't think that
> GSI should go beyond a way to invoke an interpreter and a registry for these
> interpreters. Everything else should be over to the implementation.

Everything should be in the implementation. GSI defines a generic way to
encapsulate it. the abstract ScriptLoader class uses the registry in its
static factory method to find the appropriate ScriptLoader for the
scripting language (org.jos.gsi.lua.LUAScriptLoader) and call its
abstract loadScript method which returns a Script (cast from the
language implementation, following the previous example
org.jos.gsi.lua.LUAScript).

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Tue, 03 Aug 1999 10:54:36 -0400
Date: Tue, 03 Aug 1999 10:54:36 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Package files

1. I have been using package files for a while, since 15 April 1999 to be
exact. I have been especially pleased with their performance, compared to
.class files and archives (.cab, .jar and .zip). They are easy to
distribute. They are re-useable. Each package file uses one connection from
an HTTP service.

2. I have a tool that builds packages files. It's on autopilot. If a .class
file exists, it must be part of a package. When I type in "java", it
automatically builds one package file for each package in "java". When I
type "org.jos", it automatically builds one package file for each package
in "org.jos".

3. JOS should be distributed to our customers in package files. For many
people, we compile our Java code ahead of time so they don't have to. They
should use the Java runtime environment instead of a JDK.

An CD-based distribution becomes all too easy. We put all package files
into one huge .zip file. We can install one package at a time by extracting
it from a .zip. On the other hand, if we put all package files into a .zip,
we can execute all that code by extracting it at runtime, too.

On the other hand, the point of package files is to download one package at
a time from the Internet. The JOS installer should "know" where the JOS
website is. It should be able to download a current "manifest" of all
packages that can be downloaded by end-users. In other words, there should
be a production manifest, a beta-test manifest and a alpha-test manifest.
When the JOS installer downloads the production manifest, only
production-quality packages should be shown.

Each package should have a name, description, author, etc. The JOS
installer should display that information when prompted.

I just realised that I've been using package source code when I should have
been using package configuration. My life would have been a lot easier if I
use the registry to control the specific configuration of each package:

; automatically generated by package manager
name=org.jos.demo

[dependencies]
javac=1.0.2
package1=org.jos.app
package2=org.jos.smartapi
package3=org.jos.streamfactory

[import1]
path=/lib/jos/demo/*.java
option=virtual

[javadoc]
path=/usr/local/javadoc ; see note 1

[classes]
; class list is created automatically by package manager,
; catagories are added/updated by you.
org.jos.Demo=application
org.jos.Demo=bean
org.jos.DemoApplet=applet
org.jos.DemoFrame=
org.jos.DemoServlet=servlet
org.jos.DemoPanel=
org.jos.DemoProgram=program

[Note 1] Wouldn't you like a smarter JavaDoc that scans only packages that
have *changed*? This is something that Sun Microsystems said will be
"extremely difficult" to do. With a registry-based version of JavaDoc, it
is possible to merge the documentation of a new package with existing
packages. While new indexes are built each time, the JavaDoc content is
stored in a registry, something like this:

[org.jos.demo.DemoFrame]
public DemoFrame()=<snippet>
public void main( string[] )=<snippet>

[org.jos.demo.DemoPanel]
public DemoPanel()=<snippet>
public DemoPanel( String v )=<snippet>

An independent scanner builds registries on behalf of JavaDoc. These
registries are persistent and stored in a JavaDoc cache directory. JavaDoc
loads registries to build .html files. Therefore, JavaDoc does not have to
scan .java files every time. The model looks like this:

scanner ==> registry ==> JavaDoc ==> .html




From gchii@mindspring.com Tue, 03 Aug 1999 11:01:05 -0400
Date: Tue, 03 Aug 1999 11:01:05 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] javac tool

Is it possible to run the javac tool from a custom class loader?

Here is what I want to do. I already have a custom class loader that reads
bytecode out of package files. It is a constant frustration that my javac
tool doesn't "see" any of the code in package files--I have to maintain two
copies of all that bytecode.

I want to start my JVM, load a custom class loader, and run the javac tool.
Wouldn't the javac tool "see" classes from the custom class loader?

You're probably going to tell me that the javac tool doesn't use a class
loader to load classes. It probably loads .class files directly, right? And
yet, it loads classes from archives (.cab, .jar and .zip) when they appear
on the class path.

I built a wrapper for the servletrunner. The wrapper is a simple class that
calls HttpServer.main().

public class ServletRunner {
  public static void main( String[] args ) {
    HttpServer.main( args );
  }
}

Can I do that with the javac tool?




From gchii@mindspring.com Tue, 03 Aug 1999 11:40:42 -0400
Date: Tue, 03 Aug 1999 11:40:42 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] javac tool - update

And so, I tried it. Asking the question reduced the puzzle to just one
wrapper class. I created a wrapper for the javac tool. It's obvious: the
javac tool does not use a class loader to load bytecode.

>java.exe -classpath C:\java\classes com.realignsoft.packagemanager1d.Run1d
Loading 'com.realignsoft.jose1d.RunApplication' class.
Package [C:\java\packages] com.realignsoft.jose1d
Package [C:\java\packages] com.realignsoft.studio1b
Package [C:\java\packages] com.realignsoft.jose.app1a
Package [C:\java\packages] com.realignsoft.jose1b
Package [C:\java\packages] com.realignsoft.jose1c
Package [C:\java\packages] com.realignsoft.javalab.javac
Sample.java:11: Class com.realignsoft.jose1d.BaseApplication not found in
import
.
import com.realignsoft.jose1d.BaseApplication;
^
Sample.java:19: Superclass com.realignsoft.jose1d.BaseApplication of class
com.realignsoft.javalab.javac.Sample not found.
public class Sample
             ^
2 errors

The javac tool for JOS should support alternative bytecode storage. I must
be able to store bytecode on another machine on the network (through an
application service or SQL service).

Does anyone know how the javac tool can compile classes in the java.*
packages? If javac uses the java.* packages, how can it compile the java.*
packages?




From digigod@earthling.net Tue, 03 Aug 1999 08:50:38 -0700
Date: Tue, 03 Aug 1999 08:50:38 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] javac tool - update

Gilbert Carl Herschberger II wrote:
> The javac tool for JOS should support alternative bytecode storage. I must
> be able to store bytecode on another machine on the network (through an
> application service or SQL service).

the javac tool (org.jos.apps.javac?) should support alternate bytecode
storage, infact it should be seperated into:

compiler 
dependency checker
bytecode source

the latter tiers being aware of the bytecode storage the compiler just
turning the ol' text to shiny new binary

 
> Does anyone know how the javac tool can compile classes in the java.*
> packages? If javac uses the java.* packages, how can it compile the java.*
> packages?

use the old java.*'s to compile the new ones?

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Tue, 03 Aug 1999 14:04:44 -0700
Date: Tue, 03 Aug 1999 14:04:44 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Package files

Gilbert Carl Herschberger II wrote:
> 1. I have been using package files for a while, since 15 April 1999 to be
> exact. I have been especially pleased with their performance, compared to
> .class files and archives (.cab, .jar and .zip). They are easy to
> distribute. They are re-useable. Each package file uses one connection from
> an HTTP service.
> 
> 2. I have a tool that builds packages files. It's on autopilot. If a .class
> file exists, it must be part of a package. When I type in "java", it
> automatically builds one package file for each package in "java". When I
> type "org.jos", it automatically builds one package file for each package
> in "org.jos".

if a class doesnt have a package statement its part of the "default"
package, but I like the idea of eliminating its use
 
> 3. JOS should be distributed to our customers in package files. For many
> people, we compile our Java code ahead of time so they don't have to. They
> should use the Java runtime environment instead of a JDK.

the only difference between the JRE and the JDK is the tools isnt it?
couldnt we make all those tools in Java just have a "JRE/Kernel" and
make it a "JDK" by adding the extra tools and such?
 
> An CD-based distribution becomes all too easy. We put all package files
> into one huge .zip file. We can install one package at a time by extracting
> it from a .zip. On the other hand, if we put all package files into a .zip,
> we can execute all that code by extracting it at runtime, too.
> 
> On the other hand, the point of package files is to download one package at
> a time from the Internet. The JOS installer should "know" where the JOS
> website is. It should be able to download a current "manifest" of all
> packages that can be downloaded by end-users. In other words, there should
> be a production manifest, a beta-test manifest and a alpha-test manifest.
> When the JOS installer downloads the production manifest, only
> production-quality packages should be shown.

the "manifest" server should be smart too, instead of returning all the
package files for a manifest it should return only those the person
could use (if you have a scanner the installer tells the manifest server
and the mf-server adds all the scanner packages to the list for you to
download...)
 
> Each package should have a name, description, author, etc. The JOS
> installer should display that information when prompted.

like a little textbox to the right of the listbox that shows that stuff
when you highlight it
 
> I just realised that I've been using package source code when I should have
> been using package configuration. My life would have been a lot easier if I
> use the registry to control the specific configuration of each package:
> 
> ; automatically generated by package manager
> name=org.jos.demo
> 
> [dependencies]
> javac=1.0.2
> package1=org.jos.app
> package2=org.jos.smartapi
> package3=org.jos.streamfactory
> 
> [import1]
> path=/lib/jos/demo/*.java
> option=virtual
> 
> [javadoc]
> path=/usr/local/javadoc ; see note 1
> 
> [classes]
> ; class list is created automatically by package manager,
> ; catagories are added/updated by you.
> org.jos.Demo=application
> org.jos.Demo=bean
> org.jos.DemoApplet=applet
> org.jos.DemoFrame=
> org.jos.DemoServlet=servlet
> org.jos.DemoPanel=
> org.jos.DemoProgram=program

I like this better, your package source code thing seemed kind of
"unnatural"; instead of org.jos.DemoPanel= have it =class otherwise it
makes think <null> like that class isnt there yet (that is I know Ill
have a demo panel I just havent made one yet)
 
> [Note 1] Wouldn't you like a smarter JavaDoc that scans only packages that
> have *changed*? This is something that Sun Microsystems said will be
> "extremely difficult" to do. With a registry-based version of JavaDoc, it
> is possible to merge the documentation of a new package with existing
> packages. While new indexes are built each time, the JavaDoc content is
> stored in a registry, something like this:
> 
> [org.jos.demo.DemoFrame]
> public DemoFrame()=<snippet>
> public void main( string[] )=<snippet>
> 
> [org.jos.demo.DemoPanel]
> public DemoPanel()=<snippet>
> public DemoPanel( String v )=<snippet>
> 
> An independent scanner builds registries on behalf of JavaDoc. These
> registries are persistent and stored in a JavaDoc cache directory. JavaDoc
> loads registries to build .html files. Therefore, JavaDoc does not have to
> scan .java files every time. The model looks like this:
> 
> scanner ==> registry ==> JavaDoc ==> .html

I wouldnt know, documentation isnt exactly my strong point, it tends to
just be a //can I do this?

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Tue, 03 Aug 1999 20:09:32 -0400
Date: Tue, 03 Aug 1999 20:09:32 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Package files

1. I have been using package files for a while, since 15 April 1999 to be
exact. I have been especially pleased with their performance, compared to
.class files and archives (.cab, .jar and .zip). They are easy to
distribute. They are re-useable. Each package file uses one connection from
an HTTP service.

2. I have a tool that builds packages files. It's on autopilot. If a .class
file exists, it must be part of a package. When I type in "java", it
automatically builds one package file for each package in "java". When I
type "org.jos", it automatically builds one package file for each package
in "org.jos".

3. JOS should be distributed to our customers in package files. For many
people, we compile our Java code ahead of time so they don't have to. They
should use the Java runtime environment instead of a JDK.

An CD-based distribution becomes all too easy. We put all package files
into one huge .zip file. We can install one package at a time by extracting
it from a .zip. On the other hand, if we put all package files into a .zip,
we can execute all that code by extracting it at runtime, too.

On the other hand, the point of package files is to download one package at
a time from the Internet. The JOS installer should "know" where the JOS
website is. It should be able to download a current "manifest" of all
packages that can be downloaded by end-users. In other words, there should
be a production manifest, a beta-test manifest and a alpha-test manifest.
When the JOS installer downloads the production manifest, only
production-quality packages should be shown.

Each package should have a name, description, author, etc. The JOS
installer should display that information when prompted.

I just realised that I've been using package source code when I should have
been using package configuration. My life would have been a lot easier if I
use the registry to control the specific configuration of each package:

; automatically generated by package manager
name=org.jos.demo

[dependencies]
javac=1.0.2
package1=org.jos.app
package2=org.jos.smartapi
package3=org.jos.streamfactory

[import1]
path=/lib/jos/demo/*.java
option=virtual

[javadoc]
path=/usr/local/javadoc ; see note 1

[classes]
; class list is created automatically by package manager,
; catagories are added/updated by you.
org.jos.Demo=application
org.jos.Demo=bean
org.jos.DemoApplet=applet
org.jos.DemoFrame=
org.jos.DemoServlet=servlet
org.jos.DemoPanel=
org.jos.DemoProgram=program

[Note 1] Wouldn't you like a smarter JavaDoc that scans only packages that
have *changed*? This is something that Sun Microsystems said will be
"extremely difficult" to do. With a registry-based version of JavaDoc, it
is possible to merge the documentation of a new package with existing
packages. While new indexes are built each time, the JavaDoc content is
stored in a registry, something like this:

[org.jos.demo.DemoFrame]
public DemoFrame()=<snippet>
public void main( string[] )=<snippet>

[org.jos.demo.DemoPanel]
public DemoPanel()=<snippet>
public DemoPanel( String v )=<snippet>

An independent scanner builds registries on behalf of JavaDoc. These
registries are persistent and stored in a JavaDoc cache directory. JavaDoc
loads registries to build .html files. Therefore, JavaDoc does not have to
scan .java files every time. The model looks like this:

scanner ==> registry ==> JavaDoc ==> .html


_______________________________________________
Arch maillist  -  Arch@jos.org
http://jos.org/mailman/listinfo/arch






From ryan@whitewolf.com.au Wed, 04 Aug 1999 11:25:09 +1000
Date: Wed, 04 Aug 1999 11:25:09 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] javac tool - update

Gilbert Carl Herschberger II wrote:

> Does anyone know how the javac tool can compile classes in the java.*
> packages? If javac uses the java.* packages, how can it compile the java.*
> packages?

When you run javac, the java.* classes are already in your CLASSPATH. If
javac compiles java.util.Vector, there are now two Vector classes: the
one linked into the javac process and the one that javac is generating.

This is probably one reason why javac does not read development classes
from its ClassLoader. Your development classes need to be kept separate
from the classes used by the javac process. However, if your development
classes appear in your CLASSPATH before classes.zip and you are
compiling java.* classes, javac might become confused.

The other part of the question is: if the java.* classes must already be
in your CLASSPATH to compile anything, then how were those classes
compiled in the first place? The very first Java code would have either
been written by hand in assembly (bytecodes) or compiled with a compiler
written in a language other than Java. In both cases, the circular
dependency on Java has been eliminated. The first step would have been
to write enough Java code to be self supporting, then a compiler could
be written in Java. As new classes were added to the library, javac
would have been modified to take advantage of them.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From gchii@mindspring.com Wed, 04 Aug 1999 19:29:31 -0400
Date: Wed, 04 Aug 1999 19:29:31 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Proposing archive: protocol

I was disappointed in Sun Microsystems again. Jar is just another kind of
archive. It doesn't need its own scheme.

Sun is so short-sighted. They created a jar: protocol for Java-specific
archives. And yet, what we need is a uniform URI for all archives. All
archives are similar, right?

While studying the archive scheme, it highlights an aspect of URIs that
many people find intimidating. A URI is inherently recursive. Because
digital resources contain other digital resources, we have to invent a
scheme that deals with recursion properly.

Proposal: With the archive: protocol, we have a number of different ways to
approach the recursion problem. Here is my proposal:

Scheme = x-jos:

Sub-scheme = archive:

Optional sub-sub-schemes = arc: | cab: | gz: | jar: | zip:

Identify archive itself:  <URI:     >

1. file: = <URI:file:/usr/local/example.jar>
2. http: = <URI:http://www.jos.org/download/wiki.zip>
3. ftp: = <URI:ftp://www.jos.org/      ?        >

Identify "file" within the archive: /usr/local/example

Example 1: If I put /usr/local/example.html into an archive called
"html.zip", I can display it in my HTML browser using this URI:

<URI:x-jos:file: <URI:x-jos:archive:file:html.zip> /usr/local/example.html>

It is automatically de-compressed and displayed as if it were a regular
.html file.

Example 2:
If the html.zip file is stored on an Internet server, the URI becomes

<URI:x-jos:file: <URI:x-jos:archive:http://www.jos.org/html.zip>
/usr/local/example.html>

Example 2; If I put /usr/local/src.zip into an archive called "jos-rx.zip",
I can display a source code file called /org/jos/demo/Demo.java using this
URI:

<URI:x-jos:file: <URI:x-jos:archive:file: <URI:x-jos:file:jos-rx.zip>
/usr/local/src.zip> /org/jos/demo/Demo.java>

src.zip is automatically extracted from jos-rx.zip. Demo.java is
automatically extracted from src.zip. By identifying an object, I can see
it in my JOS browser.

Plus, any JOS program has access to the smart object factory can get a
digital resource in the same way.

What about options?
If a password is required for an archive, where does it go?

<URI:x-jos:file: <URI:x-jos:archive:file:jos-rx.zip?password=XXX>
/usr/local/src.zip>

Directory listing:
When the name of an archive is entered by itself, the browser should either
display a list of files inside the archive or default to index.html.




From hilarycheng@usa.net Thu, 05 Aug 1999 12:33:53 +0800
Date: Thu, 05 Aug 1999 12:33:53 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Arch] Re: [JOS-Kernel] the vga driver is working now

Hi ,

Thomas, It should be better to keep discuission in Arch. :p


>
> I found the problem with the vga registers. It was a bug in the in8 (in32)
> method. I fixed it, and now the vga driver works. 640x480x16 (YES!!).

:o, GREAT! It is enough. Since All VGA Card supports this mode!
(If user is using EGA/CGA/HGA, we can't help............:p)

>
> Now we should start with a generic device loader (what do you think,
> Hilary? The shark examples are quite good). I'm also very interested in
> writing an IDE driver.

IMO, Shark provide a Generic Graphical Interface for drawing. We should
think about making a Generic Device Loader and then we make a Generic
Graphics Adaptor Driver.

>
> well, I've made some modifications in the source code, but I don't know
> how to upload these changes. Can anybody help me?

I think we should use CVS. But I donno how to operate the CVS and we got
no right to access current JJOS CVS.

>
> another speed question: write8 is much faster than write 32 why? I wanted
> to scrub the vga memory with write32, but it was too slow.

Would u mind pack several files to me that allows me to turn JOS to VGA Mode ?

Also, I found a Pascal Program that contains lots of SVGA Information using
VGA
Register. It called "WhatVGA". It contains lots of drivers. I think it can
cover more
than 50% of current Adaptor. We can get those information and make the drivers

for the users.

Regards,

Hilary




From al@outworld.org Thu, 05 Aug 1999 12:59:30 +0300
Date: Thu, 05 Aug 1999 12:59:30 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] Proposing archive: protocol

Gilbert Carl Herschberger II wrote:

> I was disappointed in Sun Microsystems again. Jar is just another kind
> of archive. It doesn't need its own scheme.
> 
> Sun is so short-sighted. They created a jar: protocol for
> Java-specific archives. And yet, what we need is a uniform URI for all
> archives. All archives are similar, right?

The following scheme could be useful; it uses the pipe (|) to
distinguish between embedded resources. An example would be this:


ftp://database.server.net/archives/images/contents.jar|/update/latest.zip|/acquired/foo.jpg?username=jeeves&password=cafebabe


The above URI would authenticate with the FTP protocol and open the
foo.jpg image in the latest.zip archive in the contents.jar archive in
the specified directory of the specific server. Using installed MIME
types, or possibly extensions, the software can automatically decode
(ZIP, JAR and JPG here for examples are required).

I don't believe that the pipe is reserved in URI's up to now, so maybe
we could use it, at least JOS internally?

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From digigod@earthling.net Thu, 05 Aug 1999 07:25:19 -0700
Date: Thu, 05 Aug 1999 07:25:19 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Proposing archive: protocol

Al wrote:
> The following scheme could be useful; it uses the pipe (|) to
> distinguish between embedded resources. An example would be this:

why not just use the # fragment, can you have more then one? I can see
no reason not to (the RFC doesnt say you CANT anyway)

ftp://database.server.net/archives/images/contents.jar|/update/latest.zip|/acquired/foo.jpg?username=jeeves&password=cafebabe

> The above URI would authenticate with the FTP protocol and open the
> foo.jpg image in the latest.zip archive in the contents.jar archive in
> the specified directory of the specific server. Using installed MIME
> types, or possibly extensions, the software can automatically decode
> (ZIP, JAR and JPG here for examples are required).

I like the idea of using mime to differentiate file types, but this URI
tells ftp to download contents.jar; so it has d'loaded content.jar and
it has a left over fragment it has no idea what to do with.

in gilberts scheme (to my understanding) the OS processes the URI
recursively. so: (note that the fragment is after the query as according
to the RFC)

archive:archive:ftp://database.server.net/archives/images/contents.jar?username=jeeves&password=cafebabe#/update/latest.zip#/aquired/foo.jpg

first ftp is processed by the ftp daemon, it is passed the following
URI:

ftp://database.server.net/archives/images/contents.jar?username=jeeves&password=cafebabe

it returns a file to the next URI:

archive:<file>#/update/latest.zip

this processes contents.jar and extracts latests.zip as per the fragment

then it passes this file up to:

archive:<file>#/aquired/foo.jpg

which extracts foo.jpg as per the fragment

<file> is a placeholder for the object returned by the other URI's

 
> I don't believe that the pipe is reserved in URI's up to now, so maybe
> we could use it, at least JOS internally?

its not.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Thu, 05 Aug 1999 10:26:58 -0400
Date: Thu, 05 Aug 1999 10:26:58 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Proposing archive: protocol

At 12:59 PM 8/5/99 +0300, you wrote:
>The following scheme could be useful; it uses the pipe (|) to
>distinguish between embedded resources. An example would be this:
>
>
>ftp://database.server.net/archives/images/contents.jar | /update/latest.zip
> | /acquired/foo.jpg ?username=jeeves&password=cafebabe

Note: I added spaces for clarity.

The URI and command line are based on the same mechanism. The "pipe" model
comes from a command line. While a command line is platform-dependent
(usually), a URI is platform-independent.

The ftp: scheme is a very good example. Remind me again, though. I am a
little rusty with ftp. Doesn't ftp: expect name and password parameters? In
the example above, "?username=jeeves&password=cafebabe" would be part of
ftp: scheme. I'll just move the parameters to ftp: forward:

ftp://database.server.net/archives/images/contents.jar
?username=jeeves&password=cafebabe |/update/latest.zip |/acquired/foo.jpg

>The above URI would authenticate with the FTP protocol and open the
>foo.jpg image in the latest.zip archive in the contents.jar archive in
>the specified directory of the specific server.

As long as latest.zip is not password protected, it will work. I am
concerned with what happens when latest.zip *is* password protected. Still
using pipes, this URI would become:

ftp://database.server.net/archives/images/contents.jar
?username=jeeves&password=cafebabe |/update/latest.zip ?password=jos
|/acquired/foo.jpg

>Using installed MIME types, or possibly extensions, the software can
>automatically decode (ZIP, JAR and JPG here for examples are required).

Let's talk a little about MIME types. MIME types only hint at a default
decoding and presentation. It isn't absolute; it is only a clue.
Explicitely adding the protocol should produce the same results.

ftp://database.server.net/archives/images/contents.jar ?
username=jeeves&password=cafebabe | archive:zip:/update/latest.zip |
image:jpeg:/acquired/foo.jpg

Imagine, though, that I have made up my mind and really want to see the
contents of an JPEG file in hexidecimal notation. I want the default MIME
type to be *ignored*. My decision should be reflected in the URI. Maybe it
should be like this:

ftp://database.server.net/archives/images/contents.jar
?username=jeeves&password=cafebabe | archive:zip:/update/latest.zip |
file:hex:/acquired/foo.jpg

Sure, if there is a table of default MIME types, I may be able to imply
decoding with file extensions. But our URI architecture must be able to
support explicit choices.

>I don't believe that the pipe is reserved in URI's up to now, so maybe
>we could use it, at least JOS internally?

Sometimes, I wonder how we're going to succeed with any of this. The URI is
supposed to be a global, platform-independent model. Current URIs are
monolythic and short-sighted. We *need* to do things with URIs in JOS that
none of the other operating systems can do (yet and maybe ever). We are out
in front. We are on the bleeding edge.

From RFC 2396, the verticle bar (|) is considered an "unwise" character.
We're supposed to be careful not to think about JOS as an island. JOS will
interact with all other operating systems. How can we limit URIs to
internal use only?

uri-pipe := uri "|" uri "|" uri

uri := scheme ":" path [ "?" query ] [ "#" fragment ]

Decoding a uri-pipe must be performed first, prior to decoding an
individual uri inside a pipe. Each uri inside a uri-pipe may have query
part and fragment part. The final MIME type of the uri-pipe is the MIME
type of the last uri inside the pipe.

This is almost right. But it means that all URIs that already use the
pipe--even though its an unwise character--will not be compatible with the
uri-pipe. Incompatibility with all those existing URIs is bad, very bad.

The problem would be solved if we choose another "symbol" for the pipe.
Hey, what about this:

uri-pipe := uri ">>" uri ">>" uri

Oh, and another thing. A client agent must know *immediately* that a URI is
a pipe and not a normal URI. We want those old client agents to display a
message first, before they do lots of work they can't finish.

I always imagined that the client agent would do all the work. Then our new
scheme would be compatible with existing Internet services. So the client
agent must process a uri-pipe. The client agent must download the whole
archive, even to get one small file.

I suppose it is possible for an FTP service to extract the latest.zip, then
extract foo.jpg and return only foo.jpg to the client agent. By embedding
one uri into another, a client agent sends the entire request to the
service. Wouldn't this work?

ftp://database.server.net/ <archive:archives/images/contents.jar>
<archive:/update/latest.zip> /acquired/foo.jpg
?username=jeeves&password=cafebabe

Oh, in fact, you should be able to choose client-side or server-side
decoding of a uri-pipe. Your pipe scheme would be best suited for
client-side decoding. My scheme would be best suited for server-side decoding.

The client agent would "see" this uri:

ftp://database.server.net/aquired/foo.jpg ?username=jeeves&password=cafebabe

It would connect to an FTP service with username and password and download
/aquired/foo.jpg. The FTP service would recieve this:

/archives/images/contents.jar |/update/latest.zip |/acquired/foo.jpg 
or
<archive:archives/images/contents.jar>
<archive:/update/latest.zip> /acquired/foo.jpg

If there's a vertical bar (|) in a request or if the FTP service sees "<"
as the first character in the request, it knows immediately that its an
embedded URI. It extracts /images/contents.jar and here's what's left:

/update/latest.zip |/acquired/foo.jpg
or
<archive:/update/latest.zip> /acquired/foo.jpg

Again, if there's a verticle bar (|) or a "<" as the first character, it
knows immediately that its an embedded URI. It extracts /update/latest.zip
and here's what's left:

/aquired/foo.jpg

The FTP service OR client agent must keep track of its file source. At the
beginning, it gets files from the OS file subsystem. With each archive, it
gets files from an archive.

A client agent would use its local cache. While a client agent would
download a large archive to extract a small file, the client agent might be
more efficient with subsequent requests. If the large archive has already
been downloaded to its local cache, it won't download or extract it again.
It just extracts another small file.

When running bytecode for an applet or servlet across the Internet, it is
more efficient to download the whole archive once rather than download one
class file at a time from the archive. That's yet another reason to have
the client agent handle the URI pipe and/or embedded URIs.




From onewith1@flash.net Thu, 5 Aug 1999 15:37:59 -0500
Date: Thu, 5 Aug 1999 15:37:59 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Device Architecture

Ah, into my field of study.  Unfortunately, after my change in jobs, I have
had very little time to work on this problem of discovery and storage.
When/if Wiki's back up, look at my page under DeviceArchitecture.

-----Original Message-----
From: John Morrison <jm@mak.com>
To: kernel@jos.org <kernel@jos.org>
Date: Thursday, August 05, 1999 8:28 AM
Subject: Re: [JOS-Kernel] the vga driver is working now


>> Now we should start with a generic device loader (what do you think,
>> Hilary? The shark examples are quite good). I'm also very interested in
>> writing an IDE driver.
>
>The following paragraph is based upon only what I can remember from a
cursory
>reading of both the "Inside JavaOS" book and the IBM "JavaOS for Business"
>documentation (neither is in front of me now), so there's a distinct
possibility
>that I can be really mistaken:
>
>JavaOS has this concept where they (apparently) unify the concept of a
registry
>and the traditional UNIX "/dev" device entries, and driver entries, too.
This
>Java-object tree gets populated when the device discovery is done at boot
time,
>and then drivers are also elements of the tree.  Also, user preferences are
>stored the same way somehow (serialization?).  Finally, they seem to one-up
the
>concept of a registry in that, when a member of the tree is updated (e.g.,
a
>hot-swappable device is discovered, or a new driver is loaded), then other
Java
>objects can get notified, so they can remain in synchrony with the
database.  It
>seems neat and elegant (which implies that maybe it'll be simpler to
>implement?), and I'm thinking we should clone it.

I'm attempting to summarize my design/thoughts in quick words, so this might
get confusing...  My rough sketch of the device tree was initially based on
a combination of JavaOS's viewpoint, and Jini's device discovery/listing
tree.  I agree with JavaOS's design of placing devices in a "/dev" entry in
the registry, but I feel that applications should *NOT* have access to this.
It would create too large of a dependancy on the devices - when we know that
we want real-time add/remove/replace features for drivers.  Thus, we keep
the user from having to reboot at every minor device change.

Instead, I said that we should have a "device interface" layer in the
registry, which basically has a set of classes with links to the "/dev" or
"/devInterface" locations.  This way, applications which request a device
will be unaware of a device being replaced.  All that changes is the device
interface links.  Since this is in the registry, different threads/processes
can have different sets of device links.  This requires rewriting many of
the basic java.* classes so that they reference the registry's device links.

>
>(With respect to device-discovery, I have some pretty good documentation on
the
>BIOS data areas, in which the BIOS stores the results of its device-probing
>activities.  Now that we can read physical memory, we can stroll through
this
>area and find out exactly what devices are in the box.  I'm more than
willing to
>help out here...)

The reason why I initially volunteered to cover device-discovery (which bled
into the whole device architecture) was that I have some good plug-n-play
documentation, as well as a history of device driver implementation in DOS.
Ah, those were the days...

>Fabulous work -- congratulations!!
>
>-jm

Good going on the VGA driver.  Anyone up for writing a MGA driver? :)

-Matt

"Imagine a person with a gift of ridicule.  [He might say] First that a
negative quality has no square root; secondly that a negative quality has no
logarithm; thirdly that the second non-existant is to the first as the
circumference of a circle is to the diameter."
       - Augustus de Morgan


>
>--
>==== John Morrison            ==== MaK Technologies, Inc.
>==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA
02138
>==== jm@mak.com               ==== http://www.mak.com/welcome.html
>==== vox:617-876-8085 x115    ==== fax:617-876-9208
>
>_______________________________________________
>Kernel maillist  -  Kernel@jos.org
>http://jos.org/mailman/listinfo/kernel
>
>




From al@outworld.org Thu, 05 Aug 1999 23:58:00 +0300
Date: Thu, 05 Aug 1999 23:58:00 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] Proposing archive: protocol

Gilbert Carl Herschberger II wrote:
>
> <snip>
>
> Imagine, though, that I have made up my mind and really want to see
> the contents of an JPEG file in hexidecimal notation. I want the
> default MIME type to be *ignored*. My decision should be reflected in
> the URI. Maybe it should be like this:
> 
> ftp://database.server.net/archives/images/contents.jar
> ?username=jeeves&password=cafebabe | archive:zip:/update/latest.zip |
> file:hex:/acquired/foo.jpg


Should not the hex: be in the beginning? Like hex:ftp://etc...
Since converting to HEX is not part of the retrieval of information,
just a displaying aspect to it.

hex:ftp://ftp.server.org/pub/images/jeeves/surfing.jpg?user=, etc...

This would retrieve the JPEG image, and *then* hex it. In a more
elaborate archiving system, it could be like this:

hex:zip:ftp://ftpusername:ftpuserpassword@ftp.server.org/
pub/images.zip?username=jeeves&password=cafebabe
|gzip:/jeeves/surfing.gzip?username=foo&password=bar
|jpeg:image:/cool/image1.jpg?width=100&height=50

Or maybe the internal protocol handlers should be followed by a double
slash (//)?

Maybe then the original zip: should be omitted and added *after* the
server specification? Remember, this URI won't be sent to the ftp server
to confuse it, it will be used by the internal system content handlers.

> From RFC 2396, the verticle bar (|) is considered an "unwise"
> character. We're supposed to be careful not to think about JOS as an
> island. JOS will interact with all other operating systems. How can we
> limit URIs to internal use only?

I'm not quite sure, but if we need something not yet implemented, should
we not implement it?

> Hey, what about this:
> 
> uri-pipe := uri ">>" uri ">>" uri

I would *strongly* suggest using single characters for delimiters. We
can use the backslash maybe (\)? Or the $ sign? Or the ! sign which is
already used in JAR files? Or the ~ sign? I think # should be left for
anchors, since we do want URIs to point to XML/HTML documents.

> I suppose it is possible for an FTP service to extract the latest.zip,
> then extract foo.jpg and return only foo.jpg to the client agent.

This could be very easily achieved as follows:

ftp://jeeves:cafebabe@ftp.server.org/pub/archives/images.zip!/jeeves/
surfing/image1.jpg

The client can query the server to find out if the server can perform
such an operation, and if it cannot, then the client should do it (just
as it is done currently in JAR files).

> When running bytecode for an applet or servlet across the Internet, it
> is more efficient to download the whole archive once rather than
> download one class file at a time from the archive. That's yet another
> reason to have the client agent handle the URI pipe and/or embedded
> URIs.

True, although I would like to see this done automatically: the class
loader knows when to download an entire JAR file or a portion of it. For
example, if the class needed to be loaded resides in a JAR file, then
the entire JAR should be downloaded, since it will most probably contain
other classes also required by the original class. Though, if it is to
download a resource from a JAR file, such as a sound or and image or an
icon, then it could just ask for that particular item.

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From scode@scode.webprovider.com Thu, 5 Aug 1999 22:36:35 +0200
Date: Thu, 5 Aug 1999 22:36:35 +0200
From: scode@scode.webprovider.com scode@scode.webprovider.com
Subject: [JOS-Arch] URI?

--P6YfpwaDcfcOCJkJ
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: quoted-printable

Just a quick question: what does "URI" stand for anyway? The discussion has
been going on long enough for me to really want to know :)

Thanks!

--=20
/ Peter Schuller

PGP userID: 0x5584BD98 or 'Peter Schuller <scode@scode.webprovider.com>'
Key retrival: Send an E-Mail to scode-getpgpkey@scode.webprovider.com
E-Mail: scode@scode.webprovider.com Web: http://hem.passagen.se/petersch

--P6YfpwaDcfcOCJkJ
Content-Type: application/pgp-signature

-----BEGIN PGP SIGNATURE-----
Version: PGPfreeware 5.0i for non-commercial use
MessageID: jN/X+fMbWX34kLlYfcjPD8oSy0K72Nag

iQA/AwUBN6n108BfJ1FVhL2YEQKjUwCdHxjG8a61SJBOeEvs3f03u2gIIXAAn2PO
gfmOpSpJ97EHc6meBgqS40VS
=MFjJ
-----END PGP SIGNATURE-----

--P6YfpwaDcfcOCJkJ--



From al@outworld.org Fri, 06 Aug 1999 02:17:59 +0300
Date: Fri, 06 Aug 1999 02:17:59 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] URI?

scode@scode.webprovider.com wrote:
> 
> Just a quick question: what does "URI" stand for anyway? The
> discussion has been going on long enough for me to really want to know
> :)

It stands for "Universal Resource Indicator." It is a string that can,
theoretically, point to any "resource" (information, file, etc.)
available on the local computer and the Internet.

The URI defines a communications protocol, the physical (computer name)
and virtual (path) location of the resource, along with other
information necessary to retrieve this information (a password, a
session id, etc.)

You should probably know the URL, but Indicator is better than Locator,
since DNS and server software are really the locators, the URI is the
address of resources.

Hope that makes it clear.

BTW, URL and URI are like this because of hastened implementation. Just
like the "referer" field in the HTTP header (notice the spelling
mistake?)


-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From whooops@gmx.de Fri, 06 Aug 1999 02:53:45 +0000
Date: Fri, 06 Aug 1999 02:53:45 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] URI?

Al wrote:
> 
> scode@scode.webprovider.com wrote:
> >
> > Just a quick question: what does "URI" stand for anyway? The
> > discussion has been going on long enough for me to really want to know
> > :)
> 
> It stands for "Universal Resource Indicator." It is a string that can,
> theoretically, point to any "resource" (information, file, etc.)
> available on the local computer and the Internet.

Actually it means "Uniform Ressource Identifier". From RFC2396:

   A Uniform Resource Identifier (URI) is a compact string of characters
   for identifying an abstract or physical resource. 

RFC2396 is the 'ultimate' authority on this.
ftp://ftp.isi.edu/in-notes/rfc2396.txt

Of interest:
RFC1630,RFC2396,RFC2483

Regards, Mark
-- 
"I invented the term Object-Oriented, and I can tell you I did not have C++ in
mind." - Alan Kay



From gchii@mindspring.com Thu, 05 Aug 1999 23:39:40 -0400
Date: Thu, 05 Aug 1999 23:39:40 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Proposing archive: protocol

At 11:58 PM 8/5/99 +0300, al@outworld.org wrote:
>Should not the hex: be in the beginning?

This is the heart of the matter. Should it be in the beginning? I think so...

>hex:zip:ftp://ftpusername:ftpuserpassword@ftp.server.org/
>pub/images.zip?username=jeeves&password=cafebabe
>|gzip:/jeeves/surfing.gzip?username=foo&password=bar
>|jpeg:image:/cool/image1.jpg?width=100&height=50

With hex in the beginning, your URI could look like this, too:

hex: <jpeg: <gzip: <ftp://ftpusername:ftpuserpassword@ftp.server.org/
pub/images.zip?username=jeeves&password=cafebabe>
/jeeves/surfing.gzip?username=foo&password=bar>
/cool/image1.jpg?width=100&height=50>

>Like hex:ftp://etc... Since converting to HEX is not part of the
>retrieval of information, just a displaying aspect to it.

Exactly.




From gchii@mindspring.com Thu, 05 Aug 1999 23:39:19 -0400
Date: Thu, 05 Aug 1999 23:39:19 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Embedded URI proposal

Earlier, I proposed enclosing an embedded URI scheme that puts the most
significant protocol first. With an embedded URI, you can send the whole
URI to a host for processing. I used less-than (<) and greater than (>)
characters. I'll restate my proposal here:

source-1 := "/" "/" host [ ":" port ]

source-2 := "<" uri ">"

source := "" | source-1 | source-2

uri := protocol ":" source "/" path [ ? query ] [ # fragment ]

A source is optional. When used, a source is either a traditional source
(source-1) or an embedded URI (source-2). Since this relationship is
recursive, an URI can be embedded into another infinitely.

The "host" of a traditional file: scheme is a "drive" in Microsoft Windows.
I am beginning to see that an archive file is similar to a "host". So, why
not replace "host" with an embedded URI?




From gchii@mindspring.com Thu, 05 Aug 1999 23:44:40 -0400
Date: Thu, 05 Aug 1999 23:44:40 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Proposing archive: protocol

At 07:25 AM 8/5/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>why not just use the # fragment, can you have more then one? I can see
>no reason not to (the RFC doesnt say you CANT anyway)

The RFC says that the client agent must be responsible for the fragment
part. By using the fragment for a URI pipe, the client agent must be
responsible for the entire pipe. I like that.

I have tried to use the fragment part to create an embedded URI. It works
up to a point. Using the fragment provides compatible syntax, but
semantically produces entirely wrong results. A client agent that's unaware
of the extended syntax would return an archive, instead of throwing an
exception.

The fragment part may itself be embedded in a URI. I am unable to come up
with an example. The closest thing is the x-registry scheme. It uses the
fragment to locate a sub-registry within a larger registry. If we want to
pipe a registry to some other scheme, the fragment has already been used.




From gchii@mindspring.com Fri, 06 Aug 1999 00:02:02 -0400
Date: Fri, 06 Aug 1999 00:02:02 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] AppletBrowser update

Yes! I have created an applet browser...that almost works. It has already
helped me debug a nagging problem with one of my latest applets.

URLStreamHandlers manage connections to digital resources.
URLStreamHandlerFactories create URLStreamHandlers when given the name of a
scheme.

There is no default URLStreamHandlerFactory. The default factory has been
reduced to a static method of java.net.URL. You can't extend the default
factory. You have to build your own factory from completely from scratch.

My applet browser must set a custom URLStreamHandlerFactory. That custom
factory must return a custom URLStreamHandler object even for those URIs
that are *not* streams. So far, so good.

All but one thing is working. When I create a new URI with the applet:
protocol, the URI is inexplicably altered. "applet:org.jos.demo.DemoApplet"
becomes "applet:/org.jos.demo.DemoApplet". Where did the slash (/) come from?




From gchii@mindspring.com Fri, 06 Aug 1999 00:10:40 -0400
Date: Fri, 06 Aug 1999 00:10:40 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Unified browser

When everything is finished, we should be able to combine all of the
experimental browsers into one unified browser.

PlainTextBrowser
AppletBrowser
ProgramBrowser
HTMLBrowser
TelnetBrowser
RegistryBrowser
and more...

A HREF in a HTML page can contain a URI for an applet, a program, a telnet
connection, a registry. An applet can use showDocument() to run another
applet, run a program, a telnet connection, a registry, or an HTML page. A
program can use exec() to run another program, an applet, a telnet
connection, a registry. A registry editor can use an entry as a URI, to
load another registry, run an applet, a program or display an HTML page.

An experimental browser is built in isolation. It does one thing well. When
it works, all will be combined into the unified browser with one-stop
shopping. Are you ready?




From gchii@mindspring.com Fri, 06 Aug 1999 00:19:33 -0400
Date: Fri, 06 Aug 1999 00:19:33 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] JavaBee sighting

Have you see JavaBee? Check it out at http://www.javabee.com.

How is a unified browser different than JavaBee? Unlike JavaBee, our JOS
browser is not limited to running applets. It runs anything.

So far, our experimental browsers have a crude AWT interface. It is
functional. It is not colorful. It doesn't have a cute cartoon character to
get attention. When the time comes, we'll need to put more energy into the
way the unified browser looks.

All these browsers need a "history" component, a "toolbar" component and a
"bookmark manager" component.




From whooops@gmx.de Fri, 06 Aug 1999 08:20:04 +0000
Date: Fri, 06 Aug 1999 08:20:04 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] Embedded URI proposal

Hi.
Instead of all this reinvention I've found something in the attic hidden in an
old box :)

  Browser display: Archiver deArchive: Net retrieve:
'http://www.jos.org/josRules.jar' .

Or:

  Browser display: (Archiver deArchive: (URI retrieve:
'http://www.jos.org/josRules.jar')) .

The box is labeled "Smalltalk" ;) Smalltalk offers a user the full power of an
object oriented programming language, yet it is easy to learn - even by kids -
and it offers an appealing [imho] and easy to read look. It is even easier to
read than your 'embedded URI'. Internally a URI has to be formed to a cascade
of Objects anyways.

This is my suggestion: Do it OO.

Regards, Mark

PS: in an 'open' box you would only use "Net get: 'http://foo/bar.txt'", this
would return the file object the application needs.
-- 
"Hier scheiden sich nun die Wege der Menschen; willst Du Seelenruhe und Glück
erstreben, nun so glaube, willst Du ein Jünger der Wahrheit sein, so forsche."
-Friedrich Nietzsche



From al@outworld.org Fri, 06 Aug 1999 11:23:56 +0300
Date: Fri, 06 Aug 1999 11:23:56 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] Proposing archive: protocol

DigiGod Q Frasché wrote:

> \ is already used, $ doesnt seem right, ! is off.

Why is "!" off? I agree, though, that the $ does not look right.

> # is for a fragment,
> an anchor is how HTML handles a fragment. an archive could handle the
> fragment as specifing a file
>
> archive:big.jar#/boring/stuff/no/one/uses/afile.txt

I suppose that if we are to extract an HTML page from an archive, the
URI interpreter won't mind there being two #, right?

As in:

html:archive:ftp//jeeves:cafebabe@ftp.sun.org/pub/images.jar
#/surfing/description.html#middle

Which opens "description.html" and goes to the anchor "middle"?

> The client can query the server to find out if the server can perform
> such an operation, and if it cannot, then the client should do it
> (just as it is done currently in JAR files).

Have in mind that the HEADER of an HTTP response may indicate
compression. We must always consider that various protocols also rely on
headers...

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From al@outworld.org Fri, 06 Aug 1999 11:41:28 +0300
Date: Fri, 06 Aug 1999 11:41:28 +0300
From: Al al@outworld.org
Subject: [JOS-Arch] Proposing archive: protocol

Gilbert Carl Herschberger II wrote:

> With hex in the beginning, your URI could look like this, too:
> 
> hex: <jpeg: <gzip: <ftp://ftpusername:ftpuserpassword@ftp.server.org/
> pub/images.zip?username=jeeves&password=cafebabe>
> /jeeves/surfing.gzip?username=foo&password=bar>
> /cool/image1.jpg?width=100&height=50>

Although this is probably the best way we can define the location of
protocol indentifiers and resources, I strongly disagree with the use of
the symbols '>' and '<'. These symbols are reserved in XML as tag
markers. It would be fantastically confusing if we had this:

<IMG src="<jpeg: <gzip: <http://host.com/logo.jpg>>>">

And *any* mistake not only could corrupt the entire document thereafter,
but it would require (int many cases) a human to correct it... What if
we took up XML with XPointer? Is it not designed in such a way that
almost any relationship and resource can be pointed at?


> >Like hex:ftp://etc... Since converting to HEX is not part of the
> >retrieval of information, just a displaying aspect to it.

Emm... No. The HEX could be displayed as characters, numbers, Braille or
even be dictated. It is actually *converted* to a HEX stream from an
octet stream. Just like JPEG *converts* binary data into a color matrix.
Or ZIP from inflated bytes to deflated bytes. Or a character reader from
escape characters to Unicode characters. Or an SGML engine from entities
(&lt;) to characters (<).

We should not confuse structure with appearance!

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
___________________________________________________________________
[EMAIL: mailto:al@outworld.org] [DSS: 0xDBEF8ECC | RSA: 0xBC469499]
[URL: http://www.outworld.org/people/al/] [TEL: (0030) +31 422 392]
DO NOT SEND ME UNSOLICITED COMMERCIAL, RELIGIOUS OR POLITICAL EMAIL



From digigod@earthling.net Thu, 05 Aug 1999 21:24:25 -0700
Date: Thu, 05 Aug 1999 21:24:25 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Proposing archive: protocol

Al wrote:
> hex:zip:ftp://ftpusername:ftpuserpassword@ftp.server.org/
> pub/images.zip?username=jeeves&password=cafebabe
> |gzip:/jeeves/surfing.gzip?username=foo&password=bar
> |jpeg:image:/cool/image1.jpg?width=100&height=50

I think we've officially destroyed any chance of it being human
interpratable, at least
 
> Or maybe the internal protocol handlers should be followed by a double
> slash (//)?
> 
> Maybe then the original zip: should be omitted and added *after* the
> server specification? Remember, this URI won't be sent to the ftp server
> to confuse it, it will be used by the internal system content handlers.
> 
> > From RFC 2396, the verticle bar (|) is considered an "unwise"
> > character. We're supposed to be careful not to think about JOS as an
> > island. JOS will interact with all other operating systems. How can we
> > limit URIs to internal use only?
> 
> I'm not quite sure, but if we need something not yet implemented, should
> we not implement it?
> 
> > Hey, what about this:
> >
> > uri-pipe := uri ">>" uri ">>" uri
> 
> I would *strongly* suggest using single characters for delimiters. We
> can use the backslash maybe (\)? Or the $ sign? Or the ! sign which is
> already used in JAR files? Or the ~ sign? I think # should be left for
> anchors, since we do want URIs to point to XML/HTML documents.

\ is already used, $ doesnt seem right, ! is off. # is for a fragment,
an anchor is how HTML handles a fragment. an archive could handle the
fragment as specifing a file 

archive:big.jar#/boring/stuff/no/one/uses/afile.txt
 
> > I suppose it is possible for an FTP service to extract the latest.zip,
> > then extract foo.jpg and return only foo.jpg to the client agent.
> 
> This could be very easily achieved as follows:
> 
> ftp://jeeves:cafebabe@ftp.server.org/pub/archives/images.zip!/jeeves/
> surfing/image1.jpg

in the scheme I suggested in this and other e-mails it would be:

archive:ftp://jeeves:cafebabe$ftp.server.org/pub/archives/images.zip#/jeeves/surfing/image1.jpg

its procesed as 
ftp:.../images.zip
which is passed to
archive:<the zip>#.../image1.jpg
which returns the file

for the archive in an archive situation it would be:

archive:archive:ftp://jeeves:cafebabe$ftp.server.org/pub/archives/images.zip#/extras/pics.zip#/jeeves/surfing/image1.jpg

ftp://.../images.zip is passed to
archive:<zip>#extras/pics.zip which is sent to
archive:<zip>#...image1.zip

and to force the jpeg to be shown in hex:

mime:archive:archive:ftp://jeeves:cafebabe$ftp.server.org/pub/archives/images.zip#/extras/pics.zip#/jeeves/surfing/image1.jpg?media=application&format=octet-stream

this is the same as above but it adds the extra recursion:

mime:<file>?media=application&format=octet-stream

which forces the file to be ID'ed as application/octet-stream for
purposes of viewing
 
> The client can query the server to find out if the server can perform
> such an operation, and if it cannot, then the client should do it (just
> as it is done currently in JAR files).

agreed.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Fri, 06 Aug 1999 07:29:09 -0700
Date: Fri, 06 Aug 1999 07:29:09 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Embedded URI proposal

Gilbert Carl Herschberger II wrote:
> Earlier, I proposed enclosing an embedded URI scheme that puts the most
> significant protocol first. With an embedded URI, you can send the whole
> URI to a host for processing. I used less-than (<) and greater than (>)
> characters. I'll restate my proposal here:
> 
> source-1 := "/" "/" host [ ":" port ]
> 
> source-2 := "<" uri ">"
> 
> source := "" | source-1 | source-2
> 
> uri := protocol ":" source "/" path [ ? query ] [ # fragment ]
> 
> A source is optional. When used, a source is either a traditional source
> (source-1) or an embedded URI (source-2). Since this relationship is
> recursive, an URI can be embedded into another infinitely.
> 
> The "host" of a traditional file: scheme is a "drive" in Microsoft Windows.
> I am beginning to see that an archive file is similar to a "host". So, why
> not replace "host" with an embedded URI?

host is a good place to put an embeded URI, it makes sense; but why the
< >? its going to be hard to embed in documents, even oif they're just
using <URI: /uri/> syntax, you miss one and its all over.

how is:

archive:http://jos.org/archives/jos.jar

harder to read then:

archive:< http://jos.org/archives/jos.jar >

and:

<A HREF="archive:< http://jos.org/archives/jos.jar >">

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Fri, 06 Aug 1999 07:39:06 -0700
Date: Fri, 06 Aug 1999 07:39:06 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Proposing archive: protocol

Gilbert Carl Herschberger II wrote:
> The RFC says that the client agent must be responsible for the fragment
> part. By using the fragment for a URI pipe, the client agent must be
> responsible for the entire pipe. I like that.
> 
> I have tried to use the fragment part to create an embedded URI. It works
> up to a point. Using the fragment provides compatible syntax, but
> semantically produces entirely wrong results. A client agent that's unaware
> of the extended syntax would return an archive, instead of throwing an
> exception.
> 
> The fragment part may itself be embedded in a URI. I am unable to come up
> with an example. The closest thing is the x-registry scheme. It uses the
> fragment to locate a sub-registry within a larger registry. If we want to
> pipe a registry to some other scheme, the fragment has already been used.

x-registry:archive:http://www.jos.org/registry.jar#/xml-registry#/system/toggles/sound

with spaces:

x-registry: archive: http://www.jos.org/registry.jar #/xml-registry
#/system/toggles/sound

shown hierarchially split:

x-registry: 
 archive: 
  http://www.jos.org/registry.jar
 #/xml-registry
#/system/toggles/sound

first we do http, so:

http://www.jos.org/registry.jar

then archive:

archive:...#/xml-registry

then x-registry:

x-registry:...#/system/toggles/sound

it would require a smart parser to figure this out, so maybe it is
better to use identifiers, how about []'s doesnt mess up XML/HTML

x-registry:[archive:[http://www.jos.org/registry.jar]#/xml-registry]#/system/toggles/sound

seems to work

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Fri, 06 Aug 1999 07:41:44 -0700
Date: Fri, 06 Aug 1999 07:41:44 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Embedded URI proposal

Mark Andreas Meyer wrote:
> Hi.
> Instead of all this reinvention I've found something in the attic hidden in an
> old box :)
> 
>   Browser display: Archiver deArchive: Net retrieve:
> 'http://www.jos.org/josRules.jar' .
> 
> Or:
> 
>   Browser display: (Archiver deArchive: (URI retrieve:
> 'http://www.jos.org/josRules.jar')) .
> 
> The box is labeled "Smalltalk" ;) Smalltalk offers a user the full power of an
> object oriented programming language, yet it is easy to learn - even by kids -
> and it offers an appealing [imho] and easy to read look. It is even easier to
> read than your 'embedded URI'. Internally a URI has to be formed to a cascade
> of Objects anyways.
> 
> This is my suggestion: Do it OO.
> 
> Regards, Mark
> 
> PS: in an 'open' box you would only use "Net get: 'http://foo/bar.txt'", this
> would return the file object the application needs.

so people would have to learn smalltalk to open a file? I dont think
that'll makeus the OS everyone at work can agree on...

besides the point is a language-independent way to point to stuff

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Fri, 06 Aug 1999 07:46:13 -0700
Date: Fri, 06 Aug 1999 07:46:13 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Proposing archive: protocol

Al wrote:
> Why is "!" off? I agree, though, that the $ does not look right.

its off because we already have #, why reinvent the wheel, er, token?
 
> I suppose that if we are to extract an HTML page from an archive, the
> URI interpreter won't mind there being two #, right?

why should it?
 
> As in:
> 
> html:archive:ftp//jeeves:cafebabe@ftp.sun.org/pub/images.jar
> #/surfing/description.html#middle
> 
> Which opens "description.html" and goes to the anchor "middle"?

if I was looking at it thats what Id understand

> Have in mind that the HEADER of an HTTP response may indicate
> compression. We must always consider that various protocols also rely on
> headers...

good point

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From whooops@gmx.de Fri, 06 Aug 1999 21:25:33 +0000
Date: Fri, 06 Aug 1999 21:25:33 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] Embedded URI proposal

DigiGod Q Frasché wrote:

> so people would have to learn smalltalk to open a file? I dont think
> that'll makeus the OS everyone at work can agree on...
> 
> besides the point is a language-independent way to point to stuff

No. You just have to tell the Archiver to decompress that file by "Archiver
deCompress: '/some/file'". This is of course aesier (or at least it's equal)
than reading some sort of strange non-standard URI format. Besides that your
can 'teach' your app to compress files when saving you might have a
'Bookmarks' menu from where you can select a readily defined method.

In essence you're defining a small lanugage to select a ressource (ergo
there's no language independence in your URI), but it is _very_ limited and
the user will have to program java (!) to make full use of it. What is easier
than "File open: '/home/mark/jos.txt'" or "Net get: 'www.jos.org/index.html'".
And what about authentication? I will certainly _not_ use a url to encode my
passwords, when accessing my firewall!

You'll be *speaking* to your open prompt.

Despite that and if you don't like ease of use and/or simplicity you can use
your old dialog - this can be done system wide by the appplication framework.

Regards, Mark



From digigod@earthling.net Fri, 06 Aug 1999 16:22:57 -0700
Date: Fri, 06 Aug 1999 16:22:57 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Embedded URI proposal

Mark Andreas Meyer wrote:
> No. You just have to tell the Archiver to decompress that file by "Archiver
> deCompress: '/some/file'". This is of course aesier (or at least it's equal)
> than reading some sort of strange non-standard URI format. Besides that your
> can 'teach' your app to compress files when saving you might have a
> 'Bookmarks' menu from where you can select a readily defined method.

firstly, its unusual but not non-standard. secondly, are you sugessting
that we have a smalltalk interpreter in JOS that apps send requests to?
(Im still not clear on what your talking about)
 
> In essence you're defining a small lanugage to select a ressource (ergo
> there's no language independence in your URI), but it is _very_ limited and
> the user will have to program java (!) to make full use of it. What is easier
> than "File open: '/home/mark/jos.txt'" or "Net get: 'www.jos.org/index.html'".
> And what about authentication? I will certainly _not_ use a url to encode my
> passwords, when accessing my firewall!

how is ubiquitous URI use get to be "have to program java"?

secondly an application get turn /home/mark/jos.txt into
file:/home/mark/jos.txt (or more likely: users/mark/home/jos.txt) and
send it to the URI server (when I say server I mean on the same computer
(although it doesnt have to be)) or send http://www.jos.org/index.html
to the URI server and get an input stream back. besides what about
outside an application where there is no context? this is for then.

the password in the URI is just part of the ftp url, it has nothing to
do with anything.
 
> You'll be *speaking* to your open prompt.
> 
> Despite that and if you don't like ease of use and/or simplicity you can use
> your old dialog - this can be done system wide by the appplication framework.

what application framework? explain.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Fri, 06 Aug 1999 21:31:49 -0400
Date: Fri, 06 Aug 1999 21:31:49 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Proposing archive: protocol

At 07:39 AM 8/6/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>x-registry: [archive: [http://www.jos.org/registry.jar]
>#/xml-registry] #/system/toggles/sound

That looks easy to read. It fits inside the HTML/XML format, too.

According to that URI RFC, you're officially supposed to encode a URI
that's embedded in another URI. In other words, they would like us to make
something like this:

http://www.jos.org/registry.jar
#archive%58%47xml-registry
%35x-registry%37%58%37%47system%37%47toggles%37%47sound

Note: I used decimal here instead of hex because I can't find my chart.

I would prefer an embedded URI scheme rather than encoding and
doubly-encoding URIs. The http: scheme comes first when establishing a
connection to a HTTP service. The client agent must (somehow) use the
fragment part to extract a registry from an archive and return a registry
iterator.




From digigod@earthling.net Fri, 06 Aug 1999 20:25:55 -0700
Date: Fri, 06 Aug 1999 20:25:55 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Proposing archive: protocol

Gilbert Carl Herschberger II wrote:
> That looks easy to read. It fits inside the HTML/XML format, too.

like many discoveries it was an accident, in this case typo :)
 
> According to that URI RFC, you're officially supposed to encode a URI
> that's embedded in another URI. In other words, they would like us to make
> something like this:
> 
> http://www.jos.org/registry.jar
> #archive%58%47xml-registry
> %35x-registry%37%58%37%47system%37%47toggles%37%47sound

ugh
 
> Note: I used decimal here instead of hex because I can't find my chart.

I havent seen mine since '86
 
> I would prefer an embedded URI scheme rather than encoding and
> doubly-encoding URIs. The http: scheme comes first when establishing a
> connection to a HTTP service. The client agent must (somehow) use the
> fragment part to extract a registry from an archive and return a registry
> iterator.

embedded is better, agreed. howz abouts a <code>String
toEncodedURI()</code> in the URI class? you can never go wrong with the
best of both worlds

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From hilarycheng@usa.net Sat, 07 Aug 1999 12:13:47 +0800
Date: Sat, 07 Aug 1999 12:13:47 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Arch] About Generic Driver

Hi,

    I would like to ask, is there any Generic Driver interface has been
defined ?
    Since I would like to build driver based on Thomas VGA Driver.

Regards,

Hilary




From onewith1@flash.net Sat, 7 Aug 1999 15:21:25 -0500
Date: Sat, 7 Aug 1999 15:21:25 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] About Generic Driver

Here was my first cut:

I divided the idea of a Driver into two pieces: a Device and a Driver.  The
Device knows how to configure the actual physical/virtual device, while the
Driver interfaces with the actual device to accomplish something.

I had each of these be Serializable for easy storing and restoring of the
system.  The Device interface would need to have a bean to control its
setup.  The Driver's methods can be discovered by reflection, or more
appropriately, a set of common abstract driver types should be defined which
are subclassed by the specific device writers, allowing for
pre-implementation of common functionality, and faster development time.

For instance, I pegged the video driver type to have a change mode method,
and a method to collect the java.awt.GraphicsContext for the different modes
(we may need a special method/context class for returning text modes).

------------

package jos.platform.device;


import jos.platform.hardwareResource.PrimaryHardwareManager;
import jos.platform.driver.Driver;


/**
 * Generic interface for a Device.  It handles the initial
 * discovery and setup of the actual device.
 *
 * @version 1.0
 * @author  Matt Albrecht
 */
public interface Device extends java.io.Serializable
{
   public Driver [] searchAndSetup( PrimaryHardwareManager phm );
   public String getName();
}


--------------

package jos.platform.driver;

/**
 * The Driver interface to a physical/virtual device.
 */
public interface Driver extends java.io.Serializable
{
  public String getName();
}


-Matt


-----Original Message-----
From: Hilary Cheng <hilarycheng@usa.net>
To: arch@jos.org <arch@jos.org>
Date: Friday, August 06, 1999 11:21 PM
Subject: [JOS-Arch] About Generic Driver


>Hi,
>
>    I would like to ask, is there any Generic Driver interface has been
>defined ?
>    Since I would like to build driver based on Thomas VGA Driver.
>
>Regards,
>
>Hilary
>
>
>_______________________________________________
>Arch maillist  -  Arch@jos.org
>http://jos.org/mailman/listinfo/arch
>
>




From digigod@earthling.net Sat, 07 Aug 1999 18:00:50 -0700
Date: Sat, 07 Aug 1999 18:00:50 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] About Generic Driver

Matt Albrecht wrote:
> I divided the idea of a Driver into two pieces: a Device and a Driver.  The
> Device knows how to configure the actual physical/virtual device, while the
> Driver interfaces with the actual device to accomplish something.

so JOS would know the ScannerDevice but the manufacturer would need to
provide a ScannerDriver
 
> I had each of these be Serializable for easy storing and restoring of the
> system.  The Device interface would need to have a bean to control its
> setup.  The Driver's methods can be discovered by reflection, or more
> appropriately, a set of common abstract driver types should be defined which
> are subclassed by the specific device writers, allowing for
> pre-implementation of common functionality, and faster development time.

reflection is good, but something like BeanInfo would be faster (of
course we need to do both)
 
> For instance, I pegged the video driver type to have a change mode method,
> and a method to collect the java.awt.GraphicsContext for the different modes
> (we may need a special method/context class for returning text modes).

it should be vetoable by the OS(|UI).

firstly its GraphicsConfiguration that your thinking of, and it should
be able to describe text mode (after reviewing the source)

> package jos.platform.device;
> 
> import jos.platform.hardwareResource.PrimaryHardwareManager;
> import jos.platform.driver.Driver;
> 
> /**
>  * Generic interface for a Device.  It handles the initial
>  * discovery and setup of the actual device.
>  *
>  * @version 1.0
>  * @author  Matt Albrecht
>  */
> public interface Device extends java.io.Serializable
> {
>    public Driver [] searchAndSetup( PrimaryHardwareManager phm );
>    public String getName();
> }

whats the PrimaryHardwareManager (and why's it primary? shouldnt it be
static HardwareManager PrimaryHardwareManager; in the HM class? with a
getPrimaryHardwareManager()?)

is name its device name? or its HRF name? (getHRName() also if its the
former), how about a getDescription() so a DeviceManager (config app)
can give some info.

what about some state info, like isLoaded(), isActive() or hasDriver()?

maybe a driver should plug into a device (setDriver(Driver d)) or can
there be more than one driver at a time?

> package jos.platform.driver;
> 
> /**
>  * The Driver interface to a physical/virtual device.
>  */
> public interface Driver extends java.io.Serializable
> {
>   public String getName();
> }

the same goes for this with the getDescription() and all... 

speaking of descriptions, whats this a driver for? how about: Device
getDevice()

some state info for this would be good too, like hasControlOfDevice()

You should also have an abstract DeviceAdaptor and DriverAdaptor for
faster impl.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From onewith1@flash.net Sun, 8 Aug 1999 13:41:28 -0500
Date: Sun, 8 Aug 1999 13:41:28 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] About Generic Driver

Once again, I prove that I can't get my point across in the first cut.

Also, it remindes me to remember to put up examples to help others as well
as myself understand the problem.


DigiGod wrote:


>Matt Albrecht wrote:
>> I divided the idea of a Driver into two pieces: a Device and a Driver.
The
>> Device knows how to configure the actual physical/virtual device, while
the
>> Driver interfaces with the actual device to accomplish something.
>
>so JOS would know the ScannerDevice but the manufacturer would need to
>provide a ScannerDriver

This was meant to separate the discovery/setup functionality from the
operational use.  Also, it enables the Device to store its state in a device
registry for easy recovery.  So, to answer your question: the ScannerDevice
would need a ScannerUSBDevice, ScannerSCSIDevice, ScannerParallelDevice, and
so on.  Each of these devices would subclass from the USBDevice, SCSIDevice,
&c, and implement the ScannerDeviceInterface (or possibly the other way
around - SCSIDevice is an interface, and ScannerDevice is a class.  I
haven't played around with this, so we'll have to see what works best).

When I wrote the KeyboardDevice, it had the discovery/setup code, as well as
the very basic methods to get scancodes from the device.  The KeyboardDriver
translated these scancodes into usable data.  So we could have a
ISAKeyboardDevice, linked to a ISAKeyboardTranslator (which translates
scancodes into VA_? keycodes; this is a "pass-through" driver), which is
linked to KeyboardPressedSet (monitors the press/release state of each VA_?
key) and USAKeyboardDriver (which translates the VA_? push/release keycodes
into uppercase, lowercase, special shift combinations, and num-pad character
creation).

So I guess we can look at a Device simplisticly as a standard I/O Device
which inputs a byte stream, and outputs a byte stream.  Of course,
specialized subclasses (like the KeyboardDevice, with its specialized
implementations) do a tad bit more than that.  Or maybe we could look at a
Device as either a stream device (like a hard drive), or as an event device
(like a keyboard or mouse), or as both (like a modem or ethernet card).

<snip>


>> For instance, I pegged the video driver type to have a change mode
method,
>> and a method to collect the java.awt.GraphicsContext for the different
modes
>> (we may need a special method/context class for returning text modes).
>
>it should be vetoable by the OS(|UI).

Yes!!!  Thus, we really will have bean devices!

>firstly its GraphicsConfiguration that your thinking of, and it should
>be able to describe text mode (after reviewing the source)

That was off the top of my head, so I'll take your word for it.

>whats the PrimaryHardwareManager (and why's it primary? shouldnt it be
>static HardwareManager PrimaryHardwareManager; in the HM class? with a
>getPrimaryHardwareManager()?)

Ah.  That was a beast unto itself.  That was my cut at handling platform
resources (like I/O Addresses, Memory, DMA, interrupts, and so on).  The
primary hardware manager handled routing the resource request to the
appropriate manager.  It was interesting in that it handled plug-n-play
well, where a device may request the best fit for a set of resources (for
instance, a Sound Blaster Pro needs one of IRQ 2, 5, 7, or 10).

I didn't use a static primary hardware manager, because I have a natural
aversion to using static data.  It leads to nasty situations where one
thread may need one kind of a class, and another thread needs a slightly
different class, or someone decides to use a different implementation in the
middle of runtime.  I was *especially* weary of this with a system level
variable.

>is name its device name? or its HRF name? (getHRName() also if its the
>former), how about a getDescription() so a DeviceManager (config app)
>can give some info.

Name for the Device would be the unique name for the device, such as PNP0600
(Generic ESDI/IDE/ATA hard disk controller), PNP0102 (MCA timers), and so
on.

>what about some state info, like isLoaded(), isActive() or hasDriver()?

Sure.  This was my first cut, where I wanted to leave it as open as
possible.  I would say isLoaded() is the only one really necessary.

>maybe a driver should plug into a device (setDriver(Driver d)) or can
>there be more than one driver at a time?

I was pondering the other direction: MyDriver.setDevice( Device d ) so that
multiple drivers can use a single device.  Here's where Device.veto() would
come in handy, to prevent its use.  This would allow real-time upgrades to a
better Driver.


<snip Driver.java>
>the same goes for this with the getDescription() and all...

getDescription would be a human-readable string to indicate the operation of
the Driver.  We could use this method as well in the Device.

>speaking of descriptions, whats this a driver for? how about: Device
>getDevice()?
>some state info for this would be good too, like hasControlOfDevice()

Good points.

>You should also have an abstract DeviceAdaptor and DriverAdaptor for
>faster impl.

You mean like java.awt.WindowAdapter which is a concrete class
implementation of java.awt.WindowListener?  Good idea.


-Matt




From ryan@whitewolf.com.au Mon, 09 Aug 1999 11:01:44 +1000
Date: Mon, 09 Aug 1999 11:01:44 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] URI?

scode@scode.webprovider.com wrote:

> Just a quick question: what does "URI" stand for anyway? The discussion has
> been going on long enough for me to really want to know :)

There are URLs (which you're familiar with), and URNs (Uniform Resource
Name) which are like URLs but without a machine name. So, you say I want
resource /software/graphics/gimp.tar.gz and it doesn't matter to you
what machine it gets it from.

URI is the superset of both of these. AFAIK, URNs are not used by
anyone, yet.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From ryan@whitewolf.com.au Mon, 09 Aug 1999 11:23:25 +1000
Date: Mon, 09 Aug 1999 11:23:25 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Re: [JOS-Kernel] the vga driver is working now

Hilary Cheng wrote:

> I think we should use CVS. But I donno how to operate the CVS and we got
> no right to access current JJOS CVS.

Basically, if you want write access to the JJOS module, John Morrison or
_Quinn/Todd can give you authorization.

You should simply send a request to admin@jos.org and the appropriate
module maintainer will respond to you.

The process will become more organised in the future when we set up a
web interface.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From hilarycheng@usa.net Mon, 09 Aug 1999 09:00:31 +0800
Date: Mon, 09 Aug 1999 09:00:31 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Arch] Graphics Drivers (Re: [JOS-Kernel] the vga

Hi,

    Hm, I am thinking about it. Should we put Graphics Drver under JJOS ? or
we create a new
cvs entry for Graphics Driver ?

Regards,

Hilary

Ryan Heise wrote:

> Hilary Cheng wrote:
>
> > I think we should use CVS. But I donno how to operate the CVS and we got
> > no right to access current JJOS CVS.
>
> Basically, if you want write access to the JJOS module, John Morrison or
> _Quinn/Todd can give you authorization.
>
> You should simply send a request to admin@jos.org and the appropriate
> module maintainer will respond to you.
>
> The process will become more organised in the future when we set up a
> web interface.
>
> --
> Ryan Heise
>
> http://www.progsoc.uts.edu.au/~rheise/




From hilarycheng@usa.net Mon, 09 Aug 1999 09:23:34 +0800
Date: Mon, 09 Aug 1999 09:23:34 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Arch] About Generic Driver

Hi,

    Writing a good Generic Driver Model in i386-pc is very hard. IMO, I would
better to keep
all the drivers as simple as they can. We can divided PC Device in two catalogs.

1. Stream and Event Type Driver ( Keyboard, HD, Floppy, etc )
2. Non-Stream Type Driver ( Graphics Adaptor )

Since HD can have event from DMA Processor. Keyboard and Mouse also can be a
stream.
So I would like to join these into same group. For Graphics Adaptor, it is a
Memory/IO/IRQ
Device. But it would not be a stream type driver.

For those isLoaded(), hasDriver() methods, these methods should be put it into a
Generic
Device Manager to control how many instances should be keep. If we put these
things to
driver and let them to control it, it would be little bit dangerous.

For autodetection mechianism, should we put it into generic driver spec. ? it
depends. We
can divided PC Devices into three catalogs :
1. USB Device -- A USB Manager can auto-detect all the things.
2. COM, PARALLEL, IDE, SCSI -- These devices got well defined auto-detect
mechianism, it can
put  it into a generic device manager to handle it.
3. PC-Card like network card , sound card, etc -- These devices are complicated.
Auto-Detection mechianism maybe make the computer hangs. It would be better to
put auto-detect mechianism into
driver itself.

Regards,

Hilary

Matt Albrecht wrote:

> Once again, I prove that I can't get my point across in the first cut.
>
> Also, it remindes me to remember to put up examples to help others as well
> as myself understand the problem.
>
> DigiGod wrote:
>
> >Matt Albrecht wrote:
> >> I divided the idea of a Driver into two pieces: a Device and a Driver.
> The
> >> Device knows how to configure the actual physical/virtual device, while
> the
> >> Driver interfaces with the actual device to accomplish something.
> >
> >so JOS would know the ScannerDevice but the manufacturer would need to
> >provide a ScannerDriver
>
> This was meant to separate the discovery/setup functionality from the
> operational use.  Also, it enables the Device to store its state in a device
> registry for easy recovery.  So, to answer your question: the ScannerDevice
> would need a ScannerUSBDevice, ScannerSCSIDevice, ScannerParallelDevice, and
> so on.  Each of these devices would subclass from the USBDevice, SCSIDevice,
> &c, and implement the ScannerDeviceInterface (or possibly the other way
> around - SCSIDevice is an interface, and ScannerDevice is a class.  I
> haven't played around with this, so we'll have to see what works best).
>
> When I wrote the KeyboardDevice, it had the discovery/setup code, as well as
> the very basic methods to get scancodes from the device.  The KeyboardDriver
> translated these scancodes into usable data.  So we could have a
> ISAKeyboardDevice, linked to a ISAKeyboardTranslator (which translates
> scancodes into VA_? keycodes; this is a "pass-through" driver), which is
> linked to KeyboardPressedSet (monitors the press/release state of each VA_?
> key) and USAKeyboardDriver (which translates the VA_? push/release keycodes
> into uppercase, lowercase, special shift combinations, and num-pad character
> creation).
>
> So I guess we can look at a Device simplisticly as a standard I/O Device
> which inputs a byte stream, and outputs a byte stream.  Of course,
> specialized subclasses (like the KeyboardDevice, with its specialized
> implementations) do a tad bit more than that.  Or maybe we could look at a
> Device as either a stream device (like a hard drive), or as an event device
> (like a keyboard or mouse), or as both (like a modem or ethernet card).
>
> <snip>
>
> >> For instance, I pegged the video driver type to have a change mode
> method,
> >> and a method to collect the java.awt.GraphicsContext for the different
> modes
> >> (we may need a special method/context class for returning text modes).
> >
> >it should be vetoable by the OS(|UI).
>
> Yes!!!  Thus, we really will have bean devices!
>
> >firstly its GraphicsConfiguration that your thinking of, and it should
> >be able to describe text mode (after reviewing the source)
>
> That was off the top of my head, so I'll take your word for it.
>
> >whats the PrimaryHardwareManager (and why's it primary? shouldnt it be
> >static HardwareManager PrimaryHardwareManager; in the HM class? with a
> >getPrimaryHardwareManager()?)
>
> Ah.  That was a beast unto itself.  That was my cut at handling platform
> resources (like I/O Addresses, Memory, DMA, interrupts, and so on).  The
> primary hardware manager handled routing the resource request to the
> appropriate manager.  It was interesting in that it handled plug-n-play
> well, where a device may request the best fit for a set of resources (for
> instance, a Sound Blaster Pro needs one of IRQ 2, 5, 7, or 10).
>
> I didn't use a static primary hardware manager, because I have a natural
> aversion to using static data.  It leads to nasty situations where one
> thread may need one kind of a class, and another thread needs a slightly
> different class, or someone decides to use a different implementation in the
> middle of runtime.  I was *especially* weary of this with a system level
> variable.
>
> >is name its device name? or its HRF name? (getHRName() also if its the
> >former), how about a getDescription() so a DeviceManager (config app)
> >can give some info.
>
> Name for the Device would be the unique name for the device, such as PNP0600
> (Generic ESDI/IDE/ATA hard disk controller), PNP0102 (MCA timers), and so
> on.
>
> >what about some state info, like isLoaded(), isActive() or hasDriver()?
>
> Sure.  This was my first cut, where I wanted to leave it as open as
> possible.  I would say isLoaded() is the only one really necessary.
>
> >maybe a driver should plug into a device (setDriver(Driver d)) or can
> >there be more than one driver at a time?
>
> I was pondering the other direction: MyDriver.setDevice( Device d ) so that
> multiple drivers can use a single device.  Here's where Device.veto() would
> come in handy, to prevent its use.  This would allow real-time upgrades to a
> better Driver.
>
> <snip Driver.java>
> >the same goes for this with the getDescription() and all...
>
> getDescription would be a human-readable string to indicate the operation of
> the Driver.  We could use this method as well in the Device.
>
> >speaking of descriptions, whats this a driver for? how about: Device
> >getDevice()?
> >some state info for this would be good too, like hasControlOfDevice()
>
> Good points.
>
> >You should also have an abstract DeviceAdaptor and DriverAdaptor for
> >faster impl.
>
> You mean like java.awt.WindowAdapter which is a concrete class
> implementation of java.awt.WindowListener?  Good idea.
>
> -Matt




From digigod@earthling.net Sun, 08 Aug 1999 21:32:36 -0700
Date: Sun, 08 Aug 1999 21:32:36 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] URI?

Ryan Heise wrote:

  URI
  / \
URN URL

> There are URLs (which you're familiar with), and URNs (Uniform Resource
> Name) which are like URLs but without a machine name. So, you say I want
> resource /software/graphics/gimp.tar.gz and it doesn't matter to you
> what machine it gets it from.
> 
> URI is the superset of both of these. AFAIK, URNs are not used by
> anyone, yet.

I thought it was the other way around, that URN was /just/ the machine
name (hence the 'N' for name).

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Sun, 08 Aug 1999 21:52:32 -0700
Date: Sun, 08 Aug 1999 21:52:32 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] About Generic Driver

Matt Albrecht wrote:
> Once again, I prove that I can't get my point across in the first cut.

"If you get it right the first time, you probably dont know what your
doing" --I try to keep that one close to heart as they say
 
> This was meant to separate the discovery/setup functionality from the
> operational use.  Also, it enables the Device to store its state in a device
> registry for easy recovery.  So, to answer your question: the ScannerDevice
> would need a ScannerUSBDevice, ScannerSCSIDevice, ScannerParallelDevice, and
> so on.  Each of these devices would subclass from the USBDevice, SCSIDevice,
> &c, and implement the ScannerDeviceInterface (or possibly the other way
> around - SCSIDevice is an interface, and ScannerDevice is a class.  I
> haven't played around with this, so we'll have to see what works best).

my experience would say that having SCSIDevice and the lot as interfaces
would save the most code/space/time/soda. and from an OO perspective it
makes the most sense (it IS-A ScannerDevice and it IS-A SCSIDevice in
this scenario, otherwise it would just be a SCSIDevice)
 
> When I wrote the KeyboardDevice, it had the discovery/setup code, as well as
> the very basic methods to get scancodes from the device.  The KeyboardDriver
> translated these scancodes into usable data.  So we could have a
> ISAKeyboardDevice, linked to a ISAKeyboardTranslator (which translates
> scancodes into VA_? keycodes; this is a "pass-through" driver), which is
> linked to KeyboardPressedSet (monitors the press/release state of each VA_?
> key) and USAKeyboardDriver (which translates the VA_? push/release keycodes
> into uppercase, lowercase, special shift combinations, and num-pad character
> creation).

brilliant, brilliant; yes, I understand now
 
> So I guess we can look at a Device simplisticly as a standard I/O Device
> which inputs a byte stream, and outputs a byte stream.  Of course,
> specialized subclasses (like the KeyboardDevice, with its specialized
> implementations) do a tad bit more than that.  Or maybe we could look at a
> Device as either a stream device (like a hard drive), or as an event device
> (like a keyboard or mouse), or as both (like a modem or ethernet card).

my only xprnc with device drivers is MS-DOS (and an article I read on
OS/2 dd's but I dont remember any of it), there you either have a
charecter device (a kbd) or a block device (a serial port). In Java both
would be streams, I think we should do that, leave it to the driver to
generate the events.

> >whats the PrimaryHardwareManager (and why's it primary? shouldnt it be
> >static HardwareManager PrimaryHardwareManager; in the HM class? with a
> >getPrimaryHardwareManager()?)
> 
> Ah.  That was a beast unto itself.  That was my cut at handling platform
> resources (like I/O Addresses, Memory, DMA, interrupts, and so on).  The
> primary hardware manager handled routing the resource request to the
> appropriate manager.  It was interesting in that it handled plug-n-play
> well, where a device may request the best fit for a set of resources (for
> instance, a Sound Blaster Pro needs one of IRQ 2, 5, 7, or 10).
> 
> I didn't use a static primary hardware manager, because I have a natural
> aversion to using static data.  It leads to nasty situations where one
> thread may need one kind of a class, and another thread needs a slightly
> different class, or someone decides to use a different implementation in the
> middle of runtime.  I was *especially* weary of this with a system level
> variable.

understandable, if not slightly confusing...

I cant think of how to word what I want to say so Im going to give you
this awkardly abbriviated class instead:

public class HardwareManager {
 private static HardwareManager primary;

 static {
  primary = createHardwareManager();
 }
 
 public static HardwareManager getPrimaryHardwareManager() {
  return primary;
 }

 public static HardwareManager createHardwareManager() {
  return new HardwareManager();
 }

 public static void setPrimaryHardwareManager(HardwareManager hm) {
  if(hm==null)
   return;
  synchronized(primary) {
   primary = hm;
  }
 }

 private HardwareManager() {
  super();
 }
}

I dont know if thats what you mean in the way I think or not. agh, I
dont know what I just said
 
> >is name its device name? or its HRF name? (getHRName() also if its the
> >former), how about a getDescription() so a DeviceManager (config app)
> >can give some info.
> 
> Name for the Device would be the unique name for the device, such as PNP0600
> (Generic ESDI/IDE/ATA hard disk controller), PNP0102 (MCA timers), and so
> on.

so getName() is for the computer
 
> >what about some state info, like isLoaded(), isActive() or hasDriver()?
> 
> Sure.  This was my first cut, where I wanted to leave it as open as
> possible.  I would say isLoaded() is the only one really necessary.

agreed
 
> >maybe a driver should plug into a device (setDriver(Driver d)) or can
> >there be more than one driver at a time?
> 
> I was pondering the other direction: MyDriver.setDevice( Device d ) so that
> multiple drivers can use a single device.  Here's where Device.veto() would
> come in handy, to prevent its use.  This would allow real-time upgrades to a
> better Driver.
> 
> <snip Driver.java>
> >the same goes for this with the getDescription() and all...
> 
> getDescription would be a human-readable string to indicate the operation of
> the Driver.  We could use this method as well in the Device.

you should have a getDescription() and a getHRName(), if you make a tree
of all of them you need getHRName for the name on the tree node, PNP6000
(or whatever) will hardly make sense to the average person.

or better yet getName() is the HR one and you have a
get[Device|Driver]Name() for the ID
 
> >speaking of descriptions, whats this a driver for? how about: Device
> >getDevice()?
> >some state info for this would be good too, like hasControlOfDevice()
> 
> Good points.
> 
> >You should also have an abstract DeviceAdaptor and DriverAdaptor for
> >faster impl.
> 
> You mean like java.awt.WindowAdapter which is a concrete class
> implementation of java.awt.WindowListener?  Good idea.

exactly.

this is one of the things I love about Java, I am absolutely clueless
when it comes to devices and their drivers but I can still help out

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From tmiller@haverford.edu Mon, 9 Aug 1999 07:30:23 -0400 (EDT)
Date: Mon, 9 Aug 1999 07:30:23 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] About Generic Driver

	Has there been any consideration given to using the JavaOS for
Business APIs?  We can always change them later, if we discover they don't
work, but it saves us a tremendous amount of design time now if you want
to get started on generic drivers...

-_Quinn




From onewith1@flash.net Mon, 9 Aug 1999 20:02:04 -0500
Date: Mon, 9 Aug 1999 20:02:04 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] About Generic Driver

This is a big cut-n-paste job responding to lots of good ideas brought
forward.


_Quinn wrote:
>Has there been any consideration given to using the JavaOS for
>Business APIs?  We can always change them later, if we discover they don't
>work, but it saves us a tremendous amount of design time now if you want
>to get started on generic drivers...

JavaOS had good ideas in the way of structuring their device drivers so they
hung off of base drivers, but I recall that when I looked over them about a
year ago, something about them just didn't click well with me.  Maybe I'm
just too jaded (no pun intended) and I prefer to reinvent the wheel.


Hilary Cheng wrote:
>   Writing a good Generic Driver Model in i386-pc is very hard. IMO, I
would
>better to keep
>all the drivers as simple as they can. We can divided PC Device in two
catalogs.
>
>1. Stream and Event Type Driver ( Keyboard, HD, Floppy, etc )
>2. Non-Stream Type Driver ( Graphics Adaptor )
>
>Since HD can have event from DMA Processor. Keyboard and Mouse also can >be
a stream.
>So I would like to join these into same group. For Graphics Adaptor, it is
a
>Memory/IO/IRQ Device. But it would not be a stream type driver.

So, then the absolute Generic Device is a non-stream, then an immediate (or
close to immediate) subclass would be Stream Device and Event Device?  Works
for me.

>For those isLoaded(), hasDriver() methods, these methods should be put it
into a
>Generic Device Manager to control how many instances should be keep. If we
put
>these things to driver and let them to control it, it would be little bit
dangerous.

hasDriver() *may* be appropriate for many devices (like HardDrive device - I
wouldn't like multiple drivers, unaware of each other, messing around at
low-level at the same time, but I don't care how many drivers listen to the
MouseDevice).  isLoaded(), I feel, may be a reiterative method: if the
Driver can find the device, it has been loaded.  Or maybe I'm not seeing
something with this.  I dunno.

>For autodetection mechianism, should we put it into generic driver spec. ?
it
>depends.

Auto-detection is a crazy thing.  Plug-n-play, USB, and many other "smart"
bus devices are easily detected.  But we don't want to load every known
plug-n-play device or driver into memory just to find out that we have a
"PCI Bridge" device.  This kind of detection needs to be oriented to the
"PCIDevice", which, although this Device can't be directly implemented in a
Driver as it has no real use outside detection, is solely responsible for
checking the PCI bus for devices, and telling the system of their existence.
This is where the Device Tree comes into effect.  JavaOS and Windoze 9x have
this tree, although they implement it far differently.

For devices which are not inherently auto-detectable, like legacy ISA cards,
parallel port daisy-chain attachments, and so on, we *do* need to load every
device into memory to check for its existence.  More practically, we can
load a virtual device (similar to our PCIDevice above) which is aware of
many of the devices which can be attached to itself, and it handles the
detection, or loads another device to do more detection.  As a last resort,
we can have the user as a kind of device to manually tell the system that a
device exists.

All in all, I believe that the detection and setup should be done at the
device level.  That was my initial intention in creating this separation
between the driver and the device.


DigiGod wrote:
>my only xprnc with device drivers is MS-DOS (and an article I read on
>OS/2 dd's but I dont remember any of it), there you either have a
>charecter device (a kbd) or a block device (a serial port). In Java both
>would be streams, I think we should do that, leave it to the driver to
>generate the events.

See Hilary's response above.

>> >whats the PrimaryHardwareManager (and why's it primary? shouldnt it be
>> >static HardwareManager PrimaryHardwareManager; in the HM class? with a
>> >getPrimaryHardwareManager()?)
>
<snip>
>
>I cant think of how to word what I want to say so Im going to give you
>this awkardly abbriviated class instead:
>
<snip>
>
>I dont know if thats what you mean in the way I think or not. agh, I
>dont know what I just said

Ok.  Last time.  This is your class.  This is your class on JOS.  Any
questions?  But seriously, here's snippets from my old code for a clearer
statement, followed by an overview of the design:

*** WARNING *** The following text has extremely long class names.


/**
 * <P>Manages all hardware managers for a particular bus.  Each
 * HardwareRequest is assumed to be sent for a particular
 * HardwareResourceManager, so that a request
 * does not mix different kinds of resources together.  This may be changed
later
 * on if a need (or want) arises, but for now it is the easiest way to do
things.
 *
 * @author    Matt Albrecht
 * @version   1.0
 */
public class PrimaryHardwareManager extends HardwareResourceManager;

/**
 * <P>Allocates and deallocates hardware resources for a specific type of
 * resource.  Checks if the resource allocation requests request already
allocated
 *  resources :-)   (it's a pseudo-palendrome)
 *
 * <P>A unique "type" name needs to created, under the name _typeName:
 * <PRE>
 *       public final static String _typeName = "MyUniqueTypeName"
 * </PRE>
 * Usually, this is the same as the class name.
 *
 * @author    Matt Albrecht
 * @version   1.0
 */
public abstract class HardwareResourceManager;


In this model, a "HardwareResourceRequest" is sent to the
PrimaryHardwareResourceManager (to which every known specific
HardwareResourceManager has registered itself with, or more accurately, the
PrimaryHardwareResourceManager has registered all known
HardwareResourceManagers to itself).  A request consists of a set of
"HardwareResourceSetting"s dedicated for a specific HardwareResourceManager
(like IOAddressHardwareResourceSetting is intended for
IOAddressHardwareResourceManager).  The PrimaryHardwareResourceManager
routes the request to the specific HardwareResourceManager, which analyzes
the request, and allocates the best fit HardwareResourceSetting (if there is
one), and creates a HardwareResourceInterface based on that setting for the
Driver to use.  This interface has the native code ties.

Is it any wonder no one volunteered to use it?

<snip>

>> >maybe a driver should plug into a device (setDriver(Driver d)) or can
>> >there be more than one driver at a time?
>>
>> I was pondering the other direction: MyDriver.setDevice( Device d ) so
that
>> multiple drivers can use a single device.  Here's where Device.veto()
would
>> come in handy, to prevent its use.  This would allow real-time upgrades
to a
>> better Driver.
>>
>> <snip Driver.java>
>> >the same goes for this with the getDescription() and all...
>>
>> getDescription would be a human-readable string to indicate the operation
of
>> the Driver.  We could use this method as well in the Device.
>
>you should have a getDescription() and a getHRName(), if you make a tree
>of all of them you need getHRName for the name on the tree node, PNP6000
>(or whatever) will hardly make sense to the average person.
>
>or better yet getName() is the HR one and you have a
>get[Device|Driver]Name() for the ID

Great.  After typing those enormous class names above, I'll believe
anything.  But really, that sounds like the way to go.

>this is one of the things I love about Java, I am absolutely clueless
>when it comes to devices and their drivers but I can still help out

Hey, this is a better kibitz turnout than when I first coded the beast.
Keep up the flames!

-Matt






From ryan@whitewolf.com.au Tue, 10 Aug 1999 12:51:43 +1000
Date: Tue, 10 Aug 1999 12:51:43 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] URI?

DigiGod Q Frasché wrote:
> 
> Ryan Heise wrote:
> 
>   URI
>   / \
> URN URL
> 
> > There are URLs (which you're familiar with), and URNs (Uniform Resource
> > Name) which are like URLs but without a machine name. So, you say I want
> > resource /software/graphics/gimp.tar.gz and it doesn't matter to you
> > what machine it gets it from.
> >
> > URI is the superset of both of these. AFAIK, URNs are not used by
> > anyone, yet.
> 
> I thought it was the other way around, that URN was /just/ the machine
> name (hence the 'N' for name).

'N' does stand for Name. But 'R' also stands for Resource. Together,
they make "Resource Name", where "Resource" is the key adjective. Now
resources refer to things like files, web pages, database servers etc.
All of these resources can sit on a single machine. It is the resource
on the machine that you are after. The disadvantage of URLs is that you
have to know which machine the resource is on. ie. you have to locate it
on the network, hence Uniform Resource "Locator". Uniform Resource Names
are useful when the machine is irrelevant.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From digigod@earthling.net Mon, 09 Aug 1999 20:01:53 -0700
Date: Mon, 09 Aug 1999 20:01:53 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] About Generic Driver

Matt Albrecht wrote:
> Hilary Cheng wrote:
> >   Writing a good Generic Driver Model in i386-pc is very hard. IMO, I
> would
> >better to keep
> >all the drivers as simple as they can. We can divided PC Device in two
> catalogs.
> >
> >1. Stream and Event Type Driver ( Keyboard, HD, Floppy, etc )
> >2. Non-Stream Type Driver ( Graphics Adaptor )
> >
> >Since HD can have event from DMA Processor. Keyboard and Mouse also can >be
> a stream.
> >So I would like to join these into same group. For Graphics Adaptor, it is
> a
> >Memory/IO/IRQ Device. But it would not be a stream type driver.
> 
> So, then the absolute Generic Device is a non-stream, then an immediate (or
> close to immediate) subclass would be Stream Device and Event Device?  Works
> for me.

Device
 |
StreamDevice

but why event device? wouldnt it be more economical for the drivers to
produce events?
like the mouse event has a hasMoved() function the device waits for,
when it reads positive it creates the event; a different driver could
create a different event
 
> >For those isLoaded(), hasDriver() methods, these methods should be put it
> into a
> >Generic Device Manager to control how many instances should be keep. If we
> put
> >these things to driver and let them to control it, it would be little bit
> dangerous.
> 
> hasDriver() *may* be appropriate for many devices (like HardDrive device - I
> wouldn't like multiple drivers, unaware of each other, messing around at
> low-level at the same time, but I don't care how many drivers listen to the
> MouseDevice).  isLoaded(), I feel, may be a reiterative method: if the
> Driver can find the device, it has been loaded.  Or maybe I'm not seeing
> something with this.  I dunno.

hasDriver could throw OperationUnsupportedException or it could be in a
UniDriver interface (horrid name, but you get the idea).

couldnt isLoaded() be for a device like a zip drive that you can plug
and unplug at runtime, for speed the user sets it up to always have the
device loaded (since he only takes it off to transfer data on a friends
computer, for an example)
 
> Ok.  Last time.  This is your class.  This is your class on JOS.  Any
> questions?  But seriously, here's snippets from my old code for a clearer
> statement, followed by an overview of the design:
> 
> *** WARNING *** The following text has extremely long class names.
> 
> /**
>  * <P>Manages all hardware managers for a particular bus.  Each
>  * HardwareRequest is assumed to be sent for a particular
>  * HardwareResourceManager, so that a request
>  * does not mix different kinds of resources together.  This may be changed
> later
>  * on if a need (or want) arises, but for now it is the easiest way to do
> things.
>  *
>  * @author    Matt Albrecht
>  * @version   1.0
>  */
> public class PrimaryHardwareManager extends HardwareResourceManager;
> 
> /**
>  * <P>Allocates and deallocates hardware resources for a specific type of
>  * resource.  Checks if the resource allocation requests request already
> allocated
>  *  resources :-)   (it's a pseudo-palendrome)
>  *
>  * <P>A unique "type" name needs to created, under the name _typeName:
>  * <PRE>
>  *       public final static String _typeName = "MyUniqueTypeName"
>  * </PRE>
>  * Usually, this is the same as the class name.
>  *
>  * @author    Matt Albrecht
>  * @version   1.0
>  */
> public abstract class HardwareResourceManager;
> 
> In this model, a "HardwareResourceRequest" is sent to the
> PrimaryHardwareResourceManager (to which every known specific
> HardwareResourceManager has registered itself with, or more accurately, the
> PrimaryHardwareResourceManager has registered all known
> HardwareResourceManagers to itself).  A request consists of a set of
> "HardwareResourceSetting"s dedicated for a specific HardwareResourceManager
> (like IOAddressHardwareResourceSetting is intended for
> IOAddressHardwareResourceManager).  The PrimaryHardwareResourceManager
> routes the request to the specific HardwareResourceManager, which analyzes
> the request, and allocates the best fit HardwareResourceSetting (if there is
> one), and creates a HardwareResourceInterface based on that setting for the
> Driver to use.  This interface has the native code ties.
> 
> Is it any wonder no one volunteered to use it?

I think my brain melted, jeez
 
> >> >maybe a driver should plug into a device (setDriver(Driver d)) or can
> >> >there be more than one driver at a time?
> >>
> >> I was pondering the other direction: MyDriver.setDevice( Device d ) so
> that
> >> multiple drivers can use a single device.  Here's where Device.veto()
> would
> >> come in handy, to prevent its use.  This would allow real-time upgrades
> to a
> >> better Driver.
> >>
> >> <snip Driver.java>
> >> >the same goes for this with the getDescription() and all...
> >>
> >> getDescription would be a human-readable string to indicate the operation
> of
> >> the Driver.  We could use this method as well in the Device.
> >
> >you should have a getDescription() and a getHRName(), if you make a tree
> >of all of them you need getHRName for the name on the tree node, PNP6000
> >(or whatever) will hardly make sense to the average person.
> >
> >or better yet getName() is the HR one and you have a
> >get[Device|Driver]Name() for the ID
> 
> Great.  After typing those enormous class names above, I'll believe
> anything.  But really, that sounds like the way to go.

be easier for creating a visual device tree at the very least...

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From onewith1@flash.net Tue, 10 Aug 1999 19:07:37 -0500
Date: Tue, 10 Aug 1999 19:07:37 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Re: [JOS-Kernel] Priority List

-----Original Message-----
From: Todd L. Miller <tmiller@haverford.edu>
To: kernel@jos.org <kernel@jos.org>
Cc: jm@mak.com <jm@mak.com>
Date: Tuesday, August 10, 1999 5:02 PM
Subject: Re: [JOS-Kernel] Priority List


>> Here follows the tentative list, pending updates based upon feedback.
>> Please reply to the list, so that everybody knows what's going on.
>>
>> (1) Memory management.
>> (2) Performance.
>
>(3)  Deciding what to tell the architecture list, now that they've decided
>to try and design a driver system without involving the kernel list.
>
>-_Quinn

Ok, I'm at fault for this.  I moved the discussion over to "Arch" since the
driver "architecture" doesn't directly relate to the kernel (but, my! the
implications it has!).

Actually, for Device architecture (from a nearly nieve perspective), I see
only two major hooks needed to join the kernel to the drivers:
   (1) Pat down the hardware resource interface to a point where somebody is
truly satisfied.  This is critical for both groups, but doesn't affect many
people beyond us.
   (2) Create a hook where the devices can detect and install themselves.
This is basically the "main" method of the OS, I feel (though it could be
something else too).  This is also a link into the registry and other cans
of worms.  But still, the kernel group (I feel) need only be conserned with
the "main" routine link.  If I'm not mistaken, this already exists.

Anyone see any oversights, or simplification of the real problem?

-Matt




From onewith1@flash.net Tue, 10 Aug 1999 19:43:04 -0500
Date: Tue, 10 Aug 1999 19:43:04 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] About Generic Driver

DigiGod wrote:

>
>Device
> |
>StreamDevice
>
>but why event device? wouldnt it be more economical for the drivers to
>produce events?
>like the mouse event has a hasMoved() function the device waits for,
>when it reads positive it creates the event; a different driver could
>create a different event

The Mouse device will be setup to have an IRQ callback.  This is a type of
event.  So why not let the mouse device translate this event into a mouse
event, and fire it to the registered Drivers? (That's a retorical question -
I'll try to answer it below)

Using your method above, a mouse device would need to set the event, then
notify() all waiting drivers.  This is friendly for multi-threaded
applications, where the drivers can execute their mouse event in their own
thread.  I don't know if you remember the discussion on the Kernel list when
we were trying to figure out how to handle Interrupts.  Originally, IRQ
listeners would do a:
       synchronized( interrupt12 ) {
          interrupt12.wait();
       }
And they would wake up when the interrupt occured.  The problem was that
(with the keyboard), this routine quickly encountered a deadlock.

The alternate method is to have the "wait queue", which is a event queue
where the queue performs a wait if it is empty on a request to retrieve the
next element.  This is probably the way to go in a device/driver interface.
The wait queue would be a shared object between the device and the driver.
The device would need to keep one queue per registered driver, if multiple
driver registration is supported.

>> hasDriver() *may* be appropriate for many devices (like HardDrive
device - I
>> wouldn't like multiple drivers, unaware of each other, messing around at
>> low-level at the same time, but I don't care how many drivers listen to
the
>> MouseDevice).  isLoaded(), I feel, may be a reiterative method: if the
>> Driver can find the device, it has been loaded.  Or maybe I'm not seeing
>> something with this.  I dunno.
>
>hasDriver could throw OperationUnsupportedException or it could be in a
>UniDriver interface (horrid name, but you get the idea).

I'm crossed on this.  If we could implement both at the same time, I'd be
happy 8-)

>
>couldnt isLoaded() be for a device like a zip drive that you can plug
>and unplug at runtime, for speed the user sets it up to always have the
>device loaded (since he only takes it off to transfer data on a friends
>computer, for an example)

Hot-swappable devices?  I thought that JavaOS did a good job with this.
When a device was disconnected, it sent an event to all listening drivers to
say, "Hey, I'm gone.  You're on your own."  The drivers then figure out how
to handle this problem.

In this way, devices are not in the system for registration purposes.  There
is a problem with this in the way of Java's garbage collection, but, again,
JavaOS handled it well.  I won't go into detail how they did it, unless you
*really* want me to.

>> In this model, a "HardwareResourceRequest" is sent to the
>> PrimaryHardwareResourceManager (to which every known specific
>> HardwareResourceManager has registered itself with, or more accurately,
the
>> PrimaryHardwareResourceManager has registered all known
>> HardwareResourceManagers to itself).  A request consists of a set of
>> "HardwareResourceSetting"s dedicated for a specific
HardwareResourceManager
>> (like IOAddressHardwareResourceSetting is intended for
>> IOAddressHardwareResourceManager).  The PrimaryHardwareResourceManager
>> routes the request to the specific HardwareResourceManager, which
analyzes
>> the request, and allocates the best fit HardwareResourceSetting (if there
is
>> one), and creates a HardwareResourceInterface based on that setting for
the
>> Driver to use.  This interface has the native code ties.
>>
>> Is it any wonder no one volunteered to use it?
>
>I think my brain melted, jeez

Exactly.  But I haven't been able to come up with a simpler example, besides
letting the driver send a series of requests to the manager until a hardware
configuration turns up good.  That may be the way to go.

>> >you should have a getDescription() and a getHRName(), if you make a tree
>> >of all of them you need getHRName for the name on the tree node, PNP6000
>> >(or whatever) will hardly make sense to the average person.
>> >
>> >or better yet getName() is the HR one and you have a
>> >get[Device|Driver]Name() for the ID
>>
>> Great.  After typing those enormous class names above, I'll believe
>> anything.  But really, that sounds like the way to go.
>
>be easier for creating a visual device tree at the very least...

Sounds useful.  Let's do it.

-Matt




From gchii@mindspring.com Tue, 10 Aug 1999 22:13:46 -0400
Date: Tue, 10 Aug 1999 22:13:46 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

What is a program? Any object can act like a program. Here is the Program
interface:

public interface Program
    extends Runnable {
  public void setProgramContext( ProgramContext v );
}

What is a program context? First, the host environment must be able to pass
"parameters" to a program. A program is free to ignore all parameters.
Second, a program must be able to pass a result code to the host
environment. All of the processing in the program is summed up in a single
integer, a result code.

public interface ProgramContext {
  public void getParameter( int index );
  public void getValue( String key );
  public Enumeration getParameters();
  public void setResultCode( int v );
}

The host environment creates a new program context with a default result
code of zero (0) for "no failure". The host environment configures the
program context with parameters and passes it to a new program, using
setProgramContext(). The host environment uses the Runnable interface to
run the program. When the program is finished running, the host environment
can examine the result code. The host environment must catch any runtime
exceptions thrown from inside a program's run() method.

A program is not a process. It does not have its own System.in, System.out,
and System.err. It is a well-defined interface.




From gchii@mindspring.com Tue, 10 Aug 1999 22:02:53 -0400
Date: Tue, 10 Aug 1999 22:02:53 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Event-driven devices

At the lowest level, we should be using an event model. Interrupts are part
of the oldest event model. An interrupt is an event. An interrupt service
routine (ISR) is an event listener. A hardware interrupt is an asynchronous
hardware event. A software interrupt is modeled after a hardware interrupt
to merge hardware and software into a unified event model.

Many events are processed by your computer in order to provide you a stream
interface to a digital resource. Sorry, streams are not real. Streams are
only a model to mask the asynchronous events going on everywhere in your
computer.

For example, a hard drive controller and a device driver makes asynchronous
disk requests appear to be a byte stream; but it is not.

For example, a network interface card (NIC) and TCP makes asynchronous IP
packages appear to be a byte stream; but, it is not.

I suspect that it might be a good thing to expose more of the operating
system events to application software. It might be a good thing to provide
an almost direct connection between a mouse and a mouse listener.

Asynchronous events require an event queue. You cannot interrupt a mouse
listener while it is already handling a mouse event. You cannot interrupt a
hard drive listener while it is handling a hard drive event. You cannnot
interrupt a network card listener while it is handling an IP packet.

What is the purpose of a driver? A driver is supposed to convert one kind
of event into another. A TCP/IP driver turns IP packets into a TCP stream.

Like a window manager, the kernel's primary responsibility is to dispatch
events. It must manage the focus of system-wide events. Mouse events, for
example, should not be broadcast to all applications; but, to the
application "on top". Only one application at a time can listen to mouse
events.

On one side of a kernel, a window manager taps into the virtual mouse
driver to listen to mouse events. On the other side of the kernel, the
mouse driver feeds all mouse events to the kernel. The kernel dispatches
mouse events to one window manager at a time.

An OS spends most of its time waiting. Many unusable CPU cycles go by. A
lot of time passes while an application requests the first 4KB of a "file"
and the time that 4KB is ready. A driver makes a "file" look like a stream
of bytes, even when content is scattered across a disk.

Queues are the key to bring order to asynchronous events. The request for
the first 4KB of a file is an event. Each request to the hard drive must
not interrupt other requests. There must be an event queue for hard drive
requests. The response to a hard drive request is an event. Should it go
into a queue?

It turns out that the communication between your general purpose processor
and hardware devices is the same mechanism as distributed computing. A
program sends a request to a driver to do something. A driver generates an
event when a  response is ready.




From digigod@earthling.net Tue, 10 Aug 1999 22:53:07 -0700
Date: Tue, 10 Aug 1999 22:53:07 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] About Generic Driver

Matt Albrecht wrote:
> The Mouse device will be setup to have an IRQ callback.  This is a type of
> event.  So why not let the mouse device translate this event into a mouse
> event, and fire it to the registered Drivers? (That's a retorical question -
> I'll try to answer it below)
> 
> Using your method above, a mouse device would need to set the event, then
> notify() all waiting drivers.  This is friendly for multi-threaded
> applications, where the drivers can execute their mouse event in their own
> thread.  I don't know if you remember the discussion on the Kernel list when
> we were trying to figure out how to handle Interrupts.  Originally, IRQ
> listeners would do a:
>        synchronized( interrupt12 ) {
>           interrupt12.wait();
>        }
> And they would wake up when the interrupt occured.  The problem was that
> (with the keyboard), this routine quickly encountered a deadlock.
> 
> The alternate method is to have the "wait queue", which is a event queue
> where the queue performs a wait if it is empty on a request to retrieve the
> next element.  This is probably the way to go in a device/driver interface.
> The wait queue would be a shared object between the device and the driver.
> The device would need to keep one queue per registered driver, if multiple
> driver registration is supported.

sounds good
 
> >> hasDriver() *may* be appropriate for many devices (like HardDrive
> device - I
> >> wouldn't like multiple drivers, unaware of each other, messing around at
> >> low-level at the same time, but I don't care how many drivers listen to
> the
> >> MouseDevice).  isLoaded(), I feel, may be a reiterative method: if the
> >> Driver can find the device, it has been loaded.  Or maybe I'm not seeing
> >> something with this.  I dunno.
> >
> >hasDriver could throw OperationUnsupportedException or it could be in a
> >UniDriver interface (horrid name, but you get the idea).
> 
> I'm crossed on this.  If we could implement both at the same time, I'd be
> happy 8-)

this is what I proposed:

 public void setDriver(Driver d);
 public Driver getDriver();
 public boolean hasDriver();

but maybe this is more general:

 public void addDriver(Driver d);
 public void removeDriver(Driver d);
 public boolean hasDriver(Driver d);
 public boolean noDrivers(); // true if there are 0 drivers
 
> Hot-swappable devices?  I thought that JavaOS did a good job with this.
> When a device was disconnected, it sent an event to all listening drivers to
> say, "Hey, I'm gone.  You're on your own."  The drivers then figure out how
> to handle this problem.
> 
> In this way, devices are not in the system for registration purposes.  There
> is a problem with this in the way of Java's garbage collection, but, again,
> JavaOS handled it well.  I won't go into detail how they did it, unless you
> *really* want me to.

I like this
 
> >> >you should have a getDescription() and a getHRName(), if you make a tree
> >> >of all of them you need getHRName for the name on the tree node, PNP6000
> >> >(or whatever) will hardly make sense to the average person.
> >> >
> >> >or better yet getName() is the HR one and you have a
> >> >get[Device|Driver]Name() for the ID
> >>
> >> Great.  After typing those enormous class names above, I'll believe
> >> anything.  But really, that sounds like the way to go.
> >
> >be easier for creating a visual device tree at the very least...
> 
> Sounds useful.  Let's do it.

lets do it.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From ryan@whitewolf.com.au Wed, 11 Aug 1999 16:53:59 +1000
Date: Wed, 11 Aug 1999 16:53:59 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> 
> What is a program? Any object can act like a program. Here is the Program
> interface:
> 
> public interface Program
>     extends Runnable {
>   public void setProgramContext( ProgramContext v );
> }
> 
> What is a program context?

Actually, can you tell me the context of your definition? I always
thought of a program as something with a main() method.

> First, the host environment must be able to pass
> "parameters" to a program. A program is free to ignore all parameters.
> Second, a program must be able to pass a result code to the host
> environment. All of the processing in the program is summed up in a single
> integer, a result code.
> 
> public interface ProgramContext {
>   public void getParameter( int index );
>   public void getValue( String key );
>   public Enumeration getParameters();
>   public void setResultCode( int v );
> }

Now, my program (with it's main method n'all), can:

1. get parameters from the argument list of the main() method.
2. get environment parameters from System.getProperties()
3. exit with a result code using System.exit(code)

> A program is not a process. It does not have its own System.in, System.out,
> and System.err. It is a well-defined interface.

Ok, I think this suggests (a lot of guess work here) that the use of
this Program interface is where a program wants to interact with a
number of other programs to achieve a goal, all in a single process
(optional). Here are my thoughts:

The concept of the main() method (and therefore, your Program interface
too) is very primitive. If you would like to achieve a higher goal by
linking together several programs, the main/run() method is a very
limiting solution to the problem. UNIX is about as good as it gets (UNIX
consists of lots of little programs cooperating with eachother by
calling eachother's main() methods. The shell orchestrates this with
pipes and redirection symbols. With the advent of Java, piping and
main() arguments seem unintuitive. Instead we could have JavaBeans
interacting with eachother.

Given JavaBeans and (standard) programs, do we really need a third
option?

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From jm@mak.com Wed, 11 Aug 1999 10:35:51 -0400
Date: Wed, 11 Aug 1999 10:35:51 -0400
From: John Morrison jm@mak.com
Subject: [JOS-Arch] Re: [JOS-Kernel] Priority List

Hi All;

Matt Albrecht wrote:
> Ok, I'm at fault for this.  I moved the discussion over to "Arch" since the
> driver "architecture" doesn't directly relate to the kernel (but, my! the
> implications it has!).

With all due respect, in traditional monolithic, own-address-space kernels, they
directly relate in that the kernel *defines* the driver architecture/API.  Even
though
 jjos+decaf is NOT a traditional kernel
 jjos+decaf is NOT a traditional kernel
 jjos+decaf is NOT a traditional kernel
 jjos+decaf is NOT a traditional kernel
 jjos+decaf is NOT a traditional kernel
 jjos+decaf is NOT a traditional kernel
the driver architecture absolutely *still* relates to jjos+decaf.  I think
(based upon my reading of your email), the rest of your message reinforces this
view...

> Actually, for Device architecture (from a nearly nieve perspective), I see
> only two major hooks needed to join the kernel to the drivers:
>    (1) Pat down the hardware resource interface to a point where somebody is
> truly satisfied.  This is critical for both groups, but doesn't affect many
> people beyond us.
>    (2) Create a hook where the devices can detect and install themselves.
> This is basically the "main" method of the OS, I feel (though it could be
> something else too).  This is also a link into the registry and other cans
> of worms.  But still, the kernel group (I feel) need only be conserned with
> the "main" routine link.  If I'm not mistaken, this already exists.

Having said that, a couple of points... I *still* think we ought to satisfy your
two needs by using the JavaOS API as defined in the "Device Driver Guide,"
available at the following NEW URL (the old one now gets redirected to a place
without the documents):

http://developer.java.sun.com/developer/products/JavaOS/TechDocs/index.html

BTW, please notice that I think you can also DOWNLOAD (?!?!?!) JavaOS from this
page!  (The page info says it was last modified on the 7th...)

-jm

-- 
==== John Morrison            ==== MaK Technologies, Inc.
==== Chief Technology Officer ==== 185 Alewife Brook Pkwy, Cambridge, MA 02138
==== jm@mak.com               ==== http://www.mak.com/welcome.html
==== vox:617-876-8085 x115    ==== fax:617-876-9208



From gchii@mindspring.com Wed, 11 Aug 1999 11:22:04 -0400
Date: Wed, 11 Aug 1999 11:22:04 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 04:53 PM 8/11/99 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>Actually, can you tell me the context of your definition?

JOS is expected to run all kinds of programs. In theory, a uniform API for
all kinds programs is possible. This is what we're working toward.

We should learn from the success and failures of other operating systems.
Each new operating system has a brief opportunity to challenge the
assumptions of traditional data processing models. JOS must fortify the
strengths and minimize the weaknesses of all operating systems that have
gone before.

Are Java Beans the best model of batch data processing? What are the
implications of running non-inherited static main()? Why are there separate
models for Java applications, Java applets, Java servlets and Java aglets?
Aren't all of these trying to do exactly the same thing?

JOS is not UNIX(tm). JOS is not TSO(tm) or OS/400(tm). JOS is not Microsoft
Windows(tm) or MS-DOS(tm). JOS is not Linux. JOS is not Java(tm). So, what
is it? That's what we're trying to figure out.

>I always thought of a program as something with a main() method.

An "Java application" is a kind-of program. It is defined as any class with
a static main() method. While an "application" is always a program, a
program is not always an "application". An application is a self-contained,
independent program. A result code is irrelevant for an "application"
because it is never expected to "fail".

While the "Java applet" is a strong model for a program, an "application"
is not. What is wrong with static main()? Since a static method cannot be
inherited, an application cannot inherit the main() behavior of its
superclass.

Also, the static main() is declared as void. When one application launches
another, a result code is not expected or desired. That's the nature of
applications.

On the other hand, a result code is critical when a program runs a
sub-program. It is the nature of programs. If applications are used where
programs are required, there is no result code.

>Now, my program (with it's main method n'all), can:
>
>1. get parameters from the argument list of the main() method.
>2. get environment parameters from System.getProperties()
>3. exit with a result code using System.exit(code)

Yes, Java provides the perfect environment for applications. The
application context is java.lang.System and java.lang.Runtime. An
application is all alone inside a JVM, and should be.

This is a hostile environment for programs. Each program must have its own
unique context. Programs cannot share java.lang.System and
java.lang.Runtime because each program has its own unique set of
parameters. Each has its own unique result code.

This model enables a program to use another program within a single JVM,
without resorting to the Runtime/Process model. We retain the benefit of
knowing when a program's result code.

Since applications, applets, servlets and aglets are different kinds of
"programs", it becomes possible to unify all programs under a program API.
A program browser would provide a host environment for running (and
debugging!) all kinds of programs.

>> A program is not a process. It does not have its own System.in, System.out,
>> and System.err. It is a well-defined interface.
>
>Ok, I think this suggests (a lot of guess work here) that the use of
>this Program interface is where a program wants to interact with a
>number of other programs to achieve a goal, all in a single process
>(optional).

Traditional runtime code reuse has always started with the program model.
You can build many little programs, like UNIX(tm) and all other operating
systems, an combine them with scripts (and batch files). Since JOS needs a
program model and Java API doesn't have one, we thought we'd create it.

It would be a bad thing if your shell launches a sub-program that calls
System.exit() with a result code. Your shell would end prematurely.

The make tool demonstrates the need for a program model. The make tool's
purpose is to run sub-programs based on simple rules. It is critical to the
make tool to "know" when a sub-program failed. When a sub-program fails,
the whole make fails.

It would be a bad thing if the make tool launches a sub-program that calls
System.exit() with a result code. A make script would end prematurely.

It would be a bad thing for your servlet to call System.exit() with a
result code. It would end the servlet enviroment prematurely. Servlets are
expected to use an "honor system" among serlet programmers, instead of a
security system.

>The concept of the main() method (and therefore, your Program interface
>too) is very primitive.

Exactly. A minimal interface is our goal. We are trying to reduce a program
down to its barest essentials. We are not adding the complexity of multiple
threads or multiple independent processes.

>If you would like to achieve a higher goal by linking together several
>programs, the main/run() method is a very limiting solution to the problem.
>UNIX is about as good as it gets (UNIX consists of lots of little programs
>cooperating with each other by calling each other's main() methods. The shell
>orchestrates this with pipes and redirection symbols.

UNIX(tm) is as good as it gets. The reason it exists on UNIX(tm) is simply
because it is needed. The classic data processing model has been expanded
beyond UNIX(tm). It is available on every major operating system, except Java.

>With the advent of Java, piping and main() arguments seem unintuitive.

Sun Microsystems insists that an instance of the JVM must be created for
each application. The JVM still support piping and a result code on the
outside. The native OS can still redirect standard in, standard out and
standard err. The result code passed to System.exit() is returned to the
native OS.

The benefit of the program model have not been passed on to your Java code.
It would be very difficult to get "public static int main( String[] args )"
to work anyway.

>Instead we could have JavaBeans interacting with each other.

Sure. I supposed you could have JavaBeans acting like programs without a
well-defined program interface. Each bean might have a different interface.
Parameters for a program could be thought of as properties of a bean. The
result code from a bean would be the return value of some method.

This program and program context model provides a way to use JavaBeans as
if they were programs. A well-defined interface is used instead of
reflection. And class, even a bean, can implement the program interface.

More importantly, this gives us a unified model for JOS programs. When you
want to run a program from a shell, the shell can check for a program
interface. The shell can run many programs, properly, with result codes,
within a single JVM.

Further, we bring back the power of shell scripting. When the shell runs a
shell script, it can return the result code of every program it runs. The
shell script can handle non-zero result codes.

Plus, the shell can launch a program in a separate thread or a separate
process.

>Given JavaBeans and (standard) programs, do we really need a third
>option?

We have Java "applications", "applets", "servlets", "aglets", "browslets",
"pluglets" and "jarlets". We have beans, too. All these things are
different kinds of programs. Instead of having a separate (incompatible)
interface for each speciality, there are benefits to bringing them together.




From digigod@earthling.net Wed, 11 Aug 1999 10:35:17 -0700
Date: Wed, 11 Aug 1999 10:35:17 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> JOS is expected to run all kinds of programs. In theory, a uniform API for
> all kinds programs is possible. This is what we're working toward.
> 
> We should learn from the success and failures of other operating systems.
> Each new operating system has a brief opportunity to challenge the
> assumptions of traditional data processing models. JOS must fortify the
> strengths and minimize the weaknesses of all operating systems that have
> gone before.
> 
> Are Java Beans the best model of batch data processing? What are the
> implications of running non-inherited static main()? Why are there separate
> models for Java applications, Java applets, Java servlets and Java aglets?
> Aren't all of these trying to do exactly the same thing?
> 
> JOS is not UNIX(tm). JOS is not TSO(tm) or OS/400(tm). JOS is not Microsoft
> Windows(tm) or MS-DOS(tm). JOS is not Linux. JOS is not Java(tm). So, what
> is it? That's what we're trying to figure out.
> 
> >I always thought of a program as something with a main() method.
> 
> An "Java application" is a kind-of program. It is defined as any class with
> a static main() method. While an "application" is always a program, a
> program is not always an "application". An application is a self-contained,
> independent program. A result code is irrelevant for an "application"
> because it is never expected to "fail".
> 
> While the "Java applet" is a strong model for a program, an "application"
> is not. What is wrong with static main()? Since a static method cannot be
> inherited, an application cannot inherit the main() behavior of its
> superclass.

static methods are inherited, to test it I made these three files:
/////
public class test1 {
 public static void main(String args[]) {
  System.out.println("one");
 }
}
/////
/////
public class test2 extends test1 {
 public static void main(String args[]) {
  test1.main(args);         // this is the only way to access a
superclasses static methods in another static method...
  System.out.println("two");
 }
}
/////
/////
public class test3 extends test1 {
}
/////

if you run these...
test 1 outputs:
one
test 2 outputs:
one
two
test 3 outputs:
one

which means test2 accesed its superclasses main() method (although not
in the best way)

and test3 inherited its main method and didnt need one of its own
 
> Also, the static main() is declared as void. When one application launches
> another, a result code is not expected or desired. That's the nature of
> applications.
> 
> On the other hand, a result code is critical when a program runs a
> sub-program. It is the nature of programs. If applications are used where
> programs are required, there is no result code.

thats what exit(int) is for
 
> >Now, my program (with it's main method n'all), can:
> >
> >1. get parameters from the argument list of the main() method.
> >2. get environment parameters from System.getProperties()
> >3. exit with a result code using System.exit(code)
> 
> Yes, Java provides the perfect environment for applications. The
> application context is java.lang.System and java.lang.Runtime. An
> application is all alone inside a JVM, and should be.
> 
> This is a hostile environment for programs. Each program must have its own
> unique context. Programs cannot share java.lang.System and
> java.lang.Runtime because each program has its own unique set of
> parameters. Each has its own unique result code.
> 
> This model enables a program to use another program within a single JVM,
> without resorting to the Runtime/Process model. We retain the benefit of
> knowing when a program's result code.

arguably, you could do this currently if you dont mind creating another
JVM
 
> Since applications, applets, servlets and aglets are different kinds of
> "programs", it becomes possible to unify all programs under a program API.
> A program browser would provide a host environment for running (and
> debugging!) all kinds of programs.

this would only be internal, right? I mean you have the program
interface then you have an ApplicationProgram that runs a java app as a
program or a ServletProgram, so that all programs can be handled the
same way internally; and still allow for the prospect of someone making
his app a program or use programs as plugins or whatever...
 
> >> A program is not a process. It does not have its own System.in, System.out,
> >> and System.err. It is a well-defined interface.
> >
> >Ok, I think this suggests (a lot of guess work here) that the use of
> >this Program interface is where a program wants to interact with a
> >number of other programs to achieve a goal, all in a single process
> >(optional).
> 
> Traditional runtime code reuse has always started with the program model.
> You can build many little programs, like UNIX(tm) and all other operating
> systems, an combine them with scripts (and batch files). Since JOS needs a
> program model and Java API doesn't have one, we thought we'd create it.
> 
> It would be a bad thing if your shell launches a sub-program that calls
> System.exit() with a result code. Your shell would end prematurely.

The Security manager would deny that request in a properly designed
shell, or it would simply run the app in its own process
 
> The make tool demonstrates the need for a program model. The make tool's
> purpose is to run sub-programs based on simple rules. It is critical to the
> make tool to "know" when a sub-program failed. When a sub-program fails,
> the whole make fails.
> 
> It would be a bad thing if the make tool launches a sub-program that calls
> System.exit() with a result code. A make script would end prematurely.

again, security manager...
 
> It would be a bad thing for your servlet to call System.exit() with a
> result code. It would end the servlet enviroment prematurely. Servlets are
> expected to use an "honor system" among serlet programmers, instead of a
> security system.

I was under the impression that servlets were sandboxed when it came to
stuff like that
 
> >The concept of the main() method (and therefore, your Program interface
> >too) is very primitive.
> 
> Exactly. A minimal interface is our goal. We are trying to reduce a program
> down to its barest essentials. We are not adding the complexity of multiple
> threads or multiple independent processes.
> 
> >If you would like to achieve a higher goal by linking together several
> >programs, the main/run() method is a very limiting solution to the problem.
> >UNIX is about as good as it gets (UNIX consists of lots of little programs
> >cooperating with each other by calling each other's main() methods. The shell
> >orchestrates this with pipes and redirection symbols.
> 
> UNIX(tm) is as good as it gets. The reason it exists on UNIX(tm) is simply
> because it is needed. The classic data processing model has been expanded
> beyond UNIX(tm). It is available on every major operating system, except Java.
> 
> >With the advent of Java, piping and main() arguments seem unintuitive.
> 
> Sun Microsystems insists that an instance of the JVM must be created for
> each application. The JVM still support piping and a result code on the
> outside. The native OS can still redirect standard in, standard out and
> standard err. The result code passed to System.exit() is returned to the
> native OS.
> 
> The benefit of the program model have not been passed on to your Java code.
> It would be very difficult to get "public static int main( String[] args )"
> to work anyway.

you could do:

public static void main(String args[]) {
 System.exit(intmain(args));
}

public static int intmain(String args[]) {
 //bla bla bla
 return 0;
}

but that just spells hack, on the other hand since static methods are
inherited you could put that main in a superclass and have its children
define an intmain() 

> >Instead we could have JavaBeans interacting with each other.
> 
> Sure. I supposed you could have JavaBeans acting like programs without a
> well-defined program interface. Each bean might have a different interface.
> Parameters for a program could be thought of as properties of a bean. The
> result code from a bean would be the return value of some method.
> 
> This program and program context model provides a way to use JavaBeans as
> if they were programs. A well-defined interface is used instead of
> reflection. And class, even a bean, can implement the program interface.
> 
> More importantly, this gives us a unified model for JOS programs. When you
> want to run a program from a shell, the shell can check for a program
> interface. The shell can run many programs, properly, with result codes,
> within a single JVM.

but it would support legacy by saying "oh, this is an Applet that doesnt
implemtn Program, Ill use the AppletProgram class to proxy and load
it..."
 
> Further, we bring back the power of shell scripting. When the shell runs a
> shell script, it can return the result code of every program it runs. The
> shell script can handle non-zero result codes.
> 
> Plus, the shell can launch a program in a separate thread or a separate
> process.
> 
> >Given JavaBeans and (standard) programs, do we really need a third
> >option?
> 
> We have Java "applications", "applets", "servlets", "aglets", "browslets",
> "pluglets" and "jarlets". We have beans, too. All these things are
> different kinds of programs. Instead of having a separate (incompatible)
> interface for each speciality, there are benefits to bringing them together.

Im for this, although I think it needs some work.

on another semi-related note I have a handy way of making your "main()"
class a bit easier to read and program:
////
package digigod.apps;

import java.io.*;

public abstract class Application {
 private          String         arguments[];
 private          BufferedReader reader      = null;
 protected static Application    app         = null;

 public static void main(String args[]) {
  if(app==null)
   System.exit(255);
  app.parseArgs(args);
  app.exit(app.appMain());
 }

 public int getArgsLength() {
  return arguments.length;
 }

 public String getArg(int idx) {
  return arguments[idx];
 }

 public String[] getArgs() {
  return arguments;
 }
 
 public void exit() {
  exit(0);
 }

 public void exit(int code) {
  System.exit(code);
 }

 public void print(String str) {
  System.out.print(str);
 }

 public void println(String str) {
  System.out.println(str);
 }

 public void printerr(String str) {
  System.err.println(str);
 }

 public String readln() throws IOException {
  if(reader==null)
   reader = new BufferedReader(new InputStreamReader(System.in));
  return reader.readLine();
 }

 // only these methods below should be altered by a child, and only the
first required to be
 
 public abstract int appMain();

 public void parseArgs(String args[]) { //can be overridden to add extra
parsing functionality
  arguments = args;
 }
 
 public String getApplicationInfo() {
  return "";
 } 
}
////

this is basically just a wrapper and doesnt have to be used, you can
make your hello world either way:

public class hello {
 public static void main(String args[]) {
  System.out.println("hello world");
 }
}

or

import digigod.apps.Application; //if this was in jos Id imagine it
would be in org.jos.apps

public class HelloHello extends Application {
 static {
  app = new HelloHello(); //somewhat hackish, but somehow more
explanatory...
 }

 public int appMain() {
  println("Hello World!");
 }
}

which is better? neither, they're both the same you'd run them the same
and use them the same; the only difference is a) your class now IS-An
Application and b) its easier to program since most of that crap is
taken care of.

if you want to use parameters it has some methods for getting them, and
if you want you can overide the default parseArgs() behavior to do the
parsing outside of the main method (for readability/seperation of use)
if you want you could build a HashSet (Hashtable for those who dont know
collections yet) of the parsed args so the app doesnt have to deal with
them in main at all.

I bring this up because they are related, look at the other class in the
digigod.apps package:
/////
package digigod.apps;

public abstract class JOSApplication extends Application {
 public static void main(String args[]) {
  if(System.getProperty("os.name").equals("JOS"))
   System.out.println("Requires JOS (www.jos.org)");
  Application.main(args);
 }

 public abstract int appMain();
}
/////

this is for Applications that are dependednt on JOS, as you can see
theres nothing in it now... since nothing exists really... but it could
have stuff like acess to Process information, a GSI and a Registry
binding, but more on topic, it could implement program (using the
appMain in its run, mind you)

jeez, that was long. anyway, what do you think?

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From tmiller@haverford.edu Wed, 11 Aug 1999 16:42:26 -0400 (EDT)
Date: Wed, 11 Aug 1999 16:42:26 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Program and ProgramContext

> A result code is irrelevant for an "application" because it is never expected to "fail".

	Actually, I expect grep (et al) to fail on a regular basis.  

> It would be a bad thing if your shell launches a sub-program that calls
> System.exit() with a result code. Your shell would end prematurely.

	This is one of the things that JOS needs to take care of --
otherwise, all legacy apps bomb.  I don't what the exact mechanism to
prevent/properly redirect this is, but it needs to be done...

> >With the advent of Java, piping and main() arguments seem unintuitive.
>
> Sun Microsystems insists that an instance of the JVM must be created for
> each application. The JVM still support piping and a result code on the
> outside. The native OS can still redirect standard in, standard out and
> standard err. The result code passed to System.exit() is returned to the
> native OS.

	In our case, JOS.  (See above.)  However, I do have an argument in
favor of pipes and redirection, aside from the obvious (they work and we
know how to use them) -- streams are a good model for IPC.  Because JOS is
not Unix, we can do interesting things with streams, like reflecting on
them to find out what kind of stream it is, or asking the stream object
what data it thinks it's carrying.

> Further, we bring back the power of shell scripting. When the shell runs a
> shell script, it can return the result code of every program it runs. The
> shell script can handle non-zero result codes.

	Actually, if we're going to be writing our own (shell -- but
something like tcl should be our first priority, one that works accross
shells.  IIRC, there is a source-released implementation of tcl in
java...) scripting, we might as well make it worthwhile and return result
objects (that may or may not have "unique" integer identifiers)... it
makes the difference between function and program calls narrower, which is
a good thing for the scripter.

-_Quinn




From gchii@mindspring.com Wed, 11 Aug 1999 20:06:44 -0400
Date: Wed, 11 Aug 1999 20:06:44 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 04:42 PM 8/11/99 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> A result code is irrelevant for an "application" because it is never
expected to "fail".
>
>	Actually, I expect grep (et al) to fail on a regular basis.

There is useful distiction between "application programs" and all other
"programs". You typically use "programs" in a script, not "application
programs". If you expect it to fail--if you check for its result code--it
must be a "program", not "application program". grep and all of the other
classic OS programs are not full-blown, self-contained independent
"application programs", but "programs".

What is an example of an "application program"? a text editor, an HTML
browser, an e-mail package, an accounting system, a HR system, JBuilder,
Visual Basic. An "application" is a kind-of program that is relatively "big".

When you build a interactive "application", compiled from 120,000 lines of
code, it probably doesn't run step by step, start to finish, in a straight
path of execution. When you run a batch "program", like grep, it does one
thing well and its done. It goes through pretty much the same steps everytime.

It is awkward to say batch "application" because there are few batch
"applications". But a batch "program" is very popular.

>> It would be a bad thing if your shell launches a sub-program that calls
>> System.exit() with a result code. Your shell would end prematurely.
>
>	This is one of the things that JOS needs to take care of --
>otherwise, all legacy apps bomb.  I don't what the exact mechanism to
>prevent/properly redirect this is, but it needs to be done...

Program and ProgramContext look promising. When I run many programs within
a single JVM today, my programs use the "honor system", not the security
system. It works, just like servlets. When a program needs to shutdown the
whole JVM, it can.

Think about a "logout" or "shutdown" program. When a shell runs this
program, you would expect the program to shutdown the JVM. It closes the
shell, too.

How is the telnetd service going to work inside a one-JVM-per-machine
architecture? How is security going to work inside a one-JVM-per-machine
architecture? When a program runs into critical trouble, it should be able
to throw an error. An error must cause one instance of the JVM to shutdown,
and all of its resources freed.

Each "process" should have its own java.lang.System object and
java.lang.Runtime object. You start and stop a "process". Six of one or a
half-dozen of another, you end up with multiple, concurrent JVMs on each
machine. Our mission should be to find ways to make multiple instances of a
JVM *share* all shareable resources.

What's wrong with one-JVM-per-process architecture? If we embrace that
architecture, you don't need any new mechanisms. We're done. All you need
is a java tool that creates multiple instances of a JVM, one for each process.

JOS is not a multiple process JVM. Just like JOS is not UNIX(tm), JOS may
have a multiple process JVM someday. A multiple JVM java tool is far simpler.

>> >With the advent of Java, piping and main() arguments seem unintuitive.
>>
>> Sun Microsystems insists that an instance of the JVM must be created for
>> each application. The JVM still support piping and a result code on the
>> outside. The native OS can still redirect standard in, standard out and
>> standard err. The result code passed to System.exit() is returned to the
>> native OS.
>
>	In our case, JOS.  (See above.)  However, I do have an argument in
>favor of pipes and redirection, aside from the obvious (they work and we
>know how to use them) -- streams are a good model for IPC.  Because JOS is
>not Unix, we can do interesting things with streams, like reflecting on
>them to find out what kind of stream it is, or asking the stream object
>what data it thinks it's carrying.

I agree about IPC. We can do things with streams that can't be done on any
other operating system.

What about pipes? redirection? A "process", with its java.lang.System
object, can support pipes and redirection. A "program"--my definition--does
not. All of the programs and sub-programs launched from a shell use the
standard in, standard out, standard err of the shell (by default). When you
ask the shell to run a "program" in a separate "process", the new process
can use pipes and redirection.

>> Further, we bring back the power of shell scripting. When the shell runs a
>> shell script, it can return the result code of every program it runs. The
>> shell script can handle non-zero result codes.
>
>	Actually, if we're going to be writing our own (shell -- but
>something like tcl should be our first priority, one that works accross
>shells.  IIRC, there is a source-released implementation of tcl in
>java...) scripting, we might as well make it worthwhile and return result
>objects (that may or may not have "unique" integer identifiers)... it
>makes the difference between function and program calls narrower, which is
>a good thing for the scripter.

It seems to me that a generic scripting API depends on a program API. The
program API must exist first.




From gchii@mindspring.com Wed, 11 Aug 1999 20:59:39 -0400
Date: Wed, 11 Aug 1999 20:59:39 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 10:35 AM 8/11/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>> While the "Java applet" is a strong model for a program, an "application"
>> is not. What is wrong with static main()? Since a static method cannot be
>> inherited, an application cannot inherit the main() behavior of its
>> superclass.
>
>static methods are inherited, to test it I made these three files:

<snip>

>and test3 inherited its main method and didnt need one of its own

Thanks. Your examples prove the point I was trying to make. I must clarify
what I said about "inheriting" static methods. I mean to say that "static
main()" does not provide the behavior you might expect.

When you type java test3 on the command line, you might expect it to run
test3; but, it doesn't. It runs test1. test1 should have been able to
insist that test2 and test3 override its static main().

By the way, test3 becomes only an "alias" for test1.

>arguably, you could do this currently if you dont mind creating another
>JVM

I don't want another JVM as much as I want a new OS. I don't want another
JVM as much as I want a multiple-JVM java tool.

>> Since applications, applets, servlets and aglets are different kinds of
>> "programs", it becomes possible to unify all programs under a program API.
>> A program browser would provide a host environment for running (and
>> debugging!) all kinds of programs.
>
>this would only be internal, right? I mean you have the program
>interface then you have an ApplicationProgram that runs a java app as a
>program or a ServletProgram, so that all programs can be handled the
>same way internally; and still allow for the prospect of someone making
>his app a program or use programs as plugins or whatever...

Internal? No, I don't think so. All "programs" can be handled the same way.

ApplicationProgram? That's exactly right. Using the reflection API, a
single implementation of Program is ApplicationProgram. It can run any
traditional Java "application" that declares a public static main( String[]
) method.

Using the strong servlet model, we need an implementation of Program called
ServletProgram, so that all servlets are automatically compatible with
Program and ProgramContext.

For application programmers that want to implement Program directly, they
can quickly build programs with full support for inheritence.

>> It would be a bad thing if your shell launches a sub-program that calls
>> System.exit() with a result code. Your shell would end prematurely.
>
>The Security manager would deny that request in a properly designed
>shell, or it would simply run the app in its own process

Programs, with their own ProgramContext, do not have to be sandboxed. The
security manager should not get in the way. Neither an "application" nor
"program" should run inside a sandbox. When you write a program, you should
not call System.exit() unless you want to close the shell.

>> It would be a bad thing for your servlet to call System.exit() with a
>> result code. It would end the servlet enviroment prematurely. Servlets are
>> expected to use an "honor system" among serlet programmers, instead of a
>> security system.
>
>I was under the impression that servlets were sandboxed when it came to
>stuff like that

Servlets work because they were not sandboxed. Servlets run just like a
Java application. Your servlet has access to JDBC, ODBC, sockets, threads,
class loaders--you name it.

I very much prefer to run my servlets on the client-side. The servletrunner
tool runs on all clients with no problem. That sure makes it easier to
distribute the processing load of a large distributed application.

>but it would support legacy by saying "oh, this is an Applet that doesnt
>implemtn Program, Ill use the AppletProgram class to proxy and load
>it..."

Exactly! Program and ProgramContext is just a start. It provides a way to
make JOS backward- and forward-compatible.

>package digigod.apps;
>public abstract class Application {
>}

There is a difference between your Application and mine. My Application is
an interface, not abstract class. It must be an interface because any class
can act like an application. Any class can implement my Application
interface, even an applet or Java Bean. It looks something like this:

public interface Application
    extends Runnable {
  public Console getConsole();
  public void setConsole( Console v );
}

That's it. Since an "application" is expected to never fail, there is no
result code. Since my "applications" never expect parameters, no parameters
are passed. There is no equivalent application context.

This interface has served me very well. I type in the name of an
application and my application browser runs it. There is a little more to
my Application interface because I have a Console interface that's
preferrable to standard out:

public interface Console {
  public void println( String v );
}

I have developed many implementations of Console over time. An application
is not expected to set its own console; the application environment
provides one.




From gchii@mindspring.com Wed, 11 Aug 1999 21:19:55 -0400
Date: Wed, 11 Aug 1999 21:19:55 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Virtual Network Computing

The VNC initiative brings us one step closer. Thankfully, it is distributed
under the GNU license. JOS Project members should check it out.

http://www.uk.research.att.com/vnc/

With the enthusiasm of Linux, the disappointment in "big" software vendors,
the release of Java 1.0, the software market has been changed forever.
Starting in 1996, the software market started to free itself. The tried and
true strategy of locking customers into a proprietary operating system will
never work again. People do not want to be locked to one operating system.
They want to use computers like they use a fleet of vehicles.

The one console/one processor model of the PC generation gives way to the
one console/many process model. What is the only thing preventing a
revolution? No operating system has embraced the new hardware model. VNC
comes pretty close, don't you think? JOS must finish it.




From digigod@earthling.net Wed, 11 Aug 1999 20:54:16 -0700
Date: Wed, 11 Aug 1999 20:54:16 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> >> While the "Java applet" is a strong model for a program, an "application"
> >> is not. What is wrong with static main()? Since a static method cannot be
> >> inherited, an application cannot inherit the main() behavior of its
> >> superclass.
> >
> >static methods are inherited, to test it I made these three files:
> 
> <snip>
> 
> >and test3 inherited its main method and didnt need one of its own
> 
> Thanks. Your examples prove the point I was trying to make. I must clarify
> what I said about "inheriting" static methods. I mean to say that "static
> main()" does not provide the behavior you might expect.
> 
> When you type java test3 on the command line, you might expect it to run
> test3; but, it doesn't. It runs test1. test1 should have been able to
> insist that test2 and test3 override its static main().
> 
> By the way, test3 becomes only an "alias" for test1.

how is this different from standard inheritance? java calls
test3.main(args) since it doesnt have one it uses the one in test1.
needles to say Im somewhat confused
 
> >arguably, you could do this currently if you dont mind creating another
> >JVM
> 
> I don't want another JVM as much as I want a new OS. I don't want another
> JVM as much as I want a multiple-JVM java tool.

when I said that I mean create another process...
 
> >> Since applications, applets, servlets and aglets are different kinds of
> >> "programs", it becomes possible to unify all programs under a program API.
> >> A program browser would provide a host environment for running (and
> >> debugging!) all kinds of programs.
> >
> >this would only be internal, right? I mean you have the program
> >interface then you have an ApplicationProgram that runs a java app as a
> >program or a ServletProgram, so that all programs can be handled the
> >same way internally; and still allow for the prospect of someone making
> >his app a program or use programs as plugins or whatever...
> 
> Internal? No, I don't think so. All "programs" can be handled the same way.
> 
> ApplicationProgram? That's exactly right. Using the reflection API, a
> single implementation of Program is ApplicationProgram. It can run any
> traditional Java "application" that declares a public static main( String[]
> ) method.
> 
> Using the strong servlet model, we need an implementation of Program called
> ServletProgram, so that all servlets are automatically compatible with
> Program and ProgramContext.
> 
> For application programmers that want to implement Program directly, they
> can quickly build programs with full support for inheritence.

we should also have a ProgramRunner application for non-JOS systems...
(hell, maybe it could even be used in JOS)
 
> >> It would be a bad thing if your shell launches a sub-program that calls
> >> System.exit() with a result code. Your shell would end prematurely.
> >
> >The Security manager would deny that request in a properly designed
> >shell, or it would simply run the app in its own process
> 
> Programs, with their own ProgramContext, do not have to be sandboxed. The
> security manager should not get in the way. Neither an "application" nor
> "program" should run inside a sandbox. When you write a program, you should
> not call System.exit() unless you want to close the shell.
>
> >> It would be a bad thing for your servlet to call System.exit() with a
> >> result code. It would end the servlet enviroment prematurely. Servlets are
> >> expected to use an "honor system" among serlet programmers, instead of a
> >> security system.
> >
> >I was under the impression that servlets were sandboxed when it came to
> >stuff like that
> 
> Servlets work because they were not sandboxed. Servlets run just like a
> Java application. Your servlet has access to JDBC, ODBC, sockets, threads,
> class loaders--you name it.
> 
> I very much prefer to run my servlets on the client-side. The servletrunner
> tool runs on all clients with no problem. That sure makes it easier to
> distribute the processing load of a large distributed application.

ok, this is "askin' for a hurtin'" as they say, you dont need to be
sandboxed to deny somenone access to something; thats why we have
permissions. I mean say Im running a site that offers people free
webspace and the abillity to make their own servlets (why arent there
any!?) I want to be able for people to install their own servlets
without them being able to close the whole webserver on a whim, so I
tell the security manager just to end that servlet if it calls
System.exit(), in a shell you could probably get the exit code and
return it as an int to the shell...

> >but it would support legacy by saying "oh, this is an Applet that doesnt
> >implemtn Program, Ill use the AppletProgram class to proxy and load
> >it..."
> 
> Exactly! Program and ProgramContext is just a start. It provides a way to
> make JOS backward- and forward-compatible.

hey, a few emulators and we'll run everything! :)
 
> >package digigod.apps;
> >public abstract class Application {
> >}
> 
> There is a difference between your Application and mine. My Application is
> an interface, not abstract class. It must be an interface because any class
> can act like an application. Any class can implement my Application
> interface, even an applet or Java Bean. It looks something like this:
> 
> public interface Application
>     extends Runnable {
>   public Console getConsole();
>   public void setConsole( Console v );
> }
> 
> That's it. Since an "application" is expected to never fail, there is no
> result code. Since my "applications" never expect parameters, no parameters
> are passed. There is no equivalent application context.
> 
> This interface has served me very well. I type in the name of an
> application and my application browser runs it. There is a little more to
> my Application interface because I have a Console interface that's
> preferrable to standard out:
> 
> public interface Console {
>   public void println( String v );
> }
> 
> I have developed many implementations of Console over time. An application
> is not expected to set its own console; the application environment
> provides one.

My Application class is just a way to make it easier to program the
"standard java app", I was assuming it could work with your program
interface...

public abstract class ApplicationProgram extends Application implements
Program {...}

then:

public abstract class JOSApplication extends ApplicationProgram {...}

when you use my class your class IS-A Application, with your interface
it IS-A program. it can also be both.

you use my class when your making an application, when it IS-A
application and nothing else; it might HAS-A JFrame or whatever, but it
IS-A application. I think all the sub-components of an application
should also be applications. like the image format converter dialog in a
paint program should run stand-alone just as well, with java this is
easy, slap on a main() with your program interface this is easier.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From ryan@whitewolf.com.au Thu, 12 Aug 1999 18:45:17 +1000
Date: Thu, 12 Aug 1999 18:45:17 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

DigiGod Q Frasché wrote:

> on another semi-related note I have a handy way of making your "main()"
> class a bit easier to read and program:
> ////
> package digigod.apps;
> 
> import java.io.*;
> 
> public abstract class Application {
>  private          String         arguments[];
>  private          BufferedReader reader      = null;
>  protected static Application    app         = null;

Did you intend for Application to implement the Program interface, or is
this your version of the program interface (as an abstract class
instead)?

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From ryan@whitewolf.com.au Thu, 12 Aug 1999 18:45:28 +1000
Date: Thu, 12 Aug 1999 18:45:28 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:

> JOS is expected to run all kinds of programs. In theory, a uniform API for
> all kinds programs is possible. This is what we're working toward. --snip--
> Why are there separate models for Java applications, Java applets, Java
> servlets and Java aglets? Aren't all of these trying to do exactly the same
> thing?

No, and this is why I cannot understand your goal.

Applications, applets and servlets are each used in entirely different
situations, hence they have different interfaces that reflect how they
are used:

- A servlet can only be run from within a servlet engine because it
relies on a very unique environment. For example, an HTTP servlet relies
on the fact that it can access various information in the HTTP header of
a request. It relies on the fact that its instance can persist between
invocations, so it can keep a database connection open (for example).
Both of these dependencies bar servlets from being invoked in a uniform
manner with other types of programs. For example, you just can't run a
servlet from the command-line. It doesn't make any sense.

- An applet is also very different from a command-line program. The key
quality of an Applet is that it is a part of a larger entity. It
requires this entity to be useful. An applet cannot be executed unless
it is in a web page. The applet is very aware that it is in a web page.
It can read its applet parameters which are defined in the web page, it
can communicate with other applets that are in the web page, it can even
make another web page load. Because of its different nature, it can't be
treated in a similar way to applications or servlets. Another point is
that you don't really invoke an applet (as you do with the programs you
speak of), you "embed" it in an application specific way that is
provided by the applet itself.

- Applications (both gui and command-line) are intended to be invoked.
Applications are a unique type of program that are designed to carry out
a task and return to the shell, or carry out tasks given through a user
interface until the user wishes to exit the application. These types of
programs are the only programs that are suitable for shells because they
can be invoked, they have a clearly defined lifespan, and a definite way
of returning to the shell.

> A result code is irrelevant for an "application"
> because it is never expected to "fail".

I agree. There is definately a distinction between applications and
command-line tools, even though Sun decided to invoke both types through
the same unified interface - the main() method. However, I think they
realised that the unification could not extend beyond applications and
command-line tools. So, applets and servlets are "used" through a
different interface that caters for their use.

> While the "Java applet" is a strong model for a program, an "application"
> is not. What is wrong with static main()? Since a static method cannot be
> inherited, an application cannot inherit the main() behavior of its
> superclass.

main() typically does not have any behaviour to inherit. It should fire
up a reusable object and let it handle the rest of the processing. Any
behaviour you put in to main() is not reusable from an OO perspective so
it is wise to pass control into reusable objects as soon as possible.

> This model enables a program to use another program within a single JVM,
> without resorting to the Runtime/Process model. We retain the benefit of
> knowing when a program's result code.
--snip--
> It would be a bad thing if your shell launches a sub-program that calls
> System.exit() with a result code. Your shell would end prematurely.

What you don't realise is that none of these problems exist in the
current system. Just because System.exit() is the only way to return a
result code doesn't mean that Java can't use this returned value. When
you call Runtime.exec() it returns a Process object. You can wait for
the process to exit and then query it for its result code.

Secondly, just because you are using Runtime.exec() doesn't mean that
you are starting up a whole new JVM. It simply means you are starting up
a new process. This is how UNIX works. We can implement it the same way
with a modified JVM that can spawn new processes in a lightweight
manner. You mentioned that Sun insists that we don't do this. Well who
cares what Sun say. It is obviously possible.

Your wish to have sub-programs running in the same process is a
dangerous approach. Even if you provide an alternate mechnism for
returning result codes, System.exit() is still there and used by nearly
every Java application in existence today. If a sub-program calls this,
your shell will also die, along with other sub-programs in the same
process. That is, unless you stick with the current program model where
you spawn new processes with the Runtime class (same way as UNIX). If
you impose a SecurityManager on programs which choose to call
System.exit(), they will crash. Only new programs written to your API
will work and I somehow don't think many people will want to switch.

> More importantly, this gives us a unified model for JOS programs. When you
> want to run a program from a shell, the shell can check for a program
> interface. The shell can run many programs, properly, with result codes,
> within a single JVM.

Refer to my points about this at the beginning of this email.

Ok, this one I saved 'till last:

> Since applications, applets, servlets and aglets are different kinds of
> "programs", it becomes possible to unify all programs under a program API.
> A program browser would provide a host environment for running (and
> debugging!) all kinds of programs.

Not surprisingly, I am interested in the use of what you are proposing.
Debugging was something that caught my eye. I don't yet understand how a
unified API is useful for debugging, but if you can explain it to me,
there might be a use for this unified API after all.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From ryan@whitewolf.com.au Thu, 12 Aug 1999 19:09:42 +1000
Date: Thu, 12 Aug 1999 19:09:42 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

"Todd L. Miller" wrote:

>         In our case, JOS.  (See above.)  However, I do have an argument in
> favor of pipes and redirection, aside from the obvious (they work and we
> know how to use them) -- streams are a good model for IPC.  Because JOS is
> not Unix, we can do interesting things with streams, like reflecting on
> them to find out what kind of stream it is, or asking the stream object
> what data it thinks it's carrying.

I agree that pipes and redirection are useful. What I meant to say was
that of the two models for linking tiny programs together to achieve an
outcome, I think JavaBeans is more useful than UNIX pipes:

1. UNIX pipes are usually linear because UNIX processes typically read
from stdin and write to stdout. It is difficult to achieve the effect of
parallel and forking pipes.

2. JavaBeans have multiple entry points (one for each method) where as
UNIX processes have a single entry (stdin) and a dodgy way of switching
its function (command-line arguments).

3. It is possible to overlay pipes on top of JavaBeans in the cases
where pipes are extremely useful (eg. filters).

As for IPC, you are right that we definitely need streams. The
usefulness of method invocations (when it is desirable) can be emulated
through RMI on top of streams.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From tmiller@haverford.edu Thu, 12 Aug 1999 07:49:43 -0400 (EDT)
Date: Thu, 12 Aug 1999 07:49:43 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Program and ProgramContext

> JOS is not a multiple process JVM. Just like JOS is not UNIX(tm), JOS may
> have a multiple process JVM someday. A multiple JVM java tool is far simpler.

	Actually, it's not, at least from the kernel/JVM point-of-view.
Multiple native processes create all sorts of difficulties for the kernel
and for the JVM, not the least of which is actually writing multiple
processes into the kernel.

-_Quinn




From digigod@earthling.net Thu, 12 Aug 1999 08:21:44 -0700
Date: Thu, 12 Aug 1999 08:21:44 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Ryan Heise wrote:
> > public abstract class Application {
> >  private          String         arguments[];
> >  private          BufferedReader reader      = null;
> >  protected static Application    app         = null;
> 
> Did you intend for Application to implement the Program interface, or is
> this your version of the program interface (as an abstract class
> instead)?

its just something I came up with to make apps easier to create, but I
brought it up because it could implement the program interface in a
subclass

public abstract class ApplicationProgram extends Application implements
Program {...}

although Im not entirely convinced of its use

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 08:37:07 -0700
Date: Thu, 12 Aug 1999 08:37:07 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Ryan Heise wrote:
> > JOS is expected to run all kinds of programs. In theory, a uniform API for
> > all kinds programs is possible. This is what we're working toward. --snip--
> > Why are there separate models for Java applications, Java applets, Java
> > servlets and Java aglets? Aren't all of these trying to do exactly the same
> > thing?
> 
> No, and this is why I cannot understand your goal.
> 
> Applications, applets and servlets are each used in entirely different
> situations, hence they have different interfaces that reflect how they
> are used:

I agree
 
> - A servlet can only be run from within a servlet engine because it
> relies on a very unique environment. For example, an HTTP servlet relies
> on the fact that it can access various information in the HTTP header of
> a request. It relies on the fact that its instance can persist between
> invocations, so it can keep a database connection open (for example).
> Both of these dependencies bar servlets from being invoked in a uniform
> manner with other types of programs. For example, you just can't run a
> servlet from the command-line. It doesn't make any sense.

it could be loaded in servletrunner
 
> - An applet is also very different from a command-line program. The key
> quality of an Applet is that it is a part of a larger entity. It
> requires this entity to be useful. An applet cannot be executed unless
> it is in a web page. The applet is very aware that it is in a web page.
> It can read its applet parameters which are defined in the web page, it
> can communicate with other applets that are in the web page, it can even
> make another web page load. Because of its different nature, it can't be
> treated in a similar way to applications or servlets. Another point is
> that you don't really invoke an applet (as you do with the programs you
> speak of), you "embed" it in an application specific way that is
> provided by the applet itself.

it could be loaded in appletviewer
 
> - Applications (both gui and command-line) are intended to be invoked.
> Applications are a unique type of program that are designed to carry out
> a task and return to the shell, or carry out tasks given through a user
> interface until the user wishes to exit the application. These types of
> programs are the only programs that are suitable for shells because they
> can be invoked, they have a clearly defined lifespan, and a definite way
> of returning to the shell.
> 
> > A result code is irrelevant for an "application"
> > because it is never expected to "fail".
> 
> I agree. There is definately a distinction between applications and
> command-line tools, even though Sun decided to invoke both types through
> the same unified interface - the main() method. However, I think they
> realised that the unification could not extend beyond applications and
> command-line tools. So, applets and servlets are "used" through a
> different interface that caters for their use.
> 
> > While the "Java applet" is a strong model for a program, an "application"
> > is not. What is wrong with static main()? Since a static method cannot be
> > inherited, an application cannot inherit the main() behavior of its
> > superclass.
> 
> main() typically does not have any behaviour to inherit. It should fire
> up a reusable object and let it handle the rest of the processing. Any
> behaviour you put in to main() is not reusable from an OO perspective so
> it is wise to pass control into reusable objects as soon as possible.

yup, although my application class would allow you to inherit the main
method... (which I never thought about until now...)
 
> > This model enables a program to use another program within a single JVM,
> > without resorting to the Runtime/Process model. We retain the benefit of
> > knowing when a program's result code.
> --snip--
> > It would be a bad thing if your shell launches a sub-program that calls
> > System.exit() with a result code. Your shell would end prematurely.
> 
> What you don't realise is that none of these problems exist in the
> current system. Just because System.exit() is the only way to return a
> result code doesn't mean that Java can't use this returned value. When
> you call Runtime.exec() it returns a Process object. You can wait for
> the process to exit and then query it for its result code.
> 
> Secondly, just because you are using Runtime.exec() doesn't mean that
> you are starting up a whole new JVM. It simply means you are starting up
> a new process. This is how UNIX works. We can implement it the same way
> with a modified JVM that can spawn new processes in a lightweight
> manner. You mentioned that Sun insists that we don't do this. Well who
> cares what Sun say. It is obviously possible.

we'll have to handle that carefully though, lots of messy stuff
 
> Your wish to have sub-programs running in the same process is a
> dangerous approach. Even if you provide an alternate mechnism for
> returning result codes, System.exit() is still there and used by nearly
> every Java application in existence today. If a sub-program calls this,
> your shell will also die, along with other sub-programs in the same
> process. That is, unless you stick with the current program model where
> you spawn new processes with the Runtime class (same way as UNIX). If
> you impose a SecurityManager on programs which choose to call
> System.exit(), they will crash. Only new programs written to your API
> will work and I somehow don't think many people will want to switch.

I think Enchinda uses the System.exit/SecurityManager hack it "exits"
the program by stopping its execution and takes the result code
 
> > More importantly, this gives us a unified model for JOS programs. When you
> > want to run a program from a shell, the shell can check for a program
> > interface. The shell can run many programs, properly, with result codes,
> > within a single JVM.
> 
> Refer to my points about this at the beginning of this email.
> 
> Ok, this one I saved 'till last:
> 
> > Since applications, applets, servlets and aglets are different kinds of
> > "programs", it becomes possible to unify all programs under a program API.
> > A program browser would provide a host environment for running (and
> > debugging!) all kinds of programs.
> 
> Not surprisingly, I am interested in the use of what you are proposing.
> Debugging was something that caught my eye. I don't yet understand how a
> unified API is useful for debugging, but if you can explain it to me,
> there might be a use for this unified API after all.

Id like to hear that too

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Thu, 12 Aug 1999 10:39:13 -0400
Date: Thu, 12 Aug 1999 10:39:13 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 07:49 AM 8/12/99 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> JOS is not a multiple process JVM. Just like JOS is not UNIX(tm), JOS may
>> have a multiple process JVM someday. A multiple JVM java tool is far
simpler.
>
>	Actually, it's not, at least from the kernel/JVM point-of-view.
>Multiple native processes create all sorts of difficulties for the kernel
>and for the JVM, not the least of which is actually writing multiple
>processes into the kernel.

Let me clarify this other thing I am trying to build. I continue to use the
IBM OS/400, Linux and Microsoft Windows 95 kernels. I am using Sun
Microsystems' JDK 1.1.7B for this experiment. I am working with their Java
native interface (JNI) to build my own version of the java tool. My java
tool will be called josé, not java.

1. When I start the josé tool, it creates a "primary" JVM and "primary" JVM
enviroment just like the java tool. When System.exit() is called in the
primary JVM, it shuts down the whole josé tool. This is the main native
thread of the native process. The primary JVM *always* runs the José(tm)
Master Shell. So far, that contains my bytecode and only my bytecode.

I am building a shared library with native methods so that my Java programs
can "talk" back to the native josé program.

2. When I call native JVMController.exec(), it passes a request to the main
thread of the native process. The main thread creates a new native thread.
The new native thread uses the JNI to create a "secondary" JVM and
"secondary" JVM environment. When System.exit() is called in the secondary
JVM, it shuts down only one JVM running in a native thread.

In total, there is only one native process. On the other hand, there are
multiple, independent JVMs. When an error is thrown in a secondary JVM, the
secondary JVM is shut down, just as Sun's Java virtual machine
specification requires.

The JVMController.exec() method returns a JVMProcess object, which should
extend/implement java.lang.Process but I don't have time for that right
now. The important thing is that the JVMProcess object implements a wait()
method, waiting for the secondary JVM to die.

It is very important to my long-term strategy to continue running native OS
processes through java.lang.Runtime.exec(). I don't want Runtime.exec() to
launch Java-only processes. That's why I created a separate JVMController
class to control secondary JVMs.

Oh, and part of the environment passed to a secondary JVM includes the
TCP/IP port used by the primary JVM's xdcd service. All secondary JVMs can
XDC to the primary JVM and all its other services. The primary JVM runs the
system-wide registry, for example.

While each JVM runs in a separate native thread, it looks like a separate
process in Java. I don't have to re-write a JVM. I don't have to re-write
the Java API. I should be able to use the JNI tools Sun provides to give me
what I want. If it works, what could be simpler than that?




From gchii@mindspring.com Thu, 12 Aug 1999 10:57:58 -0400
Date: Thu, 12 Aug 1999 10:57:58 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 08:54 PM 8/11/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>how is this different from standard inheritance? java calls
>test3.main(args) since it doesnt have one it uses the one in test1.
>needles to say Im somewhat confused

I is about time I used an example of how test1, test2 and test3 *should* work.

// Application.java
public abstract Application
    implements Program {
  public Application() {
  }
  public ProgramContext getProgramContext() {
    return context;
  }
  public void setProgramContext( ProgramContext v ) {
    context = v;
  }
  public void exit( int v ) {
    context.setResultCode( (byte) v );
  }
  private ProgramContext context = null;
}

// test1.java
public class test1
    extends Application {
  public test1() {
  }
  public void run() {
    System.out.println( "Running " + getClass().getName() + "..." );
    System.out.println( "one" );
  }
}

// test2.java
public class test2 
    extends test1 {
  public test2() {
    super();
  }
  public void run() {
    super.run();
    System.out.println( "two" );
  }
}

// test3.java
public class test3
    extends test1 {
  public test3() {
  }
}

$ test1
Running test1...
one

$ test2
Running test2...
one
two

$ test3
Running test3...
one

This uses all non-static methods and, in Java, benefits from all that
object-oriented stuff. You should put all of the common functionality of a
program into a base class and reuse it. With a Program and ProgramContext,
you can.

Historical note: Please don't take this as a critisism of the command-line
utilities. The command-line utilities are great! Each command line utility
has common functionality. With a stronger model for "programs", that
bytecode could have been stored only once, not duplicated in each archive.




From gchii@mindspring.com Thu, 12 Aug 1999 10:59:38 -0400
Date: Thu, 12 Aug 1999 10:59:38 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 08:54 PM 8/11/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>we should also have a ProgramRunner application for non-JOS systems...
>(hell, maybe it could even be used in JOS)

Yes, we should build a ProgramRunner. It must works on JOS (especially!)
and on all other platforms.




From gchii@mindspring.com Thu, 12 Aug 1999 11:07:38 -0400
Date: Thu, 12 Aug 1999 11:07:38 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 08:54 PM 8/11/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>My Application class is just a way to make it easier to program the
>"standard java app", I was assuming it could work with your program
>interface...

Don't get me wrong. I like your Application class. I just thought that it
should implement a broad Program interface. Plus, I think an Application
class does not need "private String[] arguments" but a separate "context"
object. I agree that your Application class should have an exit() method, too.

When a program context is set, a program has an opportunity to process its
parameters. A generic UNIX(tm)-style mechanism is possible, written into a
reusable base class. That a class that needs to be written.

Or, a program can wait until the run() method is called before examining
its parameters. When a program is "done", it sets a result code in program
context and returns from run().




From gchii@mindspring.com Thu, 12 Aug 1999 12:37:23 -0400
Date: Thu, 12 Aug 1999 12:37:23 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 06:45 PM 8/12/99 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>Applications, applets and servlets are each used in entirely different
>situations, hence they have different interfaces that reflect how they
>are used:

You are correct. Applications, applets and servlets are used in different
environments today. That is going change. We, members of the JOS Project,
should anticipate this change, embracing it.

It has been difficult for Sun Microsystems and others to see how much all
these programs have in common. All of these run Java bytecode inside a JVM.
That means that all of these have more in common than it may at first appear.

>- A servlet can only be run from within a servlet engine because it
>relies on a very unique environment. For example, an HTTP servlet relies
>on the fact that it can access various information in the HTTP header of
>a request. It relies on the fact that its instance can persist between
>invocations, so it can keep a database connection open (for example).
>Both of these dependencies bar servlets from being invoked in a uniform
>manner with other types of programs. For example, you just can't run a
>servlet from the command-line. It doesn't make any sense.

Yes, well, sort of. Servlets run inside a servlet engine. Sun provides a
servletrunner, so you don't have to have a separate HTTP service.

Warning: This information might be shocking to all those who follow Sun
Microsystems wherever they go. Sun's website very clearly states that this
can't be done.

First, you run servlets from a command line. When I run this command from
my HTML browser, or rather its location field, it invokes a servlet. The
location field is-a command line.

http://localhost:8080/servlet/org.jos.demo.DemoServlet

Second, servlets are based exclusively on *streams*, not TCP/IP. A
servletrunner provides ServletInputStreams and ServletOutputStream to a
servlet, so that a servlet doesn't need to know about TCP/IP connections.
There are no dependencies that prevent servlets from running elsewhere.
There is no need for a servlet engine to use TCP/IP--even for HTTP servlets.

Your servlet get HTTP header information from a ServletInputStream. It
writes HTTP header information to a ServletOutputStream. It doesn't need to
connect with a requestor using a TCP/IP connection.

Why would anyone want to? As a Java programmer, I need to build servlets in
the shortest amount of time possible. Debugging a servlet *inside* the
servletrunner is less than optimum for debugging servlets. You can set
break-points inside your servlet code. Yes, you can even create debugging
frames and dialog boxes (only used during testing). I would rather debug my
servlets in a plain-text browser. Hey, that's what I'm doing.

In the location field of my plain-text browser, I type the following URI:

x-servlet:org.jos.demo.DemoServlet

My plain-text browser will provide a servlet environment completely free of
TCP/IP connections. It will load and run any servlet, just like the servlet
specification says. The output from the servlet is displayed in plain text,
so that I can look at the raw HTML, to make sure the servlet produces the
HTML code that I want it to. It will be fast. It will be direct. My
plain-text browser will be easy to restart (with a restart button) so that
I can recompile my servlet frequently and start a new "session" whenever I
want.

After I get the servlet working, then I move to a more complicated
environment, using an HTML browser, a servletrunner tool, and TCP/IP.

x-servlet:org.jos.demo.DemoServlet

is equivalent to

http://localhost:8080/servlet/org.jos.demo.DemoServlet

Parameters are passed with a standard query string. I can quickly test
different combinations of parameters and instantly see the results. When I
pause a servlet right in the middle of building an HTML file, I see all
output that has been written so far.

Sidebar: You can run servlets on the client-side. Every machine that has a
JVM is capable of being a "server". If you integrate servletrunner into
your client-side Java application, you can run servlets on the client-side.
Sounds strange only because Sun mis-named them "servlets", giving everyone
the mistaken impression that they only run on the server-side.

>- An applet is also very different from a command-line program. The key
>quality of an Applet is that it is a part of a larger entity. It
>requires this entity to be useful. An applet cannot be executed unless
>it is in a web page. The applet is very aware that it is in a web page.
>It can read its applet parameters which are defined in the web page, it
>can communicate with other applets that are in the web page, it can even
>make another web page load. Because of its different nature, it can't be
>treated in a similar way to applications or servlets. Another point is
>that you don't really invoke an applet (as you do with the programs you
>speak of), you "embed" it in an application specific way that is
>provided by the applet itself.

Yes, well, sort of. Applets run inside an applet engine. Sun provides a
appletrunner, so you don't have to have a separate HTML browser.

First, you can definitely run applets outside a browser. You can run the
appletrunner, right?

Second, you can definitely run applets without HTML. This might be a
surprise to all those who use Sun's brain-dead appletrunner tool. But, it
is no surprise to those using JavaBee. Check out the wonderful JavaBee
product at <URL:http://www.javabee.com/>.

My applet browser provides a simple way to run applets with support for
parameters. In the location field of my applet browser, I type the
following URI:

x-applet:org.jos.demo.DemoApplet

My applet browser provides an applet environment completely free of HTML.
It loads and runs an applet, just like the applet specification says. The
output from the applet is displayed in a frame, so that I reside the applet
and interact with its visual components, to make sure the applet behaves
the way I want it to. It is fast. It is direct. My applet browser is easy
to restart (with a restart button) so that I can recompile my applet
frequently. I invoke an applet with exactly the same mechanism as I invoke
a servlet.

Parameters are passed with a standard query string. I can test different
combinations of parameters. Feedback is immediate. No bulky HTML browser is
required.

My applet browser supports the showDocument() and showStatus() methods
required by the applet environment. The showDocument() method overwrites
the location field with a new URI, but does not automatically run it. I can
look at the output from showDocument() to see if looks right.

Then, I move up to embedding an applet on an HTML page.

>- Applications (both gui and command-line) are intended to be invoked.
>Applications are a unique type of program that are designed to carry out
>a task and return to the shell, or carry out tasks given through a user
>interface until the user wishes to exit the application. These types of
>programs are the only programs that are suitable for shells because they
>can be invoked, they have a clearly defined lifespan, and a definite way
>of returning to the shell.

Exactly! Applications "carry out tasks given through a user interface until
the user wishes to exit the application." That's a key difference between
"applications" and "programs".

My program browser--you guessed it--runs programs. It provides a simple way
to run programs with full support for parameters. In the location field of
my program browser, I type the following URI:

x-program:org.jos.demo.DemoProgram

The standard output from the DemoProgram is display just like the
plain-text browser.

>Not surprisingly, I am interested in the use of what you are proposing.
>Debugging was something that caught my eye. I don't yet understand how a
>unified API is useful for debugging, but if you can explain it to me,
>there might be a use for this unified API after all.

In the end, I wish to combine all specialized browsers into a unified JOS
browser. Here is what you'll be able to debug and demonstrate within a
single application:

Protocol - Program Type - Status

run:os: - native OS processes - complete
run:jose: - José applications - complete
multi - (file:, http:, x-registry:, in:*, out:*) - complete
x-applet: - Java applets - almost complete
x-archive - JOS archive browser (.cab, .gz, .jar, .zip) - not started yet
x-servlet: - Java servlets - needs more work
x-program: - JOS programs - needs more work
x-aglet: - Java aglets - not started yet

What does this mean? It means that you can build a servlet that dynamically
creates an HTML index of all your applications, applets, programs, native
programs, archives, and other servlets. You click on the digital resource
you want to invoke. Ta-da! You get one.

Do you want it all? You can have it all. You can mix and match until you
get dizzy and your head hurts. We live in a brave new world where programs
are multiply connected.

- You can download and run Java bytecode from anywhere (if that's what you
really want).
- You can build a program that runs as a program...and a servlet.
- You can build a Java application that runs as a Java application...or a
program or servlet.
- You can build an applet that runs as an applet...and a program.
- You can run a servlet that runs as a servlet...and a program.
- You can run a native program as a native program...and a servlet.
- Your aglet can roam around and bring back its search results as a
program, applet, or servlet.

- It is recursive, too. So that you can launch an applet that starts a
program that uses servlets that use native programs. You can do anything
you want.

As an operating system, JOS should take advantage of some of the
combinations that make the most sense. For example, the ls command should
be available as a program, a Java application, and a servlet. When you
invoke the ls command from within your HTML browser, the results should be
returned as (1) plain-text or (2) full HTML code. Here is where program
inheritence becomes critically important.

We should have a plain-text ls program. The HTML version of the ls program
should extend the plain-text version. Both have identical functionality.
While one runs as a program or Java application, the other runs as a
servlet. You can browse around your JOS OS file subsystem using your HTML
browser on a local machine or across the Internet.

We can be compatible with other names for ls. The dir command can use the
ls program. The dir command takes much different command line parameters
than ls. The dir command should translate command line parameters, for
example, and then call the ls command. See, that's why we need to run
programs within the same process.

Or, the ls and dir commands could use a brand-new JOS program with a new
name that does file-listing better than any other operating system.

Here is one for the road. JOS command-line utilities should consistently
recognize the -html option. This command-line parameter tells a program
when it should output HTML code to standard out. When the servletrunner
runs a program as a servlet, it should automatically pass the -html option
to all of our JOS command-line utilities.




From digigod@earthling.net Thu, 12 Aug 1999 10:47:52 -0700
Date: Thu, 12 Aug 1999 10:47:52 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> >Applications, applets and servlets are each used in entirely different
> >situations, hence they have different interfaces that reflect how they
> >are used:
> 
> You are correct. Applications, applets and servlets are used in different
> environments today. That is going change. We, members of the JOS Project,
> should anticipate this change, embracing it.

whats wrong with just making applications that act as a "default"
environment for these?
 
> It has been difficult for Sun Microsystems and others to see how much all
> these programs have in common. All of these run Java bytecode inside a JVM.
> That means that all of these have more in common than it may at first appear.
> 
> >- A servlet can only be run from within a servlet engine because it
> >relies on a very unique environment. For example, an HTTP servlet relies
> >on the fact that it can access various information in the HTTP header of
> >a request. It relies on the fact that its instance can persist between
> >invocations, so it can keep a database connection open (for example).
> >Both of these dependencies bar servlets from being invoked in a uniform
> >manner with other types of programs. For example, you just can't run a
> >servlet from the command-line. It doesn't make any sense.
> 
> Yes, well, sort of. Servlets run inside a servlet engine. Sun provides a
> servletrunner, so you don't have to have a separate HTTP service.
> 
> Warning: This information might be shocking to all those who follow Sun
> Microsystems wherever they go. Sun's website very clearly states that this
> can't be done.
> 
> First, you run servlets from a command line. When I run this command from
> my HTML browser, or rather its location field, it invokes a servlet. The
> location field is-a command line.
> 
> http://localhost:8080/servlet/org.jos.demo.DemoServlet
> 
> Second, servlets are based exclusively on *streams*, not TCP/IP. A
> servletrunner provides ServletInputStreams and ServletOutputStream to a
> servlet, so that a servlet doesn't need to know about TCP/IP connections.
> There are no dependencies that prevent servlets from running elsewhere.
> There is no need for a servlet engine to use TCP/IP--even for HTTP servlets.
> 
> Your servlet get HTTP header information from a ServletInputStream. It
> writes HTTP header information to a ServletOutputStream. It doesn't need to
> connect with a requestor using a TCP/IP connection.
> 
> Why would anyone want to? As a Java programmer, I need to build servlets in
> the shortest amount of time possible. Debugging a servlet *inside* the
> servletrunner is less than optimum for debugging servlets. You can set
> break-points inside your servlet code. Yes, you can even create debugging
> frames and dialog boxes (only used during testing). I would rather debug my
> servlets in a plain-text browser. Hey, that's what I'm doing.
> 
> In the location field of my plain-text browser, I type the following URI:
> 
> x-servlet:org.jos.demo.DemoServlet
> 
> My plain-text browser will provide a servlet environment completely free of
> TCP/IP connections. It will load and run any servlet, just like the servlet
> specification says. The output from the servlet is displayed in plain text,
> so that I can look at the raw HTML, to make sure the servlet produces the
> HTML code that I want it to. It will be fast. It will be direct. My
> plain-text browser will be easy to restart (with a restart button) so that
> I can recompile my servlet frequently and start a new "session" whenever I
> want.
> 
> After I get the servlet working, then I move to a more complicated
> environment, using an HTML browser, a servletrunner tool, and TCP/IP.
> 
> x-servlet:org.jos.demo.DemoServlet
> 
> is equivalent to
> 
> http://localhost:8080/servlet/org.jos.demo.DemoServlet
> 
> Parameters are passed with a standard query string. I can quickly test
> different combinations of parameters and instantly see the results. When I
> pause a servlet right in the middle of building an HTML file, I see all
> output that has been written so far.
> 
> Sidebar: You can run servlets on the client-side. Every machine that has a
> JVM is capable of being a "server". If you integrate servletrunner into
> your client-side Java application, you can run servlets on the client-side.
> Sounds strange only because Sun mis-named them "servlets", giving everyone
> the mistaken impression that they only run on the server-side.

ok, you made a good point about how one should be able to test ones
servlet; but how does this argue that they HAVE to be a Program?

isnt a Servlet (at the very top) just an interface (what they should
have done with Applet, btw) and isnt it unasuming about HTTP, that is
not locked to it? Ive always thought of a Servlet as a service-let not a
server-let, just a handy stream based IPO plugin.
 
> >- An applet is also very different from a command-line program. The key
> >quality of an Applet is that it is a part of a larger entity. It
> >requires this entity to be useful. An applet cannot be executed unless
> >it is in a web page. The applet is very aware that it is in a web page.
> >It can read its applet parameters which are defined in the web page, it
> >can communicate with other applets that are in the web page, it can even
> >make another web page load. Because of its different nature, it can't be
> >treated in a similar way to applications or servlets. Another point is
> >that you don't really invoke an applet (as you do with the programs you
> >speak of), you "embed" it in an application specific way that is
> >provided by the applet itself.
> 
> Yes, well, sort of. Applets run inside an applet engine. Sun provides a
> appletrunner, so you don't have to have a separate HTML browser.
> 
> First, you can definitely run applets outside a browser. You can run the
> appletrunner, right?
> 
> Second, you can definitely run applets without HTML. This might be a
> surprise to all those who use Sun's brain-dead appletrunner tool. But, it
> is no surprise to those using JavaBee. Check out the wonderful JavaBee
> product at <URL:http://www.javabee.com/>.
> 
> My applet browser provides a simple way to run applets with support for
> parameters. In the location field of my applet browser, I type the
> following URI:
> 
> x-applet:org.jos.demo.DemoApplet
> 
> My applet browser provides an applet environment completely free of HTML.
> It loads and runs an applet, just like the applet specification says. The
> output from the applet is displayed in a frame, so that I reside the applet
> and interact with its visual components, to make sure the applet behaves
> the way I want it to. It is fast. It is direct. My applet browser is easy
> to restart (with a restart button) so that I can recompile my applet
> frequently. I invoke an applet with exactly the same mechanism as I invoke
> a servlet.
> 
> Parameters are passed with a standard query string. I can test different
> combinations of parameters. Feedback is immediate. No bulky HTML browser is
> required.
> 
> My applet browser supports the showDocument() and showStatus() methods
> required by the applet environment. The showDocument() method overwrites
> the location field with a new URI, but does not automatically run it. I can
> look at the output from showDocument() to see if looks right.
> 
> Then, I move up to embedding an applet on an HTML page.

ok, these arguemnts are definitley good for using URI's for everything
("JOS putting the U in URI" --how market does that sound?) but still not
so much an argument for Program.
 
> >- Applications (both gui and command-line) are intended to be invoked.
> >Applications are a unique type of program that are designed to carry out
> >a task and return to the shell, or carry out tasks given through a user
> >interface until the user wishes to exit the application. These types of
> >programs are the only programs that are suitable for shells because they
> >can be invoked, they have a clearly defined lifespan, and a definite way
> >of returning to the shell.
> 
> Exactly! Applications "carry out tasks given through a user interface until
> the user wishes to exit the application." That's a key difference between
> "applications" and "programs".
> 
> My program browser--you guessed it--runs programs. It provides a simple way
> to run programs with full support for parameters. In the location field of
> my program browser, I type the following URI:
> 
> x-program:org.jos.demo.DemoProgram
> 
> The standard output from the DemoProgram is display just like the
> plain-text browser.

I can see Programs being an internal abstraction used to work with all
programs uniformly (with proxies like ServletProgram) but I dont see
making people use them.
 
> >Not surprisingly, I am interested in the use of what you are proposing.
> >Debugging was something that caught my eye. I don't yet understand how a
> >unified API is useful for debugging, but if you can explain it to me,
> >there might be a use for this unified API after all.
> 
> In the end, I wish to combine all specialized browsers into a unified JOS
> browser. Here is what you'll be able to debug and demonstrate within a
> single application:
> 
> Protocol - Program Type - Status
> 
> run:os: - native OS processes - complete
> run:jose: - José applications - complete
> multi - (file:, http:, x-registry:, in:*, out:*) - complete
> x-applet: - Java applets - almost complete
> x-archive - JOS archive browser (.cab, .gz, .jar, .zip) - not started yet
> x-servlet: - Java servlets - needs more work
> x-program: - JOS programs - needs more work
> x-aglet: - Java aglets - not started yet
> 
> What does this mean? It means that you can build a servlet that dynamically
> creates an HTML index of all your applications, applets, programs, native
> programs, archives, and other servlets. You click on the digital resource
> you want to invoke. Ta-da! You get one.
> 
> Do you want it all? You can have it all. You can mix and match until you
> get dizzy and your head hurts. We live in a brave new world where programs
> are multiply connected.
> 
> - You can download and run Java bytecode from anywhere (if that's what you
> really want).
> - You can build a program that runs as a program...and a servlet.
> - You can build a Java application that runs as a Java application...or a
> program or servlet.
> - You can build an applet that runs as an applet...and a program.
> - You can run a servlet that runs as a servlet...and a program.
> - You can run a native program as a native program...and a servlet.
> - Your aglet can roam around and bring back its search results as a
> program, applet, or servlet.
> 
> - It is recursive, too. So that you can launch an applet that starts a
> program that uses servlets that use native programs. You can do anything
> you want.

this, again, is an argument for URI's and smart browsers but not
Programs (although again I can see its use internally, especially by
your browser)
 
> As an operating system, JOS should take advantage of some of the
> combinations that make the most sense. For example, the ls command should
> be available as a program, a Java application, and a servlet. When you
> invoke the ls command from within your HTML browser, the results should be
> returned as (1) plain-text or (2) full HTML code. Here is where program
> inheritence becomes critically important.

you can do that now though, add a main() to your servlet. implementing
program is pointless... (except on a IS-A basis, but then the interface
might just as well be empty)
 
> We should have a plain-text ls program. The HTML version of the ls program
> should extend the plain-text version. Both have identical functionality.
> While one runs as a program or Java application, the other runs as a
> servlet. You can browse around your JOS OS file subsystem using your HTML
> browser on a local machine or across the Internet.

you could do that now
 
> We can be compatible with other names for ls. The dir command can use the
> ls program. The dir command takes much different command line parameters
> than ls. The dir command should translate command line parameters, for
> example, and then call the ls command. See, that's why we need to run
> programs within the same process.
> 
> Or, the ls and dir commands could use a brand-new JOS program with a new
> name that does file-listing better than any other operating system.

the LS command could also be extended to open as a window (you know the
little windows on the desktop with all the icons of the current
directory, not explorer but you know what Im talking about)
 
> Here is one for the road. JOS command-line utilities should consistently
> recognize the -html option. This command-line parameter tells a program
> when it should output HTML code to standard out. When the servletrunner
> runs a program as a servlet, it should automatically pass the -html option
> to all of our JOS command-line utilities.

well HTML is to C++ what XML is to Java if you get my meaning, but i can
see how this would be useful (also still not an argument for Program)

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 10:52:40 -0700
Date: Thu, 12 Aug 1999 10:52:40 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> Don't get me wrong. I like your Application class. I just thought that it
> should implement a broad Program interface. Plus, I think an Application
> class does not need "private String[] arguments" but a separate "context"
> object. I agree that your Application class should have an exit() method, too.

well like I said: public abstract class ApplicationProgram extends
Application implements Program, but again Im still not convinced of
Programs usefulness.

I see what you mean about the context object... Application isnt exactly
solid yet.
 
> When a program context is set, a program has an opportunity to process its
> parameters. A generic UNIX(tm)-style mechanism is possible, written into a
> reusable base class. That a class that needs to be written.

Im going to add something like that but it wont be complex (id est no
parsing) if someone wants to extend it to add regexp's and the like Ill
post the new code here when I finish
 
> Or, a program can wait until the run() method is called before examining
> its parameters. When a program is "done", it sets a result code in program
> context and returns from run().

maybe Ill make a CommandLineTool extends Application to give it more CLI
related stuff...

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From ryan@whitewolf.com.au Fri, 13 Aug 1999 10:47:50 +1000
Date: Fri, 13 Aug 1999 10:47:50 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

This email is in reply to DigiGod's comment that servlets and applets
can still be run from the command-line with servletrunner and
appletviewer.

I am quite aware of this :-) But that misses my point. An applet is a
generic piece of code that can be embedded into many different container
environments for different purposes. To use an applet in any particular
instance, the environment must be set up before hand. This environment
might consist of a web page that contains other applets that the main
applet interacts with. It may depend on being contained in a web page
that has two frames, one frame containing the applet, the other frame
being controlled by the applet with showDocument. For example, a menu
applet might showDocument() in the other frame when you click on one of
its buttons.

AppletViewer is able to load applets but it is mainly for testing. You
can't possibly make use of the menu applet from the command-line. It is
only useful in a web page.

While the output of a command-line tool is directed back to the
command-line or to the local filesystem, the output of an Applet is
directed to an entirely different environment that lives in another
dimension to the command-line.

In the same way, the output of a servlet is directed to a completely
different environment. You can't "use" a servlet from the command-line,
you can only use it through the servlet interface because that is the
environment it was designed to take advantage of.

servletrunner and appletviewer are both programs that you can use from
the command-line, but servlets and applets are programs that can only be
"used" within certain contexts.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From ryan@whitewolf.com.au Fri, 13 Aug 1999 10:50:39 +1000
Date: Fri, 13 Aug 1999 10:50:39 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

DigiGod Q Frasché wrote:
> 
> Ryan Heise wrote:
> > > public abstract class Application {
> > >  private          String         arguments[];
> > >  private          BufferedReader reader      = null;
> > >  protected static Application    app         = null;
> >
> > Did you intend for Application to implement the Program interface, or is
> > this your version of the program interface (as an abstract class
> > instead)?
> 
> its just something I came up with to make apps easier to create, but I
> brought it up because it could implement the program interface in a
> subclass
> 
> public abstract class ApplicationProgram extends Application implements
> Program {...}
> 
> although Im not entirely convinced of its use

There is definately some useful functionality you could put in an
abstract base class (command line parsing, for example), but I think
this functionality is more reusable if it is provided as a library.
Delegation is a much more flexible design than inheritance. Even more so
in the case of Java because it does not support multiple implementation
inheritance. So, for example, if you wanted to reuse the command-line
processing functionality in an Applet, you couldn't extend the abstract
base class because applets already extend Applet.

Since my style of programming is to have very small main() methods, I
personally wouldn't gain much from inheriting functionality from a
framework-type base class, but I accept that other people have their own
preference. The main point is that if I choose not to extend
Application, or even implement Program, my programs should still work
under JOS. I would think that the vast majority of programmers will
stick to the program interface that Sun designed rather than use an
interface that someone else wrote. I'm still not sure about the purpose
of Gilbert's unified program interface but whatever the purpose, it
would be (IMHO) best to achieve that purpose without making programs
implement a non-standard interface.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From ryan@whitewolf.com.au Fri, 13 Aug 1999 10:53:32 +1000
Date: Fri, 13 Aug 1999 10:53:32 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:

> This uses all non-static methods and, in Java, benefits from all that
> object-oriented stuff. You should put all of the common functionality of a
> program into a base class and reuse it. With a Program and ProgramContext,
> you can.

Please see my comment about DigiGod's base class. (Although everyone's
entitled to their own opinion, inheriting all the common functionality
from a base class is something most OO designers use as a last resort)

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From gchii@mindspring.com Thu, 12 Aug 1999 20:47:00 -0400
Date: Thu, 12 Aug 1999 20:47:00 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 10:47 AM 8/12/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>whats wrong with just making applications that act as a "default"
>environment for these?

In an object-oriented world, a program is an object, not a class. A JOS
program should be an object, too. You should be able to use a program like
other objects.

A smart object factory should be able to return an object--not a
class--when you want to load a JOS program. Let's go back to the
DemoProgram, again. When I type this URI into my program browser, it should
return an instance of the DemoProgram.

x-program:org.jos.demo.DemoProgram

  public void example() {
    exec( "x-program:org.jos.demo.DemoProgram" ); 
  }
  public int exec( String uri ) {
    try {
      Program p = (Program) new URI( uri ).getObject();
    }
    catch( ClassCastException e ) {
      return;
    }
    p.setProgramContext( whatever );
    p.run();
    return whatever.getResultCode();
  }

When we have a smart object factory that can create all kinds of digital
resources, it would be straight forward to create a smart program factory.

- If I pass the name of a class that implements the Program interface, the
factory returns a Program object.

- If I pass the name of a class that implements the java.awt.Applet
interface, the factory returns a Program object.

- If I pass the name of a class that implements the javax.servlet.Servlet
interface, the factory returns a Program object.

- In Java 1.1 and higher, if I pass the name of a class that declares
static main(), the factory returns a Program object.

Our uniform browser would be much simpler. Given any URI, the uniform
browser would able to do handle it:

:
Object o = new URI( uri ).getObject();

if ( o instanceof Program ) {
  runProgram( (Program) o );
}
if ( o instanceof InputStream ) {
  displayInput( (InputStream) o );
}
:

I propose the Program and ProgramContext as a simple way to write programs
now that will run on JOS through a consistent in-process mechanism. I
believe that implementations of Program is more object-oriented than static
main() and provides better support for inheritence. Program and
ProgramContext do not depend on the reflection API.

>ok, you made a good point about how one should be able to test ones
>servlet; but how does this argue that they HAVE to be a Program?

A servlet does not have to implement the Program interface. A servlet
should be able to run any program. The output from any program should be
piped through the response output stream. You can create a generic servlet
that can run programs by program name. You can pass parameters to the
program with a query string.

An HTML browser should be able to run any program, including the
ServletProgram. In the marketplace, people might use a JOS browser
*because* it can run servlets without an HTTP service.

>isnt a Servlet (at the very top) just an interface (what they should
>have done with Applet, btw) and isnt it unasuming about HTTP, that is
>not locked to it? Ive always thought of a Servlet as a service-let not a
>server-let, just a handy stream based IPO plugin.

Yes, thankfully. Servlet is an interface. It seems that Sun Microsystems
may have learned something after all. It is unassuming about HTTP, too. I'm
not sure what to call it. It is something like a Java I/O Bean.
 
>("JOS putting the U in URI" --how market does that sound?)

JOS is a future-oriented operating system. We are trying to make JOS more
uniform than any other operating system. In a sense, we are re-defining the
U in URI.

>I can see Programs being an internal abstraction used to work with all
>programs uniformly (with proxies like ServletProgram) but I dont see
>making people use them.

You're right. I'm not trying to change the way everybody else writes code.
I'm trying to change the way I write code. I would like all my Java
programs to run inside a strong OO model. Could there will be more
"programs" in JOS?
 
>this, again, is an argument for URI's and smart browsers but not
>Programs (although again I can see its use internally, especially by
>your browser)

I want a ProgramFactory plugged into the ObjectFactory. Each object
returned by the ProgramFactory must be an implementation of Program. That's
what makes the smart browser possible. Otherwise, the smart browser would
be complicated with having to too much.

And probably more important for architecture, I want any Java object to be
able to run any JOS program the minimum number of lines of code.

Think about what it takes to learn how to run a program using the
reflection API. Many Java programmers won't want to learn all that just to
run a program.

Think about how easy it will be to write a scripting language to run one
JOS program after another. It does not have the overhead of separate
processes. It works without a modified JVM. It even works in Java 1.0.2.

What does a JOS batch file look like? It looks a lot like a URI list. If
one of these programs returns a non-zero result code, the script is shut down.

#org.jos.shellscript.Script
x-program:org.jos.demo.DemoProgram
x-program:org.jos.demo.DemoServlet
run:os:mkdir temp
run:os:cp * .
x-program:org.jos.demo.DemoApplet

For those working on a generic scripting API, a script is a kind of
program, too.

We should build a JOS demonstration script. It should show off all of the
things you can do with JOS that all the other operating systems can only
dream about. Wouldn't you be impressed with an operating system that runs
all of the Java applications, applets and servlets you already wrote? I would.

Oh, and did I mention piping? You can do it.

x-program:org.jos.demo.DemoProgram > temp/log.txt

>you can do that now though, add a main() to your servlet. implementing
>program is pointless... (except on a IS-A basis, but then the interface
>might just as well be empty)

Why should I go back and add main() to my old applets and servlets when I
don't have to? It doesn't have to be that way. Once I have AppletProgram
and ServletProgram and ApplicationProgram, I'm done. Further, I can use
(and test) all those Java applications, applets and servlets that other
people write.

And I keep forgetting to mention this. You can "run" any Java class that
implements java.awt.Component. You can also "run" any Java class that is a
Java Bean. The uniform browser uses URIs in the location field. It also
uses shortcuts and shortcut editor so that you don't have to create a URI
manually.

What is a shortcut? It might as well be any registry-compatible file with a
uri property.

uri=x-component:java.awt.Button?label="Hello, World!"

It might help to "browse" around a new component library to see what
everything looks like. When you want to learn the AWT or Swing, would you
like to see each component as it works at runtime? Would you like to see
all components within the same component browser? When other programmers
receive a copy of our JOS distribution (someday), they will want to see
what's there. I think we can easily put together a point-and-click tour of
all kinds of components, even those components added at the "last minute".
And more, when other people ship component librarys for JOS, all those
components will be assimilated into the JOS demo program.

Think about the JOS out-of-box experience. Based on the strengh of Java, we
can re-define the concept of "try before you buy". We can create a JOS
distribution that people can run components--before they are installed--to
see what they look like. They can download the uniform browser and take JOS
for a test drive before downloading a JOS distribution. They start the
uniform browser from a CD-ROM and start browsing around.

Our installation/configuration programs are written in Java and run
unchanged on 22 platforms. The Linux community could use JOS to make Linux
easier to install.

When we reach higher than a high level third generation language like Java,
we need a strong model for programs. Using an interactive, visual IDE, you
should be able to configure even the most complicated program. The
configuration of a single step program is reduced to a single URI. A
step-by-step script is reduced to a URI list.

A uniform browser puts any digital resource within your reach. You can
create a shortcut for it. You can write a program that uses it. You can do
whatever you want.

We need to reduce a program to its bare essentials. It must be platform
independent. It must assume neither UNIX(tm)-style or MS-DOS-style command
line parameters. That's better left to an abstract base class.

Sun Microsystems went too far. They reduced it to pre-object oriented
static main() from C. It must have been reassuring to C programmers that
started writing Java code.




From tmiller@haverford.edu Thu, 12 Aug 1999 21:14:33 -0400 (EDT)
Date: Thu, 12 Aug 1999 21:14:33 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Program and ProgramContext

> 1. UNIX pipes are usually linear because UNIX processes typically read
> from stdin and write to stdout. It is difficult to achieve the effect of
> parallel and forking pipes.

	True, but it is also difficult to develop clear and easy CLI
parellel and forking pipes, which is why I directed my commentary towards
"conventional" pipes.  But I do agree that JavaBeans have better
'connectivity' -- that is, after all, what they were designed for.  One
would /hope/ that a GUI's 'scripting'/'visual command line' would allow
for such multiple Beans as a matter-of-course way of doing things (as
opposed to discrete programs that use Beans to generate other discrete
programs)... and that those Beans, likewise, could (if appropriate) do
useful things with a pipe-only input.

-_Quinn




From tmiller@haverford.edu Thu, 12 Aug 1999 21:20:08 -0400 (EDT)
Date: Thu, 12 Aug 1999 21:20:08 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Program and ProgramContext

> While each JVM runs in a separate native thread, it looks like a separate
> process in Java. I don't have to re-write a JVM. I don't have to re-write
> the Java API. I should be able to use the JNI tools Sun provides to give me
> what I want. If it works, what could be simpler than that?

	Thanks for the explanation.  I had (apparently) misunderstood your
commentary as being directed more specifically at the decaf/jJOS portion
of JOS.  Your system, and ones like Echnida, are (evidently) valuable
tools for working with multiple processes in Java.  However, I feel that a
custom JVM and a few alterations to the interpertation of Sun's API are
both necessary and desirous for JOS.

-_Quinn




From gchii@mindspring.com Thu, 12 Aug 1999 21:54:46 -0400
Date: Thu, 12 Aug 1999 21:54:46 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 10:50 AM 8/13/99 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>Delegation is a much more flexible design than inheritance.

Good programs may use delegation and inheritence. Great programs use
delegation when delegation is needed and use inheritence when inheritence
is needed.

I agree with you about delegation. Many classes can't extend the
Application class. Delegation is better. I think the ProgramContext could
be passed to all kinds of reusable tools. Maybe a ArgumentParser tool could
accept a ProgramContext as a parameter. It goes off and parses parameters
in the style of UNIX(tm). So the code for parameter parsing doesn't have to
be written into every program.

>but I accept that other people have their own preference.

I strongly agree. I'm working on JOS because many operating systems have a
foundation of one-size-fits-all; those other vendors don't believe in your
preference. I'm working on the JOS registry so that it's easy to build
preferences into every JOS program.

I prefer to build my own operating system because Sun's JavaOS is not even
close to what I want. Neither is Microsoft Windows or Linux. I would prefer
to work with something more object oriented, something more reusable,
something more compatible.

JOS is state of the art. An operating system that benefits from all 50
years of the software industry's experience.

>I would think that the vast majority of programmers will
>stick to the program interface that Sun designed rather than use an
>interface that someone else wrote.

You're doing something different. You're working on the JOS Project, aren't
you? You're trying to imagine new possibilites. So, it's unconventional.
That doesn't bother you.

You have identified the biggest challenge facing the JOS project. Many Java
programmers prefer to follow Sun wherever they go.

- Are they going to stick to the one-process-per-JVM architecture that Sun
designed? How do we convince them they need a multiple process JOS JVM?

- Are they going to stick to depretiation, reasonable incompatibility,
feature-rich defective code and always-the-latest-platform loyalty that Sun
recommends? How do we convince them to give open source JOS APIs a try?

So, you think my design stinks? How do I fix it? You think it's a lost
cause? That's acceptable, too.

>I'm still not sure about the purpose
>of Gilbert's unified program interface but whatever the purpose, it
>would be (IMHO) best to achieve that purpose without making programs
>implement a non-standard interface.

I am an architect and software critic. I experiment with these things.
That's what I do. I'm not asking every Java programmer to implement the
Program interface. I am not making the Program interface a requirement, but
maybe a viable option. I am trying to design an interface for JOS programs.

I wish there was some way to describe all that I am working on. I am
working on something big, really big. It is different than any other
software I have ever seen. It is the kind of operating system that I've
been looking for since 1985. It supports a model of one console/many
processors. It is a platform for a mid-level fourth generation language. It
is made possible by Java, thanks to Sun Microsystems.




From tmiller@haverford.edu Thu, 12 Aug 1999 22:27:23 -0400 (EDT)
Date: Thu, 12 Aug 1999 22:27:23 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Program and ProgramContext

	In the beginning, there was the source and the object code, and
once the object code was split from its source, it withdrew within its
'main' method shell, and lived only through its stdin/out/err tubes.  Time
rolled by, and the dynamic-link library was developed, which allowed the
source to declare on the object code's shell what functions it wished
exposed.  And so applications split from libraries.  And the number of
applications grew, forcing some to specialize in niches, habitats without
which they were useless.

	With me so far?  Enter Java, and reflection.  The boundary between
application and library disappears; the internals of both are equally
exposed, though the libraries are designed for this.  Emulations for the
niches arrive.  Suddenly, we can use any chunk of code on our computer
without compiling anything, without source to any of it; but why would you
want to?

	Yes, you can create a minimal abstraction that represents this
ability, but what good does it do you?  The point of any given chunk of
code is to perform its I/O.  Different chunks of code have very different
ways of performing this I/O... the integer-returning string-array
inputting main() method, call-with-value and return-some-single-thing or
call-by-reference, a group of paired get/set XXX() functions (JavaBeans),
a pair of ServletStreams... UNIX pipes operate under the assumption that
the greatest common factor of I/O is the byte-stream.  JOS, being O-O and
blessed with reflection, can extend the byte-stream to include not only
any kind of data, but information on that data and methods by which to
manipulate it.

	To define a universal interface to which all extant bytecode
chunks could be ascribed is only useful if a universal i/o protocol can
be developed for those bytecodes.  It's truly wonderful that you can call
any chunk of code on the system and say "if it returns a non-zero result
code, halt the script," but where does that result code come from?  How do
you define success for a text-input box?  More importantly, how do I get
that entered text back out?  Pipe it out?  What if I pop a dialog with
three different text boxes?  Piping it out requires either a protocol
(i.e. a universal i/o protocol!) or reflection (which removes the need for
a universal i/o protocol!).

	The byte-stream idea has its own problems:

jpeg-picker | guassian-blur | jpeg-to-bmp > /tmp/tmp.bmp

	What does jpeg-picker output?  Suppose it's a main() application.
It returns an error code, and (might) pipe (say) a file-name to stdout.
Does gaussian-blur take the file-name as a command-line argument or expect
the jpeg image as a bytestream on stdin, or is it a javaBean, where you
call setBlurImage()?


	Function (library) calls, main() applications, JavaBeans,
servlets, applets, aglets, etc, answer all of these questions in
well-defined and useful, albeit specialized and/or limited manners.
Starting their execution in the same manner isn't all that helpful if it
immedediately degenerates into a series of special cases handling each
particular type of communication.

	It might be useful for the shell program/script interperter itself
to have to only handle two object types at the highest level -- a Program
and its ProgramContext -- but I don't see it benefitting the scripter
much.

-_Quinn






From digigod@earthling.net Thu, 12 Aug 1999 19:54:29 -0700
Date: Thu, 12 Aug 1999 19:54:29 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> I is about time I used an example of how test1, test2 and test3 *should* work.
> 
> // Application.java
> public abstract Application
>     implements Program {
>   public Application() {
>   }
>   public ProgramContext getProgramContext() {
>     return context;
>   }
>   public void setProgramContext( ProgramContext v ) {
>     context = v;
>   }
>   public void exit( int v ) {
>     context.setResultCode( (byte) v );
>   }
>   private ProgramContext context = null;
> }
> 
> // test1.java
> public class test1
>     extends Application {
>   public test1() {
>   }
>   public void run() {
>     System.out.println( "Running " + getClass().getName() + "..." );
>     System.out.println( "one" );
>   }
> }
> 
> // test2.java
> public class test2
>     extends test1 {
>   public test2() {
>     super();
>   }
>   public void run() {
>     super.run();
>     System.out.println( "two" );
>   }
> }
> 
> // test3.java
> public class test3
>     extends test1 {
>   public test3() {
>   }
> }
> 
> $ test1
> Running test1...
> one
> 
> $ test2
> Running test2...
> one
> two
> 
> $ test3
> Running test3...
> one
> 
> This uses all non-static methods and, in Java, benefits from all that
> object-oriented stuff. You should put all of the common functionality of a
> program into a base class and reuse it. With a Program and ProgramContext,
> you can.

ok, I see what you mean; but also note that you could do this with my
application class just as easily, or you could do something like:

public class apptop {
 protected static apptop realapp;
 static {
  realapp = new apptop();
 }
 public static void main(String args[]) {
  realapp.realmain();
 }
 public void realmain() {
  System.out.print("Hello");
 }
}

public class appbot extends apptop {
 static {
  realapp = new appbot();
 }
 public void realmain() {
  super.realmain();
  System.out.print(" world.");
 }
}


note that this static initializer "trick" is what I use in my app class,
a workaround nesseacary for the program to run both as a regular
application and have the ability to be used in another easily. 

> Historical note: Please don't take this as a critisism of the command-line
> utilities. The command-line utilities are great! Each command line utility
> has common functionality. With a stronger model for "programs", that
> bytecode could have been stored only once, not duplicated in each archive.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From ryan@whitewolf.com.au Fri, 13 Aug 1999 13:40:43 +1000
Date: Fri, 13 Aug 1999 13:40:43 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

{{ It appears my last email didn't get through. If you receive this
twice, sorry! }}

Gilbert Carl Herschberger II wrote:

> In an object-oriented world, a program is an object, not a class. A JOS
> program should be an object, too. You should be able to use a program like
> other objects.

I do not believe a program is an object. A program is a collection of
objects that are asked to perform a task or procedure. In an
object-oriented world, it is the objects in the program that are
reusable. Reuse at the Program interface level is how things work in the
"procedural" world.

This is why my main() methods do very little except pass control off to
"reusable" (in the OO sense) objects. The main() method (or procedure)
is useful in a procedural programming context, such as shell scripts.

A scripting language that is designed around object-oriented concepts
would not make use of the main() interface. Instead it would talk
directly with reusable objects. This is my vision of reusable JavaBeans
interacting with eachother rather than programs calling eachother in a
procedural way. I briefly outlined this vision in another email.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From ryan@whitewolf.com.au Fri, 13 Aug 1999 12:03:16 +1000
Date: Fri, 13 Aug 1999 12:03:16 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:

> In an object-oriented world, a program is an object, not a class. A JOS
> program should be an object, too. You should be able to use a program like
> other objects.

I do not believe a program is an object. A program is a collection of
objects that are asked to perform a task or procedure. In an
object-oriented world, it is the objects in the program that are
reusable. Reuse at the Program interface level is how things work in the
"procedural" world.

This is why my main() methods do very little except pass control off to
"reusable" (in the OO sense) objects. The main() method (or procedure)
is useful in a procedural programming context, such as shell scripts.

A scripting language that is designed around object-oriented concepts
would not make use of the main() interface. Instead it would talk
directly with reusable objects. This is my vision of reusable JavaBeans
interacting with eachother rather than programs calling eachother in a
procedural way. I briefly outlined this vision in another email.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From gchii@mindspring.com Fri, 13 Aug 1999 01:30:14 -0400
Date: Fri, 13 Aug 1999 01:30:14 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 01:40 PM 8/13/99 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>I do not believe a program is an object.

What is a program? Why is a program not an object?

I understand you do what I do. You write one line of code in a static
main() method.

My main method looks either like

public class DemoApplication {
  public static main( String[] args ) {
    new DemoApplication().run();
  }
}

or

public class DemoProgram {
  public static void main( String[] args ) {
    new DemoProgram( args ).run();
  }
}

I don't have a lot of fun writing pretty much the same static main() for
each Java application. But, I'm sure you'll agree that instances of
DemoApplication and DemoProgram are objects.

>Reuse at the Program interface level is how things work in the
>"procedural" world.

What is a "procedural" world? Is object-oriented not procedural? Are you
contrasting a step-by-step batch process to an event-driven one?

I understand that a OO scripting language should be able to coordinate the
activity of a collection of JavaBeans. One JavaBean should be able to load
and use another. Many beans can be developed into one new bean. It is
recursive as well as reusable. A huge and complex bean is still an object.

If I want to, I can create a custom JavaBean that reads a collection of
beans from an object stream. To configure my custom bean, it only has one
"property", an object stream. That would be a pretty powerful bean. It
could reuse any beans that have been serialized.

At some point, a requestor must initialize my custom JavaBean and set its
object stream property. And at some point, this bean must be finalized.
Maybe it shuts down when the JVM shuts down, like a static property of a
class. Maybe it "listens" for a shut down request. In the big picture, the
lifetime of a bean has a beginning and end. It is initialized and then
finalized. While the specific steps between initialization and finalization
are unplanned, this is a predictable, step-by-step batch process.

An event driven model builds upon a procedural one. Without procedures
(methods), there are no events.




From gchii@mindspring.com Fri, 13 Aug 1999 01:53:33 -0400
Date: Fri, 13 Aug 1999 01:53:33 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 07:54 PM 8/12/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>note that this static initializer "trick" is what I use in my app class,
>a workaround nesseacary for the program to run both as a regular
>application and have the ability to be used in another easily. 

Yes! I want to "run" most of my programs both as a regular Java application
compatible with the java tool *and* from any other Java class. It should be
easy. It should be direct. It shouldn't take much.

Like you, I want to build an application most of the time by extending a
powerful base class. And yet, there are times when I need to run an
existing class as a program, too. Delegating the ProgramContext to a
separate object reduces the amount of new code I have to write in either case.

So far, this discussion has identified very important issues. I hope that
some really good code comes out of it. I would like to use an
implementation of ParameterParser (ArgumentParser) that parses parameters
from ProgramContext using the UNIX(tm) way. What would a ParameterParser
look like anyway?

A program should decide for itself if it needs the assistence a parameter
parser, and if so which one.

Isn't this cool? I should be able to have properties of my program set
automatically based on command line arguments. Could we do this?

public class DemoProgram {
:
  public void set__help( boolean v ) {
  }
:
}

so that when I use java org.jos.demo.DemoProgram --help, the set__help()
method is called automatically? We can do this once with a
UNIXStyleParameterParser. But wait! We can pass a Program to a
ParameterParser, not a ProgramContext. The parser needs both the program
and context, but getProgramContext() is part of the Program interface (or
should be).

If we substitute underscores (_) for dashes (-), the names of all command
line parameters are reflected in a program. If there's a command line
parameter that does not match a method of a program, should the parser
throw an exception?

My head hurts to think about this any more.




From digigod@earthling.net Thu, 12 Aug 1999 23:22:11 -0700
Date: Thu, 12 Aug 1999 23:22:11 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> >whats wrong with just making applications that act as a "default"
> >environment for these?
> 
> In an object-oriented world, a program is an object, not a class. A JOS
> program should be an object, too. You should be able to use a program like
> other objects.
> 
> A smart object factory should be able to return an object--not a
> class--when you want to load a JOS program. Let's go back to the
> DemoProgram, again. When I type this URI into my program browser, it should
> return an instance of the DemoProgram.
> 
> x-program:org.jos.demo.DemoProgram
> 
>   public void example() {
>     exec( "x-program:org.jos.demo.DemoProgram" );
>   }
>   public int exec( String uri ) {
>     try {
>       Program p = (Program) new URI( uri ).getObject();
>     }
>     catch( ClassCastException e ) {
>       return;
>     }
>     p.setProgramContext( whatever );
>     p.run();
>     return whatever.getResultCode();
>   }
> 
> When we have a smart object factory that can create all kinds of digital
> resources, it would be straight forward to create a smart program factory.
> 
> - If I pass the name of a class that implements the Program interface, the
> factory returns a Program object.
> 
> - If I pass the name of a class that implements the java.awt.Applet
> interface, the factory returns a Program object.
> 
> - If I pass the name of a class that implements the javax.servlet.Servlet
> interface, the factory returns a Program object.
> 
> - In Java 1.1 and higher, if I pass the name of a class that declares
> static main(), the factory returns a Program object.

ok, why not just do this. the Program interface can have a
ServletProgram an AppletProgram and all it creates these internally in
your browser as a generic way to handle them, theres no reason to use it
system wide that I can see
 
> Our uniform browser would be much simpler. Given any URI, the uniform
> browser would able to do handle it:
> 
> :
> Object o = new URI( uri ).getObject();
> 
> if ( o instanceof Program ) {
>   runProgram( (Program) o );
> }
> if ( o instanceof InputStream ) {
>   displayInput( (InputStream) o );
> }
> :
> 
> I propose the Program and ProgramContext as a simple way to write programs
> now that will run on JOS through a consistent in-process mechanism. I
> believe that implementations of Program is more object-oriented than static
> main() and provides better support for inheritence. Program and
> ProgramContext do not depend on the reflection API.

no one should be forced to do this though
 
> >ok, you made a good point about how one should be able to test ones
> >servlet; but how does this argue that they HAVE to be a Program?
> 
> A servlet does not have to implement the Program interface. A servlet
> should be able to run any program. The output from any program should be
> piped through the response output stream. You can create a generic servlet
> that can run programs by program name. You can pass parameters to the
> program with a query string.
> 
> An HTML browser should be able to run any program, including the
> ServletProgram. In the marketplace, people might use a JOS browser
> *because* it can run servlets without an HTTP service.

your HTML browser seems to be a "do everything" app, at least your doing
it right by not trying to do it all at once... but why not just make the
OS/UI an OO version of unix (that is a buncha small things that are
dynamically thrown together to create "sponteneous applications" from
beans and the like based on the current situations needs)
 
> >isnt a Servlet (at the very top) just an interface (what they should
> >have done with Applet, btw) and isnt it unasuming about HTTP, that is
> >not locked to it? Ive always thought of a Servlet as a service-let not a
> >server-let, just a handy stream based IPO plugin.
> 
> Yes, thankfully. Servlet is an interface. It seems that Sun Microsystems
> may have learned something after all. It is unassuming about HTTP, too. I'm
> not sure what to call it. It is something like a Java I/O Bean.

I think SUN bashing isnt going to help anything, they didnt do it
perfect; but nobodys perfect. the JavaLobby is the yin to their yang so
that kinda talk should go on there; otherwise we should just worry about
JOS.

I think IPO plugin is more accurate then I/O Bean (but maybe thats just
because I said it ;)
 
> >("JOS putting the U in URI" --how market does that sound?)
> 
> JOS is a future-oriented operating system. We are trying to make JOS more
> uniform than any other operating system. In a sense, we are re-defining the
> U in URI.

not redefing it, just using it :)
 
> >I can see Programs being an internal abstraction used to work with all
> >programs uniformly (with proxies like ServletProgram) but I dont see
> >making people use them.
> 
> You're right. I'm not trying to change the way everybody else writes code.
> I'm trying to change the way I write code. I would like all my Java
> programs to run inside a strong OO model. Could there will be more
> "programs" in JOS?

ok, that last sentence didnt translate well. but, I think I see what
your saying...
you have a ProgramRunner that your app uses to interface with programs,
all programs, but you dont need to implement program because the
ProgramRunner creates an appropriate proxy (for a servlet it creates a
ServletProgram, etc). any program can use the program runner as it is
part of the program library; no one needs to use it.
 
> >this, again, is an argument for URI's and smart browsers but not
> >Programs (although again I can see its use internally, especially by
> >your browser)
> 
> I want a ProgramFactory plugged into the ObjectFactory. Each object
> returned by the ProgramFactory must be an implementation of Program. That's
> what makes the smart browser possible. Otherwise, the smart browser would
> be complicated with having to too much.
> 
> And probably more important for architecture, I want any Java object to be
> able to run any JOS program the minimum number of lines of code.
> 
> Think about what it takes to learn how to run a program using the
> reflection API. Many Java programmers won't want to learn all that just to
> run a program.

its pretty simple... and I can see this as an argument for internal use
 
> Think about how easy it will be to write a scripting language to run one
> JOS program after another. It does not have the overhead of separate
> processes. It works without a modified JVM. It even works in Java 1.0.2.
> 
> What does a JOS batch file look like? It looks a lot like a URI list. If
> one of these programs returns a non-zero result code, the script is shut down.

I dont think we should have a "JOS batch file" just the GSI.
 
> #org.jos.shellscript.Script
> x-program:org.jos.demo.DemoProgram
> x-program:org.jos.demo.DemoServlet
> run:os:mkdir temp
> run:os:cp * .
> x-program:org.jos.demo.DemoApplet
> 
> For those working on a generic scripting API, a script is a kind of
> program, too.

well a script is a plugin to GSI kinda, theres a ScriptRunner
Application but you could make a ScriptProgram for internal use in your
browser easily (although using GSI directly would offer many benifts)
 
> We should build a JOS demonstration script. It should show off all of the
> things you can do with JOS that all the other operating systems can only
> dream about. Wouldn't you be impressed with an operating system that runs
> all of the Java applications, applets and servlets you already wrote? I would.

this is the goal, alright
 
> Oh, and did I mention piping? You can do it.
> 
> x-program:org.jos.demo.DemoProgram > temp/log.txt
> 
> >you can do that now though, add a main() to your servlet. implementing
> >program is pointless... (except on a IS-A basis, but then the interface
> >might just as well be empty)
> 
> Why should I go back and add main() to my old applets and servlets when I
> don't have to? It doesn't have to be that way. Once I have AppletProgram
> and ServletProgram and ApplicationProgram, I'm done. Further, I can use
> (and test) all those Java applications, applets and servlets that other
> people write.

this is an argument for Program, /internally/
 
> And I keep forgetting to mention this. You can "run" any Java class that
> implements java.awt.Component. You can also "run" any Java class that is a
> Java Bean. The uniform browser uses URIs in the location field. It also
> uses shortcuts and shortcut editor so that you don't have to create a URI
> manually.

this sounds kinda like BeanBox on angel dust
 
> What is a shortcut? It might as well be any registry-compatible file with a
> uri property.
> 
> uri=x-component:java.awt.Button?label="Hello, World!"
> 
> It might help to "browse" around a new component library to see what
> everything looks like. When you want to learn the AWT or Swing, would you
> like to see each component as it works at runtime? Would you like to see
> all components within the same component browser? When other programmers
> receive a copy of our JOS distribution (someday), they will want to see
> what's there. I think we can easily put together a point-and-click tour of
> all kinds of components, even those components added at the "last minute".
> And more, when other people ship component librarys for JOS, all those
> components will be assimilated into the JOS demo program.
> 
> Think about the JOS out-of-box experience. Based on the strengh of Java, we
> can re-define the concept of "try before you buy". We can create a JOS
> distribution that people can run components--before they are installed--to
> see what they look like. They can download the uniform browser and take JOS
> for a test drive before downloading a JOS distribution. They start the
> uniform browser from a CD-ROM and start browsing around.

why not just put the JOS installer on the CD and have it setup so you
can run the browser to test it, it would be nice if we could give these
CD's out for free; unless you have broadband noones downloading an OS 
 
> Our installation/configuration programs are written in Java and run
> unchanged on 22 platforms. The Linux community could use JOS to make Linux
> easier to install.

I could imagine that would be somewhat emasculating for Linux
 
> When we reach higher than a high level third generation language like Java,
> we need a strong model for programs. Using an interactive, visual IDE, you
> should be able to configure even the most complicated program. The
> configuration of a single step program is reduced to a single URI. A
> step-by-step script is reduced to a URI list.

you should make your shortcut file so it can run a URI, a list of URI's
a script or any combination. now that would be cool
 
> A uniform browser puts any digital resource within your reach. You can
> create a shortcut for it. You can write a program that uses it. You can do
> whatever you want.

why have a browser though? why not just build most of this into JADE?
say you click on a HTML file on your desktop, it sends the URI to the
launcher which locates the right JavaBean and opens it up, if the HTML
file has JavaScript in it the HTML bean tells the OS which hands it a
GSI interface for JavaScript. a sponteneus application, of sorts.
 
> We need to reduce a program to its bare essentials. It must be platform
> independent. It must assume neither UNIX(tm)-style or MS-DOS-style command
> line parameters. That's better left to an abstract base class.
> 
> Sun Microsystems went too far. They reduced it to pre-object oriented
> static main() from C. It must have been reassuring to C programmers that
> started writing Java code.

it was, another way around this is to make your apps all OO, and have a
script to launch them. outsourcing main() basically.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 23:24:09 -0700
Date: Thu, 12 Aug 1999 23:24:09 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Ryan Heise wrote:
> 
> This email is in reply to DigiGod's comment that servlets and applets
> can still be run from the command-line with servletrunner and
> appletviewer.
> 
> I am quite aware of this :-) But that misses my point. An applet is a
> generic piece of code that can be embedded into many different container
> environments for different purposes. To use an applet in any particular
> instance, the environment must be set up before hand. This environment
> might consist of a web page that contains other applets that the main
> applet interacts with. It may depend on being contained in a web page
> that has two frames, one frame containing the applet, the other frame
> being controlled by the applet with showDocument. For example, a menu
> applet might showDocument() in the other frame when you click on one of
> its buttons.
> 
> AppletViewer is able to load applets but it is mainly for testing. You
> can't possibly make use of the menu applet from the command-line. It is
> only useful in a web page.
> 
> While the output of a command-line tool is directed back to the
> command-line or to the local filesystem, the output of an Applet is
> directed to an entirely different environment that lives in another
> dimension to the command-line.
> 
> In the same way, the output of a servlet is directed to a completely
> different environment. You can't "use" a servlet from the command-line,
> you can only use it through the servlet interface because that is the
> environment it was designed to take advantage of.
> 
> servletrunner and appletviewer are both programs that you can use from
> the command-line, but servlets and applets are programs that can only be
> "used" within certain contexts.

I was trying to reinforce Gilberts point (or what I understand of it)
that all this is just to provide a uniform testing/demoing enviroment...

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 23:32:29 -0700
Date: Thu, 12 Aug 1999 23:32:29 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Ryan Heise wrote:
> There is definately some useful functionality you could put in an
> abstract base class (command line parsing, for example), but I think
> this functionality is more reusable if it is provided as a library.
> Delegation is a much more flexible design than inheritance. Even more so
> in the case of Java because it does not support multiple implementation
> inheritance. So, for example, if you wanted to reuse the command-line
> processing functionality in an Applet, you couldn't extend the abstract
> base class because applets already extend Applet.
> 
> Since my style of programming is to have very small main() methods, I
> personally wouldn't gain much from inheriting functionality from a
> framework-type base class, but I accept that other people have their own
> preference. The main point is that if I choose not to extend
> Application, or even implement Program, my programs should still work
> under JOS. I would think that the vast majority of programmers will
> stick to the program interface that Sun designed rather than use an
> interface that someone else wrote. I'm still not sure about the purpose
> of Gilbert's unified program interface but whatever the purpose, it
> would be (IMHO) best to achieve that purpose without making programs
> implement a non-standard interface.

I agree, I made my class because Id rather do it that way, I think
gilbert made his because he likes to do it that way. my class runs as a
regluar app, gilberts needs a runner. ones not better then the other,
they're different you could even use both. I think gilbert wrote his to
make a way for his browser to abstract everything uniformly, but Im not
sure. I made mine because I program that way.

I have small main's too, I dont like having them in my objects though;
it creeps me out. I like having a class called Main thats basically a
batch file to run my stuff, this is a easy way to make that even
smaller. If I make an Applet that can run standalone I include a Main
that creates an applet context and a Frame and all that to run it, I
dont think that belongs in my Applet since its not an Applet or an
application at that point.

I agree that it should be more like a library, Im decoupling the command
line parsing from my class so it can be reused even in non
Appplication's. Ill post that when I finish it.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 23:40:04 -0700
Date: Thu, 12 Aug 1999 23:40:04 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> >Delegation is a much more flexible design than inheritance.
> Good programs may use delegation and inheritence. Great programs use
> delegation when delegation is needed and use inheritence when inheritence
> is needed.

exactly.
 
> I agree with you about delegation. Many classes can't extend the
> Application class. Delegation is better. I think the ProgramContext could
> be passed to all kinds of reusable tools. Maybe a ArgumentParser tool could
> accept a ProgramContext as a parameter. It goes off and parses parameters
> in the style of UNIX(tm). So the code for parameter parsing doesn't have to
> be written into every program.
> 
> >but I accept that other people have their own preference.
> 
> I strongly agree. I'm working on JOS because many operating systems have a
> foundation of one-size-fits-all; those other vendors don't believe in your
> preference. I'm working on the JOS registry so that it's easy to build
> preferences into every JOS program.
> 
> I prefer to build my own operating system because Sun's JavaOS is not even
> close to what I want. Neither is Microsoft Windows or Linux. I would prefer
> to work with something more object oriented, something more reusable,
> something more compatible.
> 
> JOS is state of the art. An operating system that benefits from all 50
> years of the software industry's experience.
> 
> >I would think that the vast majority of programmers will
> >stick to the program interface that Sun designed rather than use an
> >interface that someone else wrote.
> 
> You're doing something different. You're working on the JOS Project, aren't
> you? You're trying to imagine new possibilites. So, it's unconventional.
> That doesn't bother you.

unconventional doesnt bother me per se, incompatable does.
 
> You have identified the biggest challenge facing the JOS project. Many Java
> programmers prefer to follow Sun wherever they go.
> 
> - Are they going to stick to the one-process-per-JVM architecture that Sun
> designed? How do we convince them they need a multiple process JOS JVM?
> 
> - Are they going to stick to depretiation, reasonable incompatibility,
> feature-rich defective code and always-the-latest-platform loyalty that Sun
> recommends? How do we convince them to give open source JOS APIs a try?

I hate to be a bitch about this (but half of my family were english
teachers) its *deprecation*, depreciation is similar but not even based
on the same root... convergent evolution and all... anyway...

we convince them by making the best damn apps around and get everyone to
use them (big buisness, not-so-big buisness, and everyone with a PC)
 
> So, you think my design stinks? How do I fix it? You think it's a lost
> cause? That's acceptable, too.

one of my favorite quotes (even if its actually my
paraphrase/generlization of it) is: "I could be wrong, but it would
still be progress".
 
> >I'm still not sure about the purpose
> >of Gilbert's unified program interface but whatever the purpose, it
> >would be (IMHO) best to achieve that purpose without making programs
> >implement a non-standard interface.
> 
> I am an architect and software critic. I experiment with these things.
> That's what I do. I'm not asking every Java programmer to implement the
> Program interface. I am not making the Program interface a requirement, but
> maybe a viable option. I am trying to design an interface for JOS programs.
> 
> I wish there was some way to describe all that I am working on. I am
> working on something big, really big. It is different than any other
> software I have ever seen. It is the kind of operating system that I've
> been looking for since 1985. It supports a model of one console/many
> processors. It is a platform for a mid-level fourth generation language. It
> is made possible by Java, thanks to Sun Microsystems.

I like 3GL's myself, but what can I say Im a sentimentalist... I think
you should stress Program as an option though, that seems to be the root
of the confusion

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 23:42:48 -0700
Date: Thu, 12 Aug 1999 23:42:48 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Ryan Heise wrote:
> > In an object-oriented world, a program is an object, not a class. A JOS
> > program should be an object, too. You should be able to use a program like
> > other objects.
> 
> I do not believe a program is an object. A program is a collection of
> objects that are asked to perform a task or procedure. In an
> object-oriented world, it is the objects in the program that are
> reusable. Reuse at the Program interface level is how things work in the
> "procedural" world.
> 
> This is why my main() methods do very little except pass control off to
> "reusable" (in the OO sense) objects. The main() method (or procedure)
> is useful in a procedural programming context, such as shell scripts.
> 
> A scripting language that is designed around object-oriented concepts
> would not make use of the main() interface. Instead it would talk
> directly with reusable objects. This is my vision of reusable JavaBeans
> interacting with eachother rather than programs calling eachother in a
> procedural way. I briefly outlined this vision in another email.

you can do this now (well not exactly now) if you make a Script (or you
could use IBM's BML) that does whats in main, seeing as how GSI will
allow Scripts to be run as applications

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 23:48:58 -0700
Date: Thu, 12 Aug 1999 23:48:58 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> My main method looks either like
> 
> public class DemoApplication {
>   public static main( String[] args ) {
>     new DemoApplication().run();
>   }
> }
> 
> or
> 
> public class DemoProgram {
>   public static void main( String[] args ) {
>     new DemoProgram( args ).run();
>   }
> }

ugh, no offense but I hate this.

at the bare miniumum I do:

{
 DemoProgram app = new DemoProgram();
 app.parseCommands(args);
 app.run();
}

just a preference though, I also seperate that into a Main class for no
reason other then I dont like it "touching"
 
> I don't have a lot of fun writing pretty much the same static main() for
> each Java application. But, I'm sure you'll agree that instances of
> DemoApplication and DemoProgram are objects.
> 
> >Reuse at the Program interface level is how things work in the
> >"procedural" world.
> 
> What is a "procedural" world? Is object-oriented not procedural? Are you
> contrasting a step-by-step batch process to an event-driven one?
> 
> I understand that a OO scripting language should be able to coordinate the
> activity of a collection of JavaBeans. One JavaBean should be able to load
> and use another. Many beans can be developed into one new bean. It is
> recursive as well as reusable. A huge and complex bean is still an object.
> 
> If I want to, I can create a custom JavaBean that reads a collection of
> beans from an object stream. To configure my custom bean, it only has one
> "property", an object stream. That would be a pretty powerful bean. It
> could reuse any beans that have been serialized.

I think you can do this with a BeanContext
 
> At some point, a requestor must initialize my custom JavaBean and set its
> object stream property. And at some point, this bean must be finalized.
> Maybe it shuts down when the JVM shuts down, like a static property of a
> class. Maybe it "listens" for a shut down request. In the big picture, the
> lifetime of a bean has a beginning and end. It is initialized and then
> finalized. While the specific steps between initialization and finalization
> are unplanned, this is a predictable, step-by-step batch process.

Id like to use a script to run setup and the beans to dispose of
themselves.
 
> An event driven model builds upon a procedural one. Without procedures
> (methods), there are no events.

exactly

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 12 Aug 1999 23:54:07 -0700
Date: Thu, 12 Aug 1999 23:54:07 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
>>note that this static initializer "trick" is what I use in my app class,
>>a workaround nesseacary for the program to run both as a regular
>>application and have the ability to be used in another easily.
> 
> Yes! I want to "run" most of my programs both as a regular Java application
> compatible with the java tool *and* from any other Java class. It should be
> easy. It should be direct. It shouldn't take much.
> 
> Like you, I want to build an application most of the time by extending a
> powerful base class. And yet, there are times when I need to run an
> existing class as a program, too. Delegating the ProgramContext to a
> separate object reduces the amount of new code I have to write in either case.
> 
> So far, this discussion has identified very important issues. I hope that
> some really good code comes out of it. I would like to use an
> implementation of ParameterParser (ArgumentParser) that parses parameters
> from ProgramContext using the UNIX(tm) way. What would a ParameterParser
> look like anyway?

abstract class ArgumentParser {
 public ArgumentParser() { }

 public abstract parse(String args[]);

 public String getArg(int idx) {...}

 //etc.
}
 
> A program should decide for itself if it needs the assistence a parameter
> parser, and if so which one.
> 
> Isn't this cool? I should be able to have properties of my program set
> automatically based on command line arguments. Could we do this?
> 
> public class DemoProgram {
> :
>   public void set__help( boolean v ) {
>   }
> :
> }
> 
> so that when I use java org.jos.demo.DemoProgram --help, the set__help()
> method is called automatically? We can do this once with a
> UNIXStyleParameterParser. But wait! We can pass a Program to a
> ParameterParser, not a ProgramContext. The parser needs both the program
> and context, but getProgramContext() is part of the Program interface (or
> should be).
> 
> If we substitute underscores (_) for dashes (-), the names of all command
> line parameters are reflected in a program. If there's a command line
> parameter that does not match a method of a program, should the parser
> throw an exception?
> 
> My head hurts to think about this any more.

I thought you were against using reflection generally.

but Im working on something similiar

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From ryan@whitewolf.com.au Sat, 14 Aug 1999 01:22:02 +1000
Date: Sat, 14 Aug 1999 01:22:02 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:
> 
> At 06:45 PM 8/12/99 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
> >Applications, applets and servlets are each used in entirely different
> >situations, hence they have different interfaces that reflect how they
> >are used:
> 
> You are correct. Applications, applets and servlets are used in different
> environments today. That is going change. We, members of the JOS Project,
> should anticipate this change, embracing it.
> 
> It has been difficult for Sun Microsystems and others to see how much all
> these programs have in common. All of these run Java bytecode inside a JVM.
> That means that all of these have more in common than it may at first appear.

Hmm... that is like saying "My keyboard and my shoe are both made out of
matter, so why can't I operate them in a unified way?"

A shoe is useful when it is attached to a foot. Without this special
environment, there's not much you can do with a shoe. (sort of like an
applet)

A keyboard is an interface to functionality contained in a mysterious
box. It has a Print Screen key that executes a function. (sort of like a
program/command)

Now, there is not much use in strapping a keyboard to your foot and
seeing where that gets you.

Similarly, I can't plug the lace of my shoe into a computer and do
anything useful.

{{ There are exceptions, of course, where shoes and keyboards can be
used in creative ways. I feel that your unified Program interface is
only useful for these exceptions. }}

> Sidebar: You can run servlets on the client-side. Every machine that has a
> JVM is capable of being a "server". If you integrate servletrunner into
> your client-side Java application, you can run servlets on the client-side.
> Sounds strange only because Sun mis-named them "servlets", giving everyone
> the mistaken impression that they only run on the server-side.

On the contrary. You misunderstand Sun.

Yes, you can run a servlet on your computer, but that makes your
computer the server. You can also run a webserver on the client-side.
You don't need to connect to a remote host, you can run everything
locally. That also makes you the server.

Of course, the reason for connecting to a remote host is that that is
where the stuff is hosted. That's the World Wide Web. A servlet may
process data stored on the host's database and generate an HTML display
of that data. Because the database contains confidential information
(eg. credit card numbers) it would be behind a firewall so that the only
way to access public data is through the servlet interface.

That is what servlets are useful for - server side processing. You can't
simply run the servlet locally, you also need to set up the environment
which it depends on - the database server/middleware, other servlets
that it potentially interacts with, other computers behind the firewall
that provide other services. Yes, I have worked on real life servlets
that do all of these things.

On another topic, servlet invocation is unique in that when you invoke a
servlet, it may already be running. Once a servlet is activated, it
stays alive to process subsequent requests by different users. The
servletrunner is not a way to run servlets from the command line. It is
a way to start the servlet engine. The way to run a servlet is through a
specialised interface such as a web browser, or an email client. Even
within the servlet architecture there can be different types of servlets
that are operated through entirely unrelated interfaces.

{{ Before you reply to the list, you can ask me any questions personally
if I haven't explained something clearly. Otherwise this thread could go
on forever! }}

--
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From ryan@whitewolf.com.au Sat, 14 Aug 1999 01:23:28 +1000
Date: Sat, 14 Aug 1999 01:23:28 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Program and ProgramContext

Gilbert Carl Herschberger II wrote:

> >I would think that the vast majority of programmers will
> >stick to the program interface that Sun designed rather than use an
> >interface that someone else wrote.
> 
> You're doing something different. You're working on the JOS Project, aren't
> you? You're trying to imagine new possibilites. So, it's unconventional.
> That doesn't bother you.

--snip--

> So, you think my design stinks? How do I fix it? You think it's a lost
> cause? That's acceptable, too.

Go ahead and implement it. You have some ideas that are very
interesting. I just think that a few of your ideas are doomed to fail,
but that's ok if it leads you to a new useful idea.

--
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From onewith1@flash.net Fri, 13 Aug 1999 15:00:04 -0500
Date: Fri, 13 Aug 1999 15:00:04 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Program and ProgramContext

-----Original Message-----
From: Todd L. Miller <tmiller@haverford.edu>
To: Ryan Heise <ryan@whitewolf.com.au>
Cc: Gilbert Carl Herschberger II <gchii@mindspring.com>; arch@jos.org
<arch@jos.org>
Date: Thursday, August 12, 1999 8:09 PM
Subject: Re: [JOS-Arch] Program and ProgramContext


>> 1. UNIX pipes are usually linear because UNIX processes typically read
>> from stdin and write to stdout. It is difficult to achieve the effect of
>> parallel and forking pipes.
>
> True, but it is also difficult to develop clear and easy CLI
>parellel and forking pipes, which is why I directed my commentary towards
>"conventional" pipes.  But I do agree that JavaBeans have better
>'connectivity' -- that is, after all, what they were designed for.  One
>would /hope/ that a GUI's 'scripting'/'visual command line' would allow
>for such multiple Beans as a matter-of-course way of doing things (as
>opposed to discrete programs that use Beans to generate other discrete
>programs)... and that those Beans, likewise, could (if appropriate) do
>useful things with a pipe-only input.
>
>-_Quinn
>


Let me try expanding on the idea of having a BeanBox as our scripting
language.  Instead of pipes, we would have events (which would handle a heck
of a lot more than just an I/O stream).  The language is no longer text
base; instead we have true visual programming.  We'd have to clean up the
BeanBox idea to make it more practical for this kind of programming
(especially for the novice).  Of course, the BeanBox can make text
bean-scripts (xml?), and a user can hand-code these text bean-scripts.

The focus of this Scripting BeanBox would not be on a graphical
presentation, rather it would be on the routing of events, and
computational/file processing.

Just the next step in scripts!

-Matt




From tmiller@haverford.edu Fri, 13 Aug 1999 16:33:56 -0400 (EDT)
Date: Fri, 13 Aug 1999 16:33:56 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Program and ProgramContext

> Just the next step in scripts!

	Exactly.  Something needs to be arranged to handle event-based
object-modeled scripting.  What, exactly, that might be, I couldn't
imagine, but that's what the ui list is for :)

-_Quinn




From RegierAveryJ@JDCORP.deere.com Fri, 13 Aug 1999 16:03:17 -0500
Date: Fri, 13 Aug 1999 16:03:17 -0500
From: Regier Avery J RegierAveryJ@JDCORP.deere.com
Subject: [JOS-Arch] Program and ProgramContext

Matt,

I had a similar idea last year, that I still want to do sometime.  I wrote
about in on the old apps list, and is archived here:
http://www.eGroups.com/group/jos-apps/209.html?
My own priorities are to work on Processes first, then this.  We can always
do requirements, though!

Is it about what you were thinking of, or more limited, or even more
powerful?  Is there a way that we can simplify the interface for such a GUI
scripter so that it is even more powerful, or is the wiring pardigm as
powerful as a beanish interface gets?

Avery J. Regier



> -----Original Message-----
> From:	Todd L. Miller [SMTP:tmiller@haverford.edu]
> Sent:	Friday, August 13, 1999 4:34 PM
> To:	Matt Albrecht
> Cc:	Ryan Heise; Gilbert Carl Herschberger II; arch@jos.org
> Subject:	Re: [JOS-Arch] Program and ProgramContext
> 
> > Just the next step in scripts!
> 
> 	Exactly.  Something needs to be arranged to handle event-based
> object-modeled scripting.  What, exactly, that might be, I couldn't
> imagine, but that's what the ui list is for :)
> 
> -_Quinn
> 
> 
> _______________________________________________
> Arch maillist  -  Arch@jos.org
> http://jos.org/mailman/listinfo/arch



From digigod@earthling.net Fri, 13 Aug 1999 15:19:50 -0700
Date: Fri, 13 Aug 1999 15:19:50 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Program and ProgramContext

Matt Albrecht wrote:
> Let me try expanding on the idea of having a BeanBox as our scripting
> language.  Instead of pipes, we would have events (which would handle a heck
> of a lot more than just an I/O stream).  The language is no longer text
> base; instead we have true visual programming.  We'd have to clean up the
> BeanBox idea to make it more practical for this kind of programming
> (especially for the novice).  Of course, the BeanBox can make text
> bean-scripts (xml?), and a user can hand-code these text bean-scripts.

check out BML, I don't have a link but its on alphaworks. also an
article on it at javaworld
 
> The focus of this Scripting BeanBox would not be on a graphical
> presentation, rather it would be on the routing of events, and
> computational/file processing.
> 
> Just the next step in scripts!

I like the idea of "spontaneous" applications created from javabeans: I
click on a JPEG file, it opens a JPEG viewer but I want to (and somehow)
request the ability to edit it so an ImageEditor bean opens up and so
on. I have no idea how this would work... but it would be nice

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Fri, 13 Aug 1999 16:17:17 -0700
Date: Fri, 13 Aug 1999 16:17:17 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Application

here is the latest update on my Application class, here are our basic
classes:

Application - the abstract super class that wraps the standard main()
Arguments - an abstract super class that wraps a programs arguments (a
"fancy" String[])

Arguemtns has a simple child aptly called SimpleArguments that does no
parsing on the command line, it is the default.

there are two ways to set your own arguments class: A) in the clint,
after setting the required app; or B) in your appMain()

a)
static {
 app = new AnApplication();
 app.arguments = new ACustomArguments();
}

b)
public void appMain() {
 arguments = new ACustomArguments();
}

arguments is a protected variable in Application and can hence be used
like any other variable within your class, but I recommend using
Application's getArguments() (you need to use it outside of application
anyway)

making an Application is easy:

public class test extends Application {
 static {
  app = new test(); //nessecary :(
 }
 public void appMain() {
  println("hello");
  println(getArguments.getLength()); // no reason
 }
}

extending it is also easy:

public class newtest extends test {
 static {
  app = new newtest();
 }
 public void appMain() {
  super.appMain();
  Iterator i = getArguments().iterator();
  while(i.hasNext())
   println(i.next());
  println("goodbye.);
 }
}

Application
 main(String[]) -ye olde main method (Application is run just like
ordinary stand alones)
 getArguments() -return the arguments object for this instance
 print(String) -just an "alias" method to System.out.print()
 println(String) - same as above
 exit(int) -same as above
 exit() - calls exit(0)
 readln() - return a line of input from the console
 getApplicationInfo - rets a String, like getAppletInfo in applet
 abstract appMain() - neo-main

Argument 
 abstract parse(String[]) - where you handle the parsing (or lack of)
 length() - the length of the argument array
 get(int) - returns the string for the argument at said index
 iterator() - return a collections iterator (internally builds an
arraylist whenever called, so use wisely)

I was going to have a method to return all the arguments in a String[],
but decided not to as I had no idea what to call it, decided iterator()
would be more useful anyway...

////
package digigod.apps;

import java.io.*;

public abstract class Application {
 private          BufferedReader reader      = null;
 protected        Arguments      arguments   = new SimpleArguments();
 protected static Application    app         = null;

 public static void main(String args[]) {
  if(app==null)
   System.exit(255);
  app.arguments.parse(args);
  app.appMain();
 }

 public Arguments getArguments() {
  return arguments;
 }

 public void exit() {
  exit(0);
 }

 public void exit(int code) {
  System.exit(code);
 }

 public void print(String str) {
  System.out.print(str);
 }

 public void println(String str) {
  System.out.println(str);
 }

 public void printerr(String str) {
  System.err.println(str);
 }

 public String readln() throws IOException {
  if(reader==null)
   reader = new BufferedReader(new InputStreamReader(System.in));
  return reader.readLine();
 }

 public abstract void appMain();

 public String getApplicationInfo() {
  return "";
 } 
}
////
////
package digigod.apps;

import java.util.*;

public abstract class Arguments {
 protected String arguments[];
  
 public Arguments() { 
   
 }
  
 public abstract void parse(String args[]);
  
 public int length() {
  if(arguments==null)
   return 0;
  return arguments.length;
 }
  
 public String get(int idx) {
  if(arguments==null)
   return null;
  return arguments[idx];
 }
  
 public Iterator iterator() {
  ArrayList ret = new ArrayList();
  for(int i = 0; i >= arguments.length; i++)
   ret.add(arguments[i]);
  return ret.iterator();
 }
}
////
////
package digigod.apps;

public class SimpleArguments extends Arguments {
 public SimpleArguments() {
  
 }
 
 public void parse(String args[]) {
  arguments = new String[args.length];
  System.arraycopy(args, 0, arguments, 0, args.length);
 }
}
////

you by no means have to use this, only if you want to and only if you
like to. it requires no special runners as it has a classic "main()"
method that runs the new one.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From onewith1@flash.net Sat, 14 Aug 1999 18:17:32 -0500
Date: Sat, 14 Aug 1999 18:17:32 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Program and ProgramContext

Well, maybe we shouldn't have full bean support to begin with (you'll see
why below), but its an option for a "behind-the-scenes" for a general
scripting support system.

Reiger Avery J wrote:

>Matt,
>
>I had a similar idea last year, that I still want to do sometime.  I wrote
>about in on the old apps list, and is archived here:
>http://www.eGroups.com/group/jos-apps/209.html?
>My own priorities are to work on Processes first, then this.  We can always
>do requirements, though!
>
>Is it about what you were thinking of, or more limited, or even more
>powerful?  Is there a way that we can simplify the interface for such a GUI
>scripter so that it is even more powerful, or is the wiring pardigm as
>powerful as a beanish interface gets?
>
>Avery J. Regier
>


I was more or less thinking of replacing the stdin/stdout/stderr piping with
the beans event handling.  Sure, we can have a generic "StreamListener" to
emulate standard Unix/DOS filters, but we can go beyond that.

Also, instead of having just a method in a bean to call (we can have that
too), an event driven system would allow for branching (calling one event
instead of another).  This may help reduce some of the syntax developed in
shells to get the same result.

So, instead of (using ksh):
(cc mycode.c -o mycode 2> errlog) || (more errlog; rm errlog; exit)
echo "Compiled Ok"

which would output the compilation errors from the c compiler to errlog, and
on an error would display a paged version of the errors, remove that file,
then exit from the script.  If the compilation went ok, then the message is
displayed.

Instead, we could have (to use a made up language, which would/could
probably be done on a visual GUI):
let a = new ccBean()  // create a new bean interface to the compiler
let b = new pagedStreamBean() // create a new bean which pages the output of
its given stream, in the "StreamListener" event.
let c = new echoBean( "Compiled Ok" ) // echos "Compiled Ok" to the screen
on the event.
a.addErrorStreamListener( b ) // set b as the StreamListener for error text
a.addErrorListener( b ) // set b as the "next event" to be called when an
error happens
a.addSucceedListener( c ) // set c as the successful "next event" listener.
run a // or whatever we decide on to execute the bean

Ok, sure, I added a *ton* of typing to a simple command line, and I had to
really think about how to chain it together.  If I had to do this scripting
full time, I would need to know the methods of my beans before I script,
which would be like looking at the JDK documents all the time.  But then,
I've never typed bean-script before (I doubt that very many people have :),
and this is a off-the-top-of-my-head language.

So, maybe this isn't the way to go.  But perhaps we can generalize this so
that it can be a framework from which any scripting language is tied to.
Perhaps.  That's why this is still under Arch.

-Matt




From gchii@mindspring.com Sun, 15 Aug 1999 20:06:51 -0400
Date: Sun, 15 Aug 1999 20:06:51 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Application

At 04:17 PM 8/13/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
> protected static Application app = null;

Your design and my design are different. We have been working for a while
to appreciate them fully and make them even more compatible. We are solving
different puzzles; we have invented different solutions, as expected.

At this point, there is little difference in the functionality, except for
the static app field. Are you sure you need this field? Does it have to be
static? I'll explain with an example.

With either of our designs in hand, we could write a "SampleArchve"
program, a program that creates an archive file. SampleArchive could take
two parameters: archive and path. It could creates an archive file and adds
every file to an archive found along a given path.

Using the java tool, the command and its the output from this program would
look like this:

$ java org.jos.demo.SampleArchive archive=text.gz path=*.java
Creating text.gz archive.
Adding DemoApplet.java...
Adding DemoProgram.java...
Adding DemoApplication.java...
Done.

Or, the URI might look like this:

x-program:org.jos.demo.SampleArchive?archive=text.gz&path=*.java

Here a the snippet of code for a SampleArchive program.

// SampleArchive.java
public class SampleArchive
    extends BaseApplication {
  public SampleArchive() {
  }
  public void run() {
    String archive = getProgramContext().getValue( "archive" );
    String path = getProgramContext().getVavlue( "path" );
    // call some method creates an archive
    try {
      create_an_archive( archive, path );
    }
    catch( Throwable e ) {
      getProgramContext().setResultCode( 1 );
    }
  }
}

Both of our designs work the same way up to a point. Both run a program and
create an archive, one archive at a time. But, there is another thing I
look forward to doing with my programs. I look forward to running many
programs in parallel. In many cases, I must run my programs in parallel as
they are called by multiple users, multiple threads and from a servlet
environment.

Imagine I have given my computer the task of creating 100 different archive
files. My design does not depend on static main() at all. I can write a
method to create 100 archives concurrently in 100 separate threads. The
code looks like this:

  public void example() {
    String[] args = {
       "archive=src.gz&path=*.java",
       "archive=classes.gz&path=*.class",
       "archive=config.gz&path=*.ini;*.conf;*.properties";
       :
       };
    for ( int i = 0; i < 100; i++ ) {
      Program p = new SampleArchive();
      p.setProgramContext( new BasicProgramContext( args[ i ] ) );
      new Thread( p ).start();
    }
  }

With a little more work, I could collect the result code from each program
when all the programs are done.

This example is a little contrived, right? It's not like I made up the
whole thing. I have worked on a data warehouse application that needed to
launch around ~600 independent programs at exactly 5:35pm each night. Other
programs are launched later in the evening, waiting for the output from
these ~600.

Using Java and Linux, it would have been easier to launch these programs on
a small server farm. Oh well. I'll be ready next time.

It is important for a program to use sub-programs that are not static by
default. Static fields should only be used when static fields are required;
and, they are rarely required.




From gchii@mindspring.com Sun, 15 Aug 1999 20:28:02 -0400
Date: Sun, 15 Aug 1999 20:28:02 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Console for Program

While testing Program and ProgramContext for compatibility with piping and
redirection and for multiple, concurrent threads, I found a problem. While
a program can be written, it has a severe limitation. There is a problem
with singletons System.in and System.out.

While I have a few recommendations for System.out, I stuck on System.in.
Each program needs to have its own input/output device. Otherwise, there is
no easy way to make sense of the messages appearing on System.out.

public interface Console {
  public void println( String v );
}

That's it. That's the whole interface. There is no support for printing a
partial line with a Console. And our Console has no additional support for
reading from System.in. Within our José product, we have been successfully
using a Console interface. We are working on a new release of our console
studio, compatible with the smart object factory.

We have been struggling with a Terminal interface as a read-write device.
It isn't very far along. A "terminal" would be able to read from an input
stream and write to a Console.

Since writing this e-mail, I starting thinking about a input and output
class called IOStream. That might be a literal solution, providing input
and output to each Program.

// IOStream.java
public interface IOStream {
  public InputStream getInputStream();
  public OutputStream getOutputStream();
  public void flush();
  public void close();
}

// ProgramContext.java, with modifications
public interface ProgramContext {
  :
  public IOStream getIOStream();
  public void setIOStream( IOStream v );
}

I'm floundering here. What do you think?




From gchii@mindspring.com Sun, 15 Aug 1999 20:40:57 -0400
Date: Sun, 15 Aug 1999 20:40:57 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Program and ProgramContext

At 11:54 PM 8/12/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>I thought you were against using reflection generally.

As a rule, I try not to use reflection. Like delegation and inheritence,
reflection has its place. Interfaces are usually better than reflection.
Interfaces should used whenever you can find some kind of a pattern.

Patterns can be difficult to find. A problem "solved" by reflection may
indicate that a pattern hasn't been found yet. Reflection should be used
when there is no pattern. Unfortunately, many programmers use reflection
when they don't have time to look for a pattern.

Is there a pattern to parameters passed on a command line? I don't think
so. Then again, maybe I'm wrong. I might have been too quick to stop looking.

We also have to keep in mind that some JVMs have no support for reflection.




From digigod@earthling.net Sun, 15 Aug 1999 23:42:13 -0700
Date: Sun, 15 Aug 1999 23:42:13 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Application

Gilbert Carl Herschberger II wrote:
>> protected static Application app = null;
> Your design and my design are different. We have been working for a while
> to appreciate them fully and make them even more compatible. We are solving
> different puzzles; we have invented different solutions, as expected.
> 
> At this point, there is little difference in the functionality, except for
> the static app field. Are you sure you need this field? Does it have to be
> static? I'll explain with an example.

its required for backward compatability. 
 
> With either of our designs in hand, we could write a "SampleArchve"
> program, a program that creates an archive file. SampleArchive could take
> two parameters: archive and path. It could creates an archive file and adds
> every file to an archive found along a given path.
> 
> Using the java tool, the command and its the output from this program would
> look like this:
> 
> $ java org.jos.demo.SampleArchive archive=text.gz path=*.java
> Creating text.gz archive.
> Adding DemoApplet.java...
> Adding DemoProgram.java...
> Adding DemoApplication.java...
> Done.
> 
> Or, the URI might look like this:
> 
> x-program:org.jos.demo.SampleArchive?archive=text.gz&path=*.java
> 
> Here a the snippet of code for a SampleArchive program.
> 
> // SampleArchive.java
> public class SampleArchive
>     extends BaseApplication {
>   public SampleArchive() {
>   }
>   public void run() {
>     String archive = getProgramContext().getValue( "archive" );
>     String path = getProgramContext().getVavlue( "path" );
>     // call some method creates an archive
>     try {
>       create_an_archive( archive, path );
>     }
>     catch( Throwable e ) {
>       getProgramContext().setResultCode( 1 );
>     }
>   }
> }
> 
> Both of our designs work the same way up to a point. Both run a program and
> create an archive, one archive at a time. But, there is another thing I
> look forward to doing with my programs. I look forward to running many
> programs in parallel. In many cases, I must run my programs in parallel as
> they are called by multiple users, multiple threads and from a servlet
> environment.
> 
> Imagine I have given my computer the task of creating 100 different archive
> files. My design does not depend on static main() at all. I can write a
> method to create 100 archives concurrently in 100 separate threads. The
> code looks like this:
> 
>   public void example() {
>     String[] args = {
>        "archive=src.gz&path=*.java",
>        "archive=classes.gz&path=*.class",
>        "archive=config.gz&path=*.ini;*.conf;*.properties";
>        :
>        };
>     for ( int i = 0; i < 100; i++ ) {
>       Program p = new SampleArchive();
>       p.setProgramContext( new BasicProgramContext( args[ i ] ) );
>       new Thread( p ).start();
>     }
>   }
> 
> With a little more work, I could collect the result code from each program
> when all the programs are done.
> 
> This example is a little contrived, right? It's not like I made up the
> whole thing. I have worked on a data warehouse application that needed to
> launch around ~600 independent programs at exactly 5:35pm each night. Other
> programs are launched later in the evening, waiting for the output from
> these ~600.
> 
> Using Java and Linux, it would have been easier to launch these programs on
> a small server farm. Oh well. I'll be ready next time.
> 
> It is important for a program to use sub-programs that are not static by
> default. Static fields should only be used when static fields are required;
> and, they are rarely required.

the static field is only for running the app in the "standard" mode,
that is off the command line (ie java TheApp)

while my app class is good at running in this "standard" mode its not
perfect for running otherwise, but possible...

using your example:

public class SampleArchive extends Application {
 static {
  app = new SampleArchive(); //look at the main() method in Application
to see why this is needed
 }

 public SampleArchive() { 
  
 }

 public void appMain() { //I actually thought about calling this method
"applicate", not that this is much better...
  String archive = getArguments().get(1),
         path    = getArguments().get(2); //very assuming
  //fa la la
 }
}

public void example() {
 Application temp;
 //the args thing...
 for(int i=0;i<100;i++) {
  temp = new SampleArchive();
  temp.setArguments(new SimpleArguments(args[i]); //actually I didnt put
in a setArguments yet...
  temp.appMain(); //note: this does not create a thread, which can be a
benifit at times.
 }
}

Im still working on Application, so stay tuned--as they say.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Sun, 15 Aug 1999 23:45:57 -0700
Date: Sun, 15 Aug 1999 23:45:57 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Console for Program

Gilbert Carl Herschberger II wrote:
> While testing Program and ProgramContext for compatibility with piping and
> redirection and for multiple, concurrent threads, I found a problem. While
> a program can be written, it has a severe limitation. There is a problem
> with singletons System.in and System.out.
> 
> While I have a few recommendations for System.out, I stuck on System.in.
> Each program needs to have its own input/output device. Otherwise, there is
> no easy way to make sense of the messages appearing on System.out.
> 
> public interface Console {
>   public void println( String v );
> }
> 
> That's it. That's the whole interface. There is no support for printing a
> partial line with a Console. And our Console has no additional support for
> reading from System.in. Within our José product, we have been successfully
> using a Console interface. We are working on a new release of our console
> studio, compatible with the smart object factory.
> 
> We have been struggling with a Terminal interface as a read-write device.
> It isn't very far along. A "terminal" would be able to read from an input
> stream and write to a Console.
> 
> Since writing this e-mail, I starting thinking about a input and output
> class called IOStream. That might be a literal solution, providing input
> and output to each Program.
> 
> // IOStream.java
> public interface IOStream {
>   public InputStream getInputStream();
>   public OutputStream getOutputStream();
>   public void flush();
>   public void close();
> }
> 
> // ProgramContext.java, with modifications
> public interface ProgramContext {
>   :
>   public IOStream getIOStream();
>   public void setIOStream( IOStream v );
> }
> 
> I'm floundering here. What do you think?

in Application I created an ApplicationContext class (seperate from the
Arguments class) that definese these methods:

public abstract void print(String)
public abstract void println(String)
public abstract void printerr(String)
public abstract String readln()

then I made a default SystemApplicationContext, Im going to make a
SwingApplicationContext that uses textpanes to emulate a console...
anyway, thats how I did it. leave it up to the children.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Mon, 16 Aug 1999 11:27:29 -0400
Date: Mon, 16 Aug 1999 11:27:29 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Console for Program

I think DigiGod's design has a "Arguments" object as a separate class. I
think that's better. I find that I'm using "ProgramContext" elsewhere, when
I should be using something like "Arguments". These constructors from
ProgramContext should be supported by Arguments:

  public Arguments() {
  :
  }
  public Arguments( String query_string ) {
  :
  }
  public Arguments( String[] args ) {
  :
  }

At 11:45 PM 8/15/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>in Application I created an ApplicationContext class (seperate from the
>Arguments class) that definese these methods:
>
>public abstract void print(String)
>public abstract void println(String)
>public abstract void printerr(String)
>public abstract String readln()

I understand you called this collection of methods an "ApplicationContext".
In the model I've been developing, I might call this a "SimpleTerminal".

public interface SimpleTerminal {
  public void print( String v );
  public void println( String v );
  public void printerr( String v );
  public String readln();
}

A more complex "Terminal" would be able to read/write bytes:

public interface Terminal {
  public int read();
  public void write( int v );
}

I want Program and ProgramContext to full support the telnetd service. You
should be able to log on to a machine and run any program. The telnetd
service provides a connection between a program and a "remote" terminal.
The input to a program comes from a remove terminal. Output from a program
goes to a remote terminal.

I want to connect to a program using a terminal or terminal emulator. I
expect to use a TCP/IP socket to read/write bytes to a program. This is
similar to pipes and redirection, too.

I can't put my finger on it. I think there's a strong relationship between
ProgramContext and Terminal. It's as if ProgramContext extends Terminal.

And then, there is a strong relationship between ProgramContext and
Arguments. It's as if ProgramContext extends Arguments, too.

I think it's too much to have both a ProgramContext and an
ApplicationContext. There should be one context object (if possible) to
make it easier for any class to implement the Program/Application interface.

I have been thinking of "BaseApplication" as an abstract class.
BaseApplication implements Program and uses ProgramContext.




From gchii@mindspring.com Mon, 16 Aug 1999 11:45:42 -0400
Date: Mon, 16 Aug 1999 11:45:42 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Console for Program

At 11:45 PM 8/15/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>then I made a default SystemApplicationContext, Im going to make a
>SwingApplicationContext that uses textpanes to emulate a console...
>anyway, thats how I did it. leave it up to the children.

We have done the same thing, more or less. I made a "system" application
context and an "AWT" application context. While "system" application
context uses System.out, the "AWT" application context uses java.awt.List
and java.awt.TextArea and java.awt.Label to emulate a console.

I have been unable to create the equivalent context in Swing. Which version
of Swing should we support? We should support all of them.

I pushed a little farther by creating a console factory. This weekend, I
created a smart console factory. This smart console factory is part of
Console Studio - Release 2a. It is compatible with Smart API - Release 1b.
It supports a wide variety of different consoles:

System Console Controller
x-console:null - consolestudio.SystemNullConsole
x-console:out - consolestudio.SystemOutConsole
x-console:err - consolestudio.SystemErrConsole

OutputStream Console Controller
x-console:out:<output-stream-URI> - BasicStreamConsole
x-console:log:<output-stream-URI> - BasicLogConsole

AWT Console Controller
x-console:awt:<component-class>?<options> - custom AWT component/console
     - editable option := "true" | "false"
     - enabled option := "true" | "false"
     - title option := plain-text
     - visible option := "true" | "false"

Swing Console Controller (planned):
x-console:swing:<component-class> - custom Swing component/console

Through a smart console factory, you can create a console that outputs to
*any* output stream supported by the smart stream factory.

Through a smart console factory, you can create a console from any custom
AWT component that implements the Console interface.

Through a smart console factory, you will be able to create a console from
any custom Swing component that implements the Console interface.




From gchii@mindspring.com Mon, 16 Aug 1999 13:07:21 -0400
Date: Mon, 16 Aug 1999 13:07:21 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Terminal and Program

Well, that didn't work either. I tried to add read/write methods to
ProgramContext and it ruins an otherwise simple model. I must switch to a
different model.

// Terminal.java
public interface Terminal {
  public String readLine();
  public void println( String v );
}

// TerminalProgram.java
public interface TerminalProgram
    extends Program {
  public void setTerminal( Terminal v );
}

// IOStream.java
public interface IOStream {
  public InputStream getInputStream();
  public OutputStream getOutputStream();
}

// IOStreamProgram.java
public interface IOStreamProgram 
    extends Program {
  public void setIOStream( IOStream v );
}

There are different kinds of programs, so there should be different
extensions of the program interface. They all have a ProgramContext in
common because they all extend the Program interface.

IOStreamProgram should support pipes and redirection.




From digigod@earthling.net Mon, 16 Aug 1999 11:11:03 -0700
Date: Mon, 16 Aug 1999 11:11:03 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Console for Program

Gilbert Carl Herschberger II wrote:
> I think DigiGod's design has a "Arguments" object as a separate class. I
> think that's better. I find that I'm using "ProgramContext" elsewhere, when
> I should be using something like "Arguments". These constructors from
> ProgramContext should be supported by Arguments:
> 
>   public Arguments() {
>   :
>   }
>   public Arguments( String query_string ) {
>   :
>   }
>   public Arguments( String[] args ) {
>   :
>   }

I use an empty constructor and an abstract parse(String args[]) m'self
 
> At 11:45 PM 8/15/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
> >in Application I created an ApplicationContext class (seperate from the
> >Arguments class) that definese these methods:
> >
> >public abstract void print(String)
> >public abstract void println(String)
> >public abstract void printerr(String)
> >public abstract String readln()
> 
> I understand you called this collection of methods an "ApplicationContext".
> In the model I've been developing, I might call this a "SimpleTerminal".
> 
> public interface SimpleTerminal {
>   public void print( String v );
>   public void println( String v );
>   public void printerr( String v );
>   public String readln();
> }
> 
> A more complex "Terminal" would be able to read/write bytes:
> 
> public interface Terminal {
>   public int read();
>   public void write( int v );
> }
> 
> I want Program and ProgramContext to full support the telnetd service. You
> should be able to log on to a machine and run any program. The telnetd
> service provides a connection between a program and a "remote" terminal.
> The input to a program comes from a remove terminal. Output from a program
> goes to a remote terminal.
> 
> I want to connect to a program using a terminal or terminal emulator. I
> expect to use a TCP/IP socket to read/write bytes to a program. This is
> similar to pipes and redirection, too.
> 
> I can't put my finger on it. I think there's a strong relationship between
> ProgramContext and Terminal. It's as if ProgramContext extends Terminal.
> 
> And then, there is a strong relationship between ProgramContext and
> Arguments. It's as if ProgramContext extends Arguments, too.

Id say in your case its more like the programContext HAS-A Arguments
 
> I think it's too much to have both a ProgramContext and an
> ApplicationContext. There should be one context object (if possible) to
> make it easier for any class to implement the Program/Application interface.

well, we'll see where that goes... we're both still working on them,
that often leads to sponteaneus divergence so we should keep them
seperate till we get a better idea of what/how...
 
> I have been thinking of "BaseApplication" as an abstract class.
> BaseApplication implements Program and uses ProgramContext.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From tmiller@haverford.edu Mon, 16 Aug 1999 17:27:26 -0400 (EDT)
Date: Mon, 16 Aug 1999 17:27:26 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Console for Program

> While testing Program and ProgramContext for compatibility with piping and
> redirection and for multiple, concurrent threads, I found a problem. While
> a program can be written, it has a severe limitation. There is a problem
> with singletons System.in and System.out.

	This is one of the places where decaf would step in and NOT load
java.lang.System primordially, so that it, and its singletons, could be
over-ridden in the appropriate per-process fashion, as determined by the
`canonical' shell ops.  Over-riding java.lang.System on a per-process
basis also neatly solves the problem of what to do about System.exit() for
compatibility with old single-app/single-jvm code.  (The process
associated with that particular java.lang.System is terminated.)

-_Quinn




From gchii@mindspring.com Tue, 17 Aug 1999 11:01:54 -0400
Date: Tue, 17 Aug 1999 11:01:54 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Console for Program

At 05:27 PM 8/16/99 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	This is one of the places where decaf would step in and NOT load
>java.lang.System primordially, so that it, and its singletons, could be
>over-ridden in the appropriate per-process fashion, as determined by the
>`canonical' shell ops.  Over-riding java.lang.System on a per-process
>basis also neatly solves the problem of what to do about System.exit() for
>compatibility with old single-app/single-jvm code.  (The process
>associated with that particular java.lang.System is terminated.)

Our search continues. We want to build a multiple "process" JVM. We might
need a multiple instances of a few JVM classes that all other JVMs consider
singletons. For example, we might have multiple instances of
PrimordialClassLoader, one class loader for each "process". We might have
multiple instances java.lang.Runtime.

We might need multiple instances of java.lang.System, not because of
System.exit() which calls java.lang.Runtime, but because it holds
System.in, System.out, and System.err.

What is our approach to solving the unsolvable? Divide and conquer. How do
we find a mechanism for multiple processes in a single JVM? By dividing
this puzzle into Process and Program. Our approach has been to break the
puzzle into two independent problems. Solving one piece helps us understand
and solve the other. We work from the bottom up.

Instead of going after Process and ProcessContext directly, we are going
after Program and ProgramContext. What is the difference between a program
and process?

A process may be a fully independent environment. A process is similar to a
JVM running in a fully independent native process, in a traditional
JVM-runs-on-OS model. It has its own security manager. It has it own
instance of java.lang.Runtime. It has its own instance of java.lang.System
for in, out and err.

A program is a semi-independent environment. A program is similar to a
semi-independent thread, in a traditional JVM model. A program is not a
process. It does *not* have its own instance of java.lang.Runtime. It does
*not* have its own instance of java.lang.System.

And yet, Program and ProgramContext must support piping and redirection. So
far, my model proposes the equivalent of a System.in and System.out for a
IOStreamProgram. My model continue to use System.err as standard errors
stream, shared among all programs.

The Program - Release 1d package provides a few kinds of programs:

Program - This kind of program supports neither IOStreams, Console or
Terminal. This might be a good choice for GUI programs and daemons.

IOStreamProgram - This kind of program supports piping and redirection.
Instead of using System.in and System.out, you use getInputStream() and
getOutputStream() which returns the input/output streams for this program.

ConsoleProgram - This kind of program has a console, the equivalent of an
output stream; but no input stream. All of its input must come from a
parameter list. This might be a good choice for a servlet transaction and
many JOS commands. (What does $ ls < x do anyway?)

TerminalProgram - This kind of program has a terminal, the equivalent of a
input and output stream. This might be a good choice for a command line
interface, like a classic shell (bash), shell script, browser plug-in or
Internet chat relay (IRC).

When a IOStreamProgram is run as a Java application, getInputStream()
returns System.in and getOutputStream() returns System.out.

How does this help? It demonstrates that you can already run
semi-independent "programs" inside all traditional JVMs. You do not have to
modify a JVM to do it.

What's the catch? You must trust that all of Programs are well-behaved.
Since the JOS Project is going to write lots of programs, we can safely
assume that all our programs are going to be well-behaved. Otherwise, it's
a bug. When the time comes, a well-behaved program will run--unchanged--in
a separate process.

I trust all code that I write. I trust all of the open source code that I
read and understand (in C, C++ and Java). I trust all code that trustworthy
people write. I trust code distributed by book publishers and many other
software vendors. I trust code until it's proven that I can't.

While a Program is built on trust, a Process is built upon dis-trust. Why
should I wait until a Process and ProcessContext is ready? Why should I
pass sentence on all my code so it must be confined to an off-brand
multiple process JVM? It doesn't have to be that way.




From tmiller@haverford.edu Tue, 17 Aug 1999 19:09:20 -0400 (EDT)
Date: Tue, 17 Aug 1999 19:09:20 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Console for Program

> What is our approach to solving the unsolvable?

	Unsolvable?  I believe the design for a multi-process JVM that
I've been presenting on this and the kernel list is a solution.  The
solution to seperate processes is quite simply separate namespaces, which
are easy to establish if you control the primordial namespace.  Because
Java has no pointers, disjoint namespaces are protected from each other in
the exact same fashion in which multiple native processes are protected by
the PMMU.  The exact mechanics of IPC and the various methods for
obtaining space efficiency will be left almost entirely to Java code, and
will evolve over time.

	My goal in the design of this system is transperancy.  Any extant
spec-compliant code must run unmodified on decaf, and behave in the
expected manner.  This will entail modifications to certain library
classes, which also must be transparent to the caller.

	I understand your desire to start programming right away.  And it
looks like your Program proposal will indeed allow you to fake multiple
processes on a single process JVM.  If that's the case, it will certainly
work on decaf, and you can re-write the back-end to actually make the
Programs separate processes.  However, I question your diagnostic of
processes as being symptomatic of distrust.  Processes, aside from being a
wonderful programming convenience, are a way of moving the problem of
fallibility from many places (all of your programs) to one (the process
manager), which is a good thing for obvious reasons.

-_Quinn







From gchii@mindspring.com Tue, 17 Aug 1999 23:04:11 -0400
Date: Tue, 17 Aug 1999 23:04:11 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Console for Program

At 07:09 PM 8/17/99 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	Unsolvable?

Sorry, Todd. I tried to say, "What is our approach to solving the
*seemingly* unsolvable?" It is a slight exaggeration. We know that a
multiple process JVM is possible because IBM shipped it over a year ago,
with OS/400 V4R1.

Literally, I am trying to build a color-syntax highlighting program for
C/C++/Java code. I want to write it once and only once because a program
should be reusable. It must run as a batch application, where a GUI prompts
for parameters and the Run button write static HTML files to disk. And, it
must run as an applet on my website. And, it must run inside an HTML
browser, under the control of a client-side servlet. And, it must run
inside an HTTP service, under the control of a server-side servlet.




From tmiller@haverford.edu Wed, 18 Aug 1999 16:56:30 -0400 (EDT)
Date: Wed, 18 Aug 1999 16:56:30 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Console for Program

> Literally, I am trying to build a color-syntax highlighting program for
> C/C++/Java code. I want to write it once and only once because a program
> should be reusable. It must run as a batch application, where a GUI prompts
> for parameters and the Run button write static HTML files to disk. And, it
> must run as an applet on my website. And, it must run inside an HTML
> browser, under the control of a client-side servlet. And, it must run
> inside an HTTP service, under the control of a server-side servlet.

	OOP strikes again.  The hard part of the code should be isolated
into a method like syntaxColor( InputStream is, OutputStream os ).  With
that in place, wrappers for each of the situations in which you're
interested in should be easy to create... or is that the point you're
trying to make with the Program (etc) interface?  That is to say, is the
point not that Program should automagically adapt to each of the above
situations, but that a standard wrapper should exist for each situation
(except the GUI one, perhaps*), one that operates by using the Program
interface? 

	* : If the syntaxColor()-containing object is a Bean, it should be
possible to create a generic reflection-based GUI interface object, which,
when passed a Bean, extracts all the possible settings and their type, and
creates a dialog box of those settings (and their defaults as defined by
the result of a getX() before a setX()) with the proper widgets.  (I would
imagine that JavaBean-based app builders already do this...)

-_Quinn





From gchii@mindspring.com Wed, 18 Aug 1999 19:45:58 -0400
Date: Wed, 18 Aug 1999 19:45:58 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Console for Program

At 04:56 PM 8/18/99 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> Gilbert wrote:
>> Literally, I am trying to build a color-syntax highlighting program for
>> C/C++/Java code. I want to write it once and only once because a program
>> should be reusable. It must run as a batch application, where a GUI prompts
>> for parameters and the Run button write static HTML files to disk. And, it
>> must run as an applet on my website. And, it must run inside an HTML
>> browser, under the control of a client-side servlet. And, it must run
>> inside an HTTP service, under the control of a server-side servlet.
>
>	OOP strikes again.  The hard part of the code should be isolated
>into a method like syntaxColor( InputStream is, OutputStream os ).  With
>that in place, wrappers for each of the situations in which you're
>interested in should be easy to create... or is that the point you're
>trying to make with the Program (etc) interface?  That is to say, is the
>point not that Program should automagically adapt to each of the above
>situations, but that a standard wrapper should exist for each situation
>(except the GUI one, perhaps*), one that operates by using the Program
>interface?

Yes! The entire complexity of providing syntax highlighting for C/C++/Java
source code should be encapsulated into such a method. Anyone wishing to
provide syntax highlighting can use this method. I am building the
equivalent of

int syntaxColor( InputStream is, OutputStream os, ParameterList list );

With that in place, wrappers do the rest.

The next software project should be

int prettyPrint( InputStream is, OutputStream os, ParameterList list );

And yet, prettyPrint should use syntaxColor. Pretty print should be
concerned with re-arranging the source code to fit a programming style.
Your choice of programming style should be passed as a run-time parameter.
Output from pretty print could be fed into syntax color to do the
color-related stuff.

As an architect, I would like it to be far more generic, based on a
pattern. I can build the wrappers once, with a little help. Everyone can
use them if they wish.

int <method>( InputStream is, OutputStream os, ParameterList list );

A new class, like java.lang.Runtime, would add these exec() methods:

/**
 * This method uses System.in and System.out.
 */
int exec( String method, ParameterList list ) {
  return exec( method, System.in, System.out, list );

/**
 * This method uses a given input and output stream.
 */
int exec( String method, InputStream is, OutputStream os, ParameterList list )

/**
 * This method uses a "console".
 */
int exec( String method, Console c, ParameterList list );

/**
 * This method uses a "terminal".
 */
int exec( String method, Terminal c, ParameterList list );

>	* : If the syntaxColor()-containing object is a Bean, it should be
>possible to create a generic reflection-based GUI interface object, which,
>when passed a Bean, extracts all the possible settings and their type, and
>creates a dialog box of those settings (and their defaults as defined by
>the result of a getX() before a setX()) with the proper widgets.  (I would
>imagine that JavaBean-based app builders already do this...)

This is one things that (desparately) needs to be done. Both the generic
reflection and registry have a need for a property viewer/editor.

How do you do that? I would like to see this for string-type properties,
first.

  public void example() {
    String[] names = {
      "name-1",
      "name-2",
      "name-3"
      };
    String[] values = {
      "value-1",
      "value-2",
      "value-3"
      };
    show_property_editor( names, values ); // ??? 
  }




From gchii@mindspring.com Wed, 18 Aug 1999 19:50:34 -0400
Date: Wed, 18 Aug 1999 19:50:34 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] IBM AS/400 Java-server

For the record, IBM has announced a Java-only version of its AS/400. IBM
uses the terms "Java-specific server". It reward IBM customers who would
rather not create a Microsoft Windows NT server farm.

http://www.infoworld.com/cgi-bin/displayStory.pl?990816.pias400.htm

Look carefully. They do not claim to have a Java-based operating system.




From digigod@earthling.net Thu, 19 Aug 1999 12:50:10 -0700
Date: Thu, 19 Aug 1999 12:50:10 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI

well, I decieded to do some more work on GSI. I have a pretty solid
class of classes, but until now they were basically method-free.

to refresh your memory/bring-up-problems-I've-encountered-so-far:

we have the ScriptLoader thats like a ClassLoader for scripts, should we
have a SCRIPTPATH?

we have Script, how do we allow interaction generically? and its
top-level inner class Element, we have an element what do we do with it?
(goes with genric interaction above)

an Object can be Scriptable if it has a ScriptInfo getScriptInfo(), but
what goes in ScriptInfo? (I'd just use BeanInfo but its to different)

lets look at the life of the script to reflect on these problems:

ScriptLoader is asked to load a script, it finds the appropriate child
(ie LuaScriptLoader for a lua script) and calls load (returning a Script
object cast up from, using my previous example, a LuaScript). Gilbert,
how could your SmartFactory be used here?

Our program now has a Script, to run it calls execute(). is there a
better way? how does it interact with the script when its executing?
what happens when its done? if we call execute() again what happens,
what should?

and for the miscellany:

what if we have two seperate implementations from different authours,
how do we determine which to use? 

how do we tell what type of script a file is? MIME? attributes builtin
to the fs? a per directtoy DB containg info the files (I like it,
cross-fs. doesnt Jigsaw do this?)?

how do other systems like this work?

in langauges already written-for/ported-to Java work? are there
languages you can think of that wouldnt work in this GSI?

how many more questions can I ask before I run out? ...oh, thats it
then....

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Thu, 19 Aug 1999 16:00:51 -0400
Date: Thu, 19 Aug 1999 16:00:51 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Source-Doc vs. JavaDoc

You want to know how that method is implemented? Click once and you'll know.

Source-Doc will have a radically different architecture from JavaDoc.
Source-Doc assumes you are writing for an open source project and want
everyone to see the source code. Source-Doc will be powerful enough to
provide source code and documentation to 100,000+ packages. It will
provides multiple-level index for packages, fields, methods, interfaces and
classes.

Source-Doc is based on an idea of *any* progamming language should have
cross-reference documentation. It works for Java. It will work for C/C++.

JavaDoc only works with Java, not the C/C++ code you write for native
methods. JavaDoc architecture is a dead end. It works only in snap-shot
mode, where all packages must be passed on the command line. It creates
static HTML files and writes them to disk. Ugh.

Source-Doc has the potential to *execute* any class. Do you want to see
what that Java Bean looks like? Click once and you'll know.

Source-Doc is based on three loosely-coupled components:
 - syntax highlighter
 - pretty printer
 - document tool

The syntax highlighter will provide color syntax highlighting for any
programming language. How do you do that? Each language must have a unique
file extension. The file extension is used as a key into a
registry-compatible keyword file:

// keyword.ini
[extension]
c
cpp
java

[java]
if
goto
return

[c]
if
goto
return

[cpp]
if
goto
return

The pretty printer is responsible for two things: width and style. The
width required by a client agent is variable, so it must be passed as a
parameter to the pretty printer. The style required by an end-user is
variable, so it must also be passed as a parameter. With this pretty
printer, everybody can see the code in the style they prefer, not the style
preferred by the author. The pretty printer does not do syntax highlighting.

// prettyprint.ini
[styles]
k&r
jos

[k&r]
braceonseparateline=true

[jos]
braceonseparateline=true

Sometimes you want to see the documentation, not the source code. The
documentor extracts the document-compatible comments from the source code,
similar to JavaDoc.

But, there is a huge and powerful difference. The documentor is not a huge
batch process. It documents one source file at a time.

When Source-Doc is implemented as a servlet, the original source code
should be stored in an archive file. That's it. The source code is
automatically highlighted and pretty-printed dynamically by the servlet
without storing temporary files. Each request can choose a different width
and style. The source code is read-only.

What about dynamic JavaDoc? The servlet extracts documentation as the
servlet is used. It maintains a cross-reference index to all the source
code that has been read. When the servlet "sees" a source file for the
first time, it extracts the documentation to a cache. The cache enables the
servlet to generate an index of packages, methods, fields, interfaces and
classes efficiently.

In other words, you write the source code. Source-Doc automatically does
the rest. This is the perfect companion to an open source project. Both the
"JavaDoc" and source code are cross-referenced.




From gchii@mindspring.com Thu, 19 Aug 1999 16:14:06 -0400
Date: Thu, 19 Aug 1999 16:14:06 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Re: PrettyPrint

At 12:20 PM 8/19/99 -0700, DigiGod Q Frasché <digigod@earthling.net> wrote:
>heres something like your working on, always good to see how other
>people have done it: http://cgi.vaegar.force9.co.uk/java2html.html 

I looked at the presentation of java2html for the first time today. I ran
through the examples and, unfortunately, they didn't work.

>(could your pretty printer do the JavaDoc too? that way it would be in
>the same HTML file... sounds like something for v2)

The dynamic source-doc index will provides a link to a JavaDoc static .html
file if it's available. I am aiming for the syntax highlighting to do only
syntax highlighting. It does not link a class name to class documentation
or source. It does not link a package name to package documentation or source.




From tmiller@haverford.edu Thu, 19 Aug 1999 17:20:24 -0400 (EDT)
Date: Thu, 19 Aug 1999 17:20:24 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] GSI

> we have the ScriptLoader thats like a ClassLoader for scripts, should we
> have a SCRIPTPATH?

	If necessary.  I can't shake the feeling that There Ought To Be A
Better Way, though.

> an Object can be Scriptable if it has a ScriptInfo getScriptInfo(), but
> what goes in ScriptInfo? (I'd just use BeanInfo but its to different)

	If I'm scripting an object, I'm either writing intra-program
(IRC scripts) or inter-program (shell scripts).	 Typically, intra-program
scripts are event-fired (in the form of well-defined "callbacks" to the
scripts), and inter-program scripts are more like standard sequential
programming, thought there are plenty of exceptions.  Since we can embed
sequential programs in event-fired ones, event-fired scripts should be the
norm.  Therefore, getScriptInfo() should return the events that the
Scriptable Object will generate.

> we have Script, how do we allow interaction generically? and its
> top-level inner class Element, we have an element what do we do with it?
> (goes with genric interaction above)

	I'd imagine the non-script-interperting classes can safely ignore
(or should be able to safely ignore) the components of a script.  As for
generic interactions, as above, I'd suggest that the code simply fire
events to a ScriptCollection, which would in turn handle distributing thos
events to the proper Scripts for handling; last (or first), it could
return that event to the program, so a default behavior could be included.
In the shell-script case, the only event would be script_begin (or
whatever).

> ScriptLoader is asked to load a script, it finds the appropriate child
> (ie LuaScriptLoader for a lua script) and calls load (returning a Script
> object cast up from, using my previous example, a LuaScript). Gilbert,
> how could your SmartFactory be used here?

	Wouldn't ScriptLoader /be/ a SmartFactory?

> Our program now has a Script, to run it calls execute(). is there a
> better way? how does it interact with the script when its executing?
> what happens when its done? if we call execute() again what happens,
> what should?

	See above -- execute() is a bad idea, for the problems you've
mentioned.  Interacting with the script would be responding to events it
generates, as moderated by the ScriptCollection (or whatever) and/or the
scripts themselves.  If you fire off two script_begin events, the behavior
should be the scripts choice: it can ignore it, spawn a new thread, queue
it up, etc...

> what if we have two seperate implementations from different authours,
> how do we determine which to use? 

	The SmartRegistry?  I think we can safely punt on this one for
now, because it's more a UI decision than an archictecture choice.

> how do we tell what type of script a file is? MIME? attributes builtin
> to the fs? a per directtoy DB containg info the files (I like it,
> cross-fs. doesnt Jigsaw do this?)?

	Again, I'm tempted to punt on the problem for now.  I think
whatever method is chosen could be safely enscapulated accross fs's --
those don't have per-file attributes of the necessary kind get
per-directory DBs or MIME or a central registry, depending.

> in langauges already written-for/ported-to Java work? are there
> languages you can think of that wouldnt work in this GSI?

	JaCL (tcl interperter in java) is the one I'm most familiar with,
and it's not as nearly advanced as what I'm proposing here.  (BTW: the
event-based system would be translated by the respective Script objects to
whatever is most appropriate to the source language; shell script, for
instance, would get signals instead of events (which means most events
would be ignored), or (possibly) only if the event name matched a method
name, etc...

-_Quinn




From digigod@earthling.net Thu, 05 Aug 1999 20:57:14 -0700
Date: Thu, 05 Aug 1999 20:57:14 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] URI?

Mark Andreas Meyer wrote:
> > It stands for "Universal Resource Indicator." It is a string that can,
> > theoretically, point to any "resource" (information, file, etc.)
> > available on the local computer and the Internet.
> 
> Actually it means "Uniform Ressource Identifier". From RFC2396:
> 
>    A Uniform Resource Identifier (URI) is a compact string of characters
>    for identifying an abstract or physical resource.

to be clear, a URL is a type of URI (not vice-a-versa)

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 05 Aug 1999 21:10:24 -0700
Date: Thu, 05 Aug 1999 21:10:24 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Proposing archive: protocol

Gilbert Carl Herschberger II wrote:
> The ftp: scheme is a very good example. Remind me again, though. I am a
> little rusty with ftp. Doesn't ftp: expect name and password parameters? In
> the example above, "?username=jeeves&password=cafebabe" would be part of
> ftp: scheme. I'll just move the parameters to ftp: forward:
> 
> ftp://database.server.net/archives/images/contents.jar
> ?username=jeeves&password=cafebabe |/update/latest.zip |/acquired/foo.jpg

actually it uses the awkward (but legal):

ftp://user:password@domanin.com/
 
> Let's talk a little about MIME types. MIME types only hint at a default
> decoding and presentation. It isn't absolute; it is only a clue.
> Explicitely adding the protocol should produce the same results.
> 
> ftp://database.server.net/archives/images/contents.jar ?
> username=jeeves&password=cafebabe | archive:zip:/update/latest.zip |
> image:jpeg:/acquired/foo.jpg

image:jpeg: hmm, reminds me of image/jpeg. howz bouts we assume your
MIME configuration is the default editor or viewer... but you want to
open it *as* another MIME type:

mime:<uri>?family=text&species=hex

this is easier to read for an override

nota bene: I used family/species because I couldnt, for the life of me,
think of the actual names...
 
> Imagine, though, that I have made up my mind and really want to see the
> contents of an JPEG file in hexidecimal notation. I want the default MIME
> type to be *ignored*. My decision should be reflected in the URI. Maybe it
> should be like this:
> 
> ftp://database.server.net/archives/images/contents.jar
> ?username=jeeves&password=cafebabe | archive:zip:/update/latest.zip |
> file:hex:/acquired/foo.jpg
>
> Sure, if there is a table of default MIME types, I may be able to imply
> decoding with file extensions. But our URI architecture must be able to
> support explicit choices.

see above. instead of file extensions we should have a "file attribute"
or something that holds the mime (I remember when my computer was giving
me grief, it turned out I didnt have image/jpeg setup to include .jpeg
too)
 
> Sometimes, I wonder how we're going to succeed with any of this. The URI is
> supposed to be a global, platform-independent model. Current URIs are
> monolythic and short-sighted. We *need* to do things with URIs in JOS that
> none of the other operating systems can do (yet and maybe ever). We are out
> in front. We are on the bleeding edge.
> 
> >From RFC 2396, the verticle bar (|) is considered an "unwise" character.
> We're supposed to be careful not to think about JOS as an island. JOS will
> interact with all other operating systems. How can we limit URIs to
> internal use only?

forget how, ask why should we. answer: we shouldnt.
 
> uri-pipe := uri "|" uri "|" uri
> 
> uri := scheme ":" path [ "?" query ] [ "#" fragment ]
> 
> Decoding a uri-pipe must be performed first, prior to decoding an
> individual uri inside a pipe. Each uri inside a uri-pipe may have query
> part and fragment part. The final MIME type of the uri-pipe is the MIME
> type of the last uri inside the pipe.
> 
> This is almost right. But it means that all URIs that already use the
> pipe--even though its an unwise character--will not be compatible with the
> uri-pipe. Incompatibility with all those existing URIs is bad, very bad.
> 
> The problem would be solved if we choose another "symbol" for the pipe.
> Hey, what about this:
> 
> uri-pipe := uri ">>" uri ">>" uri
> 
> Oh, and another thing. A client agent must know *immediately* that a URI is
> a pipe and not a normal URI. We want those old client agents to display a
> message first, before they do lots of work they can't finish.
> 
> I always imagined that the client agent would do all the work. Then our new
> scheme would be compatible with existing Internet services. So the client
> agent must process a uri-pipe. The client agent must download the whole
> archive, even to get one small file.
> 
> I suppose it is possible for an FTP service to extract the latest.zip, then
> extract foo.jpg and return only foo.jpg to the client agent. By embedding
> one uri into another, a client agent sends the entire request to the
> service. Wouldn't this work?
> 
> ftp://database.server.net/ <archive:archives/images/contents.jar>
> <archive:/update/latest.zip> /acquired/foo.jpg
> ?username=jeeves&password=cafebabe

as long as you dont want to put it in HTML or XML... in HTML you would
get this:

ftp://database.server.net/<archive:archives/images/contents.jar> the
parser would ignore the rest
 
> Oh, in fact, you should be able to choose client-side or server-side
> decoding of a uri-pipe. Your pipe scheme would be best suited for
> client-side decoding. My scheme would be best suited for server-side decoding.
> 
> The client agent would "see" this uri:
> 
> ftp://database.server.net/aquired/foo.jpg ?username=jeeves&password=cafebabe
> 
> It would connect to an FTP service with username and password and download
> /aquired/foo.jpg. The FTP service would recieve this:
> 
> /archives/images/contents.jar |/update/latest.zip |/acquired/foo.jpg
> or
> <archive:archives/images/contents.jar>
> <archive:/update/latest.zip> /acquired/foo.jpg
> 
> If there's a vertical bar (|) in a request or if the FTP service sees "<"
> as the first character in the request, it knows immediately that its an
> embedded URI. It extracts /images/contents.jar and here's what's left:
> 
> /update/latest.zip |/acquired/foo.jpg
> or
> <archive:/update/latest.zip> /acquired/foo.jpg
> 
> Again, if there's a verticle bar (|) or a "<" as the first character, it
> knows immediately that its an embedded URI. It extracts /update/latest.zip
> and here's what's left:
> 
> /aquired/foo.jpg
> 
> The FTP service OR client agent must keep track of its file source. At the
> beginning, it gets files from the OS file subsystem. With each archive, it
> gets files from an archive.
> 
> A client agent would use its local cache. While a client agent would
> download a large archive to extract a small file, the client agent might be
> more efficient with subsequent requests. If the large archive has already
> been downloaded to its local cache, it won't download or extract it again.
> It just extracts another small file.
> 
> When running bytecode for an applet or servlet across the Internet, it is
> more efficient to download the whole archive once rather than download one
> class file at a time from the archive. That's yet another reason to have
> the client agent handle the URI pipe and/or embedded URIs.

how bout server: (or client: depending on which is non-default) to
differentiate?

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From gchii@mindspring.com Fri, 20 Aug 1999 10:11:43 -0400
Date: Fri, 20 Aug 1999 10:11:43 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] WikiServlet

When installed, a request to a WikiServlet might looks something like this:

http://www.jos.org/servlet/wiki

When configured to run in a specific servlet environment, the "name" of a
servlet can be changed. The servlet environment might map "wiki" to
org.jos.wiki1a.WikiServlet. Later, it's remapped -- without changing
external URIs -- when upgrading to org.jos.wiki1b.WikiServlet.

When a simple servlet creates HTML code with links back to itself, it
should use the getRequestURI(). The return value of getRequestURI() looks
like this:

/servlet/wiki

When writing HREFs in servlet generated pages, each of the components must
consistently use the request URI. If a keyword program checks all keywords
for wiki, the self parameter should be created by WikiServlet and passed to
KeywordProgram:

String self = "self=" + getRequestURI();
exec( new KeywordProgram(), self + "&" + request.getQueryString() );

The keyword program gets the value of self like this:

String self = getProgramContext().getValue( "self" );

Then, the keyword program can generate a HREF like this:

println( "<A HREF=\"" + self + "?option=view&forum=main&article=WebHome\">" );
println( "WebHome" );
println( "</A>" );

Like a generic registry, a generic parameter list has properties. These
properties are not known in advance, so a derived class for each kind of
parameter list would be wasteful. It would be a naming convention to always
pass the self property to sub-programs that produce HREFs.

Also, java.lang.System has generic properties. Soon, you'll be able to
bring up a property viewer to examine all of the properties of
java.lang.System.

When installed, a request to the Source-Doc servlet might look like this:

http://www.jos.org/servlet/sourcedoc




From gchii@mindspring.com Mon, 23 Aug 1999 21:32:20 -0400
Date: Mon, 23 Aug 1999 21:32:20 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Free CDs?

What "free Java-based operating system" mean?

Are we going to look for someone to give away free CDs to everyone that
wants JOS? At US$1 per CD and 22,000,000 potential customers, that's
US$22,000,000 in materials alone. That does not include tax, distribution,
shipping and packaging.

I don't think JOS CDs should be free. The license to use JOS should be
free. The license to modify JOS source code and re-compile for your own
personal use should be free. Reasonable people expect to pay for the cost
of materials plus a little extra as an incentive for continuing to
distribute high quality software.




From gchii@mindspring.com Mon, 23 Aug 1999 22:25:40 -0400
Date: Mon, 23 Aug 1999 22:25:40 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] It works.

It might be possible to extend this even further. My servlet uses a new
program to respond to each request. A generic servlet could be *configured*
to run certain programs based on certain requests, like a generic HTTP
service is configured to map requests to directories.

The bottom line is: It works. It works today. It works better than
expected. It will be available soon.

I added two methods to ParameterList (and therefore ProgramContext):

public void parseArguments( String v )
public void parseArguments( String[] v );

I removed all but the default constructor from BasicParameterList and
BasicProgramContext. It is better. Thanks!

Note: program.Program and program.ProgramContext should not be confused
with org.jos.kernel.Program and org.jos.kernel.ProgramEnvironment.




From gchii@mindspring.com Mon, 23 Aug 1999 22:31:54 -0400
Date: Mon, 23 Aug 1999 22:31:54 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Also available on CD

I have created two JAR files, one for packages depending on Smart API -
Release 1a and one for packages depending on Smart API - Release 1b. These
JAR files contain pre-compiled .class files.

It seems that the Plain-Text Browser is somewhere between these two
releases (ugh). A new release of Plain-Text Browser is planned, dependent
on Smart API - Release 1b.

These JARs, along with JOS-related source code, is also available now on CD.




From tmiller@haverford.edu Tue, 24 Aug 1999 13:45:15 -0400 (EDT)
Date: Tue, 24 Aug 1999 13:45:15 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Free CDs?

	The license for jJOS/decaf is similar to the GPL in that it allows
CD distributors to do what they've been doing with the GPL, to whit, burn
CDs and sell them at cost plus small profit.  The JOS org itself doesn't
need to get into the distribution business at all.

-_Quinn




From tmiller@haverford.edu Tue, 24 Aug 1999 13:46:13 -0400 (EDT)
Date: Tue, 24 Aug 1999 13:46:13 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Free CDs?

	Sorry about that: I meant to suggest that all JOS software follow
a similar license that allows anyone to redistribute it...

-_Quinn




From ryan@whitewolf.com.au Wed, 25 Aug 1999 09:47:22 +1000
Date: Wed, 25 Aug 1999 09:47:22 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Free CDs?

Gilbert Carl Herschberger II wrote:

> I don't think JOS CDs should be free. The license to use JOS should be
> free.

Please move this discussion to another list (eg. biz@jos.org or
general@jos.org).

The arch list is for discussing the design and implementation of those
layers that sit above the JOS kernel and JVM. This includes the user
model, security, networking, and other system services.

-- 
Ryan Heise (arch list administrator)

http://www.progsoc.uts.edu.au/~rheise/



From gchii@mindspring.com Tue, 24 Aug 1999 10:02:49 -0400
Date: Tue, 24 Aug 1999 10:02:49 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Free CDs?

At 02:08 PM 8/24/99 +0200, scode@scode.webprovider.com wrote:
>> I don't think JOS CDs should be free. The license to use JOS should be
>> free. The license to modify JOS source code and re-compile for your own
>> personal use should be free.
>
>Not only for personal use, right? Much of the code is already GPL:ed.

Right! I meant *at the very least* every part of JOS should be free for
personal use. Much of the code is GPL'ed or LGPL'd and it should be.

>Right. But "a little extra" mustn't translate to $40 or something, as is the
>case with FreeBSD. Something like $5 on the other hand would be more
>affordable.

In a free market, "a little extra" is determined by supply and demand. It
makes sense to price the JOS distribution within comparable products. If
you can buy a complete OS for $25, how much should you pay for a pre-alpha
OS? In fact, it will cost *more* to publish CDs in small quantities.

How do we keep the cost low? We give distributors a free license to
distribute JOS. Any "improvements" made by distributors must be returned to
the JOS Project. The free license reduces the cost to a distributor. The
savings are passed on to their customers.

>In any case; will the JOS project handle disttribution anyway? Wouldn't it
>be a better idea to simply have a 3rd party ditribute "official" CDs, as is
>the case with Debian GNU/Linux for example?

I believe the JOS Project should build relationships with Caldera, Red Hat,
Slackware, SuSE and others. Distributors add value to JOS by testing,
selecting packages, writing documentation and building a distribution. The
JOS Project should concentrate on making JOS.

And, these distributors are not *required* to give money to the JOS Project
under the terms of GPL/LGPL. It is an honor system. Distributors are asked
to send money to the JOS Project when JOS is a successful product. The JOS
Project doesn't seem to have that much of an operating budget anyway.




From digigod@earthling.net Thu, 26 Aug 1999 12:16:59 -0700
Date: Thu, 26 Aug 1999 12:16:59 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] Free CDs?

As long as its still free to download from our website and the CD's are
avaliable to everyone.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From digigod@earthling.net Thu, 26 Aug 1999 13:01:05 -0700
Date: Thu, 26 Aug 1999 13:01:05 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI

"Todd L. Miller" wrote:
> > we have the ScriptLoader thats like a ClassLoader for scripts, should we
> > have a SCRIPTPATH?
>         If necessary.  I can't shake the feeling that There Ought To Be A
> Better Way, though.

I know what you mean...
 
> > an Object can be Scriptable if it has a ScriptInfo getScriptInfo(), but
> > what goes in ScriptInfo? (I'd just use BeanInfo but its to different)
>         If I'm scripting an object, I'm either writing intra-program
> (IRC scripts) or inter-program (shell scripts).  Typically, intra-program
> scripts are event-fired (in the form of well-defined "callbacks" to the
> scripts), and inter-program scripts are more like standard sequential
> programming, thought there are plenty of exceptions.  Since we can embed
> sequential programs in event-fired ones, event-fired scripts should be the
> norm.  Therefore, getScriptInfo() should return the events that the
> Scriptable Object will generate.

what if we want to make our java object an element in the script though?
like an add-on library, say we have a LuaMathLib object that has X math
methods that we want to map into the Lua interpreter as X fucntions...
how would we handle that? 
 
> > we have Script, how do we allow interaction generically? and its
> > top-level inner class Element, we have an element what do we do with it?
> > (goes with genric interaction above)
>         I'd imagine the non-script-interperting classes can safely ignore
> (or should be able to safely ignore) the components of a script.  As for
> generic interactions, as above, I'd suggest that the code simply fire
> events to a ScriptCollection, which would in turn handle distributing thos
> events to the proper Scripts for handling; last (or first), it could
> return that event to the program, so a default behavior could be included.
> In the shell-script case, the only event would be script_begin (or
> whatever).

my purpose in defining the Element top-level class was to allow a java
program to use parts of the script; say we have a reinit() function in
our script that we need to call... we get the Element for it to use
it... but what does Element look like?
 
> > ScriptLoader is asked to load a script, it finds the appropriate child
> > (ie LuaScriptLoader for a lua script) and calls load (returning a Script
> > object cast up from, using my previous example, a LuaScript). Gilbert,
> > how could your SmartFactory be used here?
>         Wouldn't ScriptLoader /be/ a SmartFactory?

this is what I was thinking, but I havent --admittedtly-- looked the
SmartAPI over with what one would call a fine-toothed comb...
 
> > Our program now has a Script, to run it calls execute(). is there a
> > better way? how does it interact with the script when its executing?
> > what happens when its done? if we call execute() again what happens,
> > what should?
>         See above -- execute() is a bad idea, for the problems you've
> mentioned.  Interacting with the script would be responding to events it
> generates, as moderated by the ScriptCollection (or whatever) and/or the
> scripts themselves.  If you fire off two script_begin events, the behavior
> should be the scripts choice: it can ignore it, spawn a new thread, queue
> it up, etc...

if its left up to the script we should have a way to tell what its
action is going to be...

ok, when does the interpreter start and when does the script start? if
we have BOB (which is a C/C++ish type script) which has a main like C,
does the interpreter start the script when its loaded by calling main,
or does it wait until we tell it to start? what if its a library you
created to make programming your app easier and doesnt have a main as
its just a collection of functions... does it return a
NotARunnableScriptEvent?
 
> > what if we have two seperate implementations from different authours,
> > how do we determine which to use?
>         The SmartRegistry?  I think we can safely punt on this one for
> now, because it's more a UI decision than an archictecture choice.

I guess...
 
> > how do we tell what type of script a file is? MIME? attributes builtin
> > to the fs? a per directtoy DB containg info the files (I like it,
> > cross-fs. doesnt Jigsaw do this?)?
>         Again, I'm tempted to punt on the problem for now.  I think
> whatever method is chosen could be safely enscapulated accross fs's --
> those don't have per-file attributes of the necessary kind get
> per-directory DBs or MIME or a central registry, depending.

Id like a nice standard, fs-independent way; like the perdirectory
miniDB's since it can be copied across fs without alot of hassle... (and
hassle is one thing you dont want in coding or using an OS)
 
> > in langauges already written-for/ported-to Java work? are there
> > languages you can think of that wouldnt work in this GSI?
>         JaCL (tcl interperter in java) is the one I'm most familiar with,
> and it's not as nearly advanced as what I'm proposing here.  (BTW: the
> event-based system would be translated by the respective Script objects to
> whatever is most appropriate to the source language; shell script, for
> instance, would get signals instead of events (which means most events
> would be ignored), or (possibly) only if the event name matched a method
> name, etc...

yea, we need it to be: stable, generic and simple (as possible);
otherwise theres no point in bothering with it...

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From tmiller@haverford.edu Sat, 28 Aug 1999 20:24:35 -0400 (EDT)
Date: Sat, 28 Aug 1999 20:24:35 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] GSI

> what if we want to make our java object an element in the script though?
> like an add-on library, say we have a LuaMathLib object that has X math
> methods that we want to map into the Lua interpreter as X fucntions...
> how would we handle that? 

	Not through getScriptInfo(), because that returns information on
the script, and not on the (extended) interperter on which it runs.


> my purpose in defining the Element top-level class was to allow a java
> program to use parts of the script; say we have a reinit() function in
> our script that we need to call... we get the Element for it to use
> it... but what does Element look like?

	Okay, this makes a lot of sense.  Why not make Element an
interface implemented by java.lang.Reflect.* inheriting subclasses?  i.e.:

public class tclMethod extends Method implements jos.gsi.Element {}

> ok, when does the interpreter start and when does the script start? if
> we have BOB (which is a C/C++ish type script) which has a main like C,
> does the interpreter start the script when its loaded by calling main,
> or does it wait until we tell it to start? what if its a library you
> created to make programming your app easier and doesnt have a main as
> its just a collection of functions... does it return a
> NotARunnableScriptEvent?

	I think the ability to select when the script runs is necessary.
If we adapt the event model I've described, then generating a ScriptStart
(or whatever) event will start the script in an interperter-independent
way.  Likewise, event-triggered scripts would become 'active' on a
ScriptStart event.  Libraries are hard, but I think if you generate a
ScriptStart event, then it should be the interperter's/script's choice to
ignore it if it's inappropriate or throw an exception.


	Basically, I'm imagining a system where an object like
'jos.gsi.ScriptManager mySM' functions as a clearing-house for
jos.gsi.Script objects, so that the application can do something like:

init() {
	appMainFrame.addKeyboardListener( mySM );
	appMainFrame.addMouseListener( mySM );
	appMainFrame.addFocusListener( mySM );
	}

and the ScriptManager would handle throwing the different events at the
different scripts, so that appMainFrame suddenly becomes a scripted
object.  Something like

	appMainFrame.addURLListener( mySM );

	could be achieved by subclassing ScriptManager to implement the
URLListener interface.  (Where one would do something like:

for ( int i = 0; i < myScripts.size(); i++ ) {
	switch URLEvent.getType() {
		case FTP:
			try { myScripts.elementAt(i).runMethod( "FTP" ); }
			catch ( NoSuchMethodException nsme ) {
				/* if every element of myScripts fails,
				   throw a NoSuchMethodException... */
				}
			break;
/* etc. */

	would be the body of the URLListener methods.)

-_Quinn




From digigod@earthling.net Sat, 28 Aug 1999 19:07:35 -0700
Date: Sat, 28 Aug 1999 19:07:35 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI

"Todd L. Miller" wrote:
> > what if we want to make our java object an element in the script though?
> > like an add-on library, say we have a LuaMathLib object that has X math
> > methods that we want to map into the Lua interpreter as X fucntions...
> > how would we handle that?
>         Not through getScriptInfo(), because that returns information on
> the script, and not on the (extended) interperter on which it runs.

no, no. getScriptInfo() is in the Scriptable interface and implemented
by a class that wants to be "plugged" into a Script to extend the
Scripts functionality...
 
> > my purpose in defining the Element top-level class was to allow a java
> > program to use parts of the script; say we have a reinit() function in
> > our script that we need to call... we get the Element for it to use
> > it... but what does Element look like?
> 
>         Okay, this makes a lot of sense.  Why not make Element an
> interface implemented by java.lang.Reflect.* inheriting subclasses?  i.e.:
> 
> public class tclMethod extends Method implements jos.gsi.Element {}

those classes are all final
 
> > ok, when does the interpreter start and when does the script start? if
> > we have BOB (which is a C/C++ish type script) which has a main like C,
> > does the interpreter start the script when its loaded by calling main,
> > or does it wait until we tell it to start? what if its a library you
> > created to make programming your app easier and doesnt have a main as
> > its just a collection of functions... does it return a
> > NotARunnableScriptEvent?
> 
>         I think the ability to select when the script runs is necessary.
> If we adapt the event model I've described, then generating a ScriptStart
> (or whatever) event will start the script in an interperter-independent
> way.  Likewise, event-triggered scripts would become 'active' on a
> ScriptStart event.  Libraries are hard, but I think if you generate a
> ScriptStart event, then it should be the interperter's/script's choice to
> ignore it if it's inappropriate or throw an exception.

shouldnt we have an execute method that generates a scriptStart event?
 
>         Basically, I'm imagining a system where an object like
> 'jos.gsi.ScriptManager mySM' functions as a clearing-house for
> jos.gsi.Script objects, so that the application can do something like:
> 
> init() {
>         appMainFrame.addKeyboardListener( mySM );
>         appMainFrame.addMouseListener( mySM );
>         appMainFrame.addFocusListener( mySM );
>         }
> 
> and the ScriptManager would handle throwing the different events at the
> different scripts, so that appMainFrame suddenly becomes a scripted
> object.  Something like
> 
>         appMainFrame.addURLListener( mySM );
> 
>         could be achieved by subclassing ScriptManager to implement the
> URLListener interface.  (Where one would do something like:
> 
> for ( int i = 0; i < myScripts.size(); i++ ) {
>         switch URLEvent.getType() {
>                 case FTP:
>                         try { myScripts.elementAt(i).runMethod( "FTP" ); }
>                         catch ( NoSuchMethodException nsme ) {
>                                 /* if every element of myScripts fails,
>                                    throw a NoSuchMethodException... */
>                                 }
>                         break;
> /* etc. */
> 
>         would be the body of the URLListener methods.)

if I understand that right, it would be easier to just have the
individual scripts handle those events via an adapeter and not have a
ScriptManager...

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From tmiller@haverford.edu Mon, 30 Aug 1999 10:06:09 -0400 (EDT)
Date: Mon, 30 Aug 1999 10:06:09 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] GSI

> no, no. getScriptInfo() is in the Scriptable interface and implemented
> by a class that wants to be "plugged" into a Script to extend the
> Scripts functionality...

	Whereas I took the understanding that Scripts extend Scriptable's
functionality, I see.  

> those classes are all final

	Then wrap them instead.  java.lang.Reflect's classes should cover
the range of possiblities for script-exentension (methods, data, etc);
getScriptableInfo() could return an array of reflection classes
that are the extensions offered to the script.  The interperter would work
from there.

> shouldnt we have an execute method that generates a scriptStart event?

	Sure, why not?

> if I understand that right, it would be easier to just have the
> individual scripts handle those events via an adapeter and not have a
> ScriptManager...

	We'll see.

-_Quinn






From digigod@earthling.net Mon, 30 Aug 1999 09:46:30 -0700
Date: Mon, 30 Aug 1999 09:46:30 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI

"Todd L. Miller" wrote:
> > those classes are all final
>         Then wrap them instead.  java.lang.Reflect's classes should cover
> the range of possiblities for script-exentension (methods, data, etc);
> getScriptableInfo() could return an array of reflection classes
> that are the extensions offered to the script.  The interperter would work
> from there.

well, A) I dont think you can make your own reflection objects
willy-nilly like that and B) it would be easier just to make /similiar/
classes. Even if you could create your own Method's without having a
method to reflect there'd be no way to make it "point" to the function
in the script... Besides, these would just be convience classes as
people might need to make custom classes (they'd have to extend them
anyway)
 
> > if I understand that right, it would be easier to just have the
> > individual scripts handle those events via an adapeter and not have a
> > ScriptManager...
>         We'll see.

I read an article on a "generic listner" that used reflection to accept
events of any type... maybe we could make our own, it'd be more generic
then ScriptManager that serves the same --but broader-- purpose.

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



From tmiller@haverford.edu Mon, 30 Aug 1999 12:54:08 -0400 (EDT)
Date: Mon, 30 Aug 1999 12:54:08 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] GSI

	Okay, we talked right by each other again.  getScriptInfo() should
use reflection to return parts of its implementing class which should be
exposed to the Script.  We may need/want to wrap those reflections because
they're being used in a script, viz. ScriptMethod extends Element, where
JavaReflectionMethod extends ScriptMethod, and includes a
java.lang.reflect.Method instance (function pointer).  Then TCLMethod
(etc) could extend ScriptMethod, and 'point' to whatever method it was
that the script exported, in whatever fashion it wished.

> I read an article on a "generic listner" that used reflection to accept
> events of any type... maybe we could make our own, it'd be more generic
> then ScriptManager that serves the same --but broader-- purpose.

	That would be the way to do it, definitely.

-_Quinn





From digigod@earthling.net Mon, 30 Aug 1999 12:09:43 -0700
Date: Mon, 30 Aug 1999 12:09:43 -0700
From: DigiGod Q =?iso-8859-1?Q?Frasch=E9?= digigod@earthling.net
Subject: [JOS-Arch] GSI

"Todd L. Miller" wrote:
>         Okay, we talked right by each other again.  getScriptInfo() should
> use reflection to return parts of its implementing class which should be
> exposed to the Script.  We may need/want to wrap those reflections because
> they're being used in a script, viz. ScriptMethod extends Element, where
> JavaReflectionMethod extends ScriptMethod, and includes a
> java.lang.reflect.Method instance (function pointer).  Then TCLMethod
> (etc) could extend ScriptMethod, and 'point' to whatever method it was
> that the script exported, in whatever fashion it wished.

ok, I see what your saying. But Script.Element is for reflection from
the script to java not java to the script. that is a Scriptable wouldn't
return arrays of Script.Elements (but a Script could generate those
Elements--assuming support--after the Scriptable was plugged in) I mean
I suppose it could, but that still gets into my general problem of how
to do it generically...  But your right, reflection would be required
for access to the Scriptable... but that should be taken care of in
Script so the children dont have to be bothered by it and the code
should be hidden...

something like:

get the Scriptables ScriptInfo...
add the methods into the scripts namespace(?)...
when its called do (and cache) the reflection in the background...

that doesnt really get the idea across, but I cant think of how to
better explain it
 

> > I read an article on a "generic listner" that used reflection to accept
> > events of any type... maybe we could make our own, it'd be more generic
> > then ScriptManager that serves the same --but broader-- purpose.
>         That would be the way to do it, definitely.

I'll have to reread the article then, I think I d'loaded the source...

where would something like that go? org.jos.util.genericlistner?
(digigod.util.genericlistner for now)

Cheers,
DigiGod
_________________________
DigiGod@earthling.net
AIM:DigiGod 86
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-



