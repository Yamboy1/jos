<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [JOS-Arch] Re: [JOS-UI] Compatibility might be off-topic</TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:gchii%40mindspring.com">
   <LINK REL="Previous"  HREF="000040.html">
   <LINK REL="Next" HREF="000042.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[JOS-Arch] Re: [JOS-UI] Compatibility might be off-topic</H1>
    <B>Gilbert Carl Herschberger II</B> 
    <A HREF="mailto:gchii%40mindspring.com"
       TITLE="[JOS-Arch] Re: [JOS-UI] Compatibility might be off-topic">gchii@mindspring.com</A><BR>
    <I>Thu, 22 Jul 1999 22:07:47 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000040.html">[JOS-Arch] RE: [JOS-UI] peer-ui mappings</A></li>
        <LI> Next message: <A HREF="000042.html">[JOS-Arch] Re: [JOS-Kernel] About Graphics Device</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#41">[ date ]</a>
              <a href="thread.html#41">[ thread ]</a>
              <a href="subject.html#41">[ subject ]</a>
              <a href="author.html#41">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 12:53 PM 7/22/99 +1000, Ryan Heise &lt;<A HREF="mailto:ryan@whitewolf.com.au">ryan@whitewolf.com.au</A>&gt; wrote:

&gt;<i>- Sun give (IMHO) sufficient warning of API changes through the use of
</I>&gt;<i>the @deprecated javadoc tag. In this way, if Sun plans to remove a
</I>&gt;<i>method from the API, it takes two JDK versions to happen. In the next
</I>&gt;<i>version, the method is still there but deprecated. In the version after,
</I>&gt;<i>it may be removed.
</I>
What is sufficient warning for one is insufficient warning for another. If
you think about all of those heavily discounted Java 1.0 books that arrived
at the bookstore just as Sun Microsystems announced Java 1.1. The promises
published in those Java 1.0 books were based on things said by Sun and
enthusiastically published by all major publishers. It promised a lot.

At the very first test of Sun's talent for write once, they failed
miserably. They invented depretiation so that they didn't have to be
compatible like they promised. Depretiation is bad, very bad. It doesn't
give sufficient warning to the software you distribute on CD-ROM.

Publishers wrote about the wonders of Java 1.1. They gave away millions of
free CD-ROMs in the back of Java 1.1 books. When someone buys that book,
promises of write once on the cover, they expect it to work.

It was Sun that chose to separate Java from the rest of the programming
languages based on compatibility. And from a purely technical viewpoint,
Java is the first time it could have been done. Perfect compatibility.
Every Java 1.0 and 1.1 program could have been compiled and run on a Java
1.2 platform without changing the API.

It was Sun that wimped out on compatibility in the second round. They
invented hundreds of excuses why they couldn't obtain the kind of
compatibility they promised. They showed that they don't believe in
compatibility (or Java) after all. They want something else. Is it world
domination? I don't know.

When Sun announced that they were dumping Java 1.0 in favor of Java 1.1,
the Java evangelists were stunned. They couldn't believe that something
that showed such potential could be stuck down so quickly. Talk to Michael
Daconta. See how he was burned. He said he felt betrayed. It didn't have to
be this way.

Look at FreeBuilder, too. By the time you have something that works, Sun
changes all of the rules. It is so unnecessary.

&gt;<i>- Sun appears to have used this tool effectively, except with Swing
</I>&gt;<i>which underwent a package renaming. Obviously the @deprecated tool
</I>&gt;<i>cannot be used here, and coincidently it was this Swing incompatibility
</I>&gt;<i>that fired the discussion off.
</I>
Sun has used it politically. They were happy to let themselves &quot;off the
hook&quot;. While they promised write once, they didn't deliver. And even
programmers that are being burned by Sun take up for them.

Next, Sun demonstrated their arrogance and ignorance by moving Swing around
like a pendulum. For Java 2.0 (1.2) they put Swing inside the java packages
where it does not belong. Swing is not Java. Swing is a Java application.
Who does Sun thing they are? If I can't put my applications inside the java
packages, they can't either. What was wrong with com.sun.swing? Nothing. It
didn't have to be incompatible. It is incompatible just for the sake of
being incompatible. It is meant to ruin their competition.

Sun put JDBC inside the java packages; JDBC is not Java. Sun put Jars
inside the java package; jars are not Java. Sun put more garbage inside the
java packages than the garbage Microsoft put in Win32. It took Microsoft
years to show their arrogance and ignorance. It only took Sun 140 days.

&gt;<i>I don't see the point in bashing Sun, but I do see that compatibility is
</I>&gt;<i>something that we should consider. It is conceivable that Sun could, for
</I>&gt;<i>example, change the JVM specification making new JVMs incompatible with
</I>&gt;<i>older JVMs, or that they could make incompatible changes to the JDK
</I>&gt;<i>libraries. However, call me short-sighted but I just don't think it is
</I>&gt;<i>something worth worrying about now -- at this point in the project
</I>&gt;<i>timeline. Someone will need to think about these issues in the future.
</I>&gt;<i>Actually, you sound quite keen. Why don't you come up with a proposal?
</I>
There is no point in bashing Sun. There is a purpose for being critical of
software. When the software doesn't work as promised, you should be
critical. You shouldn't lower your standards, accepting that software
doesn't have to work. If you celebrate something, if you publish something,
if you get all of your friends involved in something, you have to take some
responsibility for the results.

I don't want to follow bad practices. I don't want to build software that
doesn't work. How long can I stay in business if I can't deliver working
software? I'd be out of business in a week.

I am critical of the software industry. The software industry has lowered
standards again and again over the last thirty-five years. The software
industry is testing the market to see how low they can go. The market has
become saturated with low quality software.

Why do you want to build a new operating system? Are you unhappy with the
one you have? Why? Could it be because it is such poor quality? Could it be
that you have been disappointed one too many times? Was it too hard to
configure? Is it unstable? Does it crash too often? Do you need it to be
more flexible?

Is it because your old software stopped working? Or, because you have to
buy a new computer just to install new software?

The existance of the JOS project shows that Sun Microsystems hasn't been
able to give us what we want.

My proposal is the Smart API and something like real implementation
packages (Java versioning):

Java 1.0 Implementation Packages:
java.10.java.applet
java.10.awt
java.10.lang
java.10.math
java.10.net
java.10.sql
java.10.util

Java 1.1 Implementation Packages:
java.11.applet
java.11.awt
java.11.awt.events
java.11.lang
java.11.math
java.11.net
java.11.sql
java.11.util
java.11.util.jar
java.11.util.zip

Java 1.2 Implementation Packages
java.12.applet
java.12.awt
java.12.awt.swing
java.12.lang
java.12.net
java.12.sql
java.12.util
java.12.util.jar
java.12.util.zip

Java API Packages
Implementation packages are only virtually inside the java packages.
Through the power of the JVM, the JVM is configured to use Java 1.0, 1.1 or
1.2 for each process. This virtualization is only going to be important for
the java packages. If a program links to the java.net package while running
with the Java 1.1 switch, the JVM feeds up java.11.net.*;

I believe that a few &quot;native&quot; classes java.10.*, java.11.* and java.12
should be a bridge to the core implementation of jos.*.

Can you see this? You can intentionally write to a specific version of Java
by changing your import statements. In other words, you really can use Java
1.0, 1.1 and 1.2 at the same time. You can compare them side by side within
a single JVM.

If we start with classpath, compatible with Java 1.2, we can copy the code
to these packages and get what we want mostly by process of elimination.

- all of the code in java.10 must be compile-able by a standard Java 1.0
compiler.
- all of the code in java.11 must be compile-able by a standard Java 1.1
compiler; it does not have to be backward compatible at all with Java 1.0.
- all of the code in java.12 must be compile-able by a standard Java 1.2
compiler; it does not have to be backward compatible at all with Java 1.0
or 1.1.

You might compile all this code someday with javac for JOS.

I ask you: Why didn't Sun Microsystems do this from day one? There was no
need whatsoever to put Java 1.1 in the namespace already occupied by Java
1.0. And, guess what? You could have added most of the
java-one-point-one.jar to your Java 1.0 classpath without delay.

There was no need to put Java 2.0 (1.2) in the namespace already occupied
by Java 1.0 and 1.1. You could have your cake and eat it too. You could
have all your Java 1.0 and 1.1 applications mixing it up with the power of
Java 2.0 without a single depretiation. Perfect compatibility.


</pre>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000040.html">[JOS-Arch] RE: [JOS-UI] peer-ui mappings</A></li>
	<LI> Next message: <A HREF="000042.html">[JOS-Arch] Re: [JOS-Kernel] About Graphics Device</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#41">[ date ]</a>
              <a href="thread.html#41">[ thread ]</a>
              <a href="subject.html#41">[ subject ]</a>
              <a href="author.html#41">[ author ]</a>
         </LI>
       </UL>
</body></html>
