<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [JOS-Arch] [multiple process] Terminology</TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:gchii%40mindspring.com">
   <LINK REL="Previous"  HREF="000484.html">
   <LINK REL="Next" HREF="000482.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[JOS-Arch] [multiple process] Terminology</H1>
    <B>Gilbert Carl Herschberger II</B> 
    <A HREF="mailto:gchii%40mindspring.com"
       TITLE="[JOS-Arch] [multiple process] Terminology">gchii@mindspring.com</A><BR>
    <I>Wed, 19 Apr 2000 09:55:40 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000484.html">[JOS-Arch] [multiple process] Kernel class loader</A></li>
        <LI> Next message: <A HREF="000482.html">[JOS-Arch] [bytecode resource] Status report</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#481">[ date ]</a>
              <a href="thread.html#481">[ thread ]</a>
              <a href="subject.html#481">[ subject ]</a>
              <a href="author.html#481">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>As we have seen, &quot;redundent&quot; classes are a good thing. &quot;Redundent&quot; classes
are required in order to achieve a process in bytecode. Multiple instances
of java.lang.System are required for each bytecode process. Each bytecode
process must have its own properties object, and in, out and err properties.

I think it must be a problem with terminology.

.java -&gt; javac -&gt; .class

.class -&gt; byte[]
or
.class -&gt; archve (.cab, .jar, .zip) -&gt; byte[]
or
.class -&gt; bytecode resource -&gt; byte[]

byte[] -&gt; class definition -&gt; java.lang.Class

&quot;Class file&quot; is a very bad name of the raw data generated by the javac
tool. The raw data does not have to be stored (a) in a file and (b) one
class per file. Even in the Java Virtual Machine Specification, &quot;class
file&quot; is noted as a very bad name. Raw data generated by the javac tool is
traditionally stored in a class file, with a .class extension.

Bytecode is a single object, a byte array. A byte array is passed to the
defineClass() method of java.lang.ClassLoader. I think of the raw data
generated by the javac tool -- the entire content of a .class file -- as
&quot;bytecode&quot;, not just the Code attribute of each method. Bytecode starts
with 0xCA, 0xFE, 0xBA, 0xBE.

A &quot;class definition&quot; marshals bytecode into a plethora of objects. A class
definition helps to verify bytecode before it is translated into a class.
Each entry in codepool might be a separate object. If a class definition
only uses the input stream model to read bytecode, the original bytecode
may be discarded. Once discarded, it is difficult to compare two class
definitions with so many separate objects. If a class definition uses an
alternative model to read bytecode, the original bytecode may be preserved.
Once preserved, it is easy to compare two class definitions by using
memcmp() on their corresponding bytecode. It is also easy to &quot;compact&quot; a
class definition, freeing its plethora of objects.

A &quot;class&quot; is an instance of java.lang.Class.



</pre>




























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000484.html">[JOS-Arch] [multiple process] Kernel class loader</A></li>
	<LI> Next message: <A HREF="000482.html">[JOS-Arch] [bytecode resource] Status report</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#481">[ date ]</a>
              <a href="thread.html#481">[ thread ]</a>
              <a href="subject.html#481">[ subject ]</a>
              <a href="author.html#481">[ author ]</a>
         </LI>
       </UL>
</body></html>
