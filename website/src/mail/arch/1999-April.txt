From onewith1@flash.net Thu, 01 Apr 1999 21:30:04 -0600
Date: Thu, 01 Apr 1999 21:30:04 -0600
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] event handling & decaf/JJOS

I moved this discussion over from kernel@jos.org, since it pertains more to the
architecture than kernel.

"Todd L. Miller" wrote:

> > I think that it is enough for now to say that the
> > shell's ProcessEnvironment will have to have its own smart event distributor
> > which will know where to send such events next.  This is a topic completely
> > seperate from the VM & device driver implementation and is best hashed out
> > in the arch@jos.org list.
>
>         Right.  I believe I mentioned this -- once we get the events to
> the shell, it's no longer our problem.

>
>
> > The real question before us is how to get KeyEvents (and other events
> > generated by device drivers) to the shell(s?) so that the shell can take
> > care of sending them where they ultimately need to go.  What we may need is
> > a simple Proxy that is not necessarily a static class but perhaps daemon
> > process which is a parent to all of the shells.
>
>         AKA "consoled," the daemon I suggested to handle multiple
> virtual consoles would be the Proxy you're talking about.  consoled would
> send each (of an arbitrary, RAM-limited number) virtual console instance
> Events that they were Listeners for and had the focus to recieve.  Whether
> the WM then displaces consoled as the "prime reciever" of Events or not is
> entirely immaterial and depends on if you think a virtual console should
> virtualize the graphics subsytem as well -- something we don't have to
> worry about for a while, if at all.  (i.e. it might be more arch@jos.org
> stuff.)  Each shell, then, that would be a child of a virtual console
> instance, would be responsible (or not, depending on the shell) listening
> to its parent ( ProcessContext, etc: the interface between shell and
> console (or shell and jterm, etc) needs to be standardized) for Events
> which might concern it.

It may seem like I'm advocating JavaOS here (I'm not), but I've read and somewhat
understood its architecture, so I'll write it here for your amusement.

It seems like JavaOS's event system allows for an event to be registered, event
announcers to be registered, and event listeners to be registered as well.
Announcers can opt to be the sole announcer for an event, and same with
listeners.  When registering an event, it is declaired whether the event is
generated asynchronously or synchronously.  Sync events go out on the same thread
from which they were announced/fired.  Async events are issued in a dedicated
event thread, separate from the announce thread.

Instead of the standard "addXxxxListener" call, it needs to be generic enough to
allow any type of event to be registered.  So it accepts something like a business
card which describes the event and which method is called to listen.  Events
themselves would need to be clonable so that each event listener can receive an
independent copy of the event.

The system is process independent (not that JavaOS even has processes), since it
distributes system-wide events like key-press.  It can be optionally extended to
allow for network-distributable events, and I assume can also be extended to
support other event systems such as Jini's distributed events (that wouldn't be
too tough).

So our KeyboardDriver would register itself with the GlobalEventSystem as a
KeyEvent announcer (but not as the only announcer - lets say that the system can
have a telnet connection from outside register itself as a KeyEvent announcer as
well, even though it could wreck havok).  The shell (used here to mean the primary
classes in charge of threading and process forking for the whole OS) would
register itself as the sole KeyListener.  Then if anyone else wants to listen to
the events, they must register through the shell: any registration as a
KeyListener in the GlobalEventSystem would throw an exception.  The shell's
listener would distribute the KeyEvents to its registered listeners depending on
who has the current focus.

In this way we can encapsulate all the event distributing in one place, and keep
it process/thread independent.

-Matt




From onewith1@flash.net Sun, 04 Apr 1999 15:17:44 -0500
Date: Sun, 04 Apr 1999 15:17:44 -0500
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Joe Shmoe Device Driver Architecture beta released!

Ok - I've finished my beta draft of my current Device Architecture
without really mentioning the driver classes, I've noticed.  So, that
needs to be added.  Here's the link:

http://www.flash.net/~onewith1/java/jos/NewDeviceSystem.html

Have fun.

-Matt




From matthew.c.albrecht@lmco.com Thu, 08 Apr 1999 10:03:34 -0600
Date: Thu, 08 Apr 1999 10:03:34 -0600
From: Albrecht, Matthew C matthew.c.albrecht@lmco.com
Subject: [JOS-Arch] Calling for Directory Designs!

In my search for the driver/configuration/etc. directory, I have come across
several designs, but none of which are really satisfactory.

Here's my current wish-list for such a directory:
   1. Able to store Java objects with a name-object binding
   2. Names are referenced in a tree-like structure (ala Unix path
       names, or something similar)
   3. Each Entry (a bounded Java object) can have a set of attributes,
       which are themselves objects.
   4. Able to search the directory by several keys:
          a. Exact Name
          b. wild-card name (ala Unix again)
          c. object class (ala Jini)
          d. attributes
   5. Each entry has the option to be persistent, remote, both, or neither.
       This would specify which objects can be remotely downloaded,
       and saved for reloading on future reboots and directory restores..
   6. The base directory class is an interface, so any number of
       implementations can be made compatible.
   7. Probably an event system to announce new or removed entries, or
changes
       in entries' object or attributes.

I envision the directory to replace the classic idea of a Kernel API with a
configurable framework.  Sure, the other "kernel" parts will have their API
being static (such as the direct hardware access and process features),
since these are the built-in basic operations.  I also see the directory
having several "static" entries which act as gateways between the Java
"static" APIs (core, Java Media, whatever), and these entries are then tied
to the directory's other entries.

To support this framework idea, the middle-tier in the architecture would
need methods to change its directory entry references, and possibly listen
to the directory events for changes in its referenced entries.

For the "static" gateways, we would need to define interfaces for each part,
and implement, at a minimum, an adapter object which accepts all calls but
does nothing.

In this way a system architecture can be user-defined.  We would only supply
(as the kernel) several foundation utilities to make it possible.  And even
these kernel utilities are configurable with the right interfaces.

Just to show that this isn't all wish with no thought, here are some example
architectures a system architect could create:

1. A Plain-Jane architecture with nothing fancy. Drivers would be registered
in the directory, then the basic layers are added on these (file system to
link the disk drivers together, protocol stacks built on the network
drivers, and so on).  Then the "static" entries are assigned to the entry
points for these layers (java.io.File is linked to "/static/java/io/File"
for File I/O, java.net.Socket is linked to "/static/java/io/TCPIPSocket",
and so on).  After this initial setup, each application only knows about the
Java API and acts as if it is in a standard jvm.

2. A research group works with per-process architecture. They design the
directory interface so that each process inherits a copy of the directory,
which can be configured such that each process can make its directory
optimized for its own task, without affecting the parent directories.  Each
process spawns off a configuration task which restructures the directory,
adding its own entries to optimize the to-driver layers.

3. A network computer sets up the directory so that it directly references a
Jini lookup server on the network.  All directory calls would be translated
into Jini remote requests and calls, and all located drivers would be RMI
stubs.


-MattAlbrecht




From guanix@softhome.net Fri, 9 Apr 1999 13:06:42 +0200
Date: Fri, 9 Apr 1999 13:06:42 +0200
From: Guan Yang guanix@softhome.net
Subject: [JOS-Arch] Re: [JOS-Kernel] Calling for Directory Designs!

I have some comments, more related to user directory design (like the Linux
FileSystem Hierachy Standard). This is actually rather unrelated to the
kernel. Sorry if it is irrelevant.

Here I use slashes to represent directory boundaries.

Definitions:
Dynamic Classpath A classpath that is searched only after the "static
   classpath" is exhausted

=== Directory Structure/User Experience ===
The Directory Structure (DS) should look like this:
/user   /* Linked to the user's home directory, or (if it is a
   single-user machine) a directory by itself */

/user/classes  // [Write-only?] these are accesible through the
/user/classes/jar // /classes-hierachy.
/user/classes/exec // (Some form of RAID.)

/user/system  /* All the stuff in /system that the user has access
   to. Perhaps /system should be executable-only?
   This should be represented in a simplefied manner.
   (In Linux, executable on directories mean that you
   can see what's in them.) */

/classes  /* Plain-vanilla Java application classes, part of the
   CLASSPATH (like /classes/org/jos/Hello.class) */

/classes/jar  /* All JAR files in this are path of the dynamic
   classpath. */

/classes/exec  /* Only contains executable JAR files that can be
   executed as if they were normal class files in the
   user environment. */

/jos   /* Everything in jos.*, and stuff like JVM and
   kernel images. */

/system   /* Everything system-related, including devices.
   So we could have stuff like:
   user.system.Audio =>
   system.local.devices.Audio =>
   jos.device.audio.SoundBlaster16 =>
   system.local.isa.slot2 */
=== END. ===

=== User Experience ===
This is just a little fictional shell session (inspired by how I
wanted Linux/bash to be) (comments are with '#' like bash):

<fictional>
[ Load stuff like JJOS, decaf, VGA logo, etc. ]
This is guan.superman.com.

Login: guan
Password: *******

jsh 1.0 (c) 1999 JOS.org
Welcome to JOS, Guan Yang. The date is 1 January 2000.

/user$ dir  # jos.command.dir; /user => /users/guan
[classes] [system] [Work]  [Home Computer] [Fun]
[source]
/user$ cd system # jos.command.cd
/user/system$ dir
[devices] [network] [computer] [jini]  [environment]
/user/system$ cd devices
/user/system$ dir # abridged
Audio  Video  ...
/user/system$ copy /user/fun/jossong.au Audio
JOSplayer: Playing /user/fun/jossong.au on /user/system/devices/Audio...
End.
# JOSplayer is "assigned" to /user/system/devices/Audio
/user/system$ adduser guan2 # Interactive call of jos.command.adduser
You do not have access to add users. Do you wish to enter password? (Y/N) y
Supervisor password: *********
User guan2 added.
/user/system$ exec adduser guan3 # Non-interactive call of
jos.command.adduser
/user/system$ checkmesg # Check messages
Messages: 1
jos.command.exec Password required for task add users
   (jos.command.adduser guan3)
   Supervisor password was not in key library.
/user/system$ keylib addkey supervisor password # add a new key to the key \
library; the key is generated from password "password"
/user/system$ exec adduser guan4 # Non-interactive call
/user/system$ checkmesg
Messages: 1
jos.command.exec Password required for task addusers
   (jos.command.adduser 4)
   Supervisor password was in key library. A-OK!

=== END. ===

A couple of points: When invoking "adduser guan2" interactively, "adduser"
asks for a password. But when invoking non-interactively, "adduser" checks
the "key library" of the current user. "Keys" are generated from passwords
and the system key library, because passwords can't be used
non-interactively. Just a security thought.





