From gchii@mindspring.com Sat, 01 Apr 2000 11:48:28 -0500
Date: Sat, 01 Apr 2000 11:48:28 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] process: scheme vs. process: subscheme

The latest design for Smart API defines a process: scheme. This scheme
always returns an instance of java.lang.Process (or null). An instance of
java.lang.Process uses streams for stardard in, out and error.

Today, a new browser must be developed to display processes. The input and
output from a process should be browse-able in the UniversalBrowser.
Keystrokes entered into the process browser should be passed to the
process. Characters from the process should be displayed in the browser.
The ProcessBrowser might be constructed from an AWT canvas. When a URI
starts with "process:", the ProcessBrowser is selected. It should create
the process. It should display the output from a process. For input,
keystrokes should be converted to ASCII characters and sent to the process.

The run: scheme is intended to run all kinds of programs, including threads
and processes. The run: scheme support scheme chaining. The process:
subscheme returns an instance of org.jos.program2a.Program. It is
compatible with the ProgramBrowser. The subscheme returns a program, not a
process.

The Find application can be created in the current thread. The program is
started when Program.run() is invoked.
  run:program:org.jos.gchii.find2a.Find

The Find application can be created in a separate thread. The thread is
created and started when Program.run() is invoked:
  run:thread:program:org.jos.gchii.find2a.Find

The Find application can be created in a separate process. The process is
created and started when Program.run() method is invoked:
  run:process:program:org.jos.gchii.find2a.FindProgram

This subscheme does not use embedded URIs. Therefore, the priority of a new
thread is normal and a child process inherits the environment of its parent
(CLASSPATH,etc).




From gchii@mindspring.com Tue, 04 Apr 2000 19:06:41 -0400
Date: Tue, 04 Apr 2000 19:06:41 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Process Diagrams

It is important to understand the difference between the classic design and
JNI design of a virtual machine. Both are implementations of the Java
Virtual Machine specification.

Personally, I like the JNI design. It solves most of the problems of the
classic design. I think the JOS design should be something like the JNI
design. In summary, I wrote two new articles on JOS Wiki:

ProcessDiagramClassic
ProcessDiagramJNI

-----

My web browser has a cache. Even if I have 100 copies of my browser open, I
only have one cache.

I'd like to have a cache for all my JOS programs. When I connect to a URL,
my JOS program should forward a request to the cache. If the document is in
the cache, the cache should return it without delay. Otherwise, the cache
should download a document, save it in the cache, and return it to my JOS
program.

With a general-purpose URL cache, there is little need for a specialized
bytecode cache. Bytecode can be downloaded with a URL, through the HTTP
protocol. A URL cache can cache bytecode.




From iainshigeoka@yahoo.com Tue, 4 Apr 2000 23:06:46 -0500
Date: Tue, 4 Apr 2000 23:06:46 -0500
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] Process Diagrams

On 4 Apr 00, at 19:06, Gilbert Carl Herschberger II wrote:

> With a general-purpose URL cache, there is little need for a specialized
> bytecode cache. Bytecode can be downloaded with a URL, through the HTTP
> protocol. A URL cache can cache bytecode.

Well, for byte code though, since its so core to the os, and will be 
used and reused so much, there may be optimizations that are 
possible and worth the effort with a byte code specific cache.  I'd 
mainly anticipate these to be in class searching (fast package 
resolution), and possible "shared memory" techniques for getting 
the cache classes as quickly as possible from the cache to the 
VM.  Other areas may be ways of pre-verifying classes, pre-
resolution of class constant pools and other pre-JIT compiling 
techniques, optimizing storage of the "pre-loaded" classes for 
space or speed (converting the string text method names for 
quicker pointers to shared strings to save space, etc), etc.

Just a hypothesis.

-iain



From Alexis Petrounias Wed, 05 Apr 2000 13:45:41 +0300
Date: Wed, 05 Apr 2000 13:45:41 +0300
From: Al Alexis Petrounias
Subject: [JOS-Arch] Process Diagrams

Gilbert Carl Herschberger II wrote:

> My web browser has a cache. Even if I have 100 copies of my browser
> open, I only have one cache.
> 
> I'd like to have a cache for all my JOS programs. When I connect to a
> URL, my JOS program should forward a request to the cache. If the
> document is in the cache, the cache should return it without delay.
> Otherwise, the cache should download a document, save it in the cache,
> and return it to my JOS program.

JOS could have a local proxy services running, that would do just that
job. Network applications will use the proxy "http://localhost/" for
their requests. Then, the local JOS proxy can be either directly
connected to the network, or it could as well connect to a "real" proxy.

-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]



From gchii@mindspring.com Wed, 05 Apr 2000 10:56:06 -0400
Date: Wed, 05 Apr 2000 10:56:06 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] WebSource 3b - Release 1

Version 3b of WebSource is available for immediate download. Look for
jos1e-websource3b... archives in the "mirror" directory.

<URL:http://www.jos.org/redist/mirror>

(I'm planning to create a Wiki article called DownloadWebSource with links
to the archives in the "mirror" directory.)

Unlike version 3a, this version does not depend on a commercial product
from Realign Software. I have replaced FileSearch with Finder. Unlike
FileSearch, Finder is integrated into the Smart API; it's open source; it's
free license; it can read source code from archives, like zip files.

I'd like to thanks Ryan Heise <ryan@whitewolf.com.au> for his testing,
suggestions and patience.




From gchii@mindspring.com Wed, 05 Apr 2000 11:27:03 -0400
Date: Wed, 05 Apr 2000 11:27:03 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] URL cache

Many applications use the URL class. The URL class can always benefit from
an automatic URL cache.

1. Every virtual machine should use a system-wide URL cache.

If I have 100 virtual machines, I only want one cache. It should be a
system-wide cache. Even if all 100 virtual machines put in a request for
the same page at the same time, the URL cache would download the resource
only once.

I don't want a URL cache limited to my web browser. Applets aren't the only
Java program that uses a URL class. If that requires a virtual machine
provides a HTTP proxy, that sounds like a good idea.

If it were implemented as a HTTP proxy service, there would only be one
HTTP proxy service listening on a specific TCP port. Each virtual machine
might automatically start an HTTP proxy service (in a separate process) if
there is no response from the TCP port. Rather than modifying each
application to use the proxy service, the virtual machine must redirect
URLs to the HTTP proxy service automatically.

The HTTP proxy itself should use a different implementation of
java.net.URL. Otherwise, the HTTP proxy would become recursive.

This is what we're experimenting with inside the Alt Package project.
Imagine there is a real URL class called alt.resource.URL, an HTTP proxy
would use it to download documents from a real HTTP service. Imagine there
is java.net.URL class that always connects to the HTTP proxy service. The
HTTP proxy service maintains its own URL cache. By refining the
java.net.URL class, every program benefits from a system-wide URL cache.

When there is only one virtual machine, like Ultimate JOS, there might be
no machine code methods bound to java.net.URL.

2. Downloading class, package or jar files from a HTTP service should be
optimized with a URL cache.

The URL-aware class loader benefits automatically from a system-wide URL
cache. When a class file is already in the URL cache, a HTTP proxy does not
have to download it again -- unless the file has changed on the real HTTP
service.

I was thinking about priority. Does a virtual machine need a URL cache more
than it needs a bytecode cache? I think a URL cache comes first. A URL
cache can excellerate all kinds of applications that use a URL. A bytecode
cache should depend on a pre-existing URL cache. A bytecode cache should
use a URL cache to download additional bytecode.

A fully optimized bytecode cache could compile each package ahead of time
into a machine code shared library. A virtual machine doesn't need a
bytecode interpreter after all.

3. I want the benefit of a URL cache without rewriting any Java application.

My applications create the same URLs. They always point to the real HTTP
service. But within the virtual machine, URL *always* go to the system-wide
URL cache. The URL cache should be enabled by default. It might take a
command line parameter to turn it off.




From gchii@mindspring.com Thu, 06 Apr 2000 19:16:39 -0400
Date: Thu, 06 Apr 2000 19:16:39 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

I have been working on the problem of multiple process in a single Java
Virtual Machine. I found that a class loader does not become part of an
object's type unless the class loader defines the class. A class loader is
not part of the type if the class loader uses findSystemClass(). This could
be significant.

Imagine I have a custom class loader that can read rt.jar and classes.zip.
It looks at the CLASSPATH property of java.lang.System.

Theory: When a request for a new java.lang.System class is passed to the
custom class loader, the custom class loader can ignore findSystemClass()
and use defineClass() to define a new instance of the java.lang.System class.

A few good things happen. There is a new instance of System.in, System.out
and System.err. The custom class loader becomes part of the new type of
java.lang.System. Throw this into a thread and you almost have a process.

Question: Starting with an instance of java.lang.Class, is there an easy
way to get its original bytecode?

When asked for "java.lang.System", a custom class loader could do something
like this:

  Class c = System.getClass();
  defineClass( c.getBytecode() );

When asked for "java.lang.Runtime", a custom class loader could do this:

  Class c = Runtime.getClass()
  defineClass( c.getBytecode() );

Or rather

  Class c = Runtime.getRuntime().getClass();
  defineClass( c.getBytecode() );

Question: Why is the access "private" for java.lang.Runtime's only
constructor? How does a virtual machine extend it without rewriting it from
scratch?

Question: Why is java.lang.Object and java.lang.Class stored inside rt.jar?
These classes should be stored in the machine code for a virtual machine,
shouldn't they?

Question: Isn't it possible to literally translate bytecode from a class
file into a C++ program? A few class files could be compiled directly into
the jJOS/decaf executable image, with no classes.zip file required.

class java_lang {
  const char *bcSystem = { 0xCA, 0xFE, 0xBA, 0xBE .. };
  const char *bcObject = { 0xCA, 0xFE, 0xBA, 0xBE .. };
  const char *bcClass = { 0xCA, 0xFE, 0xBA, 0xBE .. };
  const char *bcThread = { 0xCA, 0xFE, 0xBA, 0xBE .. };
  const char *bcThreadGroup = { 0xCA, 0xFE, 0xBA, 0xBE .. };
:
};

A class file might be a "resource" from the machine code viewpoint. Like an
icon or string table, a resource can be linked to an executable image.

A virtual machine, like decaf, could provide a BCNI interface for the
pre-defined classes, like this:

public interface PredefinedBytecode {
  public byte[] getData();
}

A URI would return the predefined bytecode to a custom class loader:

URI uri = new URI( "device:intern:java.lang.System" );
PredefinedBytecode bc = (PredefinedBytecode) uri.getObject();

Class c = defineClass( bc.getData() );

-----

Or the entire predefined bycode object could be encapsulated like this:

public interface PredefinedBytecodeManager {
  public byte[] getData( String cn );
}

URI uri = new URI( "device:bytecode:" );
PredefinedBytecodeManager manager =
    (PredefinedBytecodeManager) uri.getObject();

Class c = defineClass( manager.getData( "java.lang.System" ) );

Any binary file can be translated into a C++ program by converting each
octet to a hexidecimal literal. Or, it can be translated into a literal string.




From tmiller@haverford.edu Fri, 7 Apr 2000 02:06:49 -0400 (EDT)
Date: Fri, 7 Apr 2000 02:06:49 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> Question: Starting with an instance of java.lang.Class, is there an easy
> way to get its original bytecode?

	Not that I'm aware of, though this could probably be added w/o too
much difficulty.

> Question: Why is the access "private" for java.lang.Runtime's only
> constructor? How does a virtual machine extend it without rewriting it from
> scratch?

	AFAIK, because the native code is not bound by privacy
restrictions.  To my understanding, classpath uses native code in several
places exclusively to get around Sun's poort choices in classes like this
one.
 
> Question: Why is java.lang.Object and java.lang.Class stored inside rt.jar?
> These classes should be stored in the machine code for a virtual machine,
> shouldn't they?

	The compiler needs access to j.l.O and j.l.C, and this removes
(some) class library version dependencies from the compiler.

> Question: Isn't it possible to literally translate bytecode from a class
> file into a C++ program? A few class files could be compiled directly into
> the jJOS/decaf executable image, with no classes.zip file required.

	Yes.  My approach is (will be) that as long as I'm implementing a
native class anyway, I may as well just write the C++ class for it and
save myself some trouble.


	Processes /are/ very simple, but you must bear in mind that not
every request for a static goes through a classloader.  If application Q
spawns a new process R, R will inherit all of Q's /already loaded/ class
definitions unless specific actions are taken by the native code to
prevent this from happening.  Sun had the native code cache class
definitions -- instead of always passing class use requests to a
classloader -- for several reasons, including efficiency; this is one of
its effects.  (Another reason would include the boot-strapping problem;
beginning with say, a request for j.l.o -- the (java) classloader needs
j.l.o to function, along with several other classes.  Therefore, the
primordial class loader must supply them /before/ the classloader is
called the first time.  (Presumably, for the command-line main-function
containing class.)  (BTW -- decaf doesn't support class loaders at all
right now, which is one reason we need real classlib support.)  Allowing
the classloader to then redefine j.l.o opens any number of gaping security
and consistency holes.)

	But basically, yes, the idea is to alter the classloader and class
definition caching in such a fashion so as to prevent data sharing via
statics; this will probably be best implemented with support from the
class library's classloader.


	As an aside -- the issue of memory architecture.  Virtual memory
(and hence paging) seems like a Good Idea.  However, there is a certain
benefit to having all the (possibly multiple /native) JVMs share a single
address space (provided the memory allocator is aware of this!) -- IPC
becomes blazingly fast, because there's no copy (unless explicitly
programmed) or memory-space-switch involved.  The risk, of course, is
two-fold: (a) decaf makes a bad pointer and scribbles on another JVM's
data.  This is not something I'm terribly worried about (and could
actually be written in to a memory-protection scheme*) because if decaf
scribbles on random memory, it'll nuke itself during single-process
testing anyway.  (b) the same, but with native code we didn't
write.  (e.g. is not known to be 'perfect' anyway)  This requires a
separate address space for safety reasons (e.g. it's not 'kernel' code, so
sandbox it); but since JNI is the IPC for native code, the additional
overhead of copying things around won't be terribly noticeable.  (I
think/hope; I'll have to check the docs again to see what kind of
checking we'd need to do, if any, on objects share with native code.)  The
main reason for multiple native processes is not separate address spaces,
I think, but pre-emptive multi-tasking...

-_Quinn




From R.Argentini@student.tudelft.nl Fri, 07 Apr 2000 08:27:09 +0200
Date: Fri, 07 Apr 2000 08:27:09 +0200
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] [multiple process] Is it that simple?

>	But basically, yes, the idea is to alter the classloader and class
>definition caching in such a fashion so as to prevent data sharing via
>statics; this will probably be best implemented with support from the
>class library's classloader.

Will a new process get started by "forking" an existing process? Will it
inherit some/all of its variables? (static or non?)
The reason i'm asking this is that i'm planning on implementing the
networking subsystem in a transparent fashion, simply by calling
setSocketImplFactory() and let it return an instance of a JEPS socket for
every Socket() call instead of an instance of a default socket.
This requires some sort of persistance among child processes, or a way to
set some variable at process spawn time, but i fear the list of things to
do will grow quite large.

Wel, just let me know ;)

Ranieri



From tmiller@haverford.edu Fri, 7 Apr 2000 02:40:10 -0400 (EDT)
Date: Fri, 7 Apr 2000 02:40:10 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> Will a new process get started by "forking" an existing process? Will it
> inherit some/all of its variables? (static or non?)

	Luckily, we're not limited to UNIX conventions.  I used fork() as
an example because pretty much everyone knows how it works.  The difficult
part of designing multi-process Java is determining the interface it
should implement.  fork() seems like a good idea, in general; after all,
it's survived for thirty years :)  (BTW -- do you actually want separate
processes, or just separate threads?  Java threading will operate exactly
as it should with decaf, and threads are usually the Right Thing to do if
you need to share alot of information.)  OTOH, something like the
following would also be nice:

	/* myRunnableClass does something useful */
	Thread t = new Thread( new myRunnableClass() );
	/* Starts a clean process and loads t as its single
	   thread.  No data sharing, unless myRunnableClass()'s
	   constructor references something. */
	jos.system.process.startNewProcess( t );
	/* remove the temptation to fiddle with the other process;
	   could this be done by startNewProcess?  (may need
	   a native call) */
	t = null;

	In general, however, I think of processes as being useful mostly
as a distinction between threads which were /not/ explicitly written to
work together -- e.g. grep and less, or the windowing system and the word
processor.  Inside a single application, I think the major utility of
spawning a new process is the ability to skip potential costly (and
generally annoying to program) synchronizations.

-_Quinn




From gchii@mindspring.com Fri, 07 Apr 2000 21:53:46 -0400
Date: Fri, 07 Apr 2000 21:53:46 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

At 02:06 AM 4/7/00 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	Processes /are/ very simple, but you must bear in mind that not
>every request for a static goes through a classloader.

I'm not sure exactly what you meant. Each instance of java.lang.Class must
allocate enough space for its static fields. A class loader indirectly
allocates static fields when it defines a class.

It is both necessary and desireable to associate every static field with a
class loader. Every static field is closely associated with some class.
Every class is associated with some class loader, even if it is the
primordial class loader. Therefore, every static field is associated with a
class loader.

It is desireable because one Java applet from two or more websites must
never share static fields. Otherwise, we would be forced to create a new
instance of a virtual machine for each bytecode process.

>If application Q spawns a new process R, R will inherit all of Q's /already
>loaded/ class definitions unless specific actions are taken by the native
>code to prevent this from happening.

The best-case scenario is this: application Q is loaded by one custom class
loader and process R is loaded by another. R's class loader determines
which classes, if any, of Q should be reused.

Understanding class loaders is critical to understanding a process in
bytecode. The actual behavior of Q and R can only be determined through
experimentation. I have experimented with class loaders in Java 0, 1 and 2.

To be sure, I would need to know if application Q was loaded by a custom
class loader, or not. If it was loaded by a custom class loader, I would
need to know if its class loader follows the rules of Java 2, or not.

In general, the behavior of process R depends on an interaction between R's
class loader and the primordial class loader. A custom class loader is
critical in two cases:

1. A class has never been loaded by any class loader.
2. A class has never been loaded by this class' class loader.

A class can be a primordial class, or not. A primordial class is loaded by
the primordial class loader. Its getClassLoader() method returns null. The
primordial class loader is implemented in machine code.

Otherwise, a class is a custom class. A custom class is loaded by a custom
class loader. Its getClassLoader() method returns an object. The custom
class loader is implemented in bytecode.

If a class has never been loaded, a virtual machine uses this class' class
loader. If the calling class is a primordial class, the primordial class
loader is used. One primordial class can create another. If the calling
class is a custom class, a custom class loader is used. A custom class
loader can (a) use the primordial class loader, (b) use another class
loader, or (c) define the class as its own.

To be sure, I would need to know if application Q was loaded by a custom
class loader, or not. If part of application Q is loaded by the primordial
class loader, process R can inherit all of its primordial classes. If part
of application Q is loaded by a custom class loader, R may or may not
inherit its classes. At least it is an option in Java 1 and 2. But it is
difficult (nearly impossible) for R to inherit custom classes in Java 0.
Unfortunately, in the java.lang.ClassLoader class from Java 0, the
loadClass() method is protected, not public.

>The main reason for multiple native processes is not separate address
>spaces, I think, but pre-emptive multi-tasking...

You have mention many different issues all at once. You mention address
space, machine code vs. bytecode process, pre-emptive vs. non-pre-emptive
scheduling. Let's go over them one at a time.

1. Maintaining control over your machine.

Control is the main reason for a heavy-weight process. A heavy-weight
process puts you in control over your machine. At will, you can start and
stop your machine. At will, you can start and stop a heavy-weight process.

Stopping a heavy-weight process is a controlled crash. The best control
over your machine means *all* resources used by a heavy-weight process are
available again. If a process had 30+ MB of virtual memory allocated, that
space is available again. If a process had exclusive control over a serial
port, that serial port is available again. Even if a process had a TCP port
open, the TCP port is available again.

2. A heavy-weight process has its own address space. This is a defense
mechanism for machine code. In general, machine code is far more likely to
mis-behave than bytecode. A kernel might keep a separate address space for
each machine code process so that one process cannot overwrite the private
structures of another. A kernel might keep a separate address space so that
when a person asks the kernel to kill a process, all of its "space" can be
reused.

Therefore, a kernel must keep track of which process owns what.

3. A scheduler might be pre-emptive or non-pre-emptive. Pre-emptive
schedulers are generally more consistent and more complex. A pre-emptive
scheduler is usually based upon a clock. A clock-based scheduler has a very
predictable behavior. The frequency does not vary from one user process to
the next.

By definition, a non-pre-emptive scheduler means that, if a program doesn't
want to yield, it doesn't have to. In machine code, non-pre-emptive
schedulers waste time to determine if they should perform a task switch.
The frequency of the scheduler varies wildly from one user process to the
next. In machine code, non-pre-emptive schedulers are always at the mercy
of a program to yield.

A non-clock-based scheduler can be simpler in bytecode than machine code. A
bytecode program must yield to a virtual machine between each instruction.
And yet, such a virtual machine would waste time determining if it should
perform a task switch. Since the duration of each instruction will vary,
the frequency of the scheduler will vary from one user process to the next.

Even a clock-based scheduler can be simpler in bytecode than machine code.
Since the virtual machine is the only machine code that's running, critical
sections can use a simpler mechanism. A critical section prevents a
scheduler from switching task.

A balanced combination of clock and non-clock scheduler seems like the
ideal solution when a virtual machine is the only machine code task that's
running. A clock tells the virtual machine to yield to the scheduler at the
end of the current instruction. Instead of wasting time in between each
instruction, a virtual machine only needs to yield if the clock-timer has
expired.




From gchii@mindspring.com Fri, 07 Apr 2000 22:27:37 -0400
Date: Fri, 07 Apr 2000 22:27:37 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

At 02:40 AM 4/7/00 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>OTOH, something like the following would also be nice:
>
>	/* myRunnableClass does something useful */
>	Thread t = new Thread( new myRunnableClass() );
>	/* Starts a clean process and loads t as its single
>	   thread.  No data sharing, unless myRunnableClass()'s
>	   constructor references something. */
>	jos.system.process.startNewProcess( t );
>	/* remove the temptation to fiddle with the other process;
>	   could this be done by startNewProcess?  (may need
>	   a native call) */
>	t = null;

Personally, I prefer the standard way of creating a new process in Java.

  public void example() {
    Runtime.getRuntime().exec( ... );
  }

1. It needs no native calls.

2. Most Java applications do not become JOS-specific.

3. Killing a process also removes all custom classes owned by the process.

4. It enables inter-process communication through I/O streams.

5. The exec() method has nothing better to do when there is no foreign
operating system. When bytecode is the native executable format, the exec()
method creates a process from bytecode. In its simplest form, a "command
line" would be the name of any runnable class:

  public void example() {
    Runtime.getRuntime().exec( "myRunnableClass" );
  }

The exec() method for JOS should always run a process in a separate thread.

  public Process exec( String cmd ) {
    Runnable r;
    try {
      r = (Runnable) Class.forName( cmd ).newInstance();
    }
    catch( Throwable e ) {
      return null;
    }

    Thread t = new Thread( r );
    t.start();
    return new BytecodeProcess( t );
  }

Of course, this is a gross oversimplification. A real implementation of
exec() would determine if a class implements the Runnable interface before
creating a new instance. It should always create a new class loader, too.
While the thread and the runnable class are created with the new class
loader, the instance of java.lang.Process must be created by the parent's
class loader.

In its simplest form, Runtime.exec() method could invoke startNewProcess()
with the name of a runnable class.

  public Process exec( String v ) {
    return jos.system.process.startNewProcess( v );
  }

6. The "environment" for the new process comes from the system properties
of its parent. A parent can create a different environment for its child.
For example, a parent can run a child process with a different CLASSPATH.

What is a command line shell? A shell enables you to edit a line of text
and pass it to the exec() method.




From gchii@mindspring.com Fri, 07 Apr 2000 22:45:41 -0400
Date: Fri, 07 Apr 2000 22:45:41 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [startup sequence] scripted

Before a virtual machine processes a command line, it has a few
housekeeping chores to do. One of those housekeeping chores could be a
startup script.

After a virtual machine is initialized and before it loads any user
requested class, it can create additional threads. For example, a virtual
machine might create a user interface thread and a garbage collection thread.

A startup script can be an external resource. A startup script could be as
simple as a list of runnable classes that should be started, each class in
a separate thread. When a virtual machine gets around to starting the user
requested class, many other threads can be running.

The ERIC Project demonstrates another way to do it. The ERIC Project passes
a user requested class to a "shell". A shell is usually a runnable class. A
shell has an opportunity to do anything it wants, including starting
additional threads, before invoking the user requested class.




From tmiller@haverford.edu Sat, 8 Apr 2000 01:02:47 -0400 (EDT)
Date: Sat, 8 Apr 2000 01:02:47 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> Personally, I prefer the standard way of creating a new process in Java.
> 
>   public void example() {
>     Runtime.getRuntime().exec( ... );
>   }
> 
> 1. It needs no native calls.

	Well, Runtime.exec() does, but I do see your point.  A
JOS-specific way would allow finer-grained control, so it would be worth
doing.

-_Quinn




From tmiller@haverford.edu Sat, 8 Apr 2000 03:03:29 -0400 (EDT)
Date: Sat, 8 Apr 2000 03:03:29 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> I'm not sure exactly what you meant. Each instance of java.lang.Class must
> allocate enough space for its static fields. A class loader indirectly
> allocates static fields when it defines a class.

	The classloader only sees System.in/out/err once, the first time
System is loaded, and odds are System will be loaded by the primordial
classloader first.  Yes, all static fields are associated with a
classloader, but only because the identity of each JavaClassInstance has
to do with the classloader it was loaded by.  You can't adjust static
fields on the fly from the classloader.

> The best-case scenario is this: application Q is loaded by one custom class
> loader and process R is loaded by another. R's class loader determines
> which classes, if any, of Q should be reused.

	Indeed.  That custom classloader must use native methods provided
by JOS in order to redefine already-present classes.  No class in a JVM
may be defined more than once -- in fact, no class in a JVM will ever be
implicitly requested more than once.

> 2. A heavy-weight process has its own address space. This is a defense
> mechanism for machine code.

	And let me re-emphasize that it is ONLY necessary for machine
code.  Virtually everything else is simpler, more elegant, and more
efficient in a single address space.  The desire for heavy processes in
Java -- which are defined by disjoint classloaders, as adjusted by
JOS-aware programs -- stems from the desire to use Java programs which are
not aware of JOS without having to write native processes and complicated
IPC code for efficiency between different JVM processes.  Native processes
are not strictly necessary to the proper functioning of JOS; ideally, the
only native code is in the kernel, the interpreter, and the class library,
all of which have to be Right anyway. 


	You have come to the same conclusion that I did about a year ago
when I first proposed Java processes for decaf -- that the classloaders
are the important element, and proper manipulation of them allows
transparent operation of multiple Java processes in the same
JVM.  To quote you:

> Theory: When a request for a new java.lang.System class is passed to the
> custom class loader, the custom class loader can ignore findSystemClass()
> and use defineClass() to define a new instance of the java.lang.System
> class.

	What I meant by saying that not all statics go through a
classloader is that there will /never/ be a request for a 'new'
java.lang.System class made by the interpreter, according to my
understanding of the spec*.  Explicit request may be made by Java code,
which would generate an appropriate java.lang.Class object instantiating
the new System class -- but the bytecode which uses System, the bytecode
for which you're defining a new System class -- calls System implicitly,
that is, System.out.println( "Hello, world!" ); not by
mySystemClass.getField("out").println("Hello, world!");.  It is possible
(in fact, relatively simple) for the native code to adjust what classes
are defined, but ONLY IF the two conflicting class definitions can never
meet -- e.g. are in different Java processes.  This adjustment would take
place at the behest of, for example, Runtime.getRuntime.exec() -- or other
interfaces we deem appropriate.

-_Quinn

PS -- I looked at the code for jshell, and it doesn't do redirects for
programs invoked with main(String[]) -- which is the prime example we've
been talking about w.r.t. rewriting statics.  I checked and can no longer
find Echnida/Enchida on the web anywhere -- anyone have a URL?

* My understanding is based on the following sections from the Java
Virtual Machine Specification Second Edition and the Java Language
Specification, as amended to reflect Java 1.1 and corrected.  [Warning --
this is going to take quite a while, so bear with me.]

	Section 5.3.1 of the JVM/2 spec:

First, the Java virtual machine determines whether the bootstrap class
loader has already been recorded as an initiating loader of a class or
denoted by N. If so, this class or interface is C, and no class creation
is necessary. 

Otherwise, the Java virtual machine performs one of the following two
operations in order to load C:

1.The Java virtual machine searches for a purported representation of C in
a platform-dependent manner.
...
2.The bootstrap class loader can delegate the loading of C to some
user-defined class loader L by passing N to an invocation of a loadClass 
method on L.

	That is, nothing ever loaded into the bootstrap (==primordial)
classloader can be replaced by the JVM.  Once a user-defined classloader
is loaded, the JVM, at its discretion, may ask that classloader to find a
class for it.  Similarly, in 5.3.2:

The following steps are used to load and thereby create the nonarray class
or interface C denoted by N using a user-defined class loader L. 

First, the Java virtual machine determines whether L has already been
recorded as an initiating loader of a class or interface denoted by N. If
so, this class or interface is C, and no class creation is necessary.

	That is, the JVM checks /its own/ cache to see if this classloader
at any time ever handled a sucessful request for the requested class, and
if so, uses the class returned by that request.  Section 12.2 of the JLS
makes this clear:

A Java Virtual Machine system should maintain an internal table of classes
and interfaces that have been loaded for the sake of resolving symbolic
references. Each entry in the table should consist of a fully qualified
class name (as a string), a class loader, and a Class object. Whenever a
symbolic reference to a class or interface is to be resolved, a class
loader is identified that is responsible for loading the class or
interface, if necessary. The table should be consulted first, however; if
it already contains an entry for that class name and class loader, then
the class object in that entry should be used and no method of the class
loader should be invoked. If the table contains no such entry, then the
method loadClass (20.14.2) of the class loader should be invoked, giving
it the name of the class or interface. If and when it returns, the class
object that it returns should be used to make a new entry in the table for
that class name and class loader.

	Section 5.3.4 of the JVM spec explicitly states that no two
classloaders may attempt to define the same class differently: "It is
essential that any type name N mentioned in the field or method descriptor
denote the same class or interface when loaded by L1 and when loaded by
L2."

	From section 5.2:

The Java virtual machine starts up by creating an initial class, which is
specified in an implementation-dependent manner, using the bootstrap class
loader (5.3.1). The Java virtual machine then links the initial class,
initializes it, and invokes its public class method void main(String[]).
The invocation of this method drives all further execution. Execution of
the Java virtual machine instructions constituting the main method may
cause linking (and consequently creation) of additional classes and
interfaces, as well as invocation of additional methods.

In some implementations of the Java virtual machine the initial class
could be provided as a command line argument, as in JDK releases 1.0 and
1.1. Alternatively, the initial class could be provided by the
implementation. In this case the initial class might set up a class loader
that would in turn load an application, as in the Java 2 SDK, Standard
Edition, v1.2. Other choices of the initial class are possible so long as
they are consistent with the specification given in the previous
paragraph.


	The conclusion is that no legal java program may alter the classes
loaded in order to link and initialize the initial class -- e.g. 'init' --
or any classes loaded in order to link and initialize whatever classloader
the program may then define, or, once and supposing that custom
classloader has and maintains full control over loading classes, any
classes it defines in response to loadClass() calls, whether from the JVM
or from Java code.  It is necessary -- and explained in great detail in
"Dynamic Class Loading in the Java Virtual Machine" by Sheng
Liang and Gilad Bracha (Proceedings of the 1998 ACM SIGPLAN Conference on
Object-Oriented Programming Systems, Languages and Applications) -- that
once a class is defined, it is defined "forever".  It is, a matter of
fact, not only sufficient for classloaders to be disjoint for a pair of
Java threads to be different processes, Java threads with disjoing
classloaders are /required/ to be in different processes!

	The issue of type-safety (and correctness!) /requires/ that
processes which wish to share Java objects either via direct references or
via the Serializable interface share class definitions for the shared
objects' classes /and every class referenced in its resolution/.  This is
where you begin to want finer control over what classes your child process
starts with in its classloader.  In general, there will be a subset of
classes whose proper functioning /requires/ that the JVM rewrite their
classloader (e.g. System.in/out/err; though this can be done by cloning
and calling setIn/Out/Err, it amounts to the same thing) caches.  Except
for these, the default ought to be to share everything else, with the
application specifically mentioning the exceptions -- e.g. classes it
loaded which have statics.


	To summarize again -- and I know I'm dragging on here, but I
wanted to be as explicit as possible here -- multiple java processes, to
my understanding, requires native support, because you can't redefine an
already-loaded class, which is necessary for the simulation of an
independent virtual machine.  The concept -- (partially) disjoint class
loaders -- is simple and elegant, but the implementation, because of the
requirements for compatibility and type-safety, is not.






From ryan@whitewolf.com.au Sun, 9 Apr 2000 02:19:49 +1000 (EST)
Date: Sun, 9 Apr 2000 02:19:49 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

On Sat, 8 Apr 2000, Todd L. Miller wrote:

> PS -- I looked at the code for jshell, and it doesn't do redirects for
> programs invoked with main(String[]) -- which is the prime example we've
> been talking about w.r.t. rewriting statics.  I checked and can no longer
> find Echnida/Enchida on the web anywhere -- anyone have a URL?

	http://www.javagroup.org/echidna/

I think they do something with statics, but I don't remember for sure.

> 	Section 5.3.4 of the JVM spec explicitly states that no two
> classloaders may attempt to define the same class differently: "It is
> essential that any type name N mentioned in the field or method descriptor
> denote the same class or interface when loaded by L1 and when loaded by
> L2."

Only if, for example, class A (L1) tries to pass a variable of type N
into a method of class B (L2) - anything where N is mentioned in the
field or method descriptor. If it is not, then it is quite possible for
two classloaders to define the same class differently.

Actually, the terminology is a bit tricky here. What I mean is, it is
possible to define two classes of the same type differently in two
different classloaders on the condition described above. And to modify
your original statement, no two classloaders may attempt to define the
same class at all (I should think).

> 	The issue of type-safety (and correctness!) /requires/ that
> processes which wish to share Java objects either via direct references or
> via the Serializable interface share class definitions for the shared
> objects' classes /and every class referenced in its resolution/.

Ideally, you want to limit access to another process's objects to "as
much as is required and no more". This could be a matter of programming
style. When message passing between processes, the arguments and return
values can be of simple Classes intended only to carry data.

>  This is
> where you begin to want finer control over what classes your child process
> starts with in its classloader.  In general, there will be a subset of
> classes whose proper functioning /requires/ that the JVM rewrite their
> classloader (e.g. System.in/out/err; though this can be done by cloning
> and calling setIn/Out/Err, it amounts to the same thing) caches.  Except
> for these, the default ought to be to share everything else, with the
> application specifically mentioning the exceptions -- e.g. classes it
> loaded which have statics.

Hmm, I see your goal is to minimise memory consumption, but this sounds
like a security risk. If an application must specifically mention which
classes should be protected, that leaves existing Java applications open
to security holes. Ignoring memory for the moment, it seems to me that
the default should be to share nothing apart from what is explicitly
requested.

As for memory saving, a solution might be:

- share classes which are loaded from the same version of the same
  archive
- always maintain separate statics for different classloaders

Note that we will effectively have a primordial classloader for every
process, each under the control of the JVM. Since nearly every class
will be loaded by one of these classloaders, the JVM can check if they
are coming from the same archive.

When might they come from different archives? If you change your
CLASSPATH in a particular shell. If you are a programmer, you will
likely have many different versions of the same class on your system and
you would like to be able to run each one, potentially all at the same
time. The JVM can't just assume that it can share the same
implementation of the class among each process.

Just as well the JVM allows you to define the same class differently in
different classloaders! (see my clarification of section 5.3.4 of the
JVM spec, above)

(Note, I hope I'm not way out of context since I entered this thread
late :-)

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/




From tmiller@haverford.edu Sat, 8 Apr 2000 15:25:22 -0400 (EDT)
Date: Sat, 8 Apr 2000 15:25:22 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> I think they do something with statics, but I don't remember for sure.

	Yes, Echidna creates wrapper classes for the System.in/out/err
statics and threads that both register with a namespace manager, so that
the wrapped in/out/err classes read/write to a stream specified by their
namespace.  I didn't find anything relating to rewriting statics in
general.  Reloading of classes is accomplished by associating a specific
classloader with each 'process' and garbage collecting it on process
termination, so that the JVM unloads that classloader's classes.

> Only if, for example, class A (L1) tries to pass a variable of type N
> into a method of class B (L2) - anything where N is mentioned in the
> field or method descriptor. If it is not, then it is quite possible for
> two classloaders to define the same class differently.

	Re-reading the spec, it does in fact always indicate that classes
are defined by the union of their classloaders and name, and must in fact
be considered loaded or not only on the basis of both the ClassLoader used
and the name.  (When a class is explicitly loaded through a classloader,
every operation on that class must go through that classloader, from
section 5.3 in the spec.)  It is clear that the situation you described is
the situation in which an error must be thrown, and in fact this is
described as a loading constraint in the section on field resolution.  
(That is, the type of a field as defined by its name and its class's
classloader must be the same of the type name of the reference and the
referrer's classloader.)  Likewise for parameter types in a method
invocation.

	My apologies; in summary, classloaders do define independent
namespaces.

	Considering memory issues: Echidna takes the position that the
reason for Java processes is to eliminate the need to load every
(necessary) class in the library each time you start a new Java
program.  Since I so badly misread the spec regarding classloaders before,
I decided to determine how independent the classloader's namespaces were
experimentally -- as this bears on how much work the JVM has to do to
support processes, and how much /must/ be shared.  Writing a custom
classloader, it looks like /nothing/ is shared by default, and it's the
responsibility of the classloader to be efficient by using
findSystemClass() if it so desires.

	This agrees with my interpretation of the spec, that the JVM
checks its tables for a classname/classloader /pair/ before deciding if a
classloader gets a chance to load classname; if the classloader is new,
one would expect it not to have any entries at all in the table.

	This would suggest that Echidna doesn't actually need to wrap
java.lang.System.  In fact, it would suggest the following code in its
custom classloaders would be sufficient:

if ( className == "java.lang.System" ) {
	/* fetch java.lang.System from the filesystem... */

	Class c = defineClass( className, buffer, 0, buffer.length );

	/* shorthand */
	Method setIn = c.getMethod( setIn, { java.io.InputStream } );
	setIn.invoke( null, { theInputStreamAsRedirectedByTheShell } );

	/* repeat for setOut, setErr... */

	return c;
	}

	and would allow redirection of /any/ java application.

	Generically, one's custom classloader would never call
findSystemClass(), instead always defining those classes by itself, so
that they get new statics.  Efficiency improvements would require native
support, something like setClassLoader( Class c ), so that the class
loader could use system class definitions (e.g. JavaClass) and have an
independent Class object (e.g. JavaClassInstance), where setClassLoader
would set the class loader and redirect the static fields pointer*.

	If one unzipped the class library**, it should be relatively easy
to write a proof-of-concept shell/classloader combination that could
handle redirecting normal main()-method java applications.  (It would need
a pair of classes like OutputToInputStream and InputToOutputStream.)  
Create a new classloader for each process, get, from that classloader, a
Class of java.lang.System, set its in/out/err streams as appropriate; also
from that classloader, fetch your run-a-main-method Thread subclass,
instantiate it, and run it.  Because it lives in the same classloader as
the System class you've defined (and, of course, the classloader instance
caches its classes), it will use the System class you've defined.  If
people feel is worthwhile, I'll give it a shot.

> Ideally, you want to limit access to another process's objects to "as
> much as is required and no more". This could be a matter of programming
> style. When message passing between processes, the arguments and return
> values can be of simple Classes intended only to carry data.

	True.  The question then becomes whether or not we want to forbid
direct object sharing or not; and to do so, I think, would be extremely
unfortunate.  Direct object sharing is like CORBA, except more so, and KDE
and GNOME are putting CORBA to work for them in good and interesting
ways...

> (Note, I hope I'm not way out of context since I entered this thread
> late :-)

	No, not at all.  You're quite right to correct me when I'm so
dangerously wrong.  Thank you.

-_Quinn

* As it stands, the primordial classloader returns JavaClassInstances,
which have pointers to ClassFields in them.  There's no reason to expect
that the JCI generated by a custom classloader would have the same
ClassFields pointer, unless it's returning a java.lang.Class it got from
findSystemClass, which is the case I'm discussing.

** So that you don't have to mucking about in .zip/.jar files, just
subsitute '.' in names with '/'.




From ryan@whitewolf.com.au Sun, 9 Apr 2000 21:24:52 +1000 (EST)
Date: Sun, 9 Apr 2000 21:24:52 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

On Sat, 8 Apr 2000, Todd L. Miller wrote:

> 	Considering memory issues: Echidna takes the position that the
> reason for Java processes is to eliminate the need to load every
> (necessary) class in the library each time you start a new Java
> program.  Since I so badly misread the spec regarding classloaders before,
> I decided to determine how independent the classloader's namespaces were
> experimentally -- as this bears on how much work the JVM has to do to
> support processes, and how much /must/ be shared.  Writing a custom
> classloader, it looks like /nothing/ is shared by default, and it's the
> responsibility of the classloader to be efficient by using
> findSystemClass() if it so desires.

findSystemClass() isn't just called to save memory. You *must* call
findSystemClass() on all the linked classes which are to be referenced
by the calling code.

For example, suppose you are loading an applet across a network:

Class appletClass = appletClassLoader.loadClass(className, true);
Applet applet = (Applet)appletClass.newInstance();

When the classloader attempts to define class 'className', it will
attempt to resolve the link to its supperclass Applet. Here, you *must*
load the Applet class using findSystemClass() to ensure that the calling
code is dealing with the same Applet class. If you do not, the next line
will fail. You cannot cast the return value of newInstance() from
Applet(L2) to Applet(L1). You must ensure that Applet in each case is
the *same* class.

Note that there is no second line in Echidna as there is in the above
example. It uses reflection to invoke the main method directly on the
class. This means the two namespaces can be more independent, but the
String array argument means that the String class must be in common (and
all the classes it references, including Object). Also, any exceptions
which the main() method might throw need to be cast to a known type for
the caller to catch. So, at least Throwable needs to be in common, too.

Also, when you consider that it is a security risk to allow user defined
classes to invoke native system methods (eg. you could bypass the
sandbox), various system classes (eg. System) must always be loaded by
the(/a) primordial class loader in order to make use of their native
methods. Of course, in JOS we might have an effective primordial class
loader for each process, so it's ok to reload the System class in each
primordial (JOS-controlled) classloader.

Ideally, separate namespaces should be completely separate, apart from
the classes we *want* to share. Would it be possible to provide a native
method to invoke a program in a new process without requiring any
classes to be in common? It seems that all it needs to do is convert
the String array argument from String(L1) to String(L2). This would seem
safe given that L1 and L2 are primordial class loaders for process 1 and
process 2, and String is a system class.

Now that each process has its own version of EVERY class, we can
consider some memory optimisations. The approach outlined in my last
email might work.

One final thought: if namespaces should be completely separate except
for the classes we *want* to share, then we should consider how we are
going to share those classes. I don't particularly like the method we've
discussed so far because as soon as you share one class, it starts
dragging in everything else with it. Maybe it's possible to convert
SomeClass(L1) to SomeClass(L2) in the same way as I described above for
invoking the main method in a new process. You just need to ensure that
SomeClass(L1) and SomeClass(L2) can be treated as the same class (eg.
check that they were loaded from the same file). I'm not sure whether
"convert" is the right word here. I'd like to "treat" SomeClass(L1) as
SomeClass(L2), sort of like an illegal cast that is approved by the JVM.

> 	This would suggest that Echidna doesn't actually need to wrap
> java.lang.System.  In fact, it would suggest the following code in its
> custom classloaders would be sufficient:
> 
> if ( className == "java.lang.System" ) {
> 	/* fetch java.lang.System from the filesystem... */

I suspect this won't work (see above) - at least not in a normal JVM.

> > Ideally, you want to limit access to another process's objects to "as
> > much as is required and no more". This could be a matter of programming
> > style. When message passing between processes, the arguments and return
> > values can be of simple Classes intended only to carry data.
> 
> 	True.  The question then becomes whether or not we want to forbid
> direct object sharing or not; and to do so, I think, would be extremely
> unfortunate.  Direct object sharing is like CORBA, except more so, and KDE
> and GNOME are putting CORBA to work for them in good and interesting
> ways...

Yes, it is definately useful. I hope the "approved illegal casts" idea
is a way to solve this.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/




From tmiller@haverford.edu Sun, 9 Apr 2000 12:36:25 -0400 (EDT)
Date: Sun, 9 Apr 2000 12:36:25 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> findSystemClass() isn't just called to save memory. You *must* call
> findSystemClass() on all the linked classes which are to be referenced
> by the calling code.

	If they were referenced by the calling code /before/ the call to
the classloader, they've already been loaded; otherwise, this is the first
time they've been loaded for the calling code, and whatever you define it
as is 'right' -- although, as in your applet example, useless.

> You cannot cast the return value of newInstance() from
> Applet(L2) to Applet(L1). You must ensure that Applet in each case is
> the *same* class.

	Until that Applet(L2) is passed to a method (or assigned to a
field) that knows about Applet(L1), we're good.  It is not required, to my
understanding, that a classloader be /useful/.

	A native extension that would both allow efficient 'illegal' casts
and efficient memory usage would be, then, an assignClassLoader( Class c,
ClassLoader cl) method.  The JOS default custom classloader could use
findSystemClass to locate the (shared) class definition, and the
assignClassLoader() method to 'clone' it, marking it as a separate class
(and generating its independent statics) but flagging it as identical to
the system class for the 'illegal' casts.

> Also, when you consider that it is a security risk to allow user defined
> classes to invoke native system methods (eg. you could bypass the
> sandbox), various system classes (eg. System) must always be loaded by
> the(/a) primordial class loader in order to make use of their native
> methods. Of course, in JOS we might have an effective primordial class
> loader for each process, so it's ok to reload the System class in each
> primordial (JOS-controlled) classloader.

	Right.  Classes which, for whatever reason, the Java code is
prevented from reloading must be reloaded by the native code; and it /is/
a good idea to restrict access to certain (specified) members of the (JOS)
class library.  (This would probably be better cast as a security issues
-- e.g. only code with an effective uid of root can call (native) method
N, but security is a while off...)

> Ideally, separate namespaces should be completely separate, apart from
> the classes we *want* to share. Would it be possible to provide a native
> method to invoke a program in a new process without requiring any
> classes to be in common? It seems that all it needs to do is convert
> the String array argument from String(L1) to String(L2). This would seem
> safe given that L1 and L2 are primordial class loaders for process 1 and
> process 2, and String is a system class.

	Yes.  (Of course, it would need a separate Object, as well.)

> I suspect this won't work (see above) - at least not in a normal JVM.

	The empirical test I described in the last email generated a log
of loaded class that included java.lang.System; whether or not I can
redefine it for long enough to be useful is another question entirely...

> Yes, it is definately useful. I hope the "approved illegal casts" idea
> is a way to solve this.

	I think it could be; implementation is an issue, but it always
is. See my above assignClassLoader() idea for a way of doing this and
saving memory at the same time.

	BTW, thanks for the smart feedback.

-_Quinn




From Alexis Petrounias Sun, 09 Apr 2000 09:40:06 +0300
Date: Sun, 09 Apr 2000 09:40:06 +0300
From: Al Alexis Petrounias
Subject: [JOS-Arch] JSDK 2

I was reviewing the Java SDK2 1.3.0 (rc2) package "java.lang" source and
found the Shutdown package-private class. It basically handles all hooks
and is responsible for JVM termination. The only thing not done in Java
is a native method called "halt(int status)". It has a very nice way of
handling all finalization, closing all things that have to be closed,
etc.

The JavaDoc for its class says it's been here since JSDK 1.3, so I
guessed it would be useful to mention it in these mailing lists.

Are we interested, in JOS, to support any parts of SDK 2? Since this
part of the SDK is licensed with source code, there would not be any
legal considerations in adding them to JOS... Also, other nifty features
include the StrictMath class and the "strictfp" attribute of the class
file for Math, the BitSieve, etc.

What do you think?


-- 

      "Learn from others' mistakes, for you won't live long
          enough to make them all yourself..."
________________________________________________________________________
[EMAIL: reference:AlexisPetrounias] [URL: http://www.outworld.org/people/al]
[TEL1: (30) +31 422392] [TEL2: (30) +31 428154] [CELL: (30) +937 110247]
[ADDRESS: 14 Argonafton St., Kalamaria, 551 31, Thessaloniki, Greece GR]
PLEASE DO NOT SEND ME ANY UNSOLICITED COMMERCIAL EMAIL [DSS: 0xDBEF8ECC]




From tmiller@haverford.edu Sun, 9 Apr 2000 17:24:21 -0400 (EDT)
Date: Sun, 9 Apr 2000 17:24:21 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] JSDK 2

	Right now I'm concentrating on jdk1.1 support; as far as using
Sun's code, I'll have to take a look at their liscense, which I haven't
yet.  Primarily, I want other (open source) projects to maintain the class
libraries for us.  We'll see; I don't have any objections off-hand,
though.

-_Quinn




From ryan@whitewolf.com.au Mon, 10 Apr 2000 11:56:22 +1000
Date: Mon, 10 Apr 2000 11:56:22 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

"Todd L. Miller" wrote:
> 
> > findSystemClass() isn't just called to save memory. You *must* call
> > findSystemClass() on all the linked classes which are to be referenced
> > by the calling code.
> 
>         If they were referenced by the calling code /before/ the call to
> the classloader, they've already been loaded;

Well, they've already been defined. You must initiate the loading of the
class again in L2, but defer its definition to L1 using
findSystemClass(), which will just return its cached version if it is
already defined.

> otherwise, this is the first
> time they've been loaded for the calling code, and whatever you define it
> as is 'right' -- although, as in your applet example, useless.

Not completely useless. Echidna manages to do something with the loaded
class without ever having to cast it to a known type by using
reflection. However, in the case of achieving RMI/CORBA-type usefulness,
you want to be able to cast the object (potentially illegally :-)

> > You cannot cast the return value of newInstance() from
> > Applet(L2) to Applet(L1). You must ensure that Applet in each case is
> > the *same* class.
> 
>         Until that Applet(L2) is passed to a method (or assigned to a
> field) that knows about Applet(L1), we're good.  It is not required, to my
> understanding, that a classloader be /useful/.

Actually, newInstance() on the Applet(L2) class will still fail unless
Object(L2) == Object(L1), since newInstance() returns an Object. But if
you are only loading a class to invoke a static method on it (eg.
main()), you don't need to call newInstance() - as in Echinda. However,
to pass the arguments in to main() and catch its exceptions, you will
need to have Object in common (as well as other classes). Looks like
illegal casts are necessary to support completely independent
namespaces.

>         A native extension that would both allow efficient 'illegal' casts
> and efficient memory usage would be, then, an assignClassLoader( Class c,
> ClassLoader cl) method.  The JOS default custom classloader could use
> findSystemClass to locate the (shared) class definition, and the
> assignClassLoader() method to 'clone' it, marking it as a separate class
> (and generating its independent statics) but flagging it as identical to
> the system class for the 'illegal' casts.

Now, if the client process directly accesses static members, it will
access the cloned versions that belong to its own process. However, if
you call a method on an object that really belongs to another process,
and that method accesses a static member, then it should access the
static members of the class in the _other_process. Are there any
problems in implementing that?

There is a subtle problem with the findSystemClass/assignClassLoader
approach, though.

Let's first define what findSystemClass() does in the context of JOS. I
personally prefer findSystemClass() to refer to the primordial class
loader of the current process. But let's look at your model:

Using findSystemClass() to locate the shared class definition implies
that it is referring to a class loader that is an ancestor of the two
processes wishing to share, something like the root class loader. As you
said before, once a class loader loads a class, it is loaded forever.
That is, once the root class loader has loaded the shared class, it is
impossible to install and run a new version of your IPC-enabled program
because it will continually link to an old and potentially unusable
version of the shared class.

A modification of your idea can still work though. findSystemClass() is
one way to defer the definition of a class to another class loader. I
could imagine a server process that corresponds to an ORB (Object
Request Broker), and a findSharedClass(domain, class) method that defers
loading to the ORB's class loader for the specified domain*. Once
loaded, the class still cannot be redefined in that class loader, but
you can then call orb.reload(domain) which will cause the ORB to replace
its class loader for your particular domain.

A note on efficient memory usage, assignClassLoader() doesn't seem to be
a general solution to memory efficiency. It does save memory for classes
which are being shared between two processes, but does nothing for the
rest of the classes loaded in a process. To save memory on these
classes, you could try the approach I outlined in an earlier email
(share class definitions that are loaded from the same version of the
same archive, but keep separate areas for static fields).

In summary, it seems the assignClassLoader() approach will work, if it
is used in the right way.

{*} domains would correspond to the individual uses of IpC. For example,
you could define a domain for doing IPC between the window manager and
processes that wish to draw to a window.

> > Also, when you consider that it is a security risk to allow user defined
> > classes to invoke native system methods (eg. you could bypass the
> > sandbox), various system classes (eg. System) must always be loaded by
> > the(/a) primordial class loader in order to make use of their native
> > methods. Of course, in JOS we might have an effective primordial class
> > loader for each process, so it's ok to reload the System class in each
> > primordial (JOS-controlled) classloader.
> 
>         Right.  Classes which, for whatever reason, the Java code is
> prevented from reloading must be reloaded by the native code; and it /is/
> a good idea to restrict access to certain (specified) members of the (JOS)
> class library.  (This would probably be better cast as a security issues
> -- e.g. only code with an effective uid of root can call (native) method
> N, but security is a while off...)

I wrote a document on security within JOS about a year ago, but I didn't
receive much feedback. It presents some ideas which are relevant here
(eg. setting the effective user id):

	http://www.progsoc.uts.edu.au/~rheise/jos/jos-security.html


> > I suspect this won't work (see above) - at least not in a normal JVM.
> 
>         The empirical test I described in the last email generated a log
> of loaded class that included java.lang.System; whether or not I can
> redefine it for long enough to be useful is another question entirely...

Not in a normal JVM. In JOS, we will want to redefine all classes, and
then be able to make use of them through native support.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From tmiller@haverford.edu Sun, 9 Apr 2000 23:36:36 -0400 (EDT)
Date: Sun, 9 Apr 2000 23:36:36 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

	Is this an accurate summary?

	We agree then -- for Java processes, we need native support to
handle 'illegal' class casts; I proposed a mechanism where only class
definitions that are explicitly shared -- quite possibly by default -- are
considered the same for 'illegal' casts, because byte-for-byte checks are
grossly expensive.  For effiency, we need a mechanism to share class
definitions while maintaining disjoint statics.  These two mechanisms
could be one, where explicitly shared classes share class definitions but
have disjoint statics*, and the default for sharing classes between a
process and its parent will be generous, with separate classloaders, for
maxixum interoperability and utility.  That is, you can allow application
classes to re-load on the fly by garbage collecting that process's
ClassLoader on exit, and if the two processes communicate with Java
objects -- e.g. via Serializable objects and a standard networking layer
-- the classes for the objects will cast to each other.

-_Quinn

* The decaf JVM has explicit support for this.  JavaClass -- the class
definition as derived from its classfile -- is not JavaClassInstance,
which is a JavaClass and a pointer to its static fields (and some other,
irrelevant, things).  (And no, it's not currently coded that a JCI points
to a JC rather than inheriting from it, but that shouldn't be too hard to
put in once I'm sure decaf works -- move the code and data in JC down to a
JC implementation.)




From gchii@mindspring.com Sat, 08 Apr 2000 11:42:49 -0400
Date: Sat, 08 Apr 2000 11:42:49 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

At 01:02 AM 4/8/00 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> 1. It needs no native calls.
>
>	Well, Runtime.exec() does, but I do see your point.  A
>JOS-specific way would allow finer-grained control, so it would be worth
>doing.

With a custom implementation of java.lang.Runtime and a simple shell,
jJOS/decaf could enable us to type in an arbitrary class name to run a
class as a process.

Most virtual machines run on top of a foreign operating system. That's why
it is popular to implement the Runtime.exec() method as a native method.

JOS is not like most virtual machines. The Java Virtual Machine
specification does not require exec() to be native. It only requires exec()
to be defined with a compatible signature. All four of these signatures
would be acceptable:

public java.lang.Process exec( String[] cmd, String[] env );
public synchronized java.lang.Process exec( String[] cmd, String[] env );
public native java.lang.Process exec( String[] cmd, String[] env );
public native synchronized java.lang.Process exec( String[] cmd, String[]
env );

JavaDoc pages give programmers the wrong impression. It is defective when
it incorporates the native attribute in documentation of an API.




From ryan@whitewolf.com.au Tue, 11 Apr 2000 00:28:42 +1000 (EST)
Date: Tue, 11 Apr 2000 00:28:42 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

On Sun, 9 Apr 2000, Todd L. Miller wrote:

> 	Is this an accurate summary?
> 
> 	We agree then -- for Java processes, we need native support to
> handle 'illegal' class casts; I proposed a mechanism where only class
> definitions that are explicitly shared -- quite possibly by default -- are
> considered the same for 'illegal' casts, because byte-for-byte checks are
> grossly expensive.

We agree so far, except I'm not sure what you mean by the "quite
possibly by default" bit. Do you mean it is quite possible to share all
class definitions by default, or that it is quite possible to consider
all objects for illegal casts by default?

A note: byte-for-byte checking is not the only alternative. If we
implement my proposal for memory saving, classes that were loaded from
the same version of the same archive will reuse the same class
definition even though they are different JavaClassInstances. Any two
classes that share the same class definition (JavaClass) are able to be
explicitly shared. Then permission can be asked of the JVM to allow
casts between certain pairs of JavaClassInstances.

While this seems more consistent to me, assignClassLoader() seems like
it will work too.

>  For effiency, we need a mechanism to share class
> definitions while maintaining disjoint statics.  These two mechanisms
> could be one, where explicitly shared classes share class definitions but
> have disjoint statics*,

Agreed.

> and the default for sharing classes between a
> process and its parent will be generous, with separate classloaders, for
> maxixum interoperability and utility.  That is, you can allow application
> classes to re-load on the fly by garbage collecting that process's
> ClassLoader on exit, and if the two processes communicate with Java
> objects -- e.g. via Serializable objects and a standard networking layer
> -- the classes for the objects will cast to each other.

I'm not sure I understand this paragraph. I think we've gotten to the
point where one word can mean so many things :-)

Q1:

When you refer to sharing classes between a process and its parent, do
you mean just sharing class definitions to save memory, or explicit
sharing to allow casts? I don't think we should be generous in allowing
casts between processes.. oh, hang on...

U-Turn

What we /could/ do is allow casts between any two classes that share
the same class definition (JavaClass). No restrictions. This is safe
because the power to cast is useless unless you have a reference to an
object that you want to cast. The restriction should be on gaining
access to the shared object.

In my last email, I mentioned that an object that belongs to another
process should be able to access it's own static fields, but the client
code should not. It will instead access the static fields of its own
process. This makes the no restrictions approach safe from the statics
perspective as well.

Q2: What is the significance of sharing classes between a process and
its parent? I think you should be able to share classes with any other
process. And if all classes loaded from the same version of the same
archive share the same class definition, then this becomes possible (if
you allow casting between any two classes that share the same class
definition, as described above).

Q3: Can you please explain the bit about an application reloading its
classes?

In summary, we still disagree on a few points:

- I don't see the logic in only inheriting class definitions from the
  parent process.
- I prefer a more consistent (IMHO) approach to reusing class
  definitions.

But we at least agree on the general idea. Sorry for dragging this on -
just when you thought we agreed! 

Whatever we do, sharing class definitions seems crucial. Just as well we
have the split between JavaClass and JavaClassInstance!

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/




From gchii@mindspring.com Mon, 10 Apr 2000 10:26:45 -0400
Date: Mon, 10 Apr 2000 10:26:45 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Saving memory

The java.lang.String class has an intern() method. An intern() method is
useful when (1) an object is used frequently, and (2) an object is
immutable. Any instance of String can be exchanged for a virtual
machine-wide instance of an equivalent String. The original String is
garbage collected.

There is no corresponding intern() method for a byte array because a byte
array is mutable, not immutable.

It is possible to save lots of memory by intern'ing every immutable byte
array that holds bytecode. When a custom class loader invokes the
defineClass() method, an efficient virtual machine would intern the byte
array *before* creating an instance of java.lang.Class.

1. Such a mechanism would work across the board. It doesn't matter if a
class came from two different archives from two different servers. If the
raw byte array is identical, it's identical. Only one instance of the byte
array is required.

2. The classic design of a virtual machine modifies bytecode at runtime.
The classic design cannot intern bytecode because it insists on changing
the bytecode as a program is running.

Looking up an existing byte array of bytecode is not as difficult as it
might seem. Every byte array has a corresponding class name. If the class
name is used properly to build a hash key, all bytecode for different
implementations of a class would be stored together.

Once you work past the idea of intern'd bytecode, it is easy to see that
100 or 100,000 copies of a class would take up the same amount of space for
the original bytecode. The space required by static fields would depend on
how many times a class has been defined.




From gchii@mindspring.com Mon, 10 Apr 2000 10:38:18 -0400
Date: Mon, 10 Apr 2000 10:38:18 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Change the sequence

A classic virtual machine always uses a primordial class loader to load
java.lang.Object, java.lang.Class, java.lang.Runtime, java.lang.System.
This is a design choice. It is not required by the Java Virtual Machine
specification.

In theory, it is possible to *always* use a custom class loader. In other
words, you can create a virtual machine where no getClassLoader() method
returns null. By changing the sequence a little as a virtual machine is
created, even java.lang.Object.getClass().getClassLoader() can return an
instance of java.lang.ClassLoader.

How is this possible?

A virtual machine defines java.lang.Object, java.lang.Class and all other
classes in the usual way. Their ClassLoader property is temporarily null.
And then, it visits each class that has already been created to plug in an
instance of java.lang.ClassLoader. In other words, a virtual machine does
not have to leave the ClassLoader property null.

These classes are primordial classes. Then, they are converted to custom
classes. By changing the ClassLoader property for all of those classes,
they become custom classes.

Does ClassLoader need java.lang.System? java.lang.Runtime? I don't think
so. After an instance of ClassLoader is created, a virtual machine can fix
up its class loader property. A class loader can look like it loaded itself.




From gchii@mindspring.com Mon, 10 Apr 2000 11:00:15 -0400
Date: Mon, 10 Apr 2000 11:00:15 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

At 02:19 AM 4/9/00 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>As for memory saving, a solution might be:
>
>- share classes which are loaded from the same version of the same
>  archive

I don't like this solution for two reasons.

1. Two custom class loaders can read the same version of the same archive.
They will produce different types. Each custom class loader would have to
communicate with all others.

2. Two different archives can store the same class file. Even if a class
file comes from two different archives, an optimized virtual machine should
keep one instance.

A generic change to java.lang.ClassLoader would seemlessly enable all
virtual machines to benefit a little from optimizing the space required by
bytecode. Inside java.lang.ClassLoader, there should be a hashtable of
bytecode. The defineClass() method could be re-written, something like this:

  public Class defineClass( byte[] buf ) {
    ReadOnlyByteArray bufx = intern( buf );
    return defineClass0( bufx );
  }
  private ReadOnlyByteArray bufx intern( byte[] buf ) {
    Bytecode bc = new BasicBytecode( buf );
    String cs = bc.getThisClassSpec();
    ReadOnlyByteArray bufx = cache.get( cs );
    if ( bufx == null ) {
      bufx = new ReadOnlyByteArray( buf );
      cache.put( cs );
    }
    return bufx;
  }
  private Hashtable cache = new Hashtable();

When building your own virtual machine, the cache and read-only byte array
could be part of a native defineClass() method.

>Note that we will effectively have a primordial classloader for every
>process, each under the control of the JVM. Since nearly every class
>will be loaded by one of these classloaders, the JVM can check if they
>are coming from the same archive.

The JVM cannot easily check if a class is coming from the same archive.
Most of the problem comes from an archive with two or more "names". On my
computer, each of these names refer to copies of one archive.

  ~/eric/org.jos.gchii.eric1c.jar
  /home/Gilbert/eric/org.jos.gchii.eric1c.jar
  C:\BORLAND\lib\org.jos.gchii.eric1c.jar
  M:\eric1b-4\org.jos.gchii.eric1c.jar
  M:\eric1b-4\limited\org.jos.gchii.eric1c.jar
  V:\eric1b\org.jos.gchii.eric1c.jar

Remember, the puzzle is not to identify unique archives, but unique content
of class files.

>- always maintain separate statics for different classloaders

It is an option, not a requirement. The Java Virtual Machine specification
does not require separate statics for different class loaders. It
rightfully puts the decision in the hands of the custom class loader. A
virtual machine must support the option of separate statics for each
instance of a custom class loader.




From gchii@mindspring.com Mon, 10 Apr 2000 11:19:17 -0400
Date: Mon, 10 Apr 2000 11:19:17 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

At 03:25 PM 4/8/00 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	Considering memory issues: Echidna takes the position that the
>reason for Java processes is to eliminate the need to load every
>(necessary) class in the library each time you start a new Java
>program.

Let's consider two scenarios. If bytecode has not changed at all, a virtual
machine should not end up with two or more copies of the bytecode in
memory. This is possible by intern'ing all bytecode.

A application needs to have a fresh set of static fields each time it is
loaded. There is no way around that. A custom class loader must re-load
class files from disk every time the application is started -- just in case
the bytecode has changed. When the CLASSPATH is changed in the creation of
a child process, the child process must use its CLASSPATH to load bytecode.
It must re-load class files every time the application is started -- just
in case the bytecode has changed.

When an application is downloaded across the network, a custom class loader
must download class files every time the application is started -- just in
case the bytecode has changed. If there is a HTTP cache between the custom
class loader and the network service, the HTTP cache quickly determines if
the class file has changed.

The bytecode cache could be persistent, too. When the virtual machine is
started, it should pre-cache (intern) all bytecode that has been recently
used.

>Writing a custom classloader, it looks like /nothing/ is shared by default,
>and it's the responsibility of the classloader to be efficient by using
>findSystemClass() if it so desires.

Is this true of all virtual machines?

Does a virtual machine invoke loadClass() for all classes, even those
loaded by the primordial class loader?

An optimized virtual machine might not invoke the loadClass() method for
classes that have already been loaded by the primordial class loader.
Otherwise, I think you're right.

Certainly, a virtual machine can always create a custom class loader to
load the classes from java.applet, java.awt, java.sql, etc. A primordial
class loader should be an actual Java class. As long as semantics are
preserved, it is not necessary to store all class files in one big archive.
As long as security is preserved, it is not necessary to load all classes
in the java.* packages with a primordial class loader.




From tmiller@haverford.edu Mon, 10 Apr 2000 13:50:52 -0400 (EDT)
Date: Mon, 10 Apr 2000 13:50:52 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> We agree so far, except I'm not sure what you mean by the "quite
> possibly by default" bit. Do you mean it is quite possible to share all
> class definitions by default, or that it is quite possible to consider
> all objects for illegal casts by default?

	We /have/ to consider all objects for illegal casts by default for
this to work transparently.  Whether or not all class definitions are
shared by default is a design decision -- I was suggesting we should,
because it's the most efficient, and applications which want to do tricks
with classloaders won't be affected.

> A note: byte-for-byte checking is not the only alternative. If we
> implement my proposal for memory saving, classes that were loaded from
> the same version of the same archive will reuse the same class
> definition even though they are different JavaClassInstances.

	See Gilbert's reply on why this won't work.

> While this seems more consistent to me, assignClassLoader() seems like
> it will work too.

	We need assignClassLoader() for the reasons Gilbert outlined; the
JVM spec explicitly allows for classloaders that generate bytecode
on-the-fly.

> What we /could/ do is allow casts between any two classes that share
> the same class definition (JavaClass). No restrictions. This is safe
> because the power to cast is useless unless you have a reference to an
> object that you want to cast. The restriction should be on gaining
> access to the shared object.

	If we /don't/ allow this by default, then the application must
specifically request casting power in some fashion, which is something I
think we want to avoid.  That is -- for Serializable IPC, the two
processes MUST have different statics and MUST have the same class
definition in order to communicate.  Take the parent spawning a child
example; it seems evident to me that the expected behavior is that the
child and the parent will be compatible, without any special coding.  That
means (a) we by-default share class definitions and (b) by default allow
'illegal' casts.

> In my last email, I mentioned that an object that belongs to another
> process should be able to access it's own static fields, but the client
> code should not. It will instead access the static fields of its own
> process. This makes the no restrictions approach safe from the statics
> perspective as well.

	Exactly.  To be a separate process, the child must not have access
to anything in the namespace of the parent.  The exact implementation of
direct IPC we can leave for later.  (e.g. what happens you pass a class
reference to a different process?  Since normal java doesn't allow this,
we can also disallow it.  Etc.  This is near to mixing system policy and
design decisions.)

> Q2: What is the significance of sharing classes between a process and
> its parent? I think you should be able to share classes with any other
> process. And if all classes loaded from the same version of the same
> archive share the same class definition, then this becomes possible (if
> you allow casting between any two classes that share the same class
> definition, as described above).

	You can; the signifigance of process/parent is that I understood
that to be the most common way for multi-process applications to be
written, and is a case where a default of sharing makes semantic
sense.  What we must avoid is separate processes NOT getting the chance to
load classes and use them from their own classloaders, e.g. their own
classpaths -- this is necessary for development, so I can, for instance, 
work on a daemon's source and test it while the production version is
running, or work on an editor in that editor, etc.  See below.

> Q3: Can you please explain the bit about an application reloading its
> classes?

	Sure.  Class devEnviroment, immediately on its main() function
being called, creates a new classloader, CL.  Reading from the command
line, it decides to run main() of class developingClass.  It gets
developingClass from CL, and spawns a thread to execute
it in its own classloader.  When the thread terminates -- or the user
interrupts -- devEnviroment garbage-collects CL so that the next run of
developingClass is re-loaded from scratch, in case it's changed. 

> - I don't see the logic in only inheriting class definitions from the
>   parent process.

	To be explicit: I did not propose that this would be the
/exclusive/ method for sharing, only propose that it be the /a/ (perhaps
/the/) default method of class sharing.  Independently-started processes
/must/ be given the chance to use their own independent
classes/classloaders; should they choose to use system-provided classes,
they should share definitions and be allowed 'illegal' casts.  (And
perhaps should be anyway.)

-_Quinn






From tmiller@haverford.edu Mon, 10 Apr 2000 13:53:16 -0400 (EDT)
Date: Mon, 10 Apr 2000 13:53:16 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> >- always maintain separate statics for different classloaders

> It is an option, not a requirement. The Java Virtual Machine specification
> does not require separate statics for different class loaders. It
> rightfully puts the decision in the hands of the custom class loader. A
> virtual machine must support the option of separate statics for each
> instance of a custom class loader.

	No, it doesn't.  Our requirement for maintaining statics is the
same as a conventional JVM, with the exception that classloaders /in
different processes/, by definition, can't share statics.  (Otherwise,
they're not separate processes.)  In fact, if a class already /has/
statics, a conventional-JVM classloader /must/ define its own version of
the class to get different statics!

-_Quinn






From tmiller@haverford.edu Mon, 10 Apr 2000 14:26:52 -0400 (EDT)
Date: Mon, 10 Apr 2000 14:26:52 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Change the sequence

	Every (user-space) process is started by some other process,
except for init, which is started by the kernel.  Efficiency and common
sense would seem to indicate that processes which do not want to share
class definitions are the exception, rather than the rule.  This, in turn,
would suggest that the default classloader ought not to define classes if
there's already a definition available.  The combination of these implies
that the classloaders should organize their caches (== shared definitions)  
in the same heirarchy as the processes, that is, as a tree rooted with
init's classloader.  That is, when a new process is requested, a new
classloader is generated which has a pointer to its parent and nothing in
its cache.  When it receives a loadClass() request, it ought to, then,
check its cache (no) and ask its parent to return a new class from the
parent's definition cache, and so on; something like
loadClassFromDefinition(), a final native method defined on
java.lang.ClassLoader that walks the tree looking for cached class
definitions (JavaClass) to generate a new class instance ==
java.lang.Class instance (JavaClassInstance) from.  If
loadClassFromDefition() finds and generates a class, it returns that clas,
which the classloader caches and returns.  If loadClassFromDefinition()
can't find a cached definitoin, it returns null, and the classloader asks
the system (findSystemClass()) to find it; findSystemClass() must then
update the classloader's definition cache if it's successful.  Likewise,
for custom classloaders, defineClass() must cache new definitions.  This
scheme means 'illegal' casts must be allowed in general, as Ryan proposed.

	Custom classloaders are, of course, welcome to ignore their
parents.  The question then becomes what to do if they load a class which
happens to be indentical to some other, cached (and therefore identified
as legal to 'illegally' cast) class.  Gilbert suggests we maintain a large
cache of all bytecode in order to determine if two class definitions are,
in fact, the same.  This is going to be brutally inefficient.  I'm
strongly tempted to say that if you don't get the class from the system or
your parent, it can't be 'illegally' cast to a class from the system or
your parent.  This fits with what a programmer working with a conventional
JVM would expect -- that a custom classloader is only interoperable with
other classloaders so far as they got their java.lang.Classes from the
same place.  It also makes our job tremendously easier :)  I am, of
course, open to arguments to the contrary.

-_Quinn







From tmiller@haverford.edu Mon, 10 Apr 2000 14:30:09 -0400 (EDT)
Date: Mon, 10 Apr 2000 14:30:09 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> >Writing a custom classloader, it looks like /nothing/ is shared by default,
> >and it's the responsibility of the classloader to be efficient by using
> >findSystemClass() if it so desires.

> Is this true of all virtual machines?

	I believe so, and it matches my interpretation of the JVM
spec.  In addition, if the custom classloader does NOT use
findSystemClass() for things like java.lang.Object or String, the
application halts almost immediately with a linkage error.

> Does a virtual machine invoke loadClass() for all classes, even those
> loaded by the primordial class loader?

	I believe it is required by the specification; the JVM-maintained
cached appears to distinguish between classes loaded in different
classloaders, as it must to ensure type-safety.

> An optimized virtual machine might not invoke the loadClass() method for
> classes that have already been loaded by the primordial class loader.
> Otherwise, I think you're right.

	I'm not sure if this is strictly to-spec, but since we're writing
our own, it won't do this :)

> Certainly, a virtual machine can always create a custom class loader to
> load the classes from java.applet, java.awt, java.sql, etc. A primordial
> class loader should be an actual Java class. As long as semantics are
> preserved, it is not necessary to store all class files in one big archive.
> As long as security is preserved, it is not necessary to load all classes
> in the java.* packages with a primordial class loader.

	Yup.  It may be worthwhile to implement your class-rewriting idea
to allow more of the process/classloader control systems to be written in
Java.

-_Quinn






From gchii@mindspring.com Mon, 10 Apr 2000 21:01:10 -0400
Date: Mon, 10 Apr 2000 21:01:10 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

At 01:53 PM 4/10/00 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>> >- always maintain separate statics for different classloaders
>
>> It is an option, not a requirement. The Java Virtual Machine specification
>> does not require separate statics for different class loaders. It
>> rightfully puts the decision in the hands of the custom class loader. A
>> virtual machine must support the option of separate statics for each
>> instance of a custom class loader.
>
>	No, it doesn't.  Our requirement for maintaining statics is the
>same as a conventional JVM, with the exception that classloaders /in
>different processes/, by definition, can't share statics.  (Otherwise,
>they're not separate processes.)  In fact, if a class already /has/
>statics, a conventional-JVM classloader /must/ define its own version of
>the class to get different statics!

I may have misunderstood.

I agree that our requirement for maintaining statics is identical to a
conventional JVM. That is a good thing, too. We won't have to change much
to get multiple processes within a virtual machine after all. In fact,
that's why I asked if it really is *that* simple.

In a process environment, the findSystemClass() method must be re-worked.
It must always return a process-wide class. The java.lang.ClassLoader class
is the base class for all other class loaders. It must be re-written to
find the class loader for the process. The findSystemClass() method might
look something like this:

  public static Class findSystemClass( String className ) 
      throws ClassNotFoundException {
    Process p = jos.process.getCurrentProcess();
    ClassLoader loader = p.getClass().getClassLoader();
    if ( this == loader ) {
      throw new ClassNotFoundException( className );
    }
    return loader.loadClass( className );
  }

This again implies that the primordial class loader should be a real Java
class. A class loader can be written to load class files based on
CLASSPATH. It can load class files from archives (.cab, .jar and .zip). It
can load classes from package files (.package).

The primordial class loader should be a real Java class -- even if it
defines some native method to load classes.

A primordial class loader is a JVM-specific class. It could be compatible
with the BCNI, like this:

  public void example() {
    Factory factory = Factory.getFactory();
    ClassLoader loader = factory.getObject( "java.lang.ClassLoader" );
    :
  }

-----

Let me put it this way. I want to continue to use my Java-based HTTP
service on JOS. My Java-based HTTP service uses many custom class loaders,
one for each servlet. A custom class loader is required so that a servlet
can be loaded, unloaded and re-loaded without taking the HTTP service down.

When I run my HTTP service as a JOS process, I'm not asking for a radical
change in the way a class loader works. As we agree, it is identical to a
conventional virtual machine.

When my HTTP service loads a servlet, the custom class loader indirectly
determines if it requires separate statics. It determines which classes are
loaded with findSystemClass() and which ones are not.

Maybe there are two ways to use class loaders. There is the conventional
way of using class loaders. The standard way is highly valued for web
browsers and HTTP services. It includes this:

A. All class loaders shared the Java standard class library.
B. All classes shared java.lang.System and java.lang.Runtime.

Then, there is the unconventional way of using class loaders.

A. Each process has it own instance of the Java standard class library.
B. Within a process, all classes share java.lang.System and java.lang.Runtime.






From ryan@whitewolf.com.au Tue, 11 Apr 2000 14:35:48 +1000
Date: Tue, 11 Apr 2000 14:35:48 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

Note: This is a very long email. You'd best read it all the way through
before attempting to reply :-)

"Todd L. Miller" wrote:

> > > I proposed a mechanism where only class definitions that are
> > > explicitly shared -- quite possibly by default -- are considered the
> > > same for 'illegal' casts
> > 
> > We agree so far, except I'm not sure what you mean by the "quite
> > possibly by default" bit. Do you mean it is quite possible to share all
> > class definitions by default, or that it is quite possible to consider
> > all objects for illegal casts by default?
> 
>         We /have/ to consider all objects for illegal casts by default for
> this to work transparently.  Whether or not all class definitions are
> shared by default is a design decision -- I was suggesting we should,

Ok, so the "quite possibly by default" bit refers to what came before
it. Of course, standard English usage :-)

So, in the case where all class definitions are shared by default, it
follows from the remainder of your original sentence that all objects
"are considered the same for 'illegal' casts". 

In this case (where you share all class definitions), our ideas are very
similar. The difference is that I don't believe it makes any sense to
just reuse the class definitions of the parent process. You need another
mechanism to ensure that classes in a child process can share their
class definitions with the parent process. In fact, since there's
nothing special about the parent-child relationship in this context, the
purpose of the mechanism is to ensure that classes in process A can
share their class definitions with process B, where process A and
process B are any two arbitrary processes.

Before you object, I would like to explain the feasibility of
implementing such a mechanism. Also, I hope to clear up some other
misunderstandings later on in this email, and include a complete(ish)
specification of my proposal. Please bare with me.

But first, consider this real-life scenario: a command-line session:

$ vi README
-- here, it turns out to be safe to reuse class definitions from the
parent process (in this case, the shell)

$ export CLASSPATH=/new/versions/of/some/libraries:etc:etc:
-- you see where I'm going

$ vi README
-- ok, it is no longer valid to reuse the same class definitions since
we are now loading classes from a different location. Only classes that
are being loaded from the same archive may be shared. The new CLASSPATH
may specify some archives to be the same as they were before. In this
case, only classes loaded from those archives may be shared with
processes invoked under the old CLASSPATH.

You see, in order to implement _correct_ sharing of class definitions,
you *need* a mechanism to determine that classes were loaded from the
same archive (more specifically, the same version of the same archive).

- What happens if you try to cut corners?

Ok, we definately want to share class definitions in order to save
memory. But what happens if we use an unintelligent algorithm for
deciding to share a class? Old classes may get linked into your
application causing NoSuchMethodErrors and such (or class verifier
exceptions).

Any solution for saving memory should not impact on the external
behaviour of the system. The fatal flaw in cutting corners here is that
it does change the external behaviour. Whenever you reuse a class from
the parent process, you are potentially linking in a class that the
_user_ did not intend to use. If the class has been updated on disk
since the parent shell was started and the user executes a new command,
the new version of the class should be used - the class definition
should not be reused from the parent process. Similarly, if the user
changes their CLASSPATH to pickup libraries from a new location, the
class definitions should not be incorrectly shared.

Here's another scenario. Suppose you are developing a text editor called
"vi". "vi" is installed on your system in a standard system directory
and your default CLASSPATH is set to pick it up from there. Obviously,
if you run 10 instances of "vi", from the same binary, they should all
share the same class definitions to save memory. But, if you decide to
do some more development work on a separate copy of vi, you might change
your CLASSPATH to pick up vi from your own classes directory:

- scenario:

1. The programmer opens up a number of source files, each in a different
instance of "vi". The default CLASSPATH is used so the system version of
vi is used.

2. In a separate shell window, the programmer types:

$ export CLASSPATH="~/projects/vi/classes:$CLASSPATH"
$ javac -d ~/projects/vi/classes *.java
$ vi Test.java
-- test the new version of vi - iterative recompilation and testing.

Here, and in the generic sense, determing whether or not to share a
class has nothing to do with the parent/child process relationship. They
are orthogonal. So, how do you know to share class definitions for all
the instances of "vi", but not for the developer's version? Another
interesting example is a multi-user system in which one user decides
they want to run a later version of "vi", so they download it and set
their CLASSPATH appropriately. How do you know when to share and when
not to share class definitions. I believe I have proposed the most
consistent solution that maps more closely to reality.

Now, I would like to clear up any misunderstandings and then hint at
some possible ways of implementing this if we decide to do it.

There was some concern that my proposal would affect external behaviour
regarding user defined class loaders. It won't. My proposal (I believe)
is in complete compliance with the JVM spec apart from the ability to
explicitly share object references between processes - which is our
mutual goal. The complete proposal that follows should clear up any
misunderstandings. It is easier to grasp if you can read it all as a
whole, rather than in little pieces here and there.

== Proposal for multiple processes in a single JVM ==

= Definition of Terms

- Class : a runtime class associated with a particular class loader
- Class definition : the runtime implementation of a class
...

= The basic model

Each process will have its own primordial class loader. As in a single
process JVM, the primordial class loader will have a copy of
java.lang.Object, and any other system and library classes that are
directly referenced by the main class of the program being executed.
Each primordial class loader will appear to work exactly like it would
in a single process JVM.

The running program may use a custom class loader to load classes from
any source (eg. on-the-fly, filesystem, or network). These custom class
loaders will behave exactly as they do in a normal JVM (after all, they
are user defined).

Each process has associated with it System properties which include the
CLASSPATH value for the process. A process's primordial class loader
will always load classes which represent class files found in its
CLASSPATH.

= Memory optimisations

Since the primordial class loaders are owned by the system, they can be
trusted to perform certain memory optimisations transparently.
Particularly, sharing class definitions that have already been loaded. A
requirement is that any memory optimisations performed do not change the
external behaviour of the primordial class loaders.

As has been stated, a process's primordial class loader will always load
classes which *represent* class files found in its CLASSPATH. The memory
optimisations proposed here are to determine if there is already a class
definition in memory that *represents* a class from the archive in the
process's CLASSPATH. To achieve this, the JVM needs to be able to label
the version of each loaded class, and efficiently determine the version
of classes on the filesystem. If they differ, the class definition
cannot be reused.

One way to implement this is to use the pathname and file modification
dates as the version information. I believe Solaris does a similar
optimisation - ie, if you run 100 instances of 'vi', it will share the
executable code in memory. And if you run your own version of vi, it
will allocate a new memory space for your executable code.

= Sharing objects between processes

It is desirable to share objects between processes to provide a more
efficient mechanism for RMI-type functionality. However, to support
this, we must go against the JVM spec. The goal here is to make
everything work exactly the same as a real JVM, but with the added
ability to share particular objects between processes. No objects will
be shared by default (in which case this is exactly the same as a real
JVM), but permission may be granted to share particular objects.

This proposal states that casts between any two classes that share the
same class definition are granted by the JVM. The power to perform
illegal casts such as this is useless unless you have actually been
granted permission to obtain a reference to an object of another
process.

It is important to understand that the only case in which two classes
share the same class definition is where one class belongs to one
process and the other class belongs to a different process. You cannot
have a class loaded by a user defined class loader sharing a class
definition with a class loaded by the primordial class loader because
only the(a) primordial class loader can perform the optimisation that
links both classes to the same class definition. Only the(a) primordial
class loader can be trusted to perform such memory optimisations. In
other words, only classes defined by a primordial class loader can reuse
the definition from another primordial class loader. 

This is important because it means that standard illegal casts between
class loaders in a single process will still be handled correctly.

====== end of proposal =======

Sorry for the length, but I feel that my proposal was not completely
understood. I don't want to say that "this is the way it should be
done", but I think my proposal should at least be considered as an
alternative. And to be considered, it needs to be understood.

In the rest of this email, I will address each of the comments people
made:


> > A note: byte-for-byte checking is not the only alternative. If we
> > implement my proposal for memory saving, classes that were loaded from
> > the same version of the same archive will reuse the same class
> > definition even though they are different JavaClassInstances.
> 
>         See Gilbert's reply on why this won't work.

See my reply on why this WILL work :-)

Don't worry, I will get around to addressing Gilbert's email with a
little more detail.

> > While this seems more consistent to me, assignClassLoader() seems like
> > it will work too.
> 
>         We need assignClassLoader() for the reasons Gilbert outlined; the
> JVM spec explicitly allows for classloaders that generate bytecode
> on-the-fly.

I believe I have addressed this in my proposal. User defined class
loaders will work exactly the same as they do in a normal JVM. Object
sharing is only allowed for classes defined by primordial class loaders.

> > What we /could/ do is allow casts between any two classes that share
> > the same class definition (JavaClass). No restrictions. This is safe
> > because the power to cast is useless unless you have a reference to an
> > object that you want to cast. The restriction should be on gaining
> > access to the shared object.
> 
>         If we /don't/ allow this by default, then the application must
> specifically request casting power in some fashion, which is something I
> think we want to avoid.

True, so we do want to allow such casts to be unrestricted. However, I'm
all in favour of requiring permission to gain access to a shared object,
by some means (as opposed to gaining permission to actually perform a
cast). This is because if the mechanism is there to allow one process to
obtain a reference to a shared object, then any other process can also
obtain a reference even if they are not supposed to. Therefore we need
some means by which only authorised processes can access certain shared
objects. There are probably a few ways of doing this.

> > In my last email, I mentioned that an object that belongs to another
> > process should be able to access it's own static fields, but the client
> > code should not. It will instead access the static fields of its own
> > process. This makes the no restrictions approach safe from the statics
> > perspective as well.
> 
>         Exactly.  To be a separate process, the child must not have access
> to anything in the namespace of the parent.

Not that there's anything special about the parent ;-) A process must
not have access to anything in the namespace of any other process.

>  The exact implementation of
> direct IPC we can leave for later.  (e.g. what happens you pass a class
> reference to a different process?  Since normal java doesn't allow this,
> we can also disallow it.  Etc.  This is near to mixing system policy and
> design decisions.)

Do you mean passing instances of java.lang.Class? Yeah, that's
interesting. I get the feeling there's something special about the Class
object. If you use a custom class loader to load a class in a different
name space, it is still an instance of java.lang.Class in the _current_
namespace - or perhaps that's just because it needs something to
represent the class with in this namespace.

> > Q2: What is the significance of sharing classes between a process and
> > its parent? I think you should be able to share classes with any other
> > process. And if all classes loaded from the same version of the same
> > archive share the same class definition, then this becomes possible (if
> > you allow casting between any two classes that share the same class
> > definition, as described above).
> 
>         You can; the signifigance of process/parent is that I understood
> that to be the most common way for multi-process applications to be
> written, and is a case where a default of sharing makes semantic sense.

I think that's historic. Many multi-process applications of that
structure were written in that way because of lack of threads. Even with
thread support on UNIX, many people still find it easier to spawn child
processes because they don't know how to use the threads API.

True multi-process systems where each component interacts with eachother
to achieve a result  tend not to be based on parent child relationships.
They are all equally important components that use a lookup service to
find the other process (RPC), or a lookup service to find an object in
another process (CORBA and RMI).

In the example of programs needing to do IPC to draw to windows owned by
the window manager, there is no parent-child relationship. The window
manager can be shut down and restarted, just the same as programs which
try to interact with it. It's a horizontal relationship.

> What we must avoid is separate processes NOT getting the chance to
> load classes and use them from their own classloaders, e.g. their own
> classpaths -- this is necessary for development, so I can, for instance,
> work on a daemon's source and test it while the production version is
> running, or work on an editor in that editor, etc.  See below.

I address the same requirement in my proposal, I chose to have this
handled by the primordial class loaders in a generic fashion.

One of the points you disagreed with me on was that determining whether
or not to reuse a class definition based on what version of the class
was being read (ie. what CLASSPATH is being used) would not work, as per
Gilbert's email. It seems to me that it does work and it is required
when you take the CLASSPATH into account.

> > Q3: Can you please explain the bit about an application reloading its
> > classes?
> 
>         Sure.  Class devEnviroment, immediately on its main() function
> being called, creates a new classloader, CL.  Reading from the command
> line, it decides to run main() of class developingClass.  It gets
> developingClass from CL, and spawns a thread to execute
> it in its own classloader.  When the thread terminates -- or the user
> interrupts -- devEnviroment garbage-collects CL so that the next run of
> developingClass is re-loaded from scratch, in case it's changed.

I see what you're talking about now. In my proposal, this is handled
generically by the primordial class loader which always works off its
CLASSPATH.

Gilbert Carl Herschberger II wrote:
> 
> At 02:19 AM 4/9/00 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
> >As for memory saving, a solution might be:
> >
> >- share classes which are loaded from the same version of the same
> >  archive
> 
> I don't like this solution for two reasons.
> 
> 1. Two custom class loaders can read the same version of the same archive.
> They will produce different types. Each custom class loader would have to
> communicate with all others.

I intentionally opted to disallow class sharing between custom class
loaders since there can be no guarantee that te classes are compatible
for the purposes of IPC. Yes, a class defined by a custom class loader
will end up having a different non-compatible type, but that doesn't
stop you from defining the class using your primordial class loader, in
which case the system will allow you to participate in object sharing.

> 2. Two different archives can store the same class file. Even if a class
> file comes from two different archives, an optimized virtual machine should
> keep one instance.

I disagree. There is no guarantee that the same class file in each
archive is the same byte-for-byte (unless you do a byte-for-byte
comparason, which is unrealistic). If you share the class definitions in
this case, you can start running into incompatibility problems
(NoSuchMethodError), or Security problems (eg. you think you've loaded a
particular class, but the system has just gone and reused a different
class definition that does something different - something potentially
bad).

> >Note that we will effectively have a primordial classloader for every
> >process, each under the control of the JVM. Since nearly every class
> >will be loaded by one of these classloaders, the JVM can check if they
> >are coming from the same archive.
> 
> The JVM cannot easily check if a class is coming from the same archive.
> Most of the problem comes from an archive with two or more "names". On my
> computer, each of these names refer to copies of one archive.
> 
>   ~/eric/org.jos.gchii.eric1c.jar
>   /home/Gilbert/eric/org.jos.gchii.eric1c.jar
>   C:\BORLAND\lib\org.jos.gchii.eric1c.jar
>   M:\eric1b-4\org.jos.gchii.eric1c.jar
>   M:\eric1b-4\limited\org.jos.gchii.eric1c.jar
>   V:\eric1b\org.jos.gchii.eric1c.jar

It is easy to check if it is coming from the same archive. The class
loader loops through each archive in the classpath and stops when it
finds the class. The archive at which it stops is the archive that the
class came from. In addition to identifying the archive by path, you
also need to check the date (or some other versioning information) to
ensure that someone hasn't replaced that archive with a different one
potentially containing different versions of the classes.

(An idea, instead of using the path as part of the identifier, maybe you
could use a file id instead - an id that tracks the file wherever it
moves. Yes, it's unrealistic for now, but I imagine filesystems in the
future will export a kind of unique id for files. eg. filesystems with
built in version control. That's another thread :-)

> Remember, the puzzle is not to identify unique archives, but unique content
> of class files.

Do you agree that isolating the archive that it came from at least
achieves the required level of correctness? I see little benefit in
comparing the actual content of each class file. Checking path and
modification date of a class file or jar file guarantees that the system
will never make the mistake of reusing the class definition for
incompatible versions of the same class. If you simply run "touch
/usr/lib/vi.jar" which changes the modification date of the archive but
doesn't actually change the contents, then my system will not share old
class definitions that are already loaded with any new vi processes that
are started. You might say that this is wasted opportunity for saving
memory, but I think it's a good tradeoff considering that modification
dates usually reflect changes to the content, and byte-for-byte checking
is very expensive.

> >- always maintain separate statics for different classloaders
> 
> It is an option, not a requirement. The Java Virtual Machine specification
> does not require separate statics for different class loaders. It
> rightfully puts the decision in the hands of the custom class loader. A
> virtual machine must support the option of separate statics for each
> instance of a custom class loader.

It's not an option of the JVM. A class defined by one class loader must
have separate statics from the same class defined in a different class
loader. Perhaps you misunderstood what I was saying. I was referring to
leaving the static part of a class associated with the class loader (as
per the jvm spec), but detaching the definition part so that it can be
reused in other class loaders. This is the same concept that _quinn
actually invented a while ago. I'm just reusing it.

====

Once again, sorry for making this such a long email but I'm just trying
to give you a level of understanding that allows you to treat this as a
valid alternative. I don't want to make up your minds.

Thanks for your time :-)

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Tue, 11 Apr 2000 16:42:07 +1000
Date: Tue, 11 Apr 2000 16:42:07 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] arch list a bit flaky at the moment

If anyone is wondering why their emails are not appearing on the list,
we have just upgraded mailman and it seems to be playing up. Your emails
will eventually appear on the list, but I must manually approve them.

We will try to fix the problem ASAP, but in the meantime your patience
is appreciated.

Thank you.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From clark.evans@manhattanproject.com Tue, 11 Apr 2000 11:00:50 -0400 (EDT)
Date: Tue, 11 Apr 2000 11:00:50 -0400 (EDT)
From: clark.evans@manhattanproject.com clark.evans@manhattanproject.com
Subject: [JOS-Arch] (testing... for a third time...)

hmm.





From gchii@mindspring.com Tue, 11 Apr 2000 20:32:26 -0400
Date: Tue, 11 Apr 2000 20:32:26 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

At 02:35 PM 4/11/00 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>Each process will have its own primordial class loader. As in a single
>process JVM, the primordial class loader will have a copy of
>java.lang.Object, and any other system and library classes that are
>directly referenced by the main class of the program being executed.
>Each primordial class loader will appear to work exactly like it would
>in a single process JVM.

This is exactly right. We need one primordial class loader for each process.

For more information, see also ProcessAndPrimordialClassLoader on JOS Wiki.

The JNI design provides a primordial class loader for each bytecode
process. It also provides one garbage collector, one finalizer thread, one
user interface thread for each bytecode process. It does this by creating a
new instance of an entire virtual machine. A new instance of an entire
virtual machine is not required. Only a new instance of the primordial
class loader is required.

A. Through private property of a class, a primordial class loader could be
100% internal to a virtual machine. For perfect compatibility, the
getClassLoader() method can still return null at the bytecode level. While
we know an application is running in a separate process, this does not need
to be explained to the application.

B. Actually, process ID could become a private property of an instance of
java.lang.Class. When a new instance of systemprocess (in C++) is created,
it gets a system-wide unique ID. Every class created by that process is
tagged as part of that process. The getCurrentProcess() method uses the
private property of a class to return a SystemProcess (in bytecode), a
proxy for systemprocess.

>A process's primordial class loader will always load classes which
>represent class files found in its CLASSPATH.

A conventional primordial class loader uses CLASSPATH. CLASSPATH depends on
a file subsystem. In the startup sequence, the primordial class loader must
be available /before/ the file subsystem is installed.

The ERIC Project proves that CLASSPATH is not required. Its custom class
loader never uses CLASSPATH. It uses a "package" path. It loads classes
from the local file subsystem. It downloads bytecode from an HTTP service.
It downloads package files. It could download .jars. It could download
.class files.

Absolutely. I am strongly recommending a byte-by-byte comparision on each
class file. The machine code version of memncmp() is not expensive when
compared to the large quanitity of wasted resources cause by duplication of
bytecode.

1. This optimization would help all class loaders across the board. It
would help our own primordial class loader and all user-defined custom
class loaders.

2. The alternative is, well, exactly what I already have. I don't want more
of what I already have. The alternative lends itself to the same
mismanagement of resources as a conventional virtual machine on a foreign
operating system.

A. Through the public ClassLoader property of a class, a primordial class
loader could be (1) implemented in bytecode, (2) extendable, and (3)
customizable. It would not be perfectly compatible because the
getClassLoader() method can still return a primordial class loader at the
bytecode level. An application could easily determine if it was running in
a multiple process virtual machine:

  public void example() {
    if ( System.getClass().getClassLoader() == null ) {
      println( "Running in a conventional virtual machine." );
    }

    println( "Running in an alternative virtual machine." );
  }

B. Process (or process ID) becomes a public property of
PrimordialClassLoader. PrimordialClassLoader is a class derived from
java.lang.ClassLoader. It is likely that PrimordialClassLoader has native
methods, too. When a new instance of systemprocess (in C++) is created, it
gets a system-wide unique ID. All instances of systemprocess are "owned" by
the virtual machine. Every class created by that process is tagged as part
of that process. The getCurrentProcess() method uses the public property of
the class loader for a class to return a SystemProcess (in bytecode), a
proxy for systemprocess.

  public Process getCurrentProcess() {
    Object o = this;
    for (;;) {
      ClassLoader loader = o.getClassLoader();
      if ( loader instanceof PrimordialClassLoader ) {
        return ((PrimordialClassLoader) loader).getProcess();
      }
      o = loader;
    }
  }

No matter how many custom class loaders are creating classes, eventually
the above method has to find a primordial class loader. The virtual machine
creates a primordial class loader /first/ before loading anything else.

-----

I agree with the work of Avery Regier. Avery wrote a number of articles on
JOS Wiki, such as WhyMultiProcessJVM. Here is a quote:

"With this type of VM, you can load a single version of a class's bytecodes
into memory once and share the bytecodes amongst all of the processes. Each
process will need its own stack and static variables (otherwise they would
conflict with each other) but bytecodes can be shared."

3. If a getBytecode() method were able to return bytecode for a class, here
is how a virtual machine can test the compatibility of two arbitrary
classes for class conversion:

  public boolean isCompatible( Class x, Class y ) {
    /* *L!
    if ( x.getBytecode() == y.getBytecode() ) {
      return true;
    }
    else {
      return false;
    }
    */
    return ( x.getBytecode() == y.getBytecode() );
  }

Once bytecode has been intern'd, all compatible classes have an object
reference to exactly the same bytecode. If the bytecode is an exact match,
it does not matter where the bytecode came from. An object can be copied
from one process to another.

4. Possibly, the worst way to convert a raw class file to java.lang.Class
is by using the equivalent of an input stream. That's why the pure
reflection API does not use an input stream to parse a bytecode. Again from
the bottom up: (1) pure reflection comes before bytecode verification; (2)
bytecode verification comes before a bytecode interpreter; and (3) a
bytecode interpreter comes before a virtual machine.





From gchii@mindspring.com Tue, 11 Apr 2000 20:59:36 -0400
Date: Tue, 11 Apr 2000 20:59:36 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Great discussion!

Thank you for this discussion on the architecture mailing list. It has been
great. I hope we can keep it going. Today, I have a much better idea about
what it will take to create a multiple process virtual machine.

1. I recommend a "MPCL/M" design for a first pass at jJOS/decaf.

MPLC/M is "multiple primordial class loader in machine code". Inside the
jJOS/decaf, there is only one machine code process. The kernel and virtual
machine are a primary machine code process. Kernel modules are machine code
extensions. They run within the primary machine code process.

2. I recommend a "MPCL/B" design for a second pass.

MPCL/B is "multiple primordial class loader in bytecode". MPCL/B -- as far
as I can tell -- depends on our ability to demonstrate MPLC/M. MPLC/M
should come first.

3. I cannot ignore the JNI design.

The JNI design won't go away. The JNI design also provides multiple
bytecode processes within a machine code process. Multiple instances of a
virtual machine is infinitely more complex.

On the other hand, it ensures that each bytecode process has its own heap,
its own garbage collector, its own user interface thread, and its own
finalizer thread.

For more information, see also ProcessDiagramJNI.

4. I stand corrected.

For the first time, I see that it is not necessary to have multiple
instances of a virtual machine to accomplish multiple processes in
bytecode. By constantly chipping away at the assumptions of the Java
Virtual Machine Specification, the JOS Project has convinced me that the
primordial class loader is the critical component.

A virtual machine can have many primordial class loaders. And, these class
loaders can be hybrid classes, implimented partly in machine code and
partly in bytecode.

Enabling more than one primordial class loader seems to be the minimum
clarification to the Java Virtual Machine Specification that give us
multiple bytecode processes.

5. I have been too concerned with efficiency.

I am sorry. I have been working long and hard on the efficiency of a
bytecode cache. We can enjoy multiple processes for a long time before we
need to be concerned with virtual machine efficiency.

IF ONLY we had a virtual memory manager and a 10GB swap partition, we could
load 20+MB of bytecode for each process and really not worry about it.

Before we optimize a bytecode cache, or class definition cache, or class
cache, we should demonstrate a multiple process virtual machine (MPVM).

6. Demonstration

When I boot JOS from the JOS Binary Distribution, it should invoke init. In
turn, init should run a command line shell in a new user process. From the
keyboard, I should be able to type the name of a runnable class using a
line editor. By the way, /all/ implementations of org.jos.program2a.Program
are runnable.

When I press enter, the shell program should create a new user process. The
new user process re-loads parts of the Java standard class library. The
runnable class runs in the new user process.

We should invent the classpath application. The classpath application might
re-set the classpath property of a shell -- for creating user processes in
the future.





From gchii@mindspring.com Tue, 11 Apr 2000 21:22:20 -0400
Date: Tue, 11 Apr 2000 21:22:20 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Compiling bytecode

It is important to know your applications when building an operating
system. Consider the following scenario.

// MyUtility.java
public static void main(String[] argv) {
  System.out.println( "Running..." );
  System.out.println( "Done." );
}

$ javac MyUtility.java

$ MyUtility
Running...
Done.

$ cp utility-1/MyUtility.java .

$ javac MyUtility.java

$ MyUtility
???

Does a MPVM run the old MyUtility.class or the new one?

Does a MPVM always discard the static fields of the old class?

Choice is what I want. I always want to explicitely choose between running
a program within the current process or running in a new process. That is
why the Smart API defines two sub-schemes for running programs:

run:program: - This sub-scheme runs a program within the current process.
Typically, it's faster and retains all static fields. It retains all
instances of java.lang.Class that have already been used.

run:process: - This sub-scheme runs a program in a new bytecode process.
While it may be slower, it also loads or re-loads all bytecode. All static
fields are process-specific. It shares no instances of java.lang.Class with
other processes.

Actually, I want more choice. That's why the Smart API defines the thread:
subscheme. This sub-scheme runs a program within the current process but
creates a new thread.





From gchii@mindspring.com Tue, 11 Apr 2000 21:34:54 -0400
Date: Tue, 11 Apr 2000 21:34:54 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Invoke-able

>From a command line, type the name of any invoke-able class, which includes
any runnable class.

-----

In an earlier message, when I wrote "runnable", I meant "invoke-able". Many
classes are invoke-able. Certainly, classes that implement the
java.lang.Runnable interface are invoke-able. But there are others:

 - any class that defines a public static void main(String[]) method;

 - any class that extends java.applet.Applet;

 - any class that extends javax.servlet.Servlet;

 - any class that extends java.awt.Component, especially java.awt.Frame and
java.awt.Dialog;

 - any class that extends a class with an invoke-able adapter (an adapter
is available for classes such as java.io.InputStream and
java.io.OutputStream);

 - and many, many more.





From tmiller@haverford.edu Wed, 12 Apr 2000 00:34:10 -0400 (EDT)
Date: Wed, 12 Apr 2000 00:34:10 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Compiling bytecode

> Does a MPVM run the old MyUtility.class or the new one?

	It's up to the shell.  If the shell did the Right Thing and used
disposable custom classloader for each process it creates, than the
classes for each program are re-loaded on every execution.  Otherwise, you
use the old classes.  I agree -- I want choice, and IMO, the shell should
usually be able to make the right one, maybe with a little help from
me.  (e.g., > !myClass will always spawn a new classloader & ignore the
cache/system classes.)

> Does a MPVM always discard the static fields of the old class?

	If the old class is discarded, yes, it has to.  If it's not, than
some classloader, somewhere, has the statics, so it depends on if you're
in that classloader or not.

-_Quinn





From tmiller@haverford.edu Wed, 12 Apr 2000 01:11:19 -0400 (EDT)
Date: Wed, 12 Apr 2000 01:11:19 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Great discussion!

> 1. I recommend a "MPCL/M" design for a first pass at jJOS/decaf.
> 2. I recommend a "MPCL/B" design for a second pass.

	I agree.  (2) will require native support, but it should be
relatively easy to adapt the code from (1), and I think we'll have a
better idea of what needs to happen after working with (1).

> The JNI design won't go away. The JNI design also provides multiple
> bytecode processes within a machine code process. Multiple instances of a
> virtual machine is infinitely more complex.

	Indeed, and since our kernel doesn't support multiple native
processes yet, I think we can safely ignore if for now.  Again -- once
(1) is done, this should become clearer.

> For the first time, I see that it is not necessary to have multiple
> instances of a virtual machine to accomplish multiple processes in
> bytecode. By constantly chipping away at the assumptions of the Java
> Virtual Machine Specification, the JOS Project has convinced me that the
> primordial class loader is the critical component.

	Now that we agree on /what/ we're doing, we just need to agree on
/how/ to do it. :)

> A virtual machine can have many primordial class loaders. And, these class
> loaders can be hybrid classes, implimented partly in machine code and
> partly in bytecode.

	I might even say /ideally/ are hybrid classes, because the native
code allows great integration with the JVM and the bytecode allows for
more adaptable control.

> Enabling more than one primordial class loader seems to be the minimum
> clarification to the Java Virtual Machine Specification that give us
> multiple bytecode processes.

	It's enabling /disjoint/ classloaders that is the minimum
clarification (good word:)) to the JVM spec that allows multiple
bytecode processes.  Implementation of disjoint classloaders (without
breaking compatibility) requires multiple primordial classloaders*.

> I am sorry. I have been working long and hard on the efficiency of a
> bytecode cache. We can enjoy multiple processes for a long time before we
> need to be concerned with virtual machine efficiency.

	OTOH, we /do/ need efficient virtual machines.  My development
machine has 'just' 128 MB of RAM, so I'll be forced to write efficient
processes just to get anything done.  And don't apologize, especially for
working hard!  Trying to explain my ideas (and failing!) to you and Heise
have helped my clarify them and realize where I've been wrong.  Hopefully,
we'll be needing efficiency soon...

> Before we optimize a bytecode cache, or class definition cache, or class
> cache, we should demonstrate a multiple process virtual machine (MPVM).

	Yes, we should.  Which means I should really get cranking on
finishing the interpreter...

> When I press enter, the shell program should create a new user process. The
> new user process re-loads parts of the Java standard class library. The
> runnable class runs in the new user process.

	Right on.  The big demonstration, though, is to pipe one
application's System.out to another's System.in -- something that nobody
else can do in a single JVM.

The steps we need to take, then, are:

(1) Allow multiple independent native/primordial classloaders.  Already done.
(2) Allow Java code access to this new native power.  Either have it
framed as a request to generate a new process, which returns a Process
object (of some kind or another -- Gilbert, I believe you have a sketch of
this class somewhere?), or frame it as a request to the classloader
constructor, do I get a new primordial loader or not?  We need to
decide; and since whatever we pick is pretty much 'just' an API issue, it
can change if it doesn't work out.
(3) Write a shell.  (Gilbert, this is right up your alley; it would
basically suck input from System.in and pass it onto the browser, right?)
(3A) This would, BTW, require that the consoles handle converting keyboard
events into System.in and System.out into write requests.  (I think this
would be a better place to put it than in each shell, but I may be wrong.)
(3B) Make sure the shell redirects standard input and output as necessary.
(4) Get decaf to the state where init will set up the console and keyboard
drivers, and start 'login' on each of the consoles (or something
appropriately ad-hoc), where login then sleeps waiting for the shell it
started to end.
(5) make 'generateRandomGarbageOnStdOut | sortStdIn' work :)

That would conclude the demonstration.

Further work:

(6) Allow 'illegal' casts.  This won't be a problem until the processes
start dumping Serializables down the pipes.
(7) Do something more efficient than completely cleaning out each new
primordial loader.


	I think we all agree (more or less) on (1) to (5), and that we're
all still hacking away at (6) and (7), which are closely related.  More on
them from me later :)

-_Quinn

* Now that I'm thinking about it a little more, since classloaders can't
be disjoint unless their primordial loaders are (or don't have any classes
loaded, which can't (normally) happen), the two statements are
equivalent.  That is, disjoint classloaders require multiple primordial
classloaders, and multiple primordial classloaders, in turn, generate
disjoint classloaders.





From gchii@mindspring.com Wed, 12 Apr 2000 09:38:16 -0400
Date: Wed, 12 Apr 2000 09:38:16 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Critical methods

Let's assume -- for the sake of discussion -- that we have a multiple
primordial class loader in machine code (MPCL/M). And further, let's assume
it is a class implemented in C++.

A bytecode process is separate from a primordial class loader. And yet, one
cannot exist without the other. How much of this can be written in bytecode?

1. All primordial class loaders share a single heap.

(1a) There will be only one mechanism to generate object references in a
virtual machine.

(1b) There will be only one garbage collection thread.

(1c) There will be only one finalizer thread.

(1d) Each class "knows" its loader through a VM-specific
PrimordialClassLoader property and/or a ClassLoader property.

(1e) Each object "knows" its loader through its Class property.

(1f) An object can be dynamically cast from any other process to the
current one. An incompatible class will cause a dynamic cast to fail.

  Object cast( Object v );

2. In machine code, a virtual machine can create a new primordial class
loader in a sequence something like this:

  void exampleA() {
    primordialclassloader *loader = primordialclassloader();
    :
    delete loader;
  }

3. The process manager "owns" all primordial class loaders. Each instance
of a primordial class loader implies a separate process. Each primordial
class loader must be identified with a process object (or process ID). This
is better:

  void exampleB() {
    primordialclassloader *loader = processmanager::createLoader();
    int pid = loader.getProcessID();
    :
  }

4. A well-known interface enables the JOS standard class library to use a
primordial class loader on any JOS-compatible virtual machine.

// PrimordialClassLoader.java
package jos.jvmspecific;

public abstract PrimordialClassLoader
    extends ClassLoader {
  public abstract int getProcessID();
  public abstract String getName();
  public abstract void setName( String v );
  public abstract Process getProcess();
}

5. An instance of primordial class loader in machine code (like C++) can be
mapped to the corresponding object in bytecode (like Java).

// CustomPrimordialClassLoader.java
package decaf.jvmspecific;

public interface CustomPrimordialClassLoader 
    implements PrimordialClassLoader {
  private static native long createLoader( Object o );

  public CustomPrimordialClassLoader() {
    mcLoader = createLoader( this );
  }
  public native int getProcessID();
  public native Process getProcess();
  public native String getName();
  public native void setName( String v );
  private long mcLoader = 0;
}

6. A function in machine code enumerates all open processes.

int *list process::getProcessIDList();
for ( int i = 0; i < iMax; i++ ) {
  primordialclassloader *pcl = getProcess( list[ i ] );
  :
}

We should remember to write a bytecode equivalent to the ps command.

7. A function in machine code kills an open process:

processmanager::killProcess( int pid );

8. A function in machine code determines if a process is (still) running.

processmanager::isProcess( int pid );

9. Like a thread group, a process can be suspended and resumed.

processmanager::suspend( int pid );
processmanager::resume( int pid );





From ryan@whitewolf.com.au Thu, 13 Apr 2000 01:11:26 +1000 (EST)
Date: Thu, 13 Apr 2000 01:11:26 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Compiling bytecode

On Tue, 11 Apr 2000, Gilbert Carl Herschberger II wrote:

> Does a MPVM run the old MyUtility.class or the new one?
> 
> Does a MPVM always discard the static fields of the old class?
> 
> Choice is what I want. I always want to explicitely choose between running
> a program within the current process or running in a new process.

There are several ways one might want invoke a program:

1. In a new process with a fresh primordial class loader. This behaves
   the same way as a standard JVM in that it will load the latest version
   of every class with respect to the filesystem.
2. In a new process but with a clone of the parent process's primordial
   class loader.
3. In the current process with a fresh primordial class loader.
4. In the current process with the existing class loader.

The option you were talking about is option (4). However, since this
option doesn't respect statics, option (2) might be required for some
programs to function properly. The advantage of (4) is that it is very
light weight.

Option (3) at first glance seems to provide no benefit over (1) in that
it requires the same amount of additional resources. The difference is
that it releases the resources of the previous program running in the
process. You only need to use this option if the parent process is
waiting on your process. If you use option (1) to create a new process
and exit, the parent process will finish waiting prematurely. It depends
on your waiting needs.

Option (2) might be useful if you want to spawn a number of processes
running the same program, and you want to make sure that they are
running exactly the same version of the code. If option (1) is used and
libraries are replaced on the filesystem during the spawning process,
the different processes won't all be running off the same version of the
program. I expect option (1) would be the expected "normal" behaviour,
but option (2) might be useful in some cases.

Note: some of my comments above might only be applicable when relating
it to my proposal for multiple Java processes. Please forgive me if
that's the case (then again, it may not be).

BTW, that proposal is now at:

	http://www.progsoc.uts.edu.au/~rheise/jos/java_processes.txt

I have implemented a prototype of this process model which has an
architecture to support both a host implementation (running on top of a
standard JVM - this is complete), and a native implementation (running
inside decaf - this is incomplete). I have been using it to experiment
with my ideas on a user model and security, documented at:

	http://www.progsoc.uts.edu.au/~rheise/jos/jos-security.html

It's just something I've been using to experiment. I'll post the source
if you're interested. I just need to add a bit more to the native
implementation and write at least /some/ documentation :-)

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/






From cce@clarkevans.com Wed, 12 Apr 2000 12:04:08 -0400 (EDT)
Date: Wed, 12 Apr 2000 12:04:08 -0400 (EDT)
From: Clark C. Evans cce@clarkevans.com
Subject: [JOS-Arch] Distributed System Papers

You have probably seen this... but it may have some relevant ideas.
http://wwwspies.informatik.tu-muenchen.de/forschung/papers/eigene/








From ryan@whitewolf.com.au Thu, 13 Apr 2000 14:46:36 +1000
Date: Thu, 13 Apr 2000 14:46:36 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

Gilbert Carl Herschberger II wrote:

> >A process's primordial class loader will always load classes which
> >represent class files found in its CLASSPATH.
> 
> A conventional primordial class loader uses CLASSPATH. CLASSPATH depends on
> a file subsystem. In the startup sequence, the primordial class loader must
> be available /before/ the file subsystem is installed.

Yes, you are right to point out the bootstrapping problem. However, I
would solve it in a different way.

Rather than claiming that the primordial class loader must be available
before the filesystem is installed, I would claim that the
"KernelClassLoder" must be available before the file subsystem is
installed. In this case, the specification of the primordial class
loaders in my proposal remains valid.

The KernelClassLoader operates above all processes and is the first
class loader in the system to be created. That implies that the kernel
itself is not a process. Rather than using the CLASSPATH technique of
the primordial class loaders to load classes, it will read the required
classes from some known position (or positions) on the disk. When the
boot loader is installed, the physical location of the classes.zip (and
perhaps a separate kernel.zip) is recorded so it knows where to load
them from. (Also, the position of the native kernel code also needs to
be stored with the boot loader, and the position of required native
libraries (if they are separate libraries) need to be stored too.)

It occurs to me that any class loaded by a primordial class loader
should always share its class definition with the corresponding class in
the KernelClassLoader, if it exists there. This overrides the other form
of class definition sharing effectively whenever a "kernel required"
class is loaded. I believe this is a constraint for a correctly
functioning system:

"kernel required classes" can be defined as the set of classes that must
remain the same from system boot to shut down. At least in the context
of the primordial class loaders and the kernel class loader. This
includes classes such as java.lang.Object and java.lang.System. The
thinking behind this is that critical classes such as these should
behave consistently thoughout all system class loaders so that they may
trust each other. Note that in a standard JVM, you are allowed to
redefine the system classes before you start a new process. But then it
follows that processes such as these may not trust each other in the
same way that I'm proposing here.

I wouldn't say this idea is fully fleshed out, so feel free to point out
any holes.

> The ERIC Project proves that CLASSPATH is not required. Its custom class
> loader never uses CLASSPATH. It uses a "package" path. It loads classes
> from the local file subsystem. It downloads bytecode from an HTTP service.
> It downloads package files. It could download .jars. It could download
> .class files.

True, CLASSPATH is only one way of loading classes. It is the standard
way because it can be supported on each of the current host platforms
for standard JVMs, and the Java spec seems to cater for the lowest
common denominator.

I can imagine there will be places where we will want to abandon
sticking to the lowest common denominator. This may be one of them. One
case where we definately want to abandon the lowest common denominator
is adding support for file permissions (through the use of ACLs). I
present some ideas on this at:

	http://www.progsoc.uts.edu.au/~rheise/jos/jos-security.html

> Absolutely. I am strongly recommending a byte-by-byte comparision on each
> class file. The machine code version of memncmp() is not expensive when
> compared to the large quanitity of wasted resources cause by duplication of
> bytecode.

How about when compared to my proposal for class definition reuse? I
agree that they are both two valid alternatives. It's just a matter of
working out the tradeoff.

> 1. This optimization would help all class loaders across the board. It
> would help our own primordial class loader and all user-defined custom
> class loaders.

Here's part of the tradeoff. If we do it your way, we do get to save a
little more space. It depends whether it is worth it for the slower
speed of byte-for-byte comparisons.

> An application could easily determine if it was running in
> a multiple process virtual machine:
> 
>   public void example() {
>     if ( System.getClass().getClassLoader() == null ) {
>       println( "Running in a conventional virtual machine." );
>     }
> 
>     println( "Running in an alternative virtual machine." );
>   }

If this is the case, we may be in violation of the spec. An alternative
is to test whether we are running within JOS by testing for the
existence of a JOS specific class or simply by checking for a certain
system property.

>   public Process getCurrentProcess() {
>     Object o = this;
>     for (;;) {
>       ClassLoader loader = o.getClassLoader();
>       if ( loader instanceof PrimordialClassLoader ) {
>         return ((PrimordialClassLoader) loader).getProcess();
>       }
>       o = loader;
>     }
>   }

Excellent. I never thought of it that way. This actually solves a
problem I have with the "host" implementation in my prototype. I am
currently using the same algorithm as Echidna which is to determine the
current process from the current ThreadGroup which doesn't work properly
with AWT threads. It's a "host" specific problem, though, and this
method would work quite well in the "native" implementation.

It's interesting, though: both algorithms might actually be useful in
different situations because they can actually return different results.
The class loader based algorithm returns the process that owns a
particular class. Usually classes you have a reference to belong to your
process, but not always. The thread based algorithm will return the
current process of the controlling thread. If a thread starts operating
on objects in another process, this algorithm will return the process
that the thread belongs to rather than the process the object belongs
to.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Thu, 13 Apr 2000 01:57:54 -0400 (EDT)
Date: Thu, 13 Apr 2000 01:57:54 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

	(Boy, is this late!)

	OK, just to make sure I got your proposal straight: we have
multiple native primordial classloaders to generate our disjoint
classloaders for multiple processes.  ONLY a NPC may attempt to optimize
memory by sharing a class definition, and ONLY with another NPC, and ONLY
if that class definition is the same, which you propose to decide based on
the archive age and location.  Furthermore, casts between different
classloaders are allowed ONLY if (a) the process has asked for and
recieved permission to directly access objects of another process and
(b) that object's class was loaded by a primordial classloader, AND its
definition shared with the accessor's primordial class loader.

	I checked Serializable and RMI, and RMI is built on Serializable,
which requires that the de-serialization method handle an excess or a
shortage of fields without throwing an exception.  (And that the class to
which you're de-serializing supports a no-argument constructor, presumably
so that it's in a consistent state if the de-serializer can't do anything
useful with it.)  This means that all legacy IPC with objects will be
handled correctly and automatically.

	That is, the only time we intend to allow illegal casts is in the
special case of shared memory, which, existing outside the scope of the
JVM spec, means we can do whatever we want with it.  Our interface to
sharing memory* will necessarily be native, so we can check /when the
object is shared/ if the class definitions in the primordial loaders
(which means they /can't change/) are the same, and allow the share to
take place.  (Naturally, we have to recursively check interfaces and
superclasses.)  This means the interpreter does /not/ have to check
references to an object of a given type as being that given type except
during casts.  (That is, the overhead is marginal, because you only check
for illegal-but-allowed casts during an instanceof operation, which
already takes a 'long' time.)

	So far, so good.  In fact, the VM spec specifically allows the
primordial class loader to be /anything/, going on to say that it usually
loads pre-compiled code from the local filesystem.  So here's the
question: when, if at all, will an application want to use direct object
sharing on a class not located on the local filesystem (by the NPC)?  
Naturally, we can just say never, because the application has to be
specifically written for /our/ shared memory, but we don't want to blindly
impose limitations on JOS.  Let's look at the question another way,
because I'm having a hard time coming up with a good answer: what, if
anything, do we lose by disallowing non-primordial class sharing?  Let's
look at it slowly.  The objective of threading is to share memory between
processes, basically.  So why would separate processes need or want to
share memory?  You never /need/ to share objects, because anything you can
program with shared memory, you can likewise program with message-passing.  
(And vice-versa, actually.)  So you must want to share objects for
efficiency -- but if the two process are pieces of the same program, why
aren't they threads?  The only reasonable answer is efficiency between
separate programs.  (If you can't handle converting statics into variables
on a thread, I'm not sure I want you programming my O/S :)  Seriously, I
can't think of a reason why a single program would /require/ multiple
processes if threads were available.)

	So we're down to the case of efficient communication between
separate programs for when we're looking at when we're allowing illegal
casts, and the question is if separate programs should expect that
custom class-loaded classes be present in other processes.  I think it's
reasonable to say that no programmer would expect his custom class-loaded
classes to cast to someone elses.  (This is not an /exact/ reversal of my
prior position. :))


	*phew*  In short, it seems reasonable to adopt Ryan's proposal
... for a conventional native primordial classloader.  Gilbert's previous
emails offer the intriguing possibility that one could allow Java code to
be the primordial classloader.  Oh, before I go any further -- something
rather important just dawned on me.


	There is NOT necessarily a conflict between a bytecode cache and
Ryan's proposal.  There are two types of 'bytecode' cache, I think: the
first is to cache the whole class, and the second to cache method
bytecode.  I'll address the second one first.  A (shared or not) class
definition (JavaClass) includes a pointer to a MethodList, which in turns
retains pointers to blocks of bytecodes which specific methods execute.  
These bytecode blocks are the only blocks of the classfile which decaf
actually saves -- everything else is converted into an internal form more
amenable to manipulation and (hopefully!) efficiency.  This internal form
-- which is the class definition Ryan and I are now agreeing on how to
share -- replaces the class file bytes.  Now, any shared class
automatically shares its method bytecode, which is the only part of the
classfile bytecode decaf bothers to save.  However, non-shared classes do
/not/ share their method code or class definitions, even if they happen
to be identical.

	Summary: my code, as amended by Ryan's proposal for multiple
processes, already does almost everything a bytecode cache would do.  The
interesting case is sharing bytecode or class definitions between classes
which happen to be identical even if they're not shared.  How could this
be done?  (It may, in practice, depending on the number of custom
clasloaders, not turn out to be useful.)  Every classloader, custom or
not, must eventually call defineClass() on an array bytecode in order to a
Classb object back.  Suppose we insert the bytecode cache there?  (If this
is what you had in mind, Gilbert, my apologies.)  All the bytecode that
passes through defineClass() is intern'd along with the class definition
generated by it, indexed by classname+classloader.  Every time
defineClass() is called (which, requiring a name, won't be horribly
inefficient), the bytecode is checked against the intern'd bytecode.  If
they differ, another entry is added.  If they're the same, the intern'd
class definition (pointer) is returned, and it's used.  Because this only
affects /where the definition is/ (and, in turn, where the bytecode
definition is), it won't change the way the classloader maintains its
tables for checking casts**.  That is, since a classloader caches and
maintains in its name/loader pair tables JavaClassInstances, not
JavaClasses, everything will behave appropriately -- there will still be a
separate entry for separate classloaders.  This cache does NOT remove the
disk access (etc) required to find/generate the bytecode, but it does cut
down on memory footprint, assuming the classfile size is small relative to
the internal representation size * number of duplicates (== number of
custom classloaders); naturally, if this turns out to be inefficient, we
can do something similar for method code only.  (Where the internal rep
and bytecode are identical, so any non-duplication is saving.) Caching the
disk access (etc) is the responsibility of the loader or its
filesystem/URI/compiler/etc.

	
	Returning back to the topic (remember what it was?  I was just
about to tell you about Gilbert's interesting proposal), it seems like we
could implement the primordial classloader in java -- perhaps as a URI
loader -- if, and only if -- it could guarantee correct sharing as Ryan
defined it.  (That is, completely transparent to a custom classloader.)  
That sharing could be none, it could time/location based, or it could be
based on a bytecode cache, so long as the cache maintained coherency
against its source.  (Which may well require it to be a space-only saving
cache!)  The interpreter, frankly, doesn't give a damn.  The primordial
classloader just has to be able to (correctly) hand it JavaClassInstances
upon request.  (And throw the flag in a JavaObject if it's a candidate for
'illegal' casting.**)

-_Quinn

* Where memory and object/field references are isomorphic in Java, which
is why disjoint classloaders are equivalent to processes, which are
defined by separate memory spaces.

** decaf doesn't cache name/loader pairs right now, but it needs to.  I
think, in general, that name/loader pairs can be stuffed into the
ClassLoader class and maintained in calls to defineClass() and imMelting()
calls generated by the garbage collector.  Throwing the "potential illegal
cast" flag in JavaObject changes the cast-checking algorithm to ignore the
second field during its comparisons.






From ryan@whitewolf.com.au Thu, 13 Apr 2000 16:36:38 +1000
Date: Thu, 13 Apr 2000 16:36:38 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

"Todd L. Miller" wrote:

>         (Boy, is this late!)

That's fine - thanks for finally giving me a chance to sleep :-)

>         OK, just to make sure I got your proposal straight: we have
> multiple native primordial classloaders to generate our disjoint
> classloaders for multiple processes.

I wasn't thinking they'd be native, but if that's easier to do... I'd
actually prefer to do it Gilbert's way.

However, the KernelClassLoader proposed in one of my recent emails would
have to be native, now that I think about it. Or maybe not. hmm...
Anyway, it would be a big plus to be able to use Java to implement the
primordial class loader's responsibilities, particularly class
definition sharing and reading classes from the CLASSPATH.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Thu, 13 Apr 2000 02:56:10 -0400 (EDT)
Date: Thu, 13 Apr 2000 02:56:10 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> However, the KernelClassLoader proposed in one of my recent emails would
> have to be native, now that I think about it. Or maybe not. hmm...
> Anyway, it would be a big plus to be able to use Java to implement the
> primordial class loader's responsibilities, particularly class
> definition sharing and reading classes from the CLASSPATH.

	OK -- /I/ think doing it natively will be easier, if for no other
reason than we'll be /sure/ that the problems with it aren't in the
Java/native interface we'd be simultaneously debugging.  OTOH, it is a
design goal to have as much Java as possible, and it will be possible to
have a Java primordial classloader once we dispense with the
bootstrap.  And yes, the boostrap will have to be native.  I happen to
disagree with your implementation; both current boot mechanisms provide a
way -- that we don't have to maintain! -- to load the classfile into RAM
somewhere, and the ramdisk code is well set up already.  We load stuff
with the current code (more or less) until we can hand off to the Java
loader.  That loader, in turn, is responsible for bootstrapping a
filesystem; it will be handed the ramdisk pointer and free that RAM once
it has successfully loaded classes from the filesystem.  (and/or we/it
could mount the ramdisk as a fs until it mounts the real one, and then
unmount, which would free it for us.  whatever.)

-_Quinn





From ryan@whitewolf.com.au Thu, 13 Apr 2000 17:18:59 +1000
Date: Thu, 13 Apr 2000 17:18:59 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] [multiple process] Is it that simple?

"Todd L. Miller" wrote:

>         OK -- /I/ think doing it natively will be easier, if for no other
> reason than we'll be /sure/ that the problems with it aren't in the
> Java/native interface we'd be simultaneously debugging.

Fair enough. I don't think I know enough about the internals of decaf to
have much say in its development process. My input will mostly be higher
level design issues.

> And yes, the boostrap will have to be native.  I happen to
> disagree with your implementation; both current boot mechanisms provide a
> way -- that we don't have to maintain!

Sorry, it's fair enough to use an existing boot loader if it already
works. The only reason I bothered to imagine how one might work was to
ensure that classes may be correctly shared between the
KernelClassLoader and the primordial class loaders. I guess it is
possible to still achieve this through a third party boot loader, just
less efficiently. But it's not as important an issue as I thought it
was.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From peter.schuller@infidyne.com Thu, 13 Apr 2000 17:33:32 +0200
Date: Thu, 13 Apr 2000 17:33:32 +0200
From: Peter Schuller peter.schuller@infidyne.com
Subject: [JOS-Arch] [multiple process] Is it that simple?

> look at it slowly.  The objective of threading is to share memory between
> processes, basically.  So why would separate processes need or want to
> share memory?  You never /need/ to share objects, because anything you can
> program with shared memory, you can likewise program with message-passing.  
> (And vice-versa, actually.)  So you must want to share objects for
> efficiency -- but if the two process are pieces of the same program, why
> aren't they threads?  The only reasonable answer is efficiency between
> separate programs.

There may be another reason, depending on how one implements security. There
is often a need for an appliction to switch identity before running a piece
of code. The perfect example would be a web server. CGI scripts are usually
executed "as" the user who owns the file (but the equivalent is not possible
with servlets and JavaServer Pages using todays JVMs).

A Java based operating system should probably provide an API through which
applications can assume the identity of a user (provided that the "current"
user has sufficient access to do so).

When writing a Java application, one wants it to run on any JVM - not just
on JOS. This means that the code the switches identity will (in many cases)
have to be the only JOS-specific code. If sharing of objects across
processes is possible, the rest of the code (in the web server, or whatever
it is) could access data just as if it was just another thread - with the
difference that it's actually a process. In a conventional JVM, it would
indeed be a thread.

Not many would implement an IPC-by-serialization technique just to make it
run on JOS. This would, however, be required to achieve proper handling of
security on JOS, while at the same time making the application run in a
conventional JVM.

This assumes that the security model doesn't allow for a thread to be owned
by another user than other threads in the same process. If this would be
possible to implement, it would probably be a better solution (IMHO).

If I'm missing something blatantly obvious, please forgive me.

-- 
/ Peter Schuller, InfiDyne Technologies HB

PGP userID: 0x5584BD98 or 'Peter Schuller <peter.schuller@infidyne.com>'
Key retrival: Send an E-Mail to getpgpkey@scode.infidyne.com
E-Mail: peter.schuller@infidyne.com Web: http://scode.infidyne.com





From gchii@mindspring.com Thu, 13 Apr 2000 09:20:24 -0400
Date: Thu, 13 Apr 2000 09:20:24 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Boot classes

Classes required at boot-time are "boot classes". A boot class must be
loaded before the virtual machine is able to use a custom class loader.

Classes are organized into packages. Packages required at boot-time are
"boot" packages. Classes should be included or excluded from boot-time at
the package level.

In general, there are three ways to think about boot classes.

1. Stored in many, many files. In a classic design, boot classes are loaded
through a primordial class loader. When a classic virtual machine is
"booted" or started up, it depends on a pre-existing file sub-system.
Originally, a CLASSPATH enabled a primordial class loader to load bytecode
from class files.

2. Stored in two files. Continuing to use a primordial class loader, a
CLASSPATH was re-invented to include archive files (.cab, .jar and .zip).
At first, compressed archives were not supported. Later, it was. Again,
CLASSPATH enabled a primordial class loader to load bytecode from class
files stored alone or in an archive. This is basically how decaf works.

3. Stored in one file. A virtual machine and its boot packages can be
stored in a single executable file. Boot packages are statically linked
with a virtual machine, rather than dynamically linked. The two become
inseparable.

There are many reasons why I'd like to store a virtual machine and its boot
packages in a single file. Here are a few.

A. The startup sequence does not depend on a pre-existing file subsystem.
The mechanism for loading or downloading a boot image is encapsulated by
GRUB or Etherboot. No modules are required.

B. Bytecode is binary data. For boot packages, and boot packages only,
bytecode is a binary resource. Like icons and string tables, boot packages
can be statically linked to an executable image.

C. When bytecode is statically linked to an executable image, both Linux
and Windows correctly treat it as read-only. A bytecode resource is never
written to a swap file because it is always available in the original
executable image on disk. When bytecode is translated into a class
definition and then a class, it is not discarded. The space is never freed.
This means that the Code attribute does not have to be copied into a
read-write memory block.

D. When bytecode is statically linked to an executable image, GRUB and
Etherboot correctly tread it as read-only. No additional module is
required. When bytecode is statically linked to decaf, a primordial class
loader can always get the bytecode. It is guaranteed. No CLASSPATH is
required for boot packages.

We are again talking about the same thing in different context. Both a
system-process and a user-process class loader should implement the same
PrimordialClassLoader interface.

A kernel class loader is a kind-of primordial class loader. A kernel class
loader is used to load classes in the system process. It is a
system-process class loader. It loads init.class.

A user-process class loader is a kind-of primordial class loader. A
user-process class loader is used to load classes in a user process.

-----

A kernel class loader might use classes.zip, bytecode resources, or some
other method. It might depend on CLASSPATH or it might ignore it. It always
loads a system process. It exists before a file subsystem.

On the other hand, a user-process class loader may or may not depend on
CLASSPATH. CLASSPATH exists only for backward compatibility.

Here's a decaf scenario.

1. A virtual machine is loaded as an executable image.
2. The classes.zip archive is loaded as a module.
3. A kernel class loader is used to boot-strap the system process.
4. At least the java.lang, java.io, java.net and java.util packages are
available in classes.zip.

(Up to this point, nothing has changed.)

4. The init class loads a URL-based class loader, also stored in classes.zip.
5. The init class uses the URL-based class loader to download an
implementation of some file subsystem.
6. Many more class files, archives and package files become available
through the new file subsystem.
7. The init class launches a Java application, inside a new process, with a
new CLASSPATH and a new primordial class loader that uses CLASSPATH.
8. The Java application runs unaware that it is running on decaf. It is
unaware how it runs side-by-side with other processes.

A command line shell might be the second process. It could be a standard
Java application. The shell and the system process (init) are isolated from
each other by the process model.

In turn, the command line shell can display a list of current processes,
change the DIRECTORY, CLASSPATH and PACKAGEPATH environment variables,
launch a new process, kill a process, redirect the output from one
application to the input of another.

-----

How should they be linked? There are two good ways to do this.

1. Boot packages can be stored in an archive (like classes.zip) and the
archive concatinated to the virtual machine's executable image. A kernel
class loader would find the archive just like it finds any binary resource.

2. Boot packages can be compiled into a static library. Binary resources
can be stored in C++ source code using a code generator. By compiling the
C++ code and using a standard linker, boot package resources can be stored
in a static library.

Personally, I like method 2 for at least the following reason. When binary
resources are stored in C++ source code, they become C++ classes. The C++
class design enables an abstraction of a resource. It is no longer a raw
binary resource from the viewpoint of all the other classes. I have been
working on a translator. It does work. I have documented this on JOS Wiki,
in an article called BytecodeResource.





From tmiller@haverford.edu Thu, 13 Apr 2000 15:32:29 -0400 (EDT)
Date: Thu, 13 Apr 2000 15:32:29 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Is it that simple?

> This assumes that the security model doesn't allow for a thread to be owned
> by another user than other threads in the same process. If this would be
> possible to implement, it would probably be a better solution (IMHO).

	I agree, but I haven't gotten around to reading Ryan's proposal
yet to see how it might work.  (Apologies, Ryan.)

-_Quinn





From ryan@whitewolf.com.au Mon, 17 Apr 2000 01:08:00 +1000 (EST)
Date: Mon, 17 Apr 2000 01:08:00 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Release of rheise.os - multiprocess Java layer for JOS

After a fascinating discussion on the arch@jos.org list about how to
support multiple processes and IPC in JOS, I have finally put together
what could become a foundation for the Java layer of JOS:

...
rheise.os is a multiple process Java execution environment that can run
on top of a standard JVM (with limited support) or on top of a Java
Operating System kernel with native hooks to support multiple processes.
It is intended to be used with the JOS kernel, in which case the
rheise.os package prefix may be changed to jos.

rheise.os provides an API for managing processes, users and security in
a Java Operating System. This functionality is supported both when
running on a host JVM and when running on a native kernel, thus allowing
JOS developers to work on the upper layers of the operating system
architecture before the kernel is complete.
...

Currently you can run multiple process in separate namespaces on a
standard JVM. There is a sample program that demonstrates the security
model employed. In addition, I have included a simple window manager and
desktop environment based on swing's JDesktopPane. This only half works,
so contributors are welcome.

	http://www.progsoc.uts.edu.au/~rheise/projects/rheise.os/

Please forgive the lack of docs, and lack of comments, and lack of code
in some parts :-) It's late Sunday night over in this part of the world
(Australia) so this release is sort of a rush job before the work week
starts...

I hope we will start to see some more programming activity on the JOS
architecture from here on.

Please direct follow-up posts to arch@jos.org only.

-- 
Ryan Heise (arch@jos.org list admin)

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Wed, 19 Apr 2000 01:11:12 +1000 (EST)
Date: Wed, 19 Apr 2000 01:11:12 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os - update

I have worked out a way to load a separate version of java.lang.System
for each process in a host JVM environment. I am still amazed that it
actually works, and yet it is so simple (of course, things are always
simple in hindsight).

The problem with loading a separate version of java.lang.System for each
process is that it can no longer access its native methods. Also, it is
difficult to move a single system class from the host primordial class
loader to the process class loader without causing linking errors.

To solve the first problem, I load my own version of java.lang.System
into each process which delegates native method calls to the "real"
java.lang.System class. You might wonder how one System class can
communicate with another System class with exactly the same name. You
/can/ use reflection, but I found a simpler way: I defined an additional
class called java.lang.SystemWrapper which is loaded by the same class
loader as the "real" System class (ie. the host primordial class
loader). My System class delegates to SystemWrapper, which delegates to
the System class that it resolves to. No reflection is needed.

_quinn will be pleased to note that this passes the "ultimate test"
which is to pipe the output of one program into another. In fact I have
a demo program which does just that:

$ rheise.test.Echo hello world
hello world
$ pipe rheise.test.Echo hello world | rheise.test.Reverse
world hello

I have released version 0.1.1 of rheise.os which contains these changes:

	http://www.progsoc.uts.edu.au/~rheise/projects/rheise.os/

Note that since I have included my own version of java.lang.System, you
should make sure rheise.os appears in your CLASSPATH _after_ your JDK
classes.zip. My System class is not meant to replace the JDK one, it is
dynamically loaded in at runtime and cooperates with the standard one.

Also, I have assumed that your system classes are in classes.zip. If
they are not, you need to edit a source file, as described in the docs.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Tue, 18 Apr 2000 12:56:06 -0400 (EDT)
Date: Tue, 18 Apr 2000 12:56:06 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os - update

> _quinn will be pleased to note that this passes the "ultimate test"
> which is to pipe the output of one program into another. In fact I have
> a demo program which does just that:

	Bravo!  Now I /must/ take a look at this as soon as I can.  Do I
understand it correctly that the wrapper class is necessary only to access
native methods?  That is, if the JVM handled this issue, you'd be able to
pipe together 'legacy'  (e.g. System.in/out) programs without any changes?

-_Quinn





From ryan@whitewolf.com.au Wed, 19 Apr 2000 06:45:57 +1000 (EST)
Date: Wed, 19 Apr 2000 06:45:57 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os - update

On Tue, 18 Apr 2000, Todd L. Miller wrote:

> > _quinn will be pleased to note that this passes the "ultimate test"
> > which is to pipe the output of one program into another. In fact I have
> > a demo program which does just that:
> 
> 	Bravo!  Now I /must/ take a look at this as soon as I can.  Do I
> understand it correctly that the wrapper class is necessary only to access
> native methods?  That is, if the JVM handled this issue, you'd be able to
> pipe together 'legacy'  (e.g. System.in/out) programs without any changes?

Correct. There is one thing I forgot to mention in my last email,
though. Because of the way I have loaded te classes, the per process
System class will only be used if the caller class was loaded in the
process's class loader. Because programs usually call
System.out.println() directly, effectively this works virtually all the
time. However, if you call a method on another class loaded by the
primordial class loader, and it invokes System.out.println(), it will
resolve to the "real" System class ignoring any changes you've made to
your process's System.out variable(*). I think this is a very minor
point though, especialy since the host version doesn't care if it
doesn't work 0.001% of the time. The native version should.

(*) Actually, System.out is defined in the spec to be a final but I
redefined it as a variable so I don't need a native method to set it.
Programs won't exploit this however since they will be compiled against
the "real" version of System.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Wed, 19 Apr 2000 09:12:46 +1000
Date: Wed, 19 Apr 2000 09:12:46 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os - update

Ryan Heise wrote:

> I have released version 0.1.1 of rheise.os which contains these changes:

I suppose I should mention what the system requirements are:

JDK 1.1.x
Swing 1.1.x (to get window manager working)

I haven't tested any other combinations but Peter Schuller has reported
that it does not work on JDK 1.2. JDK 1.2 appears to have introduced new
loader constraints.

I am currently working on getting the other 0.01% of java.lang.System
functioning, so if someone else thinks they can get JDK 1.2 to work,
that would be great.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Wed, 19 Apr 2000 00:07:44 -0400 (EDT)
Date: Wed, 19 Apr 2000 00:07:44 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os questions

( Not entirely on topic -- the Blackdown 1.1.8 JDK doesn't come with
Swing, does it? )

	Clarification: the SystemObjects argument to createProcess is the
set of statics in java.lang.System that must be replaced from process to
process, right?

	In HostInit, why are you generating an instance and then
immediately resetting it to the corresponding static?  Does this have
something to do with references/classloading?

	The 'nativ' stuff doesn't ever seem to touch System -- is this
just not coded?  Or am I missing something?


	Is this summary correct?  rheise.os needs two things from the
native code before we can call it jos.os -- a completely empty classloader
so that code can't call classes loaded in the primordial classloader and
thereby bypass our rewriting of the statics; and the ability to correctly
handle native calls wrapper classes don't have to be written for every
static native method.


	Otherwise, I'm very impressed.

-_Quinn





From ryan@whitewolf.com.au Wed, 19 Apr 2000 15:56:35 +1000
Date: Wed, 19 Apr 2000 15:56:35 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os questions

"Todd L. Miller" wrote:
> 
> ( Not entirely on topic -- the Blackdown 1.1.8 JDK doesn't come with
> Swing, does it? )

I don't think so. Swing is an add-on for JDK 1.1, whereas it is a part
of JDK 1.2.

>         Clarification: the SystemObjects argument to createProcess is the
> set of statics in java.lang.System that must be replaced from process to
> process, right?

Correct. Sort of like the optional envp argument to exec() on UNIX.

>         In HostInit, why are you generating an instance and then
> immediately resetting it to the corresponding static?  Does this have
> something to do with references/classloading?

No, that line is not necessary - it returns exactly the same instance in
this case. The line is present just for the sake of consistency - the
process manager is always obtained through the get() method before it is
used. I can remove it if you think it's misleading (or maybe I could
even put a comment in!!! :-)

>         The 'nativ' stuff doesn't ever seem to touch System -- is this
> just not coded?  Or am I missing something?

No, it's incomplete because we have not yet written our JOS version of
the System class. This native implementation of java.lang.System needs
to provide a way to be initialised and I cannot initialise the System
class in the new process unless I know how to initialise it. Since I
wrote the java.lang.System class for the host implementation, I know how
to initialise it.

This is one of the things we need to do to hook up rheise.os to the JOS
kernel. We need to grab CLASSPATH and add all the support it needs to
work with JOS. Then we can modify NativeJavaProcess to make use of this
support.

>         Is this summary correct?  rheise.os needs two things from the
> native code before we can call it jos.os -- a completely empty classloader
> so that code can't call classes loaded in the primordial classloader and
> thereby bypass our rewriting of the statics;

This is how the NativeProcessClassLoader is at the moment. There are
other native specific ProcessClassLoader issues which I'll need your
help to solve:

NativeJavaProcess.createClassLoader() should construct an instance of
NativeProcessClassLoader, but what class loader should /it/ belong to?
The class loader of the new process, or the class loader of the current
process? If it should belong to the new process (that is where it will
be referenced from the most), then we'll need some native code to set
that up. In other words, NativeJavaProcess.createClassLoader() should be
defined as a native method.

And the same goes for NativeProcessManager.constructProcess() which
should perhaps return a NativeJavaProcess that belongs to the new
process's class loader. Since this is impossible (chicken and egg), we
might provide a native call to assign the class loader to the process's
class later on in the sequence (and maybe reuse this technique for
assigning the class loader to the new class loader itself).

Notice that if we do this, we are demonstrating the first use of
inter-process object sharing. The calling process needs a reference to
the process it is creating, and the program running in the new process
will need to be able to reference itself too.

Now, the alternative is to define processes so that their class loaders
are not completely disjoint, but always share java.lang.Class,
ClassLoader and Object so that the instance of the process's class
loader can be shared between the calling process and the new process
without any special JVM support. But we still need a way to share the
JavaProcess instance. In the host implementation, I share the
JavaProcess Class too, but the host implementation doesn't particularly
care about doing this properly anyway.

To consider the issues involved here, it helps to look at the
ClassLoader.loadClass() method:

	public Class loadClass(String name)
		throws ClassNotFoundException;

This method is returning an instance of java.lang.Class - the same
java.lang.Class Class seems to be used by both class loaders meaning
that in a standard JVM, class loaders can't be completely disjoint as
well as being at all useful. With our JVM, which will support
interprocess object sharing, this will be possible.

> and the ability to correctly
> handle native calls wrapper classes don't have to be written for every
> static native method.

Native wrappers are only needed for the host implementation. The native
implementation should allow native method invocations for any class
loaded by any ProcessClassLoader. But this is more a responsibility of
decaf than of rheise.os, so it's not really something rheise.os needs
support before it can be considered renameable to jos.*.

Of course, the native implementation of rheise.os isn't complete, but
the structure is in place to support decaf/JJOS on one side, and the
Java layer on the other side. It's a matter of deciding whether or not
we want to use this as the structure to build around.

>         Otherwise, I'm very impressed.

Likewise with decaf, which is like Jupiter to my Pluto :-)

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Wed, 19 Apr 2000 16:10:10 +1000
Date: Wed, 19 Apr 2000 16:10:10 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os questions

Ryan Heise wrote:

> Of course, the native implementation of rheise.os isn't complete, but

On this point, the nativ package in the latest release is slightly out
of date. NativeProcessManager.getCurrentProcess() is an old
implementation. It should probably just inherit the implementation from
ProcessManager. It can be overridden later if there is a better way to
do it in the native environment.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Wed, 19 Apr 2000 02:46:31 -0400 (EDT)
Date: Wed, 19 Apr 2000 02:46:31 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Java Processes: Final Summary?

	[BTW, the footnotes aren't numbered correctly because I though of
them out-of-order.]

	Processes can be defined as two or more threads with disjoint
memory spaces, where each group of threads (ThreadGroup or not) which
shares a memory space constituting a process.  Because Java lacks
pointers, disjoint namespaces are sufficient to ensure disjoint memory
spaces.  (So long as object references are not shared between the threads
we wish to distinguish as separate processes.)  Java namespaces are
managed by classloaders; therefore, disjoint classloaders generate
processes.

	While Java lacks pointers, and is therefore that much less
vulnerable to the class of potential problems usually cited as motiviation
for establishing (conventional, native) processes in (conventional,
native-code-oriented) operating systems, the single-process assumptions
made in the Java class libraries and virtual machine spec lend us ample
reason to desire multiple Java processes.  (Where my desire is to pass the
'ultimate test': piping the output of one legacy program into the input of
another.)  The desire for multiple Java processes in a single JVM stems
from two sources: first, the JJOS kernel's current lack of multiple native
processes (that is, we can't take the 'easy way out' and run multiple
instances of decaf); second, the potential space efficiency benefits.  A
more secondary concern is the handling of shared-object IPC.

	The insight of disjoint classloaders generating processes combined
with an examination of the JVM spec leads to the realization that we must
'clarify' it to allow more than a single primordial classloader******.  A
Java application can not (and must not) be able to distinguish between
running in its own (conventional) JVM and in its own primordial
classloader.  That is, the from the application's point of view, a JVM is
comprised of the statics in the classes returned by findSystemClass().  
This clarification, then, gives us multiple processes in a single JVM, but
quite inefficiently (sp?).  Efficiency is gained by sharing class
definitions***, which are the portions of class invariant under writes to
static variables.  (From the implementation standpoint, a class definition
is the everything in the native representation of class that isn't the
value of the statics.)  This sharing of class definitions -- that is,
/not/ reloading the whole class library for each process -- must be done
very carefully to ensure two things: type-safety* and transparency.  
(That is, legacy applications must behave identically in decaf with
multiple processes as in decaf with a single process.)

	A share may be attempted if and only if****

(1) The class definitions involved are identical.  This may be determined
	in an implementation-dependent manner. ******  Likewise,
	implementations would determine when to check for class definition
	shares based on their criteria for equality.

(2) The classloader which is defining the class is a (native)** primordial
	class loader, and the cached class definition under consideration
	for sharing was also loaded/defined by a (native)** primordial
	class loader.

	These conditions have two sources; the source for rule one is
rather obvious.  The source for rule two is the requirement that legacy
programs which utilize custom classloaders must operate properly; that is,
custom classloaders do not expect to share definitions unless they
explicitly arrange for it, and it appears to be impossible to assure the
correctness of any implicit sharing we may arrange.


	With processes and an object-oriented language, the natural
extension is object-oriented IPC.  Message-based OO-IPC is already handled
by the class libraries and conventional JVM spec.  (See my earlier mail
about Serializable and RMI.)  Shared-memory (shared-object) OO-IPC
requires special handling by the JVM.  Without a spec, we (JOS) may define
our own.  The key realization for shared-memory OO-IPC is that the
classloaders, being disjoint, do not share classes, and thus, the object
can not be cast from one process to another.  We solve this by allowing
'illegal' cast operations as follows:

(1) The security system must OK the object share.  This allows us to flag
	the object as shared for efficiency.
(2) The object's class definition must be shared between the two
	processes.  (Implying it was loaded by a (native)** primordial
	classloader.)


	Furthermore, we must assure that native methods are accessible
from any classloader which would 'normally' (e.g. in another JVM
process) have access.  Currently, as JJOS/decaf has one library and one
revision of it loadable at a time, we don't need to worry about
this; everyone's native calls resolve the same way.  Later, it seems that
a model more-or-less identical to the one above described for sharing
class definitions would be applicable to native methods; in fact, in may
be possible to fold the location (e.g. instance of loaded library for this
classloader) into the class definition, and have everything work out
auto-magically.  (I'll need to read up more on libraries for this.)

-_Quinn

* Amusingly enough, Java isn't type-safe anyway.  I don't have the
(academic) citations handy, unfortunately.  Likewise, Java's memory model
-- which I'm mostly ignoring, in part because of this -- is horribly
broken.  Bill Pugh, who's written some papers about it, seems to hold the
opinion (based on my second-hand information) that Sun's VM implementation
has a memory model which makes sense but doesn't follow the spec...

** Gilbert has some very interesting ideas about Java primordial
classloaders that I must admit I'm avoiding because they'd confuse things
(or me, anyway!) immensely before I get the processes thing nailed down.

*** A later refinement (like the above footnote) may be gained by
utilising a bytecode cache; see other emails for my thoughts on that.  
Like the previous footnote, I'm ignoring a perfectly good idea because it
might confuse me.

**** The phrase "if and only if" means I'm suggesting that when these
conditions are met, you /must/ share the definition.

***** Ryan suggests classfile/archive location and modification
date.  Gilbert suggested integration with the bytecode cache, and a
straight call to memcmp(); I've commented on both of these
before.  However, it occured to me that location & date could utilise URIs
instead of filenames, which would allow the primordial (java or
otherwise) classloaders to do more interesting things and still share
class definitions; one would expect the classloaders which implement
remote URIs to use a bytecode cache.

****** Ryan's rheise.os package demonstrating that a very large chunk of
the functionality can be duplicated with smoke & mirrors rather than
native support. :)





From tmiller@haverford.edu Wed, 19 Apr 2000 02:48:17 -0400 (EDT)
Date: Wed, 19 Apr 2000 02:48:17 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os questions

> On this point, the nativ package in the latest release is slightly out
> of date. NativeProcessManager.getCurrentProcess() is an old
> implementation. It should probably just inherit the implementation from
> ProcessManager. It can be overridden later if there is a better way to
> do it in the native environment.

	Probably not.  We want decaf to know as little as practical about
processes to ensure that its behaviour is not distinguishable from a
conventional/single-process JVM.  We'll see how it works out.

-_Quinn





From tmiller@haverford.edu Wed, 19 Apr 2000 03:33:32 -0400 (EDT)
Date: Wed, 19 Apr 2000 03:33:32 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os questions

	[It's getting really late over here, so if this doesn't make any
sense, let me know and I'll give it another try...]

> I don't think so. Swing is an add-on for JDK 1.1, whereas it is a part
> of JDK 1.2.

	Okay, makes sense.  I'll look into finding the right version of
swing, then.

> Correct. Sort of like the optional envp argument to exec() on UNIX.

	Ah, of course.

> No, that line is not necessary - it returns exactly the same instance in
> this case. The line is present just for the sake of consistency - the
> process manager is always obtained through the get() method before it is
> used. I can remove it if you think it's misleading (or maybe I could
> even put a comment in!!! :-)

	Just put in a comment -- something along the lines of "I'm doing
this in case I ever do something terrible and strange to the get() method
in these classes that would cause it not to return the instance I just
generated."

> No, it's incomplete because we have not yet written our JOS version of
> the System class. This native implementation of java.lang.System needs
> to provide a way to be initialised and I cannot initialise the System
> class in the new process unless I know how to initialise it. Since I
> wrote the java.lang.System class for the host implementation, I know how
> to initialise it.

	Actually, if the java.lang.System classes have separate statics,
you ought to be able to initialize them by calling setIn/Out/Err;
everything else ought to be taken care of by the (default) static
initializers.  (That is, ideally, we don't need to change classpath's (or
whoever's) System class at all, and the process support doesn't have to
touch System unless it wants to.)  We'll see how it goes.

> This is one of the things we need to do to hook up rheise.os to the JOS
> kernel. We need to grab CLASSPATH and add all the support it needs to
> work with JOS. Then we can modify NativeJavaProcess to make use of this
> support.

	Most of the support, I believe, will be telling it not to call
library functions we don't provide in its native code. :)  (Seriously, if
you download the classpath distro, take a look at the vm/ subdirectory,
where they stick the VM-specific bits.  There isn't a whole lot in there, 
nicely enough.)

> Notice that if we do this, we are demonstrating the first use of
> inter-process object sharing. The calling process needs a reference to
> the process it is creating, and the program running in the new process
> will need to be able to reference itself too.

	In general, we want the calling process to have a reference to the
spawned process, and spawned process obviously needs to reference itself.  
The question we must address is where the class definition of that
reference should reside.  Since this OO-IPC referencing will need
'illegal' casts, the obvious answer is that the JavaProcess class needs to
be shared between the primordial loaders of each process.  Every
JavaProcess has a private reference to its classloader, which could be
used on behalf of the calling process to set whatever statics need to be
set.  (e.g. SystemObjects.)

	Currently, the host code always sets a custom classloader because
that's the only way to generate (more-or-less) disjoint classloaders.  On
the native side, that is not the case -- an empty classloader can be
generated by the decaf code.  (In fact, at some point, must be.)  My
question, then, is -- does constructProcess() (I think!) ever /need/ to
set a classloader?  Since the native code must already generate an empty
primordial classloader for the new process, does the JOS code ever need to
worry about setting the classloader of the new process?  (That is,
JavaProcess's private ProcessClassLoader reference would be a reference to
a native PCL, generated by the native call to createProcess().  (And
possibly changed to a straight ClassLoader reference.))  A method in
JavaProcess could be used to set static variables or call static methods
on its classloader, i.e.:

myChild.setStaticField( "myRandomStaticClass", "myRandomStaticField",
	myRandomSharedObject );
Object args[1]; args[0] = myPipedInputStream;
myChild.staticFunction( "java/lang/System", "setIn", args );

	where the field values/function arguments are necessarily shared
objects.  (Would have to be to be useful anyway.)

	The idea of the above is that it ought to be possible to sidestep
about half of your question/concern.  (I think.  Maybe it won't work after
I finish sleeping:))

> Native wrappers are only needed for the host implementation. The native
> implementation should allow native method invocations for any class
> loaded by any ProcessClassLoader. But this is more a responsibility of
> decaf than of rheise.os, so it's not really something rheise.os needs
> support before it can be considered renameable to jos.*.

	Right.  I meant this question in the opposite order -- what does
decaf need to do before we can rename rheise.os, which entails getting the
nativ bit working correctly.  Something that decaf needs to do is handle
native calls correctly.

> Of course, the native implementation of rheise.os isn't complete, but
> the structure is in place to support decaf/JJOS on one side, and the
> Java layer on the other side. It's a matter of deciding whether or not
> we want to use this as the structure to build around.

	It looks like it'll work, and if we blow it, we can always rewrite
it with the lessons learned.

> Likewise with decaf, which is like Jupiter to my Pluto :-)

	I believe we've found the codenames for our milestone releases. :)  
(Where the objective is to get down to the moderately-sized but extremely
hospitable 'Earth' release.)  And thanks for the compliment.

-_Quinn








From gchii@mindspring.com Wed, 19 Apr 2000 09:48:02 -0400
Date: Wed, 19 Apr 2000 09:48:02 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Kernel class loader

Eventually, something must be added to reduce redundent bytecode. It is the
right thing to do. That was my conclusion over a year ago. But, it is not a
class loader.

Whatever it is, we should first add it to a virtual machine (decaf), refine
it through experience and testing, and then -- if necessary -- add it to a
kernel (jJOS). Any virtual machine would benefit from it. When we add it to
a kernel, it can work intimately with the kerne's virtual memory manager.

Without a virtual machine, there is no class loader. A "kernel class
loader" is not a genuine class loader. It cannot return an instance of
java.lang.Class. A class loader, implemented in machine code, can be added
to decaf, not jJOS. A kernel is not a virtual machine. It has zero or more
virtual machines.

Let's say there are 100 separate processes running in decaf at once. In the
worst case, 100 separate copies of the java.* packages would be loaded into
virtual memory (assuming jJOS has virtual memory). If the java.* packages
are 20+MB, thats 100 * 20+MB or 2000+MB. jJOS would require at least a 2GB
swap partition exclusively for system bytecode.

We already know that 100 separate processes won't load every class in the
java.* packages. In the typical case, a process might use 2+MB, not 20+MB.
That's 100 * 2+MB or 200+MB. jJOS would require at least a 200MB swap
partition exclusively for system bytecode.

Together, 100 processes would typically load every class file in the java.*
packages. With a bytecode or class definition cache, jJOS would "only"
require a 20+MB swap partition exclusively for system bytecode. Bytecode
would be loaded for each process and intern'd. The intern'd bytecode might
stay in the cache for the lifetime of the kernel. The intern'd bytecode
might stay in the cache until it is no longer used by any process.

A kernel must have a bytecode cache or a class definition cache; it cannot
have a class loader. With a bytecode cache, a kernel would offer a
VM-independent interface, usable by any virtual machine. It is not specific
to decaf. A bytecode cache maps correctly to bytecode resource, where
bytecode is part of the executable image of a virtual machine. A bytecode
cache works simultaneously for any virtual machine from Java 0 through Java 2.

With a class definition cache, a kernel would offer a VM-dependent
interface. A class definition cache must be recompiled when a virtual
machine changes. That means the kernel depends on the implementation
details of a virtual machine. This undermines a kernel's ability to host
different versions of a virtual machine.

ClassDefinition and Bytecode are not the same thing. Both are needed.
Bytecode is a VM-independent design; ClassDefinition is not.

A class definition class must return an instance of ClassDefinition when
given a ClassDefinition object:

const ClassDefinition intern( const ClassDefinition *v );

It must find an existing class definition quickly and compare it with the
given class definition. If they are equal, the existing class definition is
returned. Otherwise, a new class definition is added and it's returned.

A bytecode cache is at fast or faster than a corresponding class definition
cache. A bytecode cache must return an instance of Bytecode when given a
Bytecode object.

const Bytecode intern( const Bytecode *v );

The Bytecode class knows how to decode a class file. Its getThisClassSpec()
method returns a class spec. For java.lang.Object, the class spec is
java/lang/Object. The class spec is key to a large hash table. The large
hash table contains one hash table for each class spec. In the following
example, the C++ source has been translated to the equivalent for the Java
programming language.

  public Bytecode intern( Bytecode v ) {
    String cs = v.getThisClassSpec();
    Hashtable ch = findBytecode( v );
    if ( ch == null ) {
      return null;
    }
    Enumeration list = ch.keys();
    for (;;) {
      if ( !list.hasMoreElements() ) {
        return null;
      }

      Bytecode item = (Bytecode) list.nextElement();
      if ( item.getPayload().equals( v.getPayload() ) ) {
        return item;
      }
    }
  }
  public Hashtable findBytecode( String v ) {
    cache.get( "java/lang/Object" );
  }





From gchii@mindspring.com Wed, 19 Apr 2000 09:55:40 -0400
Date: Wed, 19 Apr 2000 09:55:40 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [multiple process] Terminology

As we have seen, "redundent" classes are a good thing. "Redundent" classes
are required in order to achieve a process in bytecode. Multiple instances
of java.lang.System are required for each bytecode process. Each bytecode
process must have its own properties object, and in, out and err properties.

I think it must be a problem with terminology.

.java -> javac -> .class

.class -> byte[]
or
.class -> archve (.cab, .jar, .zip) -> byte[]
or
.class -> bytecode resource -> byte[]

byte[] -> class definition -> java.lang.Class

"Class file" is a very bad name of the raw data generated by the javac
tool. The raw data does not have to be stored (a) in a file and (b) one
class per file. Even in the Java Virtual Machine Specification, "class
file" is noted as a very bad name. Raw data generated by the javac tool is
traditionally stored in a class file, with a .class extension.

Bytecode is a single object, a byte array. A byte array is passed to the
defineClass() method of java.lang.ClassLoader. I think of the raw data
generated by the javac tool -- the entire content of a .class file -- as
"bytecode", not just the Code attribute of each method. Bytecode starts
with 0xCA, 0xFE, 0xBA, 0xBE.

A "class definition" marshals bytecode into a plethora of objects. A class
definition helps to verify bytecode before it is translated into a class.
Each entry in codepool might be a separate object. If a class definition
only uses the input stream model to read bytecode, the original bytecode
may be discarded. Once discarded, it is difficult to compare two class
definitions with so many separate objects. If a class definition uses an
alternative model to read bytecode, the original bytecode may be preserved.
Once preserved, it is easy to compare two class definitions by using
memcmp() on their corresponding bytecode. It is also easy to "compact" a
class definition, freeing its plethora of objects.

A "class" is an instance of java.lang.Class.





From gchii@mindspring.com Wed, 19 Apr 2000 12:26:14 -0400
Date: Wed, 19 Apr 2000 12:26:14 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [bytecode resource] Status report

I have finished a BytecodeResource application using the Java programming
language. It searches a directory tree for .class files and generates the
corresponding C++ source code. Basically, this puts the raw data from a
.class file into the DATA segment of your C++ program.

Instead of raw data in a ReadOnlyByteArray class, it uses a Bytecode
object. The rc_Bytecode class in C++ is a pure virtual class that, so far,
looks like this:

class rc_Bytecode {
  public:
    virtual const void *getPayload() const = 0;
    virtual size_t getSize() const = 0;

    virtual bool isError() = 0;
    virtual int getError() = 0;
    virtual void setError( int v ) = 0;

    virtual void compact() = 0;

    virtual unsigned short getConstantPoolCount() = 0;
    virtual const void *getConstantPool( unsigned short index ) = 0;
    virtual CharBuffer getThisClassSpec() = 0;
    virtual CharBuffer getSuperClassSpec() = 0;
};

The BytecodeResourse application (in Java) uses the same model as WebSource
3b (and therefore, can't find files on Linux). Once WebSource 3b runs on
Linux, BytecodeResource will run on Linux, too.





From gchii@mindspring.com Wed, 19 Apr 2000 17:57:40 -0400
Date: Wed, 19 Apr 2000 17:57:40 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [WebSource 3b] New Release

Release 2 of WebSource Version 3b is available for immediate download. The
JOSDistribution1e page on JOS Wiki has more information. The
DownloadWebSource page on JOS Wiki has the links.

Release 1 did not run without a configuration file (configuration.txt). It
failed the same way on both Linux and Windows.

1. The Runtime Edition for Release 2 includes a sample configuration file.

2. Release 2 runs properly without a configuration file.





From tmiller@haverford.edu Wed, 19 Apr 2000 20:20:06 -0400 (EDT)
Date: Wed, 19 Apr 2000 20:20:06 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [multiple process] Kernel class loader

	I think I can agree with that; I mentioned earlier that class
definition and bytecode caches can co-exist.  My hope is that the bytecode
cache, as a kernel-level construct, will be transparent to decaf, so it
will adopt bytecode caching once the code is ready.

-_Quinn





From tmiller@haverford.edu Wed, 19 Apr 2000 20:24:06 -0400 (EDT)
Date: Wed, 19 Apr 2000 20:24:06 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [bytecode resource] Status report

> I have finished a BytecodeResource application using the Java programming
> language. It searches a directory tree for .class files and generates the
> corresponding C++ source code. Basically, this puts the raw data from a
> .class file into the DATA segment of your C++ program.

	I'd be interested in seeing this.  It may be the best way to
handle the bootstrapping problem.

-_Quinn





From ryan@whitewolf.com.au Thu, 20 Apr 2000 10:05:10 +1000
Date: Thu, 20 Apr 2000 10:05:10 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os questions

"Todd L. Miller" wrote:
> 
> > On this point, the nativ package in the latest release is slightly out
> > of date. NativeProcessManager.getCurrentProcess() is an old
> > implementation. It should probably just inherit the implementation from
> > ProcessManager. It can be overridden later if there is a better way to
> > do it in the native environment.
> 
>         Probably not.  We want decaf to know as little as practical about
> processes to ensure that its behaviour is not distinguishable from a
> conventional/single-process JVM.  We'll see how it works out.

I'd like to make it generic, but I suspected that things might get
environment specific when we start to consider how we do object sharing
is done. Consider callback methods from the AWT system. The AWT system
will invoke code in your process, but the thread executing your code
actually belongs to the AWT process. I'd like getCurrentProcess() to
return the process that owns the code being executed in this case. Maybe
it's possible to keep it generic. I'll know when I get around to looking
at it.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Thu, 20 Apr 2000 12:05:02 +1000
Date: Thu, 20 Apr 2000 12:05:02 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os questions

"Todd L. Miller" wrote:

>         Actually, if the java.lang.System classes have separate statics,
> you ought to be able to initialize them by calling setIn/Out/Err;
> everything else ought to be taken care of by the (default) static
> initializers.  (That is, ideally, we don't need to change classpath's (or
> whoever's) System class at all, and the process support doesn't have to
> touch System unless it wants to.)  We'll see how it goes.

The idea was that setIn() is for user programs (it checks the security
manager), and a special init() method would only be executed by JOS and
it would just set the attribute values directly.

I see your point that calling setIn() saves us from modifying classpath.
Maybe there is a third option, though:

It seems to make sense for the static initializer to handle it all, as
it does in classpath. It calls on FileDescriptor.in to initialise
System.in and it could do a similar thing for system properties (and the
security manager in some cases). We just need to set up those data
sources before System is initialised. This should be quite easy in the
nativ implementation (through native methods), although a bit tricky for
host (which I think I'll leave as it is). I wouldn't mind at all if
someone else did the native version :-)

>         Most of the support, I believe, will be telling it not to call
> library functions we don't provide in its native code. :)  (Seriously, if
> you download the classpath distro, take a look at the vm/ subdirectory,
> where they stick the VM-specific bits.  There isn't a whole lot in there,
> nicely enough.)

I expect there will (need to) be some VM-specific stuff for initialising
FileDescriptor.in.

> > Notice that if we do this, we are demonstrating the first use of
> > inter-process object sharing. The calling process needs a reference to
> > the process it is creating, and the program running in the new process
> > will need to be able to reference itself too.
> 
>         In general, we want the calling process to have a reference to the
> spawned process, and spawned process obviously needs to reference itself.
> The question we must address is where the class definition of that
> reference should reside.

I am thinking that the class definition resides in a cache separate from
all processes. Only actual java.lang.Class-es reside in a place
associated with a particular process. (see below for a further analysis
of class definition caches)

>  Since this OO-IPC referencing will need
> 'illegal' casts, the obvious answer is that the JavaProcess class needs to
> be shared between the primordial loaders of each process.

Do you mean the JavaProcess class _definition_ needs to be shared?
(because an alternative way is to actually share the Class). I also came
to this conclusion in this post:

	http://jos.org/pipermail/arch/2000-April/000461.html

"It occurs to me that any class loaded by a primordial class loader
should always share its class definition with the corresponding class in
the KernelClassLoader, if it exists there. This overrides the other form
of class definition sharing effectively whenever a "kernel required"
class is loaded. I believe this is a constraint for a correctly
functioning system"

Of course, the KernelClassLoader is just a concept. It is not
necessarily a tangible thing.

We can identify two class definition caches:

- one that is shared between all primordial class loaders
- one that is owned by the kernelClassLoader (or just "kernel")

When a ProcessClassLoader loads a class (eg. when findSystemClass() is
called in a process), it should check the kernel's class cache first
(this will include JavaProcess) to ensure that class definitions that
*must* be reused conistently are reused. If the class is not in that
cache, the cache for primordial class loaders is used.

> Every
> JavaProcess has a private reference to its classloader, which could be
> used on behalf of the calling process to set whatever statics need to be
> set.  (e.g. SystemObjects.)
> 
>         Currently, the host code always sets a custom classloader because
> that's the only way to generate (more-or-less) disjoint classloaders.  On
> the native side, that is not the case -- an empty classloader can be
> generated by the decaf code.  (In fact, at some point, must be.)  My
> question, then, is -- does constructProcess() (I think!) ever /need/ to
> set a classloader?  Since the native code must already generate an empty
> primordial classloader for the new process, does the JOS code ever need to
> worry about setting the classloader of the new process?  (That is,
> JavaProcess's private ProcessClassLoader reference would be a reference to
> a native PCL, generated by the native call to createProcess().  (And
> possibly changed to a straight ClassLoader reference.))

So, what you're saying is JavaProcess will still have a reference to a
ProcessClassLoader, just that the the class loader constructed in the
nativ version will be generated natively by decaf?

That's fine by me. I'm not sure what the advantages of making
NativeProcessClassLoader natively generated are, but feel free to do it
that way if it's easier. I will try to get the Java implementation of
NativeProcessClassLoader working so that it might be useful in the
future.

BTW, if it is implemented in Java, that doesn't mean getClassLoader()
won't return null for classes loaded by a primordial class loader.
Class.getClassLoader() can simply state:

ClassLoader getClassLoader()
	{
	if (classLoader instanceof ProcessClassLoader)
		return null;
	return classLoader;
	}

If we do this, Processmanager.getOwningProcess() needs to be changed too
since it checks if the return value of getClassLoader() is an instance
of ProcessClassLoader. That shouldn't be too difficult to fix.

> A method in
> JavaProcess could be used to set static variables or call static methods
> on its classloader, i.e.:
> 
> myChild.setStaticField( "myRandomStaticClass", "myRandomStaticField",
>         myRandomSharedObject );
> Object args[1]; args[0] = myPipedInputStream;
> myChild.staticFunction( "java/lang/System", "setIn", args );

Whatever we use to achieve this, it would be nice if it were generic (at
the JavaProcess level). So, it is important that even if a process's
class loader is natively generated, there is still a reference to it.

In this case, setStaticField and staticFunction can still be useful as
convenience methods.

>         Right.  I meant this question in the opposite order -- what does
> decaf need to do before we can rename rheise.os, which entails getting the
> nativ bit working correctly.  Something that decaf needs to do is handle
> native calls correctly.

If you are going to use rheise.os from decaf, it would seem easier to do
the renaming before you get started. Also, the sooner this stabilises
the sooner I can put it in CVS.

> > Likewise with decaf, which is like Jupiter to my Pluto :-)
> 
>         I believe we've found the codenames for our milestone releases. :)

Yes! Excellent idea :-)

PS. I have read your Final Summary, but I need to catch up on some sleep
before I look at it in more detail - that'll probably be tomorrow.
sorry!

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From gchii@mindspring.com Thu, 20 Apr 2000 09:56:21 -0400
Date: Thu, 20 Apr 2000 09:56:21 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] rheise.os questions

At 10:05 AM 4/20/00 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>Consider callback methods from the AWT system. The AWT system
>will invoke code in your process, but the thread executing your code
>actually belongs to the AWT process. I'd like getCurrentProcess() to
>return the process that owns the code being executed in this case. Maybe
>it's possible to keep it generic. I'll know when I get around to looking
>at it.

I disagree. There must be two mechanisms. The getCurrentProcess() method
returns the current process -- regardless of who owns the code. The
getProcess() method returns the process that owns an object. While
getCurrentProcess() probably uses getCurrentThread(), getProcess() probably
uses getClass().getClassLoader().

Consider the AWT system carefully. The AWT is part of system classes
(java.awt.*). It is process-wide subsystem, not system-wide. It must be
part of each bytecode process. Each bytecode process has its own
java.awt.Toolkit. This is required to maintain the illusion that a bytecode
process is running within its own virtual machine. Two different processes
can have two different toolkits. Like a security manager, a toolkit is
unique to a bytecode process.

Each process must have its own AWT thread. Again, this is required to
maintain the illusion that a bytecode process is running within its own
virtual machine. A thread that pushes an event through a process must
belong to that process. The getCurrentProcess() must always return the
current process, regardless of object sharing.

On the other hand, JADE is a system-wide subsystem. There may be one
instance of JADE for each virtual console. The interaction between JADE and
AWT is this: JADE actually paints the screen for one or more instances of
AWT. JADE collects UI events and dispatches them to the appropriate
process. JADE components interact with corresponding AWT components. If 100
processes share a virtual console, there is one instance of JADE and 100
instances of AWT.

If there is more than one instance of JADE, only one instance of JADE can
be visible at a time in full screen mode. There may be special key
combinations or mouse events to switch between virtual consoles.





From ryan@whitewolf.com.au Fri, 21 Apr 2000 00:51:32 +1000 (EST)
Date: Fri, 21 Apr 2000 00:51:32 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os questions

On Thu, 20 Apr 2000, Gilbert Carl Herschberger II wrote:

> At 10:05 AM 4/20/00 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
> >Consider callback methods from the AWT system. The AWT system
> >will invoke code in your process, but the thread executing your code
> >actually belongs to the AWT process. I'd like getCurrentProcess() to
> >return the process that owns the code being executed in this case. Maybe
> >it's possible to keep it generic. I'll know when I get around to looking
> >at it.
> 
> I disagree. There must be two mechanisms. The getCurrentProcess() method
> returns the current process -- regardless of who owns the code. The
> getProcess() method returns the process that owns an object. While
> getCurrentProcess() probably uses getCurrentThread(), getProcess() probably
> uses getClass().getClassLoader().

Maybe that way's better. I keep changing my mind on this so I should
probably think about it more thoroughly.

> Consider the AWT system carefully. The AWT is part of system classes
> (java.awt.*). It is process-wide subsystem, not system-wide.

Not necessarily. I would have thought that the standard toolkit peers
belong to an AWT process. Peers need to collaborate with eachother, even
if they are peers of components from different processes. Therefore, if
the peers don't belong to the same process, there needs to be additional
object sharing - which I'd rather avoid since it is not necessary.

So, I see the functionality of AWT being split across the process
boundary. Part of AWT will be in the application's process, and part
(the peers) will be in the AWT process.

> It must be
> part of each bytecode process. Each bytecode process has its own
> java.awt.Toolkit.

Yes, or even multiple. But I would expect the default Toolkit to
delegate to the AWT process which is able to manage the creation of all
peers (so they can collaborate with eachother). The AWT system in a
standard JVM achieves this collaboration through native calls.

> Each process must have its own AWT thread. Again, this is required to
> maintain the illusion that a bytecode process is running within its own
> virtual machine.

This is a good idea. Although, it's not necessary. You can achieve the
illusion other ways, but it may make more sense to pass events over to
the AWT thread of a process if that's where it's destined.

> On the other hand, JADE is a system-wide subsystem. There may be one
> instance of JADE for each virtual console. The interaction between JADE and
> AWT is this: JADE actually paints the screen for one or more instances of
> AWT. JADE collects UI events and dispatches them to the appropriate
> process. JADE components interact with corresponding AWT components. If 100
> processes share a virtual console, there is one instance of JADE and 100
> instances of AWT.

I forgot that I'm not on the gui list so I may have missed the JADE
discussion. But if I can give my fresh perspective, I thought JADE was a
desktop environment that ran on top of a windowing system (ie. Toolkit).
It sounds like you're making JADE take on responsibility that is meant
to be handled by a Toolkit.

> If there is more than one instance of JADE, only one instance of JADE can
> be visible at a time in full screen mode. There may be special key
> combinations or mouse events to switch between virtual consoles.

Here it also seems you're talking about a Toolkit. ie. there can be a
Toolkit per virtual console (although, a single process can also use
multiple Toolkits, as I said before).

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From gchii@mindspring.com Thu, 20 Apr 2000 11:30:27 -0400
Date: Thu, 20 Apr 2000 11:30:27 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] [distribution] JOS Distribution 1f

Once again the time has come for a new distribution of JOS. This
distribution is version "1f". For more information, see also
JOSDistribution1f, a new article on JOS Wiki.

<URL:http://www.metamech.com/wiki/view/Main/JOSDistribution1f>

To start the process, I created a snapshot of CVS and added two archives to
the DownloadCVSModules page on JOS Wiki.

<URL:http://www.metamech.com/wiki/view/Main/DownloadCVSModules>

Also, I created a jos1f subdirectory in redist/mirror on the www.jos.org
server.

<URL:http://www.jos.org/redist/mirror/jos1f/>

Wouldn't it be sweet if the binary and technical editions matched exactly?
Maybe that's something we could plan on in the future. Since I am still
unable to build a binary edition of JOS, I can't create a binary edition
that matches the technical one.

New products for this version are:

 - Dawn, the scripting language
 - rheise.os, the multiple process API
 - bytecode resource, putting bytecode in the DATA segment

What else is there? I'm sure there are more.





From tmiller@haverford.edu Thu, 20 Apr 2000 14:56:08 -0400 (EDT)
Date: Thu, 20 Apr 2000 14:56:08 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] [distribution] JOS Distribution 1f

> Wouldn't it be sweet if the binary and technical editions matched exactly?
> Maybe that's something we could plan on in the future. Since I am still
> unable to build a binary edition of JOS, I can't create a binary edition
> that matches the technical one.

	I don't recall what problems you were having.  Had you posted them
to this (or another) jos mailling list?  (If so, I'll look back over
them.)

-_Quinn





From tmiller@haverford.edu Thu, 20 Apr 2000 15:28:39 -0400 (EDT)
Date: Thu, 20 Apr 2000 15:28:39 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os questions

> It seems to make sense for the static initializer to handle it all, as
> it does in classpath. It calls on FileDescriptor.in to initialise
> System.in and it could do a similar thing for system properties (and the
> security manager in some cases). We just need to set up those data
> sources before System is initialised. This should be quite easy in the
> nativ implementation (through native methods), although a bit tricky for
> host (which I think I'll leave as it is). I wouldn't mind at all if
> someone else did the native version :-)

	I wasn't particularly expecting you to handle the native-side of
the nativ implementation :)  Yes, it looks like we may be able to set
things up elsewhere (may have to set things up elsewhere); and we do want
to avoid changing classpath as much as possible, so as to reduce our
maintenance workload.  With respect to using setIn(), etc, I was trying to
say that, in general, we should use the interfaces provided by the class
to modify it.

> I am thinking that the class definition resides in a cache separate from
> all processes. Only actual java.lang.Class-es reside in a place
> associated with a particular process. (see below for a further analysis
> of class definition caches)

	OK -- the way I phrased the 'final summary' leaves open the
question of whether or not the definition cache is system wide.  As long
as we distinguish between revisions, I think we'll be OK.  (I need to
think this through more, probably.)

> When a ProcessClassLoader loads a class (eg. when findSystemClass() is
> called in a process), it should check the kernel's class cache first
> (this will include JavaProcess) to ensure that class definitions that
> *must* be reused conistently are reused. If the class is not in that
> cache, the cache for primordial class loaders is used.

	Architecturally, I think it would work better to have the
primordial class loader check the kernel's class definition cache
first.  (I'm not sure we want system-wide statics, but I'm open to being
convinced.)

	The kernel classloader could be just about anything -- the first
native primordial classloader to be created; a specific class that uses
the ramdisk generated by the bootloader; a specific class that uses
Gilbert's rater intriguing DATA-section bytecode resource; and so
on.  Since each process has a primordial classloader, and the primordial
classloaders are all generated by code we control, we can simply insert
the necessary shares before handing the classloader back to the Java
program. 

> So, what you're saying is JavaProcess will still have a reference to a
> ProcessClassLoader, just that the the class loader constructed in the
> nativ version will be generated natively by decaf?

	Exactly.  Every JavaProcess needs a new primordial classloader, so
decaf may as well supply it when the JP is created.  Every
NativeProcessClassLoader must be (access) a primordial loader
anyway; doing the creation with the creation of a JP eliminates the
bootstrap problem.

> So, it is important that even if a process's class loader is natively
> generated, there is still a reference to it.

	I agree.  I was suggesting that native generation could sidestep
some problems with doing the code in Java, create the native primordial
classloader and assign the JP PCL reference to it.

> If you are going to use rheise.os from decaf, it would seem easier to do
> the renaming before you get started. Also, the sooner this stabilises
> the sooner I can put it in CVS.

	True.  We'll see what happens.

-_Quinn





From tmiller@haverford.edu Thu, 20 Apr 2000 15:39:52 -0400 (EDT)
Date: Thu, 20 Apr 2000 15:39:52 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os questions

> I disagree. There must be two mechanisms. The getCurrentProcess() method
> returns the current process -- regardless of who owns the code. The
> getProcess() method returns the process that owns an object. While
> getCurrentProcess() probably uses getCurrentThread(), getProcess() probably
> uses getClass().getClassLoader().

	I'll second this.  If we allow multiple-process objects, there
could be code that could be running in a process other than its nominal
owner.


	Considering the AWT: the AWT is only an interface.  How we choose
to implement it is completely up to us.  Current AWT implementations must
use native peers because the windowing system, graphics libraries, etc,
aren't written in Java.  This will not be the case for JOS.  I rather like
the idea of translating all AWT calls into Swing calls, so that we can
skin legacy apps -- but more importantly, we only have one library to
write support for.  (That is, the AWT peers could be BCNI redirectors to
Swing.)  Swing, in turn, could get its JDesktop analouge from the virtual
console driver.

	My point here is that we don't have to, and in fact, don't want,
native peers, and that this puts a different slant on things.  JADE, in
fact, may /be/ the toolkit.  If our toolkit code is written to always ask
the X-server analouge process for instances of widgets (etc), than the
number of shares is just the number of widgets, because the widgets and
their code all reside in the process the toolkit code is using as its
backend.

	(I think that made sense.)

> If there is more than one instance of JADE, only one instance of JADE can
> be visible at a time in full screen mode. There may be special key
> combinations or mouse events to switch between virtual consoles.

	There already are special key combinations to switch between
virtual consoles :)  (ALT-Fx)

-_Quinn








From ryan@whitewolf.com.au Fri, 21 Apr 2000 13:13:03 +1000 (EST)
Date: Fri, 21 Apr 2000 13:13:03 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os questions

On Thu, 20 Apr 2000, Todd L. Miller wrote:

> 	I wasn't particularly expecting you to handle the native-side of
> the nativ implementation :)  Yes, it looks like we may be able to set
> things up elsewhere (may have to set things up elsewhere); and we do want
> to avoid changing classpath as much as possible, so as to reduce our
> maintenance workload.

Agreed.

> With respect to using setIn(), etc, I was trying to
> say that, in general, we should use the interfaces provided by the class
> to modify it.

Yes, but often not to initialise it. Objects have constructors partly
because it enables internals to be set in a way that is impossible after
the object is constructed. A similar effect can be achieved for static
classes.

> > When a ProcessClassLoader loads a class (eg. when findSystemClass() is
> > called in a process), it should check the kernel's class cache first
> > (this will include JavaProcess) to ensure that class definitions that
> > *must* be reused conistently are reused. If the class is not in that
> > cache, the cache for primordial class loaders is used.
> 
> 	Architecturally, I think it would work better to have the
> primordial class loader check the kernel's class definition cache
> first.  (I'm not sure we want system-wide statics, but I'm open to being
> convinced.)

In rheise.os, the primordial class loader of a process is called a
ProcessClassLoader. Does that mean we agree?

> 	The kernel classloader could be just about anything -- the first
> native primordial classloader to be created; a specific class that uses
> the ramdisk generated by the bootloader; a specific class that uses
> Gilbert's rater intriguing DATA-section bytecode resource; and so
> on.  Since each process has a primordial classloader, and the primordial
> classloaders are all generated by code we control, we can simply insert
> the necessary shares before handing the classloader back to the Java
> program. 

Are you implying that each ProcessClassLoader has its own class
definition cache? Can you explain how this works?

> > So, it is important that even if a process's class loader is natively
> > generated, there is still a reference to it.
> 
> 	I agree.  I was suggesting that native generation could sidestep
> some problems with doing the code in Java, create the native primordial
> classloader and assign the JP PCL reference to it.

Ok. I'd still like to maintain the Java implementation in case it proves
to be useful in the end.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Thu, 20 Apr 2000 23:47:21 -0400 (EDT)
Date: Thu, 20 Apr 2000 23:47:21 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os questions

> Yes, but often not to initialise it. Objects have constructors partly
> because it enables internals to be set in a way that is impossible after
> the object is constructed. A similar effect can be achieved for static
> classes.

	OK, I understand your point.  Things like this will get hammered
by out by doing the implementation.

> > 	Architecturally, I think it would work better to have the
> > primordial class loader check the kernel's class definition cache
> > first.  (I'm not sure we want system-wide statics, but I'm open to being
> > convinced.)
> 
> In rheise.os, the primordial class loader of a process is called a
> ProcessClassLoader. Does that mean we agree?

	If and only if we guarantee that ProcessClassLoader is one of
those classes which are consistent system-wide.  I think I assume/imply
later on that the PCL generated by decaf for a JavaProcess is entirely
native, which makes PCL an interface.  This isn't necessary, and perhaps
is not desirous; my intent was to minimize the overall number of native
calls, since they'll probably incur a performance penalty.

> Are you implying that each ProcessClassLoader has its own class
> definition cache? Can you explain how this works?

	Every classloader must cache its classes -- otherwise, static
references wouldn't work.  Because we can split the definition and the
statics, what the classloaders will actually point to is a class
definition pointer and static variable pointer pair.  The class definition
pointer may point at a shared copy (a cache.)  The static variable pointer
must not be shared, for obvious reasons.  What I meant by 'insert before
returning' is that /this/ cache/table could have entries in it with shared
class definitions and unique statics /before/ the Java code has a chance
to load a differing definition.  Any attempt to define bytecode for a
class already loaded is rejected according to the spec, so the JavaProcess
class definition, for instance, remains consisten across all processes.

	Furthermore, I wrote the 'final summary' in such a fashion that it
does not require a system-wide cache, though the transitive closure of the
pair-sharing it does define could very well be the whole system; as I
mentioned elsewhere, I'm not totally convinced the cache /must/ be
system-wide, though there are obviously specific classes which ought to be
system-wide.  That is, does the set of system-wide-by-design classes
exactly correspond to the set of classes which will be
system-wide-by-caching?  I /think/ the answer is yes, but I'm not sure.  
That is, any class definition differing between two processes is not
shared, so it /shouldn't/ be a problem to share the common class
definitions among every process which uses them.  I just can't shake the
feeling that I'm missing/forgetting something...

> Ok. I'd still like to maintain the Java implementation in case it proves
> to be useful in the end.

	It probably will.  We'll see during implementation :)

-_Quinn





From gchii@mindspring.com Fri, 21 Apr 2000 10:46:02 -0400
Date: Fri, 21 Apr 2000 10:46:02 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] rheise.os questions

At 03:39 PM 4/20/00 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>Considering the AWT: the AWT is only an interface.  How we choose
>to implement it is completely up to us.

In theory, we can run all AWT-dependent applications on JOS /because/ the
implementation details are completely up to us. We must implement the AWT
peers. We can implement the AWT peers without any native methods.

The AWT peers are an interface, or API. On the other hand, AWT is a
framework, not an API. Swing is a framework. Swing uses AWT.

>Current AWT implementations must use native peers because the windowing
>system, graphics libraries, etc, aren't written in Java.

Native methods are quite popular with C/C++ programmers. Native methods
might feel better than bytecode for someone trained in the art of C/C++.
Programmers have used native methods even when native methods are not
required. AWT peers are a good example.

After reviewing the Java Virtual Machine Specification again, I make the
following assertion:


AWT peers are not required to implement native methods. As always, native
methods are optional in the implementation of the Java standard class
libraries.


Many, but not all, foreign operating systems have a bit-mapped windowing
system. A bit-mapped windowing system for many mainframe, midrange and
microcomputer servers is simply not an option. For the server itself, it is
neither necessary nor desireable for these computers to have a bit-mapped
windowing system. People sit in front of a local or remote console; nobody
sits in front of the server itself.

On a server farm (or serverfarm-in-a-box), most of the general purpose
processors do not have a bit-mapped windowing system. They have no support
for bit-mapped graphics. They have no monitor, no keyboard, no mouse.
People sit in front of a local or remote console; nobody sits in front of
the server itself.

Any yet, AWT runs successfully on all these machines. A bit-mapped
windowing system is obviously not required to run a virtual machine. While
many virtual machines use them, native peers are not required. For those
without a bit-mapped windowing system, a foreign operating system cannot
provide native peers for a windowing system it does not have.

Peers for JOS are more like peers on OS/400. For example, a pure bytecode
version of the AWT on OS/400 is necessary to separate the process-wide
components in java.awt.* with the session-wide components of
java.awt.peer.*. The OS/400 redirects all AWT "peers" across a TCP/IP
connection. Peers are never displayed on the OS/400 itself.

Peers for JOS are more like peers for X. A native library might be useful
to redirect I/O from a process to the X server. Peers for JOS might skip
the native library altogether and, within bytecode, redirect I/O from a
process to the X server.

Current AWT implementations must use peers because the windowing system is
a system-wide object and AWT is process-wide. Native peers are useful to
cross over from a virtual machine to a foreign operating system. This has
little to do with machine code vs. bytecode.

An AWT peer is a proxy. An AWT peer runs in one process while the real
bit-mapped component runs in another. Let's consider running 100 AWT-based
applications. Each AWT-based application runs in its own process. Each AWT
peer is created in the same process as its application.

A windowing system simultaneously display the output from many other
processes. Like an X service, our windowing system runs in a separate
process, isolated from all other processes. It must be a separate process
in order for a windowing system to be loaded, reloaded, shutdown and
restarted.

When an AWT peer is created, it creates a corresponding component in
service process. An AWT peer must use some form of inter-process
communication to tell the windowing system to create a component. Once a
corresponding component has been created, an AWT peer must continue to use
some form of inter-process communication to paint the display owned by the
windowing system.

To suitably illustrate this, imagine 100 servers and 1 console are wired in
a server farm. For simplicity, imagine each server is running one AWT-based
application. It is desireable to redirect I/O from all 100 servers to a
master console. The master console is the only machine that runs a
bit-mapped windowing service. It can simultaneously display components
created by AWT peers on all 100 servers.





From ryan@whitewolf.com.au Sat, 22 Apr 2000 01:43:43 +1000 (EST)
Date: Sat, 22 Apr 2000 01:43:43 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os questions

On Fri, 21 Apr 2000, Gilbert Carl Herschberger II wrote:

> AWT peers are not required to implement native methods.

We even have proof of that, with SwingToolkit :-)

Although control must switch over to native code at some point, and the
deeper the better. At the deepest level there could be an implementation
of java.awt.Graphics that draws directly to the screen, and perhaps has
a few more methods than its superclass to be more efficient for certain
types of operations (eg. g.drawPixel()).

> Current AWT implementations must use peers because the windowing system is
> a system-wide object and AWT is process-wide.

For an implementation of AWT without peers, take a look at Kaffe (I
don't know if it's changed since I last looked).

> An AWT peer is a proxy. An AWT peer runs in one process while the real
> bit-mapped component runs in another.

Right, I see the distinction you're trying to make now. The Toolkit is
built on top of the windowing system, whereas I was treating them both
collectively as "the windowing system". This actually maps to how I've
done it in SwingToolkit (hey, I wrote it a year ago! :-), where the peer
objects are considered part of the Toolkit and the swing components they
operate are considered part of the windowing system (as you described),
which runs in a separate process.

It makes sense now why you think there should be an AWT thread per
process. So, basic events originate from the windowing system and are
reposted by the AWT system of the interested process on its own AWT
thread.

The question is, do you call the windowing system JADE? I think I was
slightly confused because I thought JADE was a desktop environment that
ran on top of the windowing system.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Tue, 25 Apr 2000 18:13:06 +1000 (EST)
Date: Tue, 25 Apr 2000 18:13:06 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Java Processes: Final Summary?

As promised, here is my response to _Quinn's final summary. Nice,
thorough summary. I only have a couple of comments:

On Wed, 19 Apr 2000, Todd L. Miller wrote:

> another.)  The desire for multiple Java processes in a single JVM stems
> from two sources: first, the JJOS kernel's current lack of multiple native
> processes (that is, we can't take the 'easy way out' and run multiple
> instances of decaf); second, the potential space efficiency benefits.  A
> more secondary concern is the handling of shared-object IPC.

Shared-object IPC might be more important from a functional perspective.
rheise.os demonstrates that JavaProcess objects must be shared (although
I'm sure there are hacky ways around this). Rather than perfecting
memory efficiency, then implementing IPC, we could start with incomplete
implementations of each one and work from there. eg. allow IPC for
"kernel required" classes (regardless of whether memory efficiency is
implemented).

> our own.  The key realization for shared-memory OO-IPC is that the
> classloaders, being disjoint, do not share classes, and thus, the object
> can not be cast from one process to another.  We solve this by allowing
> 'illegal' cast operations as follows:
> 
> (1) The security system must OK the object share.  This allows us to flag
> 	the object as shared for efficiency.
> (2) The object's class definition must be shared between the two
> 	processes.  (Implying it was loaded by a (native)** primordial
> 	classloader.)

- I think the mechanism for (1) needs to be investigated further.
  Flagging the object is one way to handle it. Another way is to simply
control "access" to the object. A process can't ordinarily gain access to
an object in another process, so there needs to be some bridge method
that returns a reference to an object of another process. This method
can perform access control. The difficulty in flagging is that you can't
simply flag an object as shared because that won't give you access to
its member variables, or to objects returned by methods on the object
you do have access to. Flagging is obviously a way to make the system
safer, but is it really necessary?

- The model of sharing here is not fully specified. In particular, with
  regard to access to static member variables of shared objects. In a
past email (http://www.jos.org/pipermail/arch/2000-April/000438.html) I
proposed:

"Now, if the client process directly accesses static members, it will
access the cloned versions that belong to its own process. However, if
you call a method on an object that really belongs to another process,
and that method accesses a static member, then it should access the
static members of the class in the _other_process. Are there any
problems in implementing that?"

> * Amusingly enough, Java isn't type-safe anyway.  I don't have the
> (academic) citations handy, unfortunately.

You might be referring to this:

	http://www.research.att.com/~vj/bug.html

I think Sun has resolved this problem in JDK 1.2:

	http://java.sun.com/people/gbracha/classloaders.ps

It introduces new loader constraints, which I think are getting in the
way of rheise.os working with JDK 1.2. I haven't looked at this yet (I'm
in no rush either since I'm not using JDK 1.2 :-)

> Likewise, Java's memory model
> -- which I'm mostly ignoring, in part because of this -- is horribly
> broken.  Bill Pugh, who's written some papers about it, seems to hold the
> opinion (based on my second-hand information) that Sun's VM implementation
> has a memory model which makes sense but doesn't follow the spec...

Can you point me to these papers? Thanks.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Wed, 26 Apr 2000 00:50:31 +1000 (EST)
Date: Wed, 26 Apr 2000 00:50:31 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os-0.1.2 released

This will be the last combined rheise.os/SwingToolkit release. In future
these will be released separately.

	http://www.progsoc.uts.edu.au/~rheise/projects/rheise.os/

Specific changes in this release are as follows (scroll to the end of
this email for additional notes):

Changes to rheise.os:

        - Implemented System.exit() - sort of.
        - Implemented HostProcessClassLoader.getResourceAsStream()
        - Assigned delegators to kernel-space System statics.
        - Provided method to construct UserThreadGroup before User is
          known.
        - SystemObjects are created through
          ProcessManager.createSystemObjects()
        - Created "basic" implementation of process package.

Changes to SwingToolkit:

        - Frame.pack() works properly.
        - Added new peers:
                - CheckboxMenuItemPeer
                - ChoicePeer
                - MenuBarPeer
                - MenuItemPeer
                - MenuPeer
                - TextAreaPeer
        - Reorganised packages, created new package for swing widgets.


- Additional notes:

I looked at SwingToolkit for the first time in a year and noticed that
much of it didn't work. For example, if your application doesn't call
Frame.setSize() explicitly, you don't see the Frame at all (oops!). With
that fixed, it should be /much/ closer to being useful but without
actually being useful - it's work in progress.

One thing I noticed is that, with or without the SwingToolkit, both AWT
and Swing menus don't work under rheise.os (at least on Linux). It is
probably to do with assumptions on class loading which I'm breaking. I
created a new implementation of the process package called "basic" which
runs all processes in the same namespace. Menus work under this
implementation. To test this environment, run:

	java rheise.os.process.basic.BasicInit

Also in this release, I think I have the other 0.01% of System statics
working, ie. if a kernel space class accesses a System static, the
request will still be forwarded to the current process through
delegators.

- How you can help:

Since some people have shown an interest in helping, here are the main
areas that need attention:

	- Get other platforms working (eg. JDK 1.2 and Windows)
	- Expand on security APIs.
	- Fix remaining bugs in SwingToolkit.

There is too much for one person to do, so any help would be greatly
appreciated. If you're interested, check out the release notes for more
information on what's missing, and email me to see how you can help.

Thanks.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Tue, 25 Apr 2000 16:40:27 -0400 (EDT)
Date: Tue, 25 Apr 2000 16:40:27 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Java Processes: Final Summary?

> As promised, here is my response to _Quinn's final summary. Nice,
> thorough summary. I only have a couple of comments:

	Thanks for the review.

> Shared-object IPC might be more important from a functional perspective.
> rheise.os demonstrates that JavaProcess objects must be shared (although
> I'm sure there are hacky ways around this).

	D'oh!  I'd clean forgotten that we needed shared objects for
rheise.os.  How about:

"The desire for multiple processes ... benefits.  Most elegant
implentations of multiple processes requires shared-object IPC, if for
nothing aside from the created process object.  (Strictly, the process
object returned to the creating function could be a message-passing stub,
like RMI.)"

> Rather than perfecting memory efficiency, then implementing IPC, we
> could start with incomplete implementations of each one and work from
> there. eg. allow IPC for "kernel required" classes (regardless of
> whether memory efficiency is implemented).

	Right.  I'll see how things turn out in implementation.  (It may
be easier to do both at the same time.)

> - I think the mechanism for (1) needs to be investigated further.
>   Flagging the object is one way to handle it. Another way is to simply
> control "access" to the object. A process can't ordinarily gain access to
> an object in another process, so there needs to be some bridge method
> that returns a reference to an object of another process. This method
> can perform access control. The difficulty in flagging is that you can't
> simply flag an object as shared because that won't give you access to
> its member variables, or to objects returned by methods on the object
> you do have access to. Flagging is obviously a way to make the system
> safer, but is it really necessary?

	Flagging was my suggestiong for an implementation of (1).  With a
bridge method, once the object has been returned, how does decaf know it
can be 'illegally' cast?  Something about that object in particular is
different than other object -- so I suggested a flag.  Where/when that
flag -- that something special about an object that says 'I'm shared, cast
me illegally' -- is set is mostly an interface issue.

> - The model of sharing here is not fully specified.

	Good point.  Any shared object may generate additional objects
which must be shared.  According to the summary so far, a security check
is necessary before objects may be shared.  Naturally, this must apply to
objects returned by the shared object as well.  I think the same arguments
apply here as they did before; we don't want to do this implicitly.  That
is, by default, a shared object generates objects belonging to the
classloader to which the constant class reference used loaded -- that is,
when decaf goes to look for a class instance to generate an object from,
it will (perhaps implicitly) use that classloader of the current
thread.  I think forcing the shares to be explicit and having generated
objects be local will take car of the cases we need to worry about.

> "Now, if the client process directly accesses static members, it will
> access the cloned versions that belong to its own process. However, if
> you call a method on an object that really belongs to another process,
> and that method accesses a static member, then it should access the
> static members of the class in the _other_process. Are there any
> problems in implementing that?"

	I think it comes out implicitly in the way things are done by the
interpreter.  The shared object's class references will be resolved in/by
the classloader which loaded it first, because the CL of an object
(actually, of its class definition) is never changed.  This should be an
exact fit for the ownership semantics.  This also means, incidentally,
that a process that exits can't be cleaned up until we're sure no shared
object classloaders point at it.  (That is, we have to run a garbage
collection on process exit.)

	I'll think about how to add this to the summary.

> Can you point me to these papers? Thanks.

	http://www.cs.umd.edu/~pugh/java/  has a great deal of information
about various problems with Java, including the memory model and
type-safety.  (esp see his paper from the ACM Java Grande conference)

-_Quinn

BTW, I put the corrected summary up on the wiki, MultipleJavaProcesses
(http://www.metamech.com/wiki/view/Main/MultipleJavaProcesses), so that we
can work on it more collaboratively, should we need to.






From tmiller@haverford.edu Tue, 25 Apr 2000 16:58:58 -0400 (EDT)
Date: Tue, 25 Apr 2000 16:58:58 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os-0.1.2 released

> Also in this release, I think I have the other 0.01% of System statics
> working, ie. if a kernel space class accesses a System static, the
> request will still be forwarded to the current process through
> delegators.

	How'd you manage this, BTW?  (Quickie overview before I start
looking at the code.)

-_Quinn





From ryan@whitewolf.com.au Wed, 26 Apr 2000 08:34:53 +1000 (EST)
Date: Wed, 26 Apr 2000 08:34:53 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os-0.1.2 released

On Tue, 25 Apr 2000, Todd L. Miller wrote:

> > Also in this release, I think I have the other 0.01% of System statics
> > working, ie. if a kernel space class accesses a System static, the
> > request will still be forwarded to the current process through
> > delegators.
> 
> 	How'd you manage this, BTW?  (Quickie overview before I start
> looking at the code.)

I'm just leaving for work, but I can give you some quick directions.
HostInit.java is the place to start. It even has comments! (the first
class to have them :-)

If you have further questions I'll explain at a later time.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Tue, 25 Apr 2000 23:40:53 -0400 (EDT)
Date: Tue, 25 Apr 2000 23:40:53 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os-0.1.2 released

> I didn't really "move" to doing that. The System wrapper class is used
> 99% of the time (which is good because it prevents one process from
> writing over the System.in that is being used by another process), and
> the static field wrappers are used as a fallback for the other 1% of the
> time.

	My bad.  I didn't look at enough of the code, obviously :)  
However, I think it /could/ be done with just that -- though I may not be
thinking clearly at this point... splitting it up ought to be more
efficient, right?

-_Quinn





From ryan@whitewolf.com.au Wed, 26 Apr 2000 13:28:36 +1000
Date: Wed, 26 Apr 2000 13:28:36 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os-0.1.2 released

"Todd L. Miller" wrote:
> 
> > If you have further questions I'll explain at a later time.
> 
>         Okay, took a look there.  You moved from wrapping System to
> wrapping its static variables, right, setting those wrappers in the kernel
> System class so they couldn't be avoided.  I like it.

I didn't really "move" to doing that. The System wrapper class is used
99% of the time (which is good because it prevents one process from
writing over the System.in that is being used by another process), and
the static field wrappers are used as a fallback for the other 1% of the
time.

When these fallback wrappers are used, there is still a chance things
can go wrong, for example if "system" code calls setIn() or any of the
other set methods. Luckily I don't think there is any system code that
does this. Another thing that could go wrong is if system code tries to
set the security manager. It is usually expected that no security
manager is set, however I must set the security manager to something so
I can do forwarding. I emulate a null security manager with
NullSecurityManager. However, if any system code tries to call
setSecurityManager() it will fail. So, any code that wishes to call
setSecurityManager() must belong to a user process which has its own
System (wrapper) class and an actual 'null' for the security manager
(which is 99% of the time).

By the way, the only reason I am able to load my own System class and
have it work 99% of the time is that java.lang.System is a purely static
class. There are no instances of System, and so there are no references
to System objects. If there were references to System objects, rheise.os
would fail when you tried to pass in a reference to a System object
owned by your process into a method in a class loaded by the host
primordial class loader (ie. system code). That was the original insight
that led me to this solution.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Wed, 26 Apr 2000 14:13:11 +1000
Date: Wed, 26 Apr 2000 14:13:11 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os-0.1.2 released

"Todd L. Miller" wrote:
> 
> > I didn't really "move" to doing that. The System wrapper class is used
> > 99% of the time (which is good because it prevents one process from
> > writing over the System.in that is being used by another process), and
> > the static field wrappers are used as a fallback for the other 1% of the
> > time.
> 
>         My bad.  I didn't look at enough of the code, obviously :)
> However, I think it /could/ be done with just that -- though I may not be
> thinking clearly at this point...

The System wrapper class is required to prevent one process from writing
over the System.in that is being used by another process.

Echidna does as you are saying but it suffers from the flaw I'm pointing
out: System.setIn() stuffs everything up, and we must support it.
Echidna provides a non-standard api for setting System.in to avoid the
problem but this means standard Java programs that attempt to call
System.setIn() will stuff up the system (all processes will suddenly
start reading from the single stdin that was just set).

> splitting it up ought to be more
> efficient, right?

I'm not exactly sure what you're referring to here. rheise.os uses two
methods where one is a fallback. The one that is used 99% of the time is
the System wrapper class ,which is the most efficient method because it
doesn't do any forwarding. The fallback method is less efficient because
it must determine the current process and forward on the request to
where it was /meant/ to go, but it is necessary to cover the remaining
1% (*).

(*) As I noted earlier, it doesn't actually cover all of the remaining
1% but most of it. There is a chance something could go wrong, but it
might be that there is no "system code" that causes this to happen, so
we're ok. I can deal with it when/if it happens, but the "host"
implementation isn't really meant to be perfect anyway - in fact it
can't be. The "nativ" implementation will be able to handle these
problems, however.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Wed, 26 Apr 2000 00:25:01 -0400 (EDT)
Date: Wed, 26 Apr 2000 00:25:01 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] rheise.os-0.1.2 released

> Echidna does as you are saying but it suffers from the flaw I'm pointing
> out: System.setIn() stuffs everything up, and we must support it.
> Echidna provides a non-standard api for setting System.in to avoid the
> problem but this means standard Java programs that attempt to call
> System.setIn() will stuff up the system (all processes will suddenly
> start reading from the single stdin that was just set).

	Now I'm certain I wasn't thinking clearly.  Ignore the question
about splitting things up, then.  (my apologies for filling mailboxes like
this)

-_Quinn





From ryan@whitewolf.com.au Thu, 27 Apr 2000 00:25:56 +1000 (EST)
Date: Thu, 27 Apr 2000 00:25:56 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Java Processes: Final Summary?

On Tue, 25 Apr 2000, Todd L. Miller wrote:

> > Shared-object IPC might be more important from a functional perspective.
> > rheise.os demonstrates that JavaProcess objects must be shared (although
> > I'm sure there are hacky ways around this).
> 
> 	D'oh!  I'd clean forgotten that we needed shared objects for
> rheise.os.  How about:
> 
> "The desire for multiple processes ... benefits.  Most elegant
> implentations of multiple processes requires shared-object IPC, if for
> nothing aside from the created process object.  (Strictly, the process
> object returned to the creating function could be a message-passing stub,
> like RMI.)"

Sounds fine.

> > - I think the mechanism for (1) needs to be investigated further.
> >   Flagging the object is one way to handle it. Another way is to simply
> > control "access" to the object. A process can't ordinarily gain access to
> > an object in another process, so there needs to be some bridge method
> > that returns a reference to an object of another process. This method
> > can perform access control. The difficulty in flagging is that you can't
> > simply flag an object as shared because that won't give you access to
> > its member variables, or to objects returned by methods on the object
> > you do have access to. Flagging is obviously a way to make the system
> > safer, but is it really necessary?
> 
> 	Flagging was my suggestiong for an implementation of (1).  With a
> bridge method, once the object has been returned, how does decaf know it
> can be 'illegally' cast?

If we use a bridge method, that method can perform access control,
meaning decaf itself doesn't need to do access control. So, decaf can
allow illegal casts between any two objects that share the same class
definition, so long as you are "able to gain access to" the object.

There are advantages and disadvantages to both approaches but I suspect
implementing access control in a Java method will be simpler than
providing special JVM support. So even if we end up agreeing that
objects must be flagged, I think it might be easier to start with the
simplest implementation.

> > "Now, if the client process directly accesses static members, it will
> > access the cloned versions that belong to its own process. However, if
> > you call a method on an object that really belongs to another process,
> > and that method accesses a static member, then it should access the
> > static members of the class in the _other_process. Are there any
> > problems in implementing that?"
> 
> 	I think it comes out implicitly in the way things are done by the
> interpreter.  The shared object's class references will be resolved in/by
> the classloader which loaded it first, because the CL of an object
> (actually, of its class definition) is never changed.  This should be an
> exact fit for the ownership semantics.  This also means, incidentally,
> that a process that exits can't be cleaned up until we're sure no shared
> object classloaders point at it.  (That is, we have to run a garbage
> collection on process exit.)

You could provide the option to share objects via weak references (JDK
1.2). In this case, references to the shared object will automatically
become null when the server process exits.

Otherwise, you need to somehow notify the client processes that the
server's dead and they should give up their references. That may mean
that the clients must themselves exit.

Or, another option is to have clients deal with a proxy object that
transparently hooks up to the new version of the shared server object if
the server is simply restarted. This might not work if state information
is lost.

> 	I'll think about how to add this to the summary.

Ok.

> > Can you point me to these papers? Thanks.
> 
> 	http://www.cs.umd.edu/~pugh/java/  has a great deal of information
> about various problems with Java, including the memory model and
> type-safety.  (esp see his paper from the ACM Java Grande conference)

Thanks. I'll be sure to check it out.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Wed, 26 Apr 2000 16:21:53 -0400 (EDT)
Date: Wed, 26 Apr 2000 16:21:53 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Java Processes: Final Summary?

> If we use a bridge method, that method can perform access control,
> meaning decaf itself doesn't need to do access control. So, decaf can
> allow illegal casts between any two objects that share the same class
> definition, so long as you are "able to gain access to" the object.

	That is, it will always allow 'illegal' casts, because you can
only ever be in a position to make them if the access control allows you.  
I never meant to suggest that decaf itself would handle access control,
just that given access control, we could make our checks more
efficient, that is, not check for illegal casts.  I'll say it again --
object flagging/tagging is not necessary, it just seems like a good
implementation idea.

> You could provide the option to share objects via weak references (JDK
> 1.2). In this case, references to the shared object will automatically
> become null when the server process exits.

	Of course, this doesn't help for jdk1.1.x apps, but again, since
JOS is defining this interface, that may not be a problem.  Elegant,
though.  (A pity decaf doesn't do weak references quite yet.)

> > 	I'll think about how to add this to the summary.
> 
> Ok.

	It /is/ on the wiki (MultipleJavaProcesses), so if you've got any
good ideas, feel free to help out with the editing.

-_Quinn





From ryan@whitewolf.com.au Thu, 27 Apr 2000 10:10:13 +1000
Date: Thu, 27 Apr 2000 10:10:13 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Java Processes: Final Summary?

"Todd L. Miller" wrote:

>         That is, it will always allow 'illegal' casts, because you can
> only ever be in a position to make them if the access control allows you.
> I never meant to suggest that decaf itself would handle access control,
> just that given access control, we could make our checks more
> efficient, that is, not check for illegal casts.  I'll say it again --
> object flagging/tagging is not necessary, it just seems like a good
> implementation idea.

I see, I misunderstood. Then when is an object flagged? And what is the
exact definition of what it means for an object to be flagged?

Whether or not an object can be shared depends on the two processes
(class loaders) involved. An object in process A may be shared with
process B if both processes share the same class definition for that
class. However, process C may have a different (eg. newer) class
definition for that class and even if the object is flagged, it may not
be shared with this process. So, if we have a flag, its usefulness is in
testing if the object may _not_ be shared. The opposite is that it can
_potentially_ be shared, and the two classes must be checked to see if
they have the same class definition to be certain that the object can be
shared.

Another point occurred to me: efficiency may not be that important since
access to shared objects will be rare (compared with access to objects
that are in the same process).

> > You could provide the option to share objects via weak references (JDK
> > 1.2). In this case, references to the shared object will automatically
> > become null when the server process exits.
> 
>         Of course, this doesn't help for jdk1.1.x apps, but again, since
> JOS is defining this interface, that may not be a problem.  Elegant,
> though.  (A pity decaf doesn't do weak references quite yet.)

On the topic of JDK 1.1.x vs. JDK 1.2, rheise.os is currently based on
JDK 1.1 (which is convenient for decaf). Al <Alexis Petrounias> pointed
out to me that his registry depends on JDK 1.2, and to integrate his
work with mine we will need to either move our base level support to JDK
1.2, or rewrite his registry to support JDK 1.1. I'm a bit nervous about
moving to JDK 1.2 just yet, but I'm wondering whether you have a
different opinion. Is JDK 1.2 realistic for you?

>         It /is/ on the wiki (MultipleJavaProcesses), so if you've got any
> good ideas, feel free to help out with the editing.

I must have missed it. We are talking about access to statics of shared
objects, right?

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From gchii@mindspring.com Thu, 27 Apr 2000 12:23:20 -0400
Date: Thu, 27 Apr 2000 12:23:20 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Java Processes: Final Summary?

We are so close to the right answer.

We must be careful not to add complexity when complexity is not needed. The
minimalist approach is always best. We are looking for the smallest
possible change to the standard Java Virtual Machine Specification to
accomplish multiple Java processes. In short, we only need a few new things:

1. multiple primordial class loaders
2. a process management API, like rheise.os

We only need to optimize the design for a few things:

1. highly optimized protocol stack for inter-process communication
2. bytecode/class definition cache

At 10:10 AM 4/27/00 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>I see, I misunderstood. Then when is an object flagged? And what is the
>exact definition of what it means for an object to be flagged?

Streams, RPC, IPC, RMI and CORBA are fundamental building blocks of shared
objects. "Flagging" an object as shared is un-definable. Very quickly
flagging shared objects gets very complicated. Why re-invent the wheel? We
already have a well-refined inter-machine communication that solves the
inter-process communication problem. A protocol stack, like JEPS, is the
only subsystem that might be optimized for object sharing. It is the
protocol stack and only the protocol stack that can be optimized for a
MPCL-compatible virtual machine.

A protocol stack only shares data, not objects. Therefore, an optimization
of communication between processes within a virtual machine is simple,
direct and follows all of the rules of transparency.

>Whether or not an object can be shared depends on the two processes
>(class loaders) involved. An object in process A may be shared with
>process B if both processes share the same class definition for that
>class. However, process C may have a different (eg. newer) class
>definition for that class and even if the object is flagged, it may not
>be shared with this process. So, if we have a flag, its usefulness is in
>testing if the object may _not_ be shared. The opposite is that it can
>_potentially_ be shared, and the two classes must be checked to see if
>they have the same class definition to be certain that the object can be
>shared.

An object is by definition 'shared' when it is found in an RMI or CORBA
registry. At a high level, any user process can share an object with any
other process. At a low level, an optimized protocol stack is the only
system component that "knows" that it is running in a MPCL-compatible
virtual machine.

>Another point occurred to me: efficiency may not be that important since
>access to shared objects will be rare (compared with access to objects
>that are in the same process).

Exactly! The greatest positive impact comes from a protocol stack that
takes advantage of a MPCL-compatible virtual machine. By making the
protocol stack more efficient, we make all applications more efficient,
even RMI and CORBA.

>On the topic of JDK 1.1.x vs. JDK 1.2, rheise.os is currently based on
>JDK 1.1 (which is convenient for decaf). Al <Alexis Petrounias> pointed
>out to me that his registry depends on JDK 1.2, and to integrate his
>work with mine we will need to either move our base level support to JDK
>1.2, or rewrite his registry to support JDK 1.1. I'm a bit nervous about
>moving to JDK 1.2 just yet, but I'm wondering whether you have a
>different opinion. Is JDK 1.2 realistic for you?

The multiple primordial class loader (MPCL) design is not limited to one
Java platform. A kernel is not tied to one virtual machine, is it? On one
machine I could run decaf on top of jJOS. On another, I could run an
experimental version of decaf on top of jJOS, right? A kernel is not
reusable if it only runs one virtual machine. All Java platforms must be
implemented eventually, not just one. An open architecture must enable the
link process to determine which virtual machine (if any) is statically
linked to a kernel.

>I must have missed it. We are talking about access to statics of shared
>objects, right?

We should not tamper with the simplicity of the Java Virtual Machine
Specification. We should not change the semantics of object ownership. All
objects -- with no exceptions -- are owned by their corresponding process.
An object cannot be owned by more than one process. An object cannot
literally be shared, even in a MPCL-compatible virtual machine. It can only
be shared by proxy.

The protocol stack should be able to pass a packet (the value of a byte
array) from one bytecode process to another. A packet does not escape a
virtual machine when it's destination is another process within the virtual
machine. Even when there are multiple virtual machines running on a kernel,
a packet does not escape a kernel when it's destination is another virtual
machine within the kernel. The protocol stack can efficiently copy a byte
array from one process to another by sending a DatagramPacket.

Some objects might not be shareable between Java platforms. The
restrictions on sharing objects is identical to what already exist for
sharing objects between Java platforms. Serialization is not, nor has ever
been, the answer to long-term object persistence. Just as a Java 1.2 client
won't connect to a Java 1.1 RMI service, you can't automatically share
objects between different Java platforms. Many class designs have radically
changed although names are the same. That is fatal to long-term object
persistence.





From tmiller@haverford.edu Thu, 27 Apr 2000 14:18:54 -0400 (EDT)
Date: Thu, 27 Apr 2000 14:18:54 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Java Processes: Final Summary?

> I see, I misunderstood. Then when is an object flagged? And what is the
> exact definition of what it means for an object to be flagged?

	I just wrote some example code and realized something: the
efficiency benefit I was considering is actually rather small, because you
could code the instanceof/checkcast stuff to call a function to compare if
two classes/interfaces are the same, like so:

bool classEQ( dst, src ) {
	if ( dst->classdefinition == src->classdefinition ) {
		return true;
		}
	else if ( dst == src && dst->classloader == src->classloader ) {
		return true;
		}
	else {
		return classEQ( dst->parentclass, src );
		}
	}

	The only additional cost to always allowing illegal casts is the
single if statement at the beginning, which is comparing pointers to
classdefinitions, and is thus cheap.  (With multiple native processes, it
would have to compare GIDs, instead, because pointers aren't unique, but
this applies everywhere I assume they are, like the next if.)

	Originally, I'd been thinking the additional cost for always
allowing illegal casts would be high, but it's not, for two reasons: the
class definition sharing is done at class loading, and second, because our
OO-IPC method secures cross-process object references, we don't have to
worry about security.

	So it turns out I was, in fact, just being totally stupid.

> On the topic of JDK 1.1.x vs. JDK 1.2, rheise.os is currently based on
> JDK 1.1 (which is convenient for decaf). Al <Alexis Petrounias> pointed
> out to me that his registry depends on JDK 1.2, and to integrate his
> work with mine we will need to either move our base level support to JDK
> 1.2, or rewrite his registry to support JDK 1.1. I'm a bit nervous about
> moving to JDK 1.2 just yet, but I'm wondering whether you have a
> different opinion. Is JDK 1.2 realistic for you?

	Honestly, I haven't looked at how different (in VM terms) JDK1.2
is from 1.1.x; I'm still not supporting inner classes, either.  I'll look
into, hopefully sometime soon, but I'm not optimistic.  My gut feeling is
that Sun added a great deal of native code to the 1.2 libraries to allow
it do what it does, code that we're not going to port any time
soon.  (and/or that classpath will have implementations of)  The JVM
changes could very well be very minor -- I've been programming out of the
Second Edition VM spec, which I think covers the VM for JDK1.2 -- it, at
least, mentions it fairly often.  Even before I started re-writing decaf,
it didn't support certain things in the spec just because I hadn't gotten
around programming them yet.  Actually, I'm pretty sure the JVM changes
will fairly minor, because otherwise the 1.2 jdk couldn't run 1.1 code :)

> I must have missed it. We are talking about access to statics of shared
> objects, right?

	Right.  MultipleJavaProcesses is the wiki topic for the text 
of the 'final summary', which seems to me like a good place to put this
kind of consideration; I was just setting up the wiki page as a
possibility for collaboration.

-_Quinn





From ryan@whitewolf.com.au Fri, 28 Apr 2000 17:20:14 +1000
Date: Fri, 28 Apr 2000 17:20:14 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Java Processes: Final Summary?

Gilbert Carl Herschberger II wrote:

> Streams, RPC, IPC, RMI and CORBA are fundamental building blocks of shared
> objects.

I see it the other way around. Shared objects and streams are
fundamental building blocks of RPC, IPC, RMI and CORBA.

Optimising the protocol stack requires shared objects as a fundamental
building block. 

> "Flagging" an object as shared is un-definable. Very quickly
> flagging shared objects gets very complicated. Why re-invent the wheel? We
> already have a well-refined inter-machine communication that solves the
> inter-process communication problem.

While flagging has its problems, that doesn't rule out having object
sharing as a fundamental primitive. The existing inter-machine IPC
solution satisfies us for inter-machine IPC but not inter-process IPC on
the same machine. Raw object sharing is *much* faster. Even with an
optimised protocol stack as you described (even though this is a good
idea, as far as optimising the operation of existing RMI and CORBA
implementations goes), the very nature of this style of IPC means it has
to do much more additional work. Even if you optimise the transfer of a
packet from one process to another, the data in that packet needs to be
serialised and un-serialised. Using raw shared objects (either directly
or via a proxy) means that objects do not need to be serialised and read
back in to construct a new object.

> An object is by definition 'shared' when it is found in an RMI or CORBA
> registry.

Not in the sense that of the term 'object sharing' that we have used so
far. RMI and CORBA provide a way to effectively share objects when you
don't have (or can't have) true object sharing.

> >Another point occurred to me: efficiency may not be that important since
> >access to shared objects will be rare (compared with access to objects
> >that are in the same process).
> 
> Exactly! The greatest positive impact comes from a protocol stack that
> takes advantage of a MPCL-compatible virtual machine. By making the
> protocol stack more efficient, we make all applications more efficient,
> even RMI and CORBA.

Yes we do, but we could make RMI and CORBA more efficient (for IPC on
the same machine) by writing our own versions that use true object
sharing.

> >On the topic of JDK 1.1.x vs. JDK 1.2, rheise.os is currently based on
> >JDK 1.1 (which is convenient for decaf). Al <Alexis Petrounias> pointed
> >out to me that his registry depends on JDK 1.2, and to integrate his
> >work with mine we will need to either move our base level support to JDK
> >1.2, or rewrite his registry to support JDK 1.1. I'm a bit nervous about
> >moving to JDK 1.2 just yet, but I'm wondering whether you have a
> >different opinion. Is JDK 1.2 realistic for you?
> 
> The multiple primordial class loader (MPCL) design is not limited to one
> Java platform. A kernel is not tied to one virtual machine, is it? On one
> machine I could run decaf on top of jJOS. On another, I could run an
> experimental version of decaf on top of jJOS, right? A kernel is not
> reusable if it only runs one virtual machine.

The JJOS kernel is not the issue since it has nothing directly to do
with any particular version of Java. JJOS can support any version of
Java because it doesn't handle Java directly.

The layer on top of JJOS (decaf/classpath) is what supports the
different versions of Java, and currently JDK 1.2 seems like a long way
off. That doesn't mean we can't use JDK 1.2 for the host version of
rheise.os, but my question is whether we should start writing core
system components of JOS to depend on JDK 1.2 when other parts (eg.
decaf) can't support it yet.

One option is to take the parts of classpath that support JDK 1.2 and
use them as libraries linked in to JOS running against JDK 1.1. For
example, classpath has an implementation of the collection APIs that we
can reuse under JDK 1.1 if we want to use them.

> >I must have missed it. We are talking about access to statics of shared
> >objects, right?
> 
> We should not tamper with the simplicity of the Java Virtual Machine
> Specification. We should not change the semantics of object ownership

--snip--

I'm out of time here, so I'll answer this later (in a couple of hours).
Sorry.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Fri, 28 Apr 2000 17:48:38 +1000
Date: Fri, 28 Apr 2000 17:48:38 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Java Processes: Final Summary?

Gilbert Carl Herschberger II wrote:

> >I must have missed it. We are talking about access to statics of shared
> >objects, right?
> 
> We should not tamper with the simplicity of the Java Virtual Machine
> Specification. We should not change the semantics of object ownership. All
> objects -- with no exceptions -- are owned by their corresponding process.

(before I answer, my proposal for access to statics of shared objects
doesn't change the semantics of object ownership, but I understand that
you're not responding directly to my comment)

Although I would personally choose to adopt the semantics of object
ownership you just described, I wouldn't rule out "changing" them. It is
similar to the concept of a UNIX hard link. You could say a file is
owned by a directory, but as soon as you make a hard link in UNIX, the
ownership is truly shared between all parent directories (UNIX hackers
will spot that I'm oversimplifying a little here).

But for the moment, suppose we state that an object is only 'owned' by
one process, it still may be useful to change the ownership of an object
to another process (eg. when the original owner dies, but other peers in
the distributed system want to keep on working with eachother). All I'm
saying is, I'm not ready to rule out ideas like this, although I don't
see the need to implement controversial ideas such as this right now. We
are in the early stages of development so we don't know what we will
need when we start to put JOS to use.

> An object cannot be owned by more than one process. An object cannot
> literally be shared, even in a MPCL-compatible virtual machine. It can only
> be shared by proxy.

Sharing by proxy is another idea again. But we can share an object
between multiple processes and still have a single owner.

Sharing by proxy means that rather than sharing a direct reference to
the object you want to share, a proxy/wrapper object is shared which
provides a level of protection for the owning process. However, to
implement this, we still need direct object sharing under the hood. I
think both types of sharing will be useful.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From ryan@whitewolf.com.au Fri, 28 Apr 2000 18:24:02 +1000
Date: Fri, 28 Apr 2000 18:24:02 +1000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Java Processes: Final Summary?

"Todd L. Miller" wrote:

>         Originally, I'd been thinking the additional cost for always
> allowing illegal casts would be high, but it's not, for two reasons: the
> class definition sharing is done at class loading, and second, because our
> OO-IPC method secures cross-process object references, we don't have to
> worry about security.
> 
>         So it turns out I was, in fact, just being totally stupid.

Hardly. If you stopped thinking the way you do, this project would make
far less progress.

I think flags are still useful if we use Gilbert's byte cache and apply
it to user defined class loaders. This breaks our assumption that any
two classes that share the same class definition can be shared. A more
correct statement is that any two classes that share the same class
definition and are loaded by primordial class loaders may be shared. It
just so happens that in my proposal for class definition sharing, my
original assumption held.

Although, even in this case, maybe the check can be done efficiently
without a flag.. Anyway, we can sort it out in the case that we end up
using Gilbert's byte cache.

>         Honestly, I haven't looked at how different (in VM terms) JDK1.2
> is from 1.1.x; I'm still not supporting inner classes, either.  I'll look
> into, hopefully sometime soon, but I'm not optimistic.  My gut feeling is
> that Sun added a great deal of native code to the 1.2 libraries to allow
> it do what it does, code that we're not going to port any time
> soon.

Right. It's not just the JVM support, but native code support. I think
the 1.2 JVM does need to maintain additional information associated with
the class loader, stuff that's related to security. I'm not certain this
is the case, but from looking at the security APIs, it seems like there
needs to be JVM support.


> Actually, I'm pretty sure the JVM changes
> will fairly minor, because otherwise the 1.2 jdk couldn't run 1.1 code :)

Although being backwards compatible doesn't mean that there aren't a
whole set of new features in JDK 1.2 that don't work under JDK 1.1.

> > I must have missed it. We are talking about access to statics of shared
> > objects, right?
> 
>         Right.  MultipleJavaProcesses is the wiki topic for the text
> of the 'final summary', which seems to me like a good place to put this
> kind of consideration; I was just setting up the wiki page as a
> possibility for collaboration.

Ok. I think it's probably best for you to work out how to phrase this
bit since you're most familiar with how the JVM works - if that's ok. Of
course, that means there's nothing left for me to write :-) Well, at
least for the moment.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





From tmiller@haverford.edu Fri, 28 Apr 2000 06:11:21 -0400 (EDT)
Date: Fri, 28 Apr 2000 06:11:21 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Java Processes: Final Summary?

> > Streams, RPC, IPC, RMI and CORBA are fundamental building blocks of shared
> > objects.
> 
> I see it the other way around. Shared objects and streams are
> fundamental building blocks of RPC, IPC, RMI and CORBA.

(Strictly speaking, you could have said "Shared objects and streams are
the fundamental building blocks of RPC, RMI, and CORBA," because the other
five things are all types of IPC.  But anyway...)

	Any form of IPC can be implemented in terms of any other form of
IPC.  Shared objects are currently implemented as message-passing between
stubs, because they can't be shared directly in a conventional JVM.  It is
similarly easy to see how RMI -- the invocation of a method in another
process -- could implemented using shared objects.  The distinction and
equivalance between IPC methods is of fundamental importance to parallel
programming; the question of whether message-passing or shared-memory is
appropriate rests on two questions: first, which is easier to program
(which interface should you use?); and second, which is more efficient (is
this program running on an 8-way SMP Alpha?  8 Athlons on a 10baseT
network?), where the hardware topology is the primary determinant.  That
is, the 8-way SMP will have better shared-memory performance, usually,
than the network of workstations (NOW).  On the 8-way SMP, message-passing
is implemented as an operation on shared memory, because it's so fast (has
hardware support).  On the NOW, shared memory is implemented as
message-passing because the only h/w support for i/o between nodes is the
message-based network.

	We can provide interfaces to both shared-memory (shared
object/stream) and message-passing (RPC, RMI, CORBA) techniques.  The
implementation of these interfaces (some of which are required by Java,
some of which we can define) is h/w-specific.  My feeling is that the
complexity of supporting loosely-coupled (non-physically-shared-memory)
hardware should not be present in the kernel, and should be handled in a
user-space library.  That user-space library may very well be jos.os.*!  
The kernel shouldn't be able to tell.  As a matter of fact, of all the
IPC methods, only shared memory requires kernel support.  Message-passing
can always be arranged over the loopback network device.  (Well, the
loopback network device (traditionally) requires kernel support, but it's 
not exclusively used for IPC.)  Writing the RPC, CORBA, and RMI libs is,
from my rather narrow-minded JVM-author POV, somebody else's
problem.  Whether or not they're optimized for an architecture which can
share objects is not my concern...  [btw, I used kernel a whole lot up
here, and I technically should have been saying JVM support.  While kernel
support would be necessary if we had native processes, we don't, so...]


	Multiple native processes do not require 'natively' shared
objects, as me and Ryan and have been contending; you could, conceivably,
have the JavaProcess object in each Java process stub out to the canonical
single JavaProcess that the (JVM's) scheduler plays with.  Doing this in
(non-decaf) Java would require the use of RMI, which really should be
implemented user-space -- and making a user-space call to create a process
strikes me as a Bad Idea.  Implementing it natively, we actually have two
choices: first, make two JavaProcess objects, one for each Java process,
that have private native pointers to the same JVM (C++) object, and whose
methods (all native) all operate on that object.  The second choice is
more elegant, because it's a general solution to the problem of
implementing a shared-objects API based on having references to
processes.

(BTW -- this API must be different from the one that would allow shared
objects across multiple machines; again, we don't want process creation to
depend on a user-space call.  That user-space API (PJM, let's say, for
parallel java machine) would use the kernel (JVM) -level calls for shared
objects if the processes in question were both/all on the same machine.)

	The difficulty in the second choice -- what Ryan and I have been
discussing/advocating -- doesn't like so much in enourmous complexity, but
in doing it for the first time.  AFAIK, nobody's done work quite like this
before.  (Though I have not done a literature search to confirm
that.)  We must be very careful with what we're doing, and that takes time
and alot of attention to little nagging details that looks suprisingly
like complexity. :)  My objective in object-sharing is the principle of
least suprises, mostly -- we want shared objects to act the way they
'ought' to act, which, to me, implies the way objects shared between
threads do.  It may be that we can't guarantee (sp?) certain properties we
must be able to if we allow/support this very simple model.  (Also, most
of the recent traffic has involved my rather stupid thoughts on
flagging, which turns out to be totally useless.)

	What properties do we need to guarantee?  First, that object
sharing doesn't violate any requirements for in the VM or language specs,
aside from the (I think) solved problem of type-safety.  That is, will the
program operate as it should?  Second, we need to guarantee that object
sharing does not adversely impact security or stability.  This combination
of conditions may very well impose some very strict limits on the kinds of
objects that can be shared.

	In general, shared objects are desirous across processes for the
same reasons they are across threads.  I see two: first, data, and second,
methods.  For the first, shared-memory is a very convienient way to
program certain kinds of parallelism; the second is OOP principle of
packaging data with the methods necessary to utilise it.  As it turns out,
we can mostly ignore methods!  Their bytecode is shared in the class
definition share that enables object sharing.  Because the data associated
with methods reside with the object, synchronization will behave exactly
as expected across processes.  Sharing of data...

	Clearly, sharing primitive types is not a problem, since they get
handled by-value anyway.  (And since Strings are immutable, you could make
a good argument that could be 'shared' by copying and nobody could
tell.)  The question that remains to ponder is what happens when (a) we
copy an object reference from a shared object or (b) a shared object's
method returns an object reference.

-_Quinn






From gchii@mindspring.com Fri, 28 Apr 2000 08:40:37 -0400
Date: Fri, 28 Apr 2000 08:40:37 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Java Processes: Final Summary?

At 05:48 PM 4/28/00 +1000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>Although I would personally choose to adopt the semantics of object
>ownership you just described, I wouldn't rule out "changing" them. It is
>similar to the concept of a UNIX hard link. You could say a file is
>owned by a directory, but as soon as you make a hard link in UNIX, the
>ownership is truly shared between all parent directories (UNIX hackers
>will spot that I'm oversimplifying a little here).

A link in a file subsystem is a useful analogy to the object graph in a
MPCL-compatible virtual machine. In a non-linked file, there must be two
parts: the actual payload (which exists once regardless of how many links)
and a directory entry. The payload exists for a while after the directory
entry is garbage collected. In a linked file, there are more than two
parts: the actual payload and one directory entry for each link.

In a virtual machine, it is hard to think about the object in the same way.
On the one hand, a system-wide object (without its class loader property)
is just like a payload. A process-specific object (with its class loader
property) is normally what we think of as an instance of java.lang.Object.

With a certain level of redirection, a system-wide object might be "owned"
by one or more processes if a list inside the object holds a reference to
each process. At the machine code level, all objects are owned by a virtual
machine.

In other words, the Process property is a list, not an item.

  public Process[] getProcessList() {
  :
  }
  public void addProcess( Process v ) {
  :
  }
  public void removeProcess( Process v ) {
  :
  }

When an object is "shared" it has more than one process in its process
list. During garbage collection, an object is destroyed when there are no
more processes in its process list.

>But for the moment, suppose we state that an object is only 'owned' by
>one process, it still may be useful to change the ownership of an object
>to another process (eg. when the original owner dies, but other peers in
>the distributed system want to keep on working with eachother). All I'm
>saying is, I'm not ready to rule out ideas like this, although I don't
>see the need to implement controversial ideas such as this right now. We
>are in the early stages of development so we don't know what we will
>need when we start to put JOS to use.

This is the best thing I've heard all week. We can provide a function to
"move" an object from one user process to another. In other words, an
object can be passed to another process simply by modifying its Process
property.

I can imagine that a DatagramPacket can be "sent" to another user process
by updating its Process property from a protocol stack to a user process.
Since the protocol stack no longer owns the object, it can be garbage
collected in the usual way.

The idea of moving an object around, from process to process, is a strong
point of Java technologies. The same function could move an object from one
machine to another.

There is only one catch. A complex object could not be moved from one
process to another without moving all of its dependent objects. While it
might be good for shallow moves, it could not be automatic for deep moves.

>Sharing by proxy is another idea again. But we can share an object
>between multiple processes and still have a single owner.

A directory entry is a proxy for a file's payload. A directory and payload
are separate. An object proxy is like a directory entry. A proxy is owned
by exactly one process. Behind the scenes, a proxy has an object property.
The object property always points to an object owned by the system process.

>Sharing by proxy means that rather than sharing a direct reference to
>the object you want to share, a proxy/wrapper object is shared which
>provides a level of protection for the owning process. However, to
>implement this, we still need direct object sharing under the hood. I
>think both types of sharing will be useful.

I believe a proxy will be more efficient than direct references. When the
Process property of each object is an item, it is very easy for the process
to be de-referenced. It is straight forward.

The idea of maintaining a list (see above) of processes makes it simple to
maintain process information but makes it difficult to de-reference. The
complexity is this: a process object returned from getProcessList() belongs
to another process. The implications of this are incomprehensible.

When each object belongs to exactly one process, the implications are easy
to understand (easy to code) and limit the object sharing to a centralized API.





From gchii@mindspring.com Fri, 28 Apr 2000 08:59:17 -0400
Date: Fri, 28 Apr 2000 08:59:17 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Java Processes: Final Summary?

At 02:18 PM 4/27/00 -0400, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	I just wrote some example code and realized something: the
>efficiency benefit I was considering is actually rather small, because you
>could code the instanceof/checkcast stuff to call a function to compare if
>two classes/interfaces are the same, like so:
>
>bool classEQ( dst, src ) {
>	if ( dst->classdefinition == src->classdefinition ) {
>		return true;
>		}
>	else if ( dst == src && dst->classloader == src->classloader ) {
>		return true;
>		}
>	else {
>		return classEQ( dst->parentclass, src );
>		}
>	}

Exactly! Earlier, I offered an equivalent example in the Java programming
language and used bytecode instead of class definition. Bytecode and class
definition are the same thing.

Class definitions (or bytecode) can be intern'd. If the primordial class
loader is the only class loader that can intern a class definition,
checking for equal class loaders is redundent. An object can be shared if
its class definition is the same.

bool classEQ( dst, src ) {
	if ( dst->classdefinition == src->classdefinition ) {
		return true;
		}
	else {
		return classEQ( dst->parentclass, src );
		}
	}


If a primordial class loader is written in bytecode, it needs to intern
class definitions too. Any class definition could be intern'd by any class
loader. If both primordial and custom class loaders can intern a class
definition, an object can be shared if its class definition is the same.

bool classEQ( dst, src ) {
	if ( dst->classdefinition == src->classdefinition ) {
		return true;
		}
	else {
		return classEQ( dst->parentclass, src );
		}
	}

If the Java standard class library is broken into two parts, boot packages
and standard packages, only part of the standard class library will be
loaded by a machine code class loader. Boot packages are loaded by a
primordial class loader. Standard packages will be loaded by a custom class
loader.

I'm pretty sure I cannot make use of an operating system that exclusively
intern's system classes. Most of the reusable classes in my applications
are /not/ system classes. JEPS, JADE and JSDK and other javax.* packages
are big; but, they are /not/ system classes. Even their class definitions
should be intern'd.





From tmiller@haverford.edu Fri, 28 Apr 2000 13:58:36 -0400 (EDT)
Date: Fri, 28 Apr 2000 13:58:36 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Java Processes: Final Summary?

	w.r.t. to the ownership of JavaProcess objects, it has occured to
me that we could do things the UNIX way.  getJavaProcess() does not return
the process object used by the VM, but an object wrapping a pid with
whatever functions we feel are appropriate.  With the process identified
with a by-value variable (e.g. the pid), we don't have to worry about who
owns what; we just return the pid by-value, or create a new pid wrapper
every time getJavaProcess() is called.  ("Those who forget UNIX are doomed
to re-write it, poorly.")  UNIX uses the magic-number principle for
(AFAIK) every object (a socket, a file, a process, etc) for everything
returned to userspace by the kernel.  With this in hand, we can code
multiple java processes without having to decide if/how we handle the
general case of shared objects.  This is, BTW, an adaptation of Gilbert's
proxy idea, where don't have to concern ourselves with any problems or
limitations which may arise in the general case.

-_Quinn






From tmiller@haverford.edu Fri, 28 Apr 2000 14:20:38 -0400 (EDT)
Date: Fri, 28 Apr 2000 14:20:38 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Java Processes: Final Summary?

> Exactly! Earlier, I offered an equivalent example in the Java programming
> language and used bytecode instead of class definition. Bytecode and class
> definition are the same thing.

	Well, from here in the JVM trenches, they're not, but yeah, I
think I see where you were coming from.

> Class definitions (or bytecode) can be intern'd. If the primordial class
> loader is the only class loader that can intern a class definition,
> checking for equal class loaders is redundent. An object can be shared if
> its class definition is the same.

	I thought there was a hole in this somewhere when I coded the
example, but I may be wrong.  (That is, since pointers to class
definitions vary between classloaders, they carry information equivalent
to both...)  I'll think about this some more.

> If a primordial class loader is written in bytecode, it needs to intern
> class definitions too. Any class definition could be intern'd by any class
> loader. If both primordial and custom class loaders can intern a class
> definition, an object can be shared if its class definition is the same.

	No.  A custom classloader which does not use findSystemClass() (or
equivalent, e.g. asking a process-wide static for a Class) can not share
definitions with another custom classloader.  The semantics of the VM
require that those classes be considered different, and to do otherwise is
not transparent to 'legacy' applications which use custom
classloaders.  If a custom classloader passes on a Class from somewhere
else in the same process, naturally the Class is the same in both
classloaders, and casting is allowed.  (According to my recollection of
the spec.)

> I'm pretty sure I cannot make use of an operating system that exclusively
> intern's system classes. Most of the reusable classes in my applications
> are /not/ system classes. JEPS, JADE and JSDK and other javax.* packages
> are big; but, they are /not/ system classes. Even their class definitions
> should be intern'd.

	Yes, the should be, but in order to make sure that their sharing
is transparent, they must be loaded by a primordial loader.  However,
there is not, to my understanding, a limitation on how the class
definition gets into the primordial loader.  You have pointed out that a
bytecode primordial loader ought to be possible; it would then be
relatively easy to perform whatever non-mounted-fs method you want in
order to generate class definitions.  If we could define a special variety
of custom classloaders that could be used to generate class definitions to
hand off to a primordial loader, than we /may/ be able to do shares that
way.  But I think this is a complexity that can be handled later.

-_Quinn





From gchii@mindspring.com Fri, 28 Apr 2000 21:12:40 -0400
Date: Fri, 28 Apr 2000 21:12:40 -0400
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Bytecode vs. class definition

The difference between bytecode and class definition is negligible. It's
hardly worth mentioning. It is six of one and half dozen of another. My
math is horrible; but, even I understand equivalence.

X = Y, therefore Y = X

The subtle difference -- the only one I've been able to find so far -- is
how bytecode retains the original payload of a class file and a class
definition does not. The slight difference is only an issue of how
efficiently they can be intern'd, not semantics.

Both bytecode and class definition are everything besides the static
fields. These are objects, which are not quite a class.

It doesn't matter so much how efficiently the comparison operator (==)
works, as long as I have one:

  class ClassDefinition {
    public:
      bool operator==( const ClassDefinition &v );
  :
  };

vs.

  class Bytecode {
    public:
      bool operator==( const Bytecode &v );
  :
  };

One class definition can be compared to another. One bytecode object can be
compared to another. Bytecode is a class definition; class definition is
bytecode.





From tmiller@haverford.edu Fri, 28 Apr 2000 21:40:14 -0400 (EDT)
Date: Fri, 28 Apr 2000 21:40:14 -0400 (EDT)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Bytecode vs. class definition

> The subtle difference -- the only one I've been able to find so far -- is
> how bytecode retains the original payload of a class file and a class
> definition does not. The slight difference is only an issue of how
> efficiently they can be intern'd, not semantics.

	There are -- I believe -- other efficiency benefits to class
definitions, but I also can't come up with a reason why you couldn't wrap
bytecode in the same interface as you do a class definition and have
everything happen correctly.  It may be worthwhile at some point to write
such a class and see; it would become painfully clear, as well, where
efficiency gains could be made.  For instance, constant pool look up --
which happens all the time -- doesn't lend itself to O(1) (constant-time)
lookups, because the constants in the pool aren't the same size.  
Converting (or maintaining) to a list of pointers to constant pool entries
changes the algorithm from O(n) (linear-time search) to O(1), while
increasing the space bound by n.  Given that our target platform is a PC,
I think we can afford that.  Similar issues occur w.r.t. encoded values,
especially UTF-8 to (wide) character strings.

	There is analogy between a compressed zip archive of classfiles
and the exploded directory tree, and the classfile and the class
definition.

-_Quinn





From ryan@whitewolf.com.au Mon, 1 May 2000 01:12:46 +1000 (EST)
Date: Mon, 1 May 2000 01:12:46 +1000 (EST)
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] rheise.os-0.1.3 released.

Available at:

	http://www.progsoc.uts.edu.au/~rheise/projects/rheise.os/

One of the main changes in this release is that the manager classes are
now purely static, meaning you can call ProcessManager.createProcess()
instead of ProcessManager.get().createProcess(). This also means I had
to include a compatible version of SwingToolkit in this release
(contrary to what I said I would do).

All implementation specific classes have been moved out of the main
public packages and into rheise.os.impl. So, for example,
rheise.os.process only contains classes that application developers
might wish to use. This is similar to how java.* only contains classes
application developers might use, and sun.* contains their private
implementation classes.

I would imagine that if rheise.os.* is renamed to jos.*, we could have
jos.process.ProcessManager, and
org.jos.process.host.HostProcessManagerImpl. This implies that
application developers should never use the org.jos package. I realise
that the JOS project has already agreed on the exact opposite, but this
seems to make more sense to me so I thought I'd raise the issue again.
Thoughts?

But back to the release, here is the latest changelog entry:

        - JavaProcess is now a subclass of java.lang.Process.
        - Made managers static (ie. no need to call ProcessManager.get())
        - Split managers into xxxManager and xxxManagerImpl.
        - Moved implementation specific classes to rheise.os.impl.*
        - BaseJavaProcess maintains process state.
        - Processes are now cleaned up properly when they terminate.
        - Renamed kill() to destroy()
        - Added unit tests.
        - Added comments!!! Well, for process.* anyway.

Enjoy.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/





