From gchii@mindspring.com Sat, 06 Nov 1999 09:34:11 -0500
Date: Sat, 06 Nov 1999 09:34:11 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Out-of-sync w/ Source Code

There are two things that snuck up on me and gave me a big surprise.

1. The first thing is that my development process has not been able to
guarantee all of the class files are up-to-date with their corresponding
source code. I use make on a project-by-project basis. As a ritual, I make
or rebuild a project at the end of a development session.

While working on a bulk make program to compile all of the JOS Project
source code, I wrote a program to scan all packages and show when
out-of-sync class files. When a class file does not exist, it is
out-of-sync. When source code was saved after the class file was compiled,
it is out-of-sync.

I make a few simple assumptions:

(1) all .java files should be compiled;
(2) all directories with .java files are packages

What was the surprise? Many of my class files were out-of-sync even while I
use a make program. It seems that some of my .java files aren't compile-able.

The first program in bulk make showed me which packages needed to be made.
I made the packages in the usual way, with make. Eventually, bulk make will
call the javac tool when a class is out-of-sync.

2. The second surprise is that I forgot to publish a few of the JOS Project
packages. For example, the smartregistry1a package contains the connection
between a registry and the Smart API. While I have been using the Smart API
to fetch a registry in my own programs, I had the mistaken impression other
programmers could, too.

While working through the binary distribution of the Java-based part of the
JOS Project, I found that there is a lot of source code that cannot be
recompiled. While some packages depend on com.sun.java.swing.*, others
depend on javax.swing.*. This concerns me. While I have voice my concern
before, let me explain the impact of this on JOS architecture.

1. JOS is an operating system. As an operating system, it is expected to be
a general purpose mechanism to operate the computer. It must be able to
launch and run with success any program written in Java, with few exceptions.

2. The condition of the source code inside the JOS Project proves that Java
is a hostile environment for open source projects. The purpose of an open
source project is to demonstrate good code, working code. When we build an
open source program that can't be compiled after 90 days, it proves that
Java is a hostile environment for software that lasts.

3. Fixing the source code which has already been collected by the JOS
Project is going to be a monumental task. There are so many different
things that this source code depends on.

(a) Where is the Pizza compiler? The URL that I have doesn't work any more.
Has it moved? Without the Pizza compiler, the FreeBuilder application for
JOS cannot be compiled.

(b) Where is the JOS development of the java.* packages?

(c) What is the status of the FreeSwing project?

My recommendation is this: We need to form a distribution group. It should
be a special interest group under architecture (continuing to use the
architecture mailing list).

Should we drop FreeBuilder for JOS? When FreeBuilder for Java will run
unchanged on JOS, does there need to be a JOS-specific release?

The 'classfile' package is significant to the development of a virtual
machine. And yet, there are major problems with the 'classfile' package as
a pure reflection library. For example, the core components of the
'classfile' package must not throw a ClassFormatError. Only a class file
that is loaded for the purpose of running inside the virtual machine should
"throw" an error.

Do you know there are two org.jos.util packages? There are two packages
with the same name and (fortunately) a different set of classes.

In order to make the JOS worthwhile as an open source project, all its code
must be compile-able on other programmer's machines. We should be able to
demonstrate frequently how easy it is to download and recompile the whole
collection of source code.

Many people would prefer a binary distribution. I am working toward
building a binary distribution to prove that the Java source code can be
compiled and used in working Java programs.

What will it take to reach this goal?




From iainshigeoka@yahoo.com Sat, 6 Nov 1999 12:42:55 -0600
Date: Sat, 6 Nov 1999 12:42:55 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] Out-of-sync w/ Source Code

> My recommendation is this: We need to form a distribution group. It should
> be a special interest group under architecture (continuing to use the
> architecture mailing list).

This sounds like a good idea.

> Should we drop FreeBuilder for JOS? When FreeBuilder for Java will run
> unchanged on JOS, does there need to be a JOS-specific release?

No.  IMHO, this should be a high priority.  If we can have a special 
edition of FreeBuilder designed especially for JOS it will have 
properties that are not needed in a general purpose FreeBuilder for 
general Java.  These include support for JOS "native" classes 
(things under jos.*), hopefully, enough of a C/C++/assembly 
compiler to build ALL of JOS, and debugger support for the JOS 
specific debugging interfaces we'll have to design into the kernel, 
JOSBox, etc that aren't normal java.

Ideally, people can use FreeBuilder to build all of JOS and its add 
on utilities/apps.  I think that while our present strategy of using 
GNU tools on Linux is a good stop-gap measure, JOS won't really 
be on its own without all its build tools being Java (i.e. I don't run 
Linux anywhere convenient for my using it to develop so I'm "out of 
the loop" as far as being able to contribute to kernel development.  
If we used java C/C++ compilers/assemblers, I could also help out 
on my Win32 box).

> In order to make the JOS worthwhile as an open source project, all its code
> must be compile-able on other programmer's machines. We should be able to
> demonstrate frequently how easy it is to download and recompile the whole
> collection of source code.

This may be something that will naturally occur when we actually 
have a working distribution.  I mean, someone will have to re-
organize and build everything for a distribution... :)  But I agree, 
organizing it sooner rather than later is a good idea.

> Many people would prefer a binary distribution. I am working toward
> building a binary distribution to prove that the Java source code can be
> compiled and used in working Java programs.
> 
> What will it take to reach this goal?

Probably a lot.  As is true in any big opensource project, its hard to 
pin people to being "points of contact" for all packages.  So you 
really need someone with the personality that they will build what 
they find, and if they can't find a good point of contact, will assume 
responsibility for at least getting it to build.  In addition, since we're 
in a pretty unique position with the crossplatform Java bytecode as 
our binary standard, we can actually, legitimately break our 
distribution into:

JOS - the os and tightly integrated utilities
JAVA - apps and everything else that runs in java and can be used 
on any java platform.

Now, the JOS distribution is not ready.  But we should be able to 
put together some distribution which is basically the JAVA part as 
one big installable set of apps/utils.  This would be good to create 
separately because it would allow us to work on fundamental 
issues we'll have to face later anyhow.  Such as how to actually 
distribute our code/binaries.  An installer/uninstaller system.  A 
registry or similar method of keeping track of software (and 
management tools for such).  How to handle the class versioning 
problem (I think if we can address this problem alone, its worth the 
price of admission!).  A more elegant system of launching and 
configuring programs (the whole classpath/policy files problems 
that constanly crop up when getting java programs used is just 
unacceptable... but a "replacement" system will have to be smart 
to work on regular java systems... Maybe a custom classloader?).

Anyhow, its a lot of work, but there's very interesting and 
challenging issues to address so its not all grunt labor.  Just my 
opinion of course.

-iain



From tmiller@haverford.edu Sat, 6 Nov 1999 14:22:10 -0500 (EST)
Date: Sat, 6 Nov 1999 14:22:10 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Out-of-sync w/ Source Code

> (b) Where is the JOS development of the java.* packages?

	It's not.  We're going to try and integrate classpath; obviously
some things will need to be changed, but we're hoping not by enough that
we won't be able to take advantage of their work.

-_Quinn





From gchii@mindspring.com Mon, 08 Nov 1999 12:46:03 -0500
Date: Mon, 08 Nov 1999 12:46:03 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Two Parts

The JOS project has two parts: Java and Non-Java.

The non-Java part includes the kernel and such. The Java part includes the
utilities and applications and subsystems that can run inside any Java
virtual machine.

When distributing what we call "JOS", it must include both the Java and
non-Java parts. JOS is not equal to the non-Java part.

"A kernel does not an operating system make." - quoted from JOS Wiki.

JOS should be the whole thing. JJOS might be a kernel; it's a part of
"JOS". decaf might be a virtual machine; it's a part of "JOS". The Smart
API and JADE and many other things might be a Java package that runs on any
virtual machine; it is a part of "JOS", too.

JOS is-a collection of products. Each JOS product is-a collection of
packages. A package is-a collection of classes and other digital resources.




From iainshigeoka@yahoo.com Mon, 8 Nov 1999 14:07:52 -0600
Date: Mon, 8 Nov 1999 14:07:52 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] Two Parts

On 8 Nov 99, at 12:46, Gilbert Carl Herschberger II wrote:

> The JOS project has two parts: Java and Non-Java.
> 
> The non-Java part includes the kernel and such. The Java part includes the
> utilities and applications and subsystems that can run inside any Java
> virtual machine.

Actually, I'd like to think of 3 parts:

JOS kernel (non-java and java parts)  (JOSBox and JOSystem)
JOS programs (tied to JOS via jos.* packages, many of which will
	 not be easily portable to a "vanilla" Java Platform without
	 porting most of the jos.* packages... pretty much converting
	 that Java Platform into a JOSystem via a lot of JNI work.)
Java programs for JOS (will run on any full Java 1.x Platform)

> When distributing what we call "JOS", it must include both the Java and
> non-Java parts. JOS is not equal to the non-Java part.
> 
> "A kernel does not an operating system make." - quoted from JOS Wiki.
> 
> JOS should be the whole thing. JJOS might be a kernel; it's a part of
> "JOS". decaf might be a virtual machine; it's a part of "JOS". The Smart
> API and JADE and many other things might be a Java package that runs on any
> virtual machine; it is a part of "JOS", too.
> 
> JOS is-a collection of products. Each JOS product is-a collection of
> packages. A package is-a collection of classes and other digital resources.

Yes, but following the Linux/FreeBSD model, I think we should 
really target the core kernel + jos.* packages and a limited number 
of "JOS Programs" as a JOS "base distribution".  IMHO this should 
be the main focus of the JOS project as per jos.org.  Then, when 
you add all the extra programs, you have a "standard" distribution.

This is akin to the difference between Linux, the kernel, and say 
the "standard distribution" of slackware or redhat.  Linux is pretty 
much the kernel plus the GNU libraries and tools, RedHat 
distribution of Linux includes WordPerfect, StarOffice etc.. Linux 
programs bundles with the base Linux distribution.  

IMHO www.jos.org can publish one "standard distribution" but we 
should really encourage 3rd parties to create other JOS 
distributions.

-iain



From gchii@mindspring.com Mon, 08 Nov 1999 12:38:07 -0500
Date: Mon, 08 Nov 1999 12:38:07 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Motivation for distribution group

Personally, the distribution group is important to me. I would like to take
a moment to explain why.

It was only by accident that I discovered a need for a distribution group.
In my own goal to take JOS for a test drive, I discovered that it is
difficult to collect all of the pieces to get JOS up and running. It
doesn't have to be that way.

I just want to run it. Running Java-based utilities and applications is
exciting. I want to see what JOS might look like. I want to help build a
binary distribution of JOS so that other people can download and run it. I
want other people to see what JOS might look like, too.

As far as open source goes, I want reassurances that I could read the
source code for everything if I want to. I only want to compile the little
bit of source code that I absolutely have to in order to get it to work on
my computer.

Compiling Java code isn't my kind of fun. I would like to download
Java-related parts of JOS and run it on my computer. I do not want to
compile it, debug it or develop it.

I have been working on a technique to create a binary distribution of JOS.
It organizes a collection of closely related Java packages into a
"product". Each "product" is maintained (and distributed) independently.

For example, all of the packages closely related to "Smart API - Release
1a" should be maintained together in a "smartapi1a" collection. From a
small collection of packages, a version is distributed with or without
source code.

The following information illustrates how to distribute a JOS product,
using the Smart API - Release 1a as an example.

smartapi1a-1.1.jar
A typical end-user doesn't need to rebuild the smartapi1a-1.1.jar. This
distributable archive contains a copy of all class files for the smartapi1a
collection, manifest, README and JOS-LICENSE. Everything is pre-compiled.
This is not a programmer's edition. A jar file is "installed" on a machine
after it is made.

smartapi1a-1.1-sx.zip
A typical programmer doesn't need to rebuild the smartapi1a-1.1.jar. But
he/she must understand how to use it to build Java programs. This
distributable archive contains source code and only source code for the
smartapi1a.jar file. It does not contain smartapi1a-1.1.jar. The source
code is stored in src.zip. This is a programmer's edition. A programmer can
write Java programs that use the classes in smartapi1a-1.1.jar. A
programmer might create JavaDoc from the source code. A programmer might
format the source code to HTML with a pretty printer.

smartapi1a-1.1-tx.zip
Members of the JOS Project and others will contribute source code to the
collection. This distributable archive contains the make files, tools,
utilities, and instructions on how to customize and build a substitute for
the smartapi1a-1.1.jar.

/smartapi1a-1.1/src directory
This directory contains a copy of source code to build class files. This
directory is distributed as src.zip inside smartapi1a-1.1-sx.zip.

/smartapi1a-1.1/classes directory
This directory contains class files. This directory is distributed as
smartapi1a-1.1.jar.

/smartapi1a-1.1/make file
This make script should make all of the class files from source _and_
create a new smartapi1a-1.1.jar from class files. An "install" define
should install a jar in a JRE/lib directory.




From jewel@pixie.co.za Tue, 9 Nov 1999 02:05:43 +0200 (SAST)
Date: Tue, 9 Nov 1999 02:05:43 +0200 (SAST)
From: John Leuner jewel@pixie.co.za
Subject: [JOS-Arch] Two Parts

> > "JOS". decaf might be a virtual machine; it's a part of "JOS". The Smart
> > API and JADE and many other things might be a Java package that runs on any
> > virtual machine; it is a part of "JOS", too.
> > 
> > JOS is-a collection of products. Each JOS product is-a collection of
> > packages. A package is-a collection of classes and other digital resources.
> 
> Yes, but following the Linux/FreeBSD model, I think we should 
> really target the core kernel + jos.* packages and a limited number 
> of "JOS Programs" as a JOS "base distribution".  IMHO this should 
> be the main focus of the JOS project as per jos.org.  Then, when 
> you add all the extra programs, you have a "standard" distribution.

Yes, it's amazing how much stuff comes with an operating system these
days. I think the "base distribution" should include the JVM, drivers,
filesystems etc plus what is need to run a command line shell.

Then on the next layer you can add Window Managers, text editors,
compilers etc etc

Of course a typical distribution wouldn't be complete without a text
editor, so this would be a "JOS program" included in the base. 

John Leuner

 > This is
akin to the difference between Linux, the kernel, and say 
> the "standard distribution" of slackware or redhat.  Linux is pretty 
> much the kernel plus the GNU libraries and tools, RedHat 
> distribution of Linux includes WordPerfect, StarOffice etc.. Linux 
> programs bundles with the base Linux distribution.  
> 
> IMHO www.jos.org can publish one "standard distribution" but we 
> should really encourage 3rd parties to create other JOS 
> distributions.




From ryan@whitewolf.com.au Tue, 09 Nov 1999 02:44:20 +0000
Date: Tue, 09 Nov 1999 02:44:20 +0000
From: Ryan Heise ryan@whitewolf.com.au
Subject: [JOS-Arch] Motivation for distribution group

Gilbert Carl Herschberger II wrote:

> smartapi1a-1.1-sx.zip
> 
> ...
> This
> distributable archive contains source code and only source code for the
> smartapi1a.jar file.

May I suggest we follow the rpm standard which is something more like:

smartapi1a-1.1-1.src.zip

(or .tar.gz)

?

> It does not contain smartapi1a-1.1.jar. The source
> code is stored in src.zip.

A zip file within a zip file?

> smartapi1a-1.1-tx.zip
> Members of the JOS Project and others will contribute source code to the
> collection. This distributable archive contains the make files, tools,
> utilities, and instructions on how to customize and build a substitute for
> the smartapi1a-1.1.jar.

Do you mean a forking kit? ie. a distribution that is specifically
designed to be modified from the original?

> /smartapi1a-1.1/make file

"Makefile" is probably a better choice (if you're aiming for a
standard).

So, smartapi1a-1.1 corresponds to a product within JOS. It would be nice
to have an automated tool to build all products. We could have marker
files in CVS that declare what product this directory belongs to.

-- 
Ryan Heise

http://www.progsoc.uts.edu.au/~rheise/



From hilarycheng@usa.net Tue, 9 Nov 1999 08:41:46 +0800
Date: Tue, 9 Nov 1999 08:41:46 +0800
From: Hilary Cheng hilarycheng@usa.net
Subject: [JOS-Arch] Motivation for distribution group

Hi,

    Well, I don't think it is the right time to create a distribution group
for JOS.
Since there is no kernel that is fully implemented. Also, until right now,
there is
only a few people are still actively working on JOS. So, Let wait for one
kernel that's
fully runnable.

Regards,

Hilary


-----Original Message-----
From: Gilbert Carl Herschberger II <gchii@mindspring.com>
To: arch@jos.org <arch@jos.org>
Date: Tuesday, November 09, 1999 6:41 AM
Subject: [JOS-Arch] Motivation for distribution group


>Personally, the distribution group is important to me. I would like to take
>a moment to explain why.
>
>It was only by accident that I discovered a need for a distribution group.
>In my own goal to take JOS for a test drive, I discovered that it is
>difficult to collect all of the pieces to get JOS up and running. It
>doesn't have to be that way.
>
>I just want to run it. Running Java-based utilities and applications is
>exciting. I want to see what JOS might look like. I want to help build a
>binary distribution of JOS so that other people can download and run it. I
>want other people to see what JOS might look like, too.
>
>As far as open source goes, I want reassurances that I could read the
>source code for everything if I want to. I only want to compile the little
>bit of source code that I absolutely have to in order to get it to work on
>my computer.
>
>Compiling Java code isn't my kind of fun. I would like to download
>Java-related parts of JOS and run it on my computer. I do not want to
>compile it, debug it or develop it.
>
>I have been working on a technique to create a binary distribution of JOS.
>It organizes a collection of closely related Java packages into a
>"product". Each "product" is maintained (and distributed) independently.
>
>For example, all of the packages closely related to "Smart API - Release
>1a" should be maintained together in a "smartapi1a" collection. From a
>small collection of packages, a version is distributed with or without
>source code.
>
>The following information illustrates how to distribute a JOS product,
>using the Smart API - Release 1a as an example.
>
>smartapi1a-1.1.jar
>A typical end-user doesn't need to rebuild the smartapi1a-1.1.jar. This
>distributable archive contains a copy of all class files for the smartapi1a
>collection, manifest, README and JOS-LICENSE. Everything is pre-compiled.
>This is not a programmer's edition. A jar file is "installed" on a machine
>after it is made.
>
>smartapi1a-1.1-sx.zip
>A typical programmer doesn't need to rebuild the smartapi1a-1.1.jar. But
>he/she must understand how to use it to build Java programs. This
>distributable archive contains source code and only source code for the
>smartapi1a.jar file. It does not contain smartapi1a-1.1.jar. The source
>code is stored in src.zip. This is a programmer's edition. A programmer can
>write Java programs that use the classes in smartapi1a-1.1.jar. A
>programmer might create JavaDoc from the source code. A programmer might
>format the source code to HTML with a pretty printer.
>
>smartapi1a-1.1-tx.zip
>Members of the JOS Project and others will contribute source code to the
>collection. This distributable archive contains the make files, tools,
>utilities, and instructions on how to customize and build a substitute for
>the smartapi1a-1.1.jar.
>
>/smartapi1a-1.1/src directory
>This directory contains a copy of source code to build class files. This
>directory is distributed as src.zip inside smartapi1a-1.1-sx.zip.
>
>/smartapi1a-1.1/classes directory
>This directory contains class files. This directory is distributed as
>smartapi1a-1.1.jar.
>
>/smartapi1a-1.1/make file
>This make script should make all of the class files from source _and_
>create a new smartapi1a-1.1.jar from class files. An "install" define
>should install a jar in a JRE/lib directory.
>
>
>_______________________________________________
>Arch maillist  -  Arch@jos.org
>http://jos.org/mailman/listinfo/arch
>




From ion@larc.com Mon, 8 Nov 1999 23:41:06 -0600
Date: Mon, 8 Nov 1999 23:41:06 -0600
From: Iain Shigeoka ion@larc.com
Subject: [JOS-Arch] Two Parts

From:           	John Leuner <jewel@pixie.co.za>

> Yes, it's amazing how much stuff comes with an operating system these
> days. I think the "base distribution" should include the JVM, drivers,
> filesystems etc plus what is need to run a command line shell.

Yup.  That's what I had in mind.  Glad we think alike!

> Of course a typical distribution wouldn't be complete without a text
> editor, so this would be a "JOS program" included in the base. 

The JOS vi editor?!?  :)  Actually, I regularly use and enjoy the vi 
editor (yeah, its sick I know) so I shouldn't make fun.

-iain



From iainshigeoka@yahoo.com Mon, 8 Nov 1999 23:41:05 -0600
Date: Mon, 8 Nov 1999 23:41:05 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] Motivation for distribution group

From:           	Ryan Heise <ryan@whitewolf.com.au>

> It would be nice
> to have an automated tool to build all products. We could have marker
> files in CVS that declare what product this directory belongs to.

Actually, I've been hoping to add this to the updated JOS website 
but work has conspired to slow me down on my JOS website 
work...  If anyone is interested in helping, or have ideas I'd love to 
hear from you.  

What I was thinking was an automated Build Manager tool.  It 
would let designated "build managers" check sources out of CVS 
build them on your local machine (I'd hate to have the JOS 
webserver bogged down compiling code) and then upload the 
"products" (jar's, class files, javadoc html, etc) to "standard" 
locations where people can download/browse them.  (Obviously it's 
the "product upload" capability that would be restricted to build 
managers, cvs dowload is already available to anyone).  A really 
ambitious project would also develop a tool (in java) that would 
automate this task for the build managers.  :)  

Right now just getting wiki integrated into the website is enough to 
keep me pulling hairs.  :(

-iain



From gchii@mindspring.com Thu, 11 Nov 1999 08:11:05 -0500
Date: Thu, 11 Nov 1999 08:11:05 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Motivation for distribution group

At 08:41 AM 11/9/99 +0800, "Hilary Cheng" <hilarycheng@usa.net> wrote:

1. Do you have a copy of JOS?

2. Where did you get it?

3. How long did it take you?

4. Do you have everything? If you do, could you help me make sure that I
have all of the pieces?

If you have taken the time to create your own collection of JOS, you could
help out others by helping us put together a JOS distribution. You should
be part of the distribution group, too.

I want to take JOS for a test drive. I had to download parts from CVS,
parts from Source Server, parts from various websites across the Internet.
It took me over eight months to gather parts of JOS. I know that I do not
have a full copy of JOS. There are critical pieces missing from my own
collection.

Missing: Pizza Compiler - I cannot find a copy of the Pizza Compiler. My
URL for its website must be out-of-date. Without it, I cannot compile
FreeBuilder for JOS.

>Well, I don't think it is the right time to create a distribution group
>for JOS.

The question of timing is important. We should determine the right time to
form a special interest group.

In addition to timing, the basic questions are these:

1. Will the JOS Project ever need such a group?

2. Can we function without it?

3. What kind of problems will a distribution group solve?

4. Will such a group get in the way?

5. Who will contribute to the distribution group?

6. How much power and authority should such a group have? (Who should they
answer to?)

>Since there is no kernel that is fully implemented. Also, until right now,
>there is only a few people are still actively working on JOS. So, Let wait
>for one kernel that's fully runnable.

There is far more to the JOS Project than a kernel. There are products
available today that are fully implemented and can be distributed.

1. The distribution group should work hard to make everyone is aware of
these other products. They can be collected together, described and
reviewed on behalf of the community.

2. The distribution group should help us show how many people are working
on JOS. You might be surprised to find out that quite a few people are (1)
actively working on JOS and (2) far more people are keenly interested in
using JOS.

It is an important function of the distribution group to show how times the
distribution has been downloaded. For example, the JJOS module has been
downloaded 240+ times in October from the JOS 1d Technical Distribution.

Plus, such a distribution group might solicite others to put up mirror
sites for JOS. Why? Because as soon as a JOS kernel is available, I believe
there will be thousands of people who will want to take it for a test drive.

I believe in being prepared. The distribution group sounds like one of the
best ways I can think of to prepare the JOS Project for the next level.

I have reason to believe the JOS Project needs a distribution group and has
needed it for quite some time. The demand for JOS distribution has not been
met by CVS or Source Server. CVS is too complex for only trying to take JOS
for a test drive. (The Internet tradition is to offer a .tar.gz and .zip
test drive with zero complexity.) The Source Server might have helped but
it is fatally broken. (It doesn't get the job done.)

If the distribution group is not needed already, it might be needed soon.
Why wait?




From gchii@mindspring.com Thu, 11 Nov 1999 08:39:20 -0500
Date: Thu, 11 Nov 1999 08:39:20 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Motivation for distribution group

At 02:44 AM 11/9/99 +0000, Ryan Heise <ryan@whitewolf.com.au> wrote:
>May I suggest we follow the rpm standard which is something more like:
>
>smartapi1a-1.1-1.src.zip
>
>(or .tar.gz)

Could you please explain the parts of the rpm standard.

As for my proposal, it doesn't seem to be practical after all. I tried it
and I don't like it. I have simplified it to this:

smartapi1a-1.zip
smartapi1a-1.tgz

I should use -1, -2, -3 to indicate the distribution. Each distribution
should be uniquely numbered. Inside this archive, everything is safely
tucked away in its smartapi1a-1 directory.

Smart API is a product line. The Smart API - Release 1a is specific release
of the Smart API. Release 1a does not go out of style -- nor does it become
obsolete -- with the introduction of Release 1b or 2a. In fact, Release 1b
is dependent on Release 1a. Release 2a is dependent on Releases 1a and 1b.

I use "1a" instead of 1.0, "1b" instead of 1.1, "2a" instead of 2.0 because
1b does not replace 1a; 2a does not replace 1b or 1a.

>A zip file within a zip file?

Yes. It is a good idea. There are many people who only want to take JOS for
a test drive. They do not want to compile any source code. For all those
people, they can leave source code inside its archive. A number of
different programming tools enable you to "browse" the source code directly
from such an archive.

Many people put a jar file in a .tgz or .zip file. Since a jar is an
archive, that's an archive inside an archive.

>Do you mean a forking kit? ie. a distribution that is specifically
>designed to be modified from the original?

I have never before heard of a forking kit. From your description, that's
not exactly what I had in mind. I meant that members of the JOS Project
should download the technical distribution in order to build unique
distributions of JOS.

For an open source project, three kinds of customers are recognized. The
JOS Project should care for all three:

1. People who do not care about source code at all.
2. People who only read source code
3. People who read and write source code.

1. For people who do not care about source code at all:
A "runtime" distribution is a special distribution for people who do not
care about source code at all. While it might be hard for a programmer to
imagine, this kind of customer is critical to the long term success of any
distribution.

2. For people who only read source code:
A "source code" distribution is a special distribution for people, like me,
who want to read source code. They neither want to modify nor compile an
existing product. This kind of customer has great interest in using the
techniques and models found in the JOS Project. This kind of customer will
write new applications that run on top of JOS.

3. People who read and write source code:
A "technical" distribution is a special distribution for people who want to
write source code for the JOS Project. They want to read the source code
for other JOS products and write their own. This kind of customer is
critical for the development of valuable JOS-related subsystems, like a
file subsystem, object registry and device drivers.

Note: CVS is an appropriate solution for developing and distributing a
mixed-language JOS kernel. A binary (or runtime) distribution is available
for people, like me, who want to take JOS for a test drive.




From digigod@earthling.net Thu, 11 Nov 1999 18:13:18 -0500 (EST)
Date: Thu, 11 Nov 1999 18:13:18 -0500 (EST)
From: digigod@earthling.net digigod@earthling.net
Subject: [JOS-Arch] Motivation for distribution group

> At 02:44 AM 11/9/99 +0000, Ryan Heise <ryan@whitewolf.com.au> wrote:
> >May I suggest we follow the rpm standard which is something more like:
> >
> >smartapi1a-1.1-1.src.zip
> >
> >(or .tar.gz)
> 
> Could you please explain the parts of the rpm standard.
> 
> As for my proposal, it doesn't seem to be practical after all. I tried it
> and I don't like it. I have simplified it to this:
> 
> smartapi1a-1.zip
> smartapi1a-1.tgz
> 
> I should use -1, -2, -3 to indicate the distribution. Each distribution
> should be uniquely numbered. Inside this archive, everything is safely
> tucked away in its smartapi1a-1 directory.
> 
> Smart API is a product line. The Smart API - Release 1a is specific release
> of the Smart API. Release 1a does not go out of style -- nor does it become
> obsolete -- with the introduction of Release 1b or 2a. In fact, Release 1b
> is dependent on Release 1a. Release 2a is dependent on Releases 1a and 1b.
> 
> I use "1a" instead of 1.0, "1b" instead of 1.1, "2a" instead of 2.0 because
> 1b does not replace 1a; 2a does not replace 1b or 1a.
> 
> >A zip file within a zip file?
> 
> Yes. It is a good idea. There are many people who only want to take JOS for
> a test drive. They do not want to compile any source code. For all those
> people, they can leave source code inside its archive. A number of
> different programming tools enable you to "browse" the source code directly
> from such an archive.
> 
> Many people put a jar file in a .tgz or .zip file. Since a jar is an
> archive, that's an archive inside an archive.
> 
> >Do you mean a forking kit? ie. a distribution that is specifically
> >designed to be modified from the original?
> 
> I have never before heard of a forking kit. From your description, that's
> not exactly what I had in mind. I meant that members of the JOS Project
> should download the technical distribution in order to build unique
> distributions of JOS.
> 
> For an open source project, three kinds of customers are recognized. The
> JOS Project should care for all three:
> 
> 1. People who do not care about source code at all.
> 2. People who only read source code
> 3. People who read and write source code.
> 
> 1. For people who do not care about source code at all:
> A "runtime" distribution is a special distribution for people who do not
> care about source code at all. While it might be hard for a programmer to
> imagine, this kind of customer is critical to the long term success of any
> distribution.
> 
> 2. For people who only read source code:
> A "source code" distribution is a special distribution for people, like me,
> who want to read source code. They neither want to modify nor compile an
> existing product. This kind of customer has great interest in using the
> techniques and models found in the JOS Project. This kind of customer will
> write new applications that run on top of JOS.
> 
> 3. People who read and write source code:
> A "technical" distribution is a special distribution for people who want to
> write source code for the JOS Project. They want to read the source code
> for other JOS products and write their own. This kind of customer is
> critical for the development of valuable JOS-related subsystems, like a
> file subsystem, object registry and device drivers.
> 
> Note: CVS is an appropriate solution for developing and distributing a
> mixed-language JOS kernel. A binary (or runtime) distribution is available
> for people, like me, who want to take JOS for a test drive.

Whatever we use internally all people should see is somesort of "download manager" Applet or at least some nice HTML pages, no one likes dealing with bland directories of cryptic file names (these pages could be part of the distribution groups job).

Cheers,
DigiGod
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-
----------------------------------------------------------------
Get your free email from AltaVista at http://altavista.iname.com



From digigod@earthling.net Thu, 11 Nov 1999 18:24:19 -0500 (EST)
Date: Thu, 11 Nov 1999 18:24:19 -0500 (EST)
From: digigod@earthling.net digigod@earthling.net
Subject: [JOS-Arch] Motivation for distribution group

> At 08:41 AM 11/9/99 +0800, "Hilary Cheng" <hilarycheng@usa.net> wrote:
> 
> 1. Do you have a copy of JOS?
> 
> 2. Where did you get it?
> 
> 3. How long did it take you?
> 
> 4. Do you have everything? If you do, could you help me make sure that I
> have all of the pieces?
> 
> If you have taken the time to create your own collection of JOS, you could
> help out others by helping us put together a JOS distribution. You should
> be part of the distribution group, too.
> 
> I want to take JOS for a test drive. I had to download parts from CVS,
> parts from Source Server, parts from various websites across the Internet.
> It took me over eight months to gather parts of JOS. I know that I do not
> have a full copy of JOS. There are critical pieces missing from my own
> collection.
> 
> Missing: Pizza Compiler - I cannot find a copy of the Pizza Compiler. My
> URL for its website must be out-of-date. Without it, I cannot compile
> FreeBuilder for JOS.
> 
> >Well, I don't think it is the right time to create a distribution group
> >for JOS.
> 
> The question of timing is important. We should determine the right time to
> form a special interest group.
> 
> In addition to timing, the basic questions are these:
> 
> 1. Will the JOS Project ever need such a group?

I think so.
 
> 2. Can we function without it?

Short answer: yes; long answer: no. We can but it'll never make us popular with the masses.
 
> 3. What kind of problems will a distribution group solve?

Getting JOS to people who want it. It could also act as a quasimanagerial force (leader vs. ruler) helping the different projects and groups communicate.
 
> 4. Will such a group get in the way?

Potentially any group can get in the way, but we can always, simply, ignore them when and by that I mean if they do.
 
> 5. Who will contribute to the distribution group?

Whomever wants to.
 
> 6. How much power and authority should such a group have? (Who should they
> answer to?)

I didn't know anyone "answered" to anyone...
 
> >Since there is no kernel that is fully implemented. Also, until right now,
> >there is only a few people are still actively working on JOS. So, Let wait
> >for one kernel that's fully runnable.
> 
> There is far more to the JOS Project than a kernel. There are products
> available today that are fully implemented and can be distributed.

like Jext
 
> 1. The distribution group should work hard to make everyone is aware of
> these other products. They can be collected together, described and
> reviewed on behalf of the community.
> 
> 2. The distribution group should help us show how many people are working
> on JOS. You might be surprised to find out that quite a few people are (1)
> actively working on JOS and (2) far more people are keenly interested in
> using JOS.

They could also take suggestions from the interested public to us, the programmers.

> It is an important function of the distribution group to show how times the
> distribution has been downloaded. For example, the JJOS module has been
> downloaded 240+ times in October from the JOS 1d Technical Distribution.
> 
> Plus, such a distribution group might solicite others to put up mirror
> sites for JOS. Why? Because as soon as a JOS kernel is available, I believe
> there will be thousands of people who will want to take it for a test drive.
> 
> I believe in being prepared. The distribution group sounds like one of the
> best ways I can think of to prepare the JOS Project for the next level.

I agree.

> I have reason to believe the JOS Project needs a distribution group and has
> needed it for quite some time. The demand for JOS distribution has not been
> met by CVS or Source Server. CVS is too complex for only trying to take JOS
> for a test drive. (The Internet tradition is to offer a .tar.gz and .zip
> test drive with zero complexity.) The Source Server might have helped but
> it is fatally broken. (It doesn't get the job done.)
> 
> If the distribution group is not needed already, it might be needed soon.
> Why wait?

At the very least they can start getting organized now.

Cheers,
DigiGod
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-
----------------------------------------------------------------
Get your free email from AltaVista at http://altavista.iname.com



From gchii@mindspring.com Thu, 11 Nov 1999 19:40:51 -0500
Date: Thu, 11 Nov 1999 19:40:51 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Package Cross-Reference

I updated my package cross-reference today. Take a look.

<URL:http://www.mindspring.com/~gchii/jos/library/packages.html>

None of my tools were up to the task of bulk compiling, so I wrote my own
bulk compiler. I mentioned some of the benefits of package-oriented
copying, compiling and archiving on the PackageOriented article on JOS Wiki.

I was please to find that CSI-0.4 and Amairgin-0.10 products compiled after
minor adjustments to the package/import statements. Amairgin depends on CSI.

CSI becomes org.jos.experimental.csi
Amairgin becomes org.jos.experimental.amairgin

After a detailed inventory, I found orphaned JOS-related packages. They
were built for the JOS Project over the past year and did not make it into
any of the distribution files. This will be corrected in my current
distribution project. A binary distribution of JOS is expected to be
finished by the end of this year.




From gchii@mindspring.com Fri, 12 Nov 1999 11:22:57 -0500
Date: Fri, 12 Nov 1999 11:22:57 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Smart API

Building the Smart API is just about the most ambitious project I have ever
completed. I have been complaining for over fifteen years about the complex
problems created by class libraries. It has only been within the last year
that I see where class libraries can be loosely coupled for programming in
the large. Compared to subroutine libraries and libraries with an
object-oriented wrapper, a genuine class library is a challenge for
backward compatibility and future orientation.

If you haven't noticed the potential of the Smart API yet, you should take
a moment to read the SmartAPIProtocols page on JOS Wiki.

It is hard to pin down my favorite example of the Smart API. I certainly
enjoyed the Connection Factory when writing Java servlets for an AS/400 and
DB/2. It came down to requesting a connection, like this:

URI uri = new URI( "jdbc:db2://HOST/LIBRARY" );
Connection c = (Connection) uri.getObject();

My application program did not configure any JDBC drivers. My application
program benefits from any future JDBC drivers configured for the Connection
Factory.

And recently, I wrote a program to copy source code on a package-by-package
basis. It was refreshing to output source code without explicitely creating
target directories:

URI uri = new URI( "out:print:file:org/jos/demo/Demo.java" );
PrintStream p = (PrintStream) uri.getObject();

Besides I have been using the Smart API to load all kinds of configuration
files as registry objects, like this:

URI uri = new URI( "x-registry:ini:file:config" );
Registry r = (Registry) uri.getObject();

Has anyone else been able to use the Smart API?

I have been using it in production systems for two of my ultra-conservative
corporate customers for a couple of months. They appreciate the benefits of
pre-compiled and pre-configured one-stop-shopping for all digital resources.

What will it take for an entire operating system to embrace the concepts of
loosely-coupled class libraries, uniform resource identifiers, backward
compatibilty and future orientation?

For Java, it means that well-known interfaces must be kept in packages free
from custom implementations. It also means that each release of an API must
have a unique part of the Java namespace.




From gchii@mindspring.com Sat, 13 Nov 1999 18:12:58 -0500
Date: Sat, 13 Nov 1999 18:12:58 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Binary Distribution

I downloaded a binary distribution of JOS 1d. I would like very much to get
it to run on my JOS machine. Here is the steps I have taken:

A. I downloaded the binary distribution of JOS 1d.
B. I downloaded the JOS tools from <http://www.jos.org/tools/tools.tgz>
C. I created a boot disk for my JOS machine from Etherboot 4.0, using
something like this:

1. mkfs.minix -c /def/fd0 1440
2. cat floppyload.bin ne.rom > /def/fd0

D. I enabled the TFTP service on my Linux box.
E. I created a /tftpboot directory and set its attributes.
F. I copied jjos-nbi to the /tftpboot directory.
F. I configured the BOOTP service on my Linux box, setting up my JOS
machine with a machine name and IP address.
G. I boot my JOS machine. 

It displays the MAC address of my NIC. I displays the following message and
then goes to sleep. JOS never boots.

	Searching for server...

How do I know for sure that my BOOTP service is running?

Did I skip a step? Where did I go wrong?

This is a network computer architecture. I have a 500MB drive in my JOS
machine. I would like to boot JOS directly from its hard drive and not
through the network anyway. Where can I find more information about using
JOS in a personal computer architecture?




From whooops@gmx.de Sun, 14 Nov 1999 03:00:21 +0000
Date: Sun, 14 Nov 1999 03:00:21 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] Binary Distribution

Gilbert Carl Herschberger II wrote:

> How do I know for sure that my BOOTP service is running?

If nobody answers in a reasonable amount of time, put a tcpdump on port 67 and
68 on you network, pipe the output into a file and send it to the list, so we
can have a closer look.

Regards, Mark
-- 
Mark Andreas Meyer                         <> You're free
Freedom loving individual.                 <> to use GNU



From tmiller@haverford.edu Sat, 13 Nov 1999 19:29:39 -0500 (EST)
Date: Sat, 13 Nov 1999 19:29:39 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Binary Distribution

> Did I skip a step? Where did I go wrong?

	It looks right to me, but check your firewalling and bootpd logs
(bootpd -d4 will dump all sorts of debug information to syslog, IIRC)
on the server machine; make sure your bootptab is set up correctly.  If
the server isn't receiving any bootp requests, try hooking the two
directly via a null-ethernet cable, if they're on different subnets, etc.

> This is a network computer architecture. I have a 500MB drive in my JOS
> machine. I would like to boot JOS directly from its hard drive and not
> through the network anyway. Where can I find more information about using
> JOS in a personal computer architecture?

	If you have the latest CVS code, one of the build options is 'make
grub' (i386/nativecode); this will produce what ought to be a
GRUB-bootable image of JJOS.  The GRUB instructions, according to George
Marrows (who developed the JOS suport) are as follows:

kernel=<path to kernel> init
module=<path to jjos-common.zip>
boot

Ask around on the kernel list for more help if you need it.  GRUB will
boot from a floppy; if you've got installed as your bootloader already,
JOS will boot straight off your HD.  (Though it won't do much in its
present state :))

-_Quinn






From Corrado.Santoro@IIT.UNICT.IT Mon, 15 Nov 1999 08:42:33 +0100
Date: Mon, 15 Nov 1999 08:42:33 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Arch] Binary Distribution

On Sun, 14 Nov 1999, Gilbert Carl Herschberger II wrote:
> [cut]
> It displays the MAC address of my NIC. I displays the following message and
> then goes to sleep. JOS never boots.
> 
> 	Searching for server...
> 
> How do I know for sure that my BOOTP service is running?
> 
> Did I skip a step? Where did I go wrong?

...ummm.... are you sure that you etherboot is working with BOOTP ?
By default, Etherboot compiles with DHCP not BOOTP, so take a look in etherboot
configuration files.

Cheers,
	Corrado.

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://netra.cdc.unict.it/ARCA
======================================================




From George.Marrows@Smallworld.co.uk Mon, 15 Nov 1999 09:28:44 -0000
Date: Mon, 15 Nov 1999 09:28:44 -0000
From: George.Marrows@Smallworld.co.uk George.Marrows@Smallworld.co.uk
Subject: [JOS-Arch] GRUB (was [JOS-Arch] Binary Distribution)

Unfortunately, the makefile is a bit ill when it comes to grub support --
the executable doesn't get linked at the moment. I'll try to find time to
tweak it back into shape.

-- George

---------------------------------------------------------------
If you have the latest CVS code, one of the build options is 'make
grub' (i386/nativecode); this will produce what ought to be a
GRUB-bootable image of JJOS.  The GRUB instructions, according to George
Marrows (who developed the JOS suport) are as follows:

kernel=<path to kernel> init
module=<path to jjos-common.zip>
boot

Ask around on the kernel list for more help if you need it.  GRUB will
boot from a floppy; if you've got installed as your bootloader already,
JOS will boot straight off your HD.  (Though it won't do much in its
present state :))



From jake66@iname.com Mon, 15 Nov 1999 10:20:32 -0500
Date: Mon, 15 Nov 1999 10:20:32 -0500
From: Jake Meier jake66@iname.com
Subject: [JOS-Arch] multiple processor architecture

I am new to the JOS project, so please excuse my ignorance if this 
topic has been discussed in the past:

	I believe that it is counterproductive in this day and age to 
create an application or operating system that can only run on a 
handful of processor types, ie, x86 etc...  The reason that Java is 
so revoloutionary is that it is able to run in a runtime environment 
inside of any operating system.  I understand that this project would 
eliminate the need for a runtime, but I do not see why we should 
focus our efforts on only Pentium class processors.  I personaly use 
a Mac, a PC, and a SGI, and of those I like my Mac the best.  I would 
love to see a Java operating system for the PowerPC, especially now 
that IBM is working extensively with it in an attempt to incorperate 
it into different types of systems.  I am willing to help on this 
indevor, but I will need a plethora of people who are willing to try 
to develop this system, not just for the PC people of the world, but 
the people of the world in general.



From vijay-raghavan0524@usa.net 15 Nov 99 11:57:02 MST
Date: 15 Nov 99 11:57:02 MST
From: Vijay Raghavan vijay-raghavan0524@usa.net
Subject: [JOS-Arch] TCP/IP stack ...

Hey everybody ,
I'm interested in doing the TCP/IP stack for the JOS... anybody want to hop on
???
Clarion call to all those network-savvy dudes there ... 
Lets' get stacking !!!

Vijay

____________________________________________________________________
Get free email and a permanent address at http://www.netaddress.com/?N=1



From tmiller@haverford.edu Mon, 15 Nov 1999 16:41:22 -0500 (EST)
Date: Mon, 15 Nov 1999 16:41:22 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] multiple processor architecture

> 	I believe that it is counterproductive in this day and age to 
> create an application or operating system that can only run on a 
> handful of processor types, ie, x86 etc...

	The current VM for JOS runs on a very small kernel, at about 144 K
of C++ source (du -ac *.cc *.h in arch/i386/nativecode) and 33K of i386
ASM (du -ac *.asm), including both boot loaders.  The C++ source is
(AFAIK) standard ANSI code that should compile to any platform that g++
supports without change.  The ASM, obviously, will need to be changed, but
most of it is fairly simply stuff like preparing a flat address space and
passing interrupts (21K) to the C++ code.  (The most complicated bits are
extracting the location of the ramdisk from the booter, I think, but I
didn't right so I couldn't tell you for sure.)

	The reason to initially concentrate on the i386 is just that
they're dirt cheap (comparitively) and almost everyone has one.  Since
we've defined all our data types away from C already, I think portability
isn't going to be much of an issue which such a small kernel, but I could
be wrong.  Unfortunately, I don't have systems besides i386 with which to
test, nor do I know ASM for them...

-_Quinn





From gchii@mindspring.com Mon, 15 Nov 1999 19:41:36 -0500
Date: Mon, 15 Nov 1999 19:41:36 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] multiple processor architecture

At 10:20 AM 11/15/99 -0500, you wrote:
>	I believe that it is counterproductive in this day and age to 
>create an application or operating system that can only run on a 
>handful of processor types, ie, x86 etc...

Here! Here! I hear a lot of discussion about a native kernel. JOS
architecture does not require a native kernel. Like all Java bytecode, all
you need is a JVM. I wish there was more discussion about the Java-side of
JOS.

As a Java-related project, JOS fills in the missing pieces in the Java
class libraries. It is a loose collection of additional applications and
services, like FTP, HTTP, and TELNET. In addition, it fixes some of the
defects in the Java class libraries, including backward compatibility and
future orientation.

JOS does not require you to replace your favorite machine. JOS does not
require you to replace your native operating system. But JOS enables you to
learn one desktop/shell/browser mechanism and carry it with you wherever
you go.

On the Mac, JOS appears as a native GUI program. Inside the GUI window, JOS
has its own set of desktop/shell/browser configurations. JOS supports
multiple desktops. You start your Mac OS and then start your JOS desktop.

It is the same for people who use Linux/UNIX (and X/Windows) and people who
use Microsoft MS-DOS (and Microsoft Windows).




From tmiller@haverford.edu Tue, 16 Nov 1999 01:32:39 -0500 (EST)
Date: Tue, 16 Nov 1999 01:32:39 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] multiple processor architecture

> Here! Here! I hear a lot of discussion about a native kernel. JOS
> architecture does not require a native kernel.

	This is a dangerous misconception.  Maintaining compatibility with
extant JVMs below the application level is a great way to cripple JOS's
potential.  It's an operating system -- its job is to provide hardware
services to its applications.  Restricting these services to those can be
provided only on a conventional JVM reduces JOS to a none-too-useful
operating enviroment.  That is, it won't be doing anything that's not
already possible under conventional JVM, and the design limits inherent in
the JVM are difficult at best to circumvent, and in many cases well-nigh
impossible without its source code -- which defeats the point of
maintaining compatibility with extant JVMs!

	If JOS is to run as a process (or processes) on some other O/S,
how can it possibly provide the stability, speed, or services of its full
potential?  (Windows will crash on its own and kill JOS for us.  Ditto the
Macintosh; Linux doesn't crash as it is, so JOS would only slow your UI
down if you're using it.)  Java is already slow, even with the latest and
greatest of JIT or dynamic compilers.  A large portion of that sloth comes
from making native calls to actually get the work done (that is, JNI has
an enourmous overhead).  The native kernel / native JVM combination
doesn't suffer from this problem -- for instance, graphics (will) NEVER
make a native call, because the kernel provides java with a MappedArray
(tentative name) where the initial byte is at a given address (0xb0000)
and doesn't move; the bytecode assigning a value to an offset in that
array writes directly to the relevant physical location. (The VGA frame
buffer -- other architectures, obviously, differ.)  How does dynamic
device handling work if there's some host O/S to fight for control of the
hardware?

	If I sit down at an NT box running your vision of JOS, what makes
JOS worthwhile compared to running an X client on that NT box?  To
maintain the same desktop accross your multiple computers, you need a
network anyway.  What makes it different than VNC, or pcAnywhere?  If JOS
runs locally, what makes it superior to daul-booting into some other
operating system better suited to your needs?  Running apps in different
windows?  To interoperate, JOS would need large native libraries, which
would seem to ruin the point.  If you're really hard up for running Word
97 in one window and some (java-only, remember!) application in another,
why not convert your extra boxes (Mac, Linux, Win9x, IIRC from your
example) into an X server and install the java binary there -- it'll run
much faster on the remote machine.
	Both Corel and Sun tried and failed to port major office suites to
straight-up normal Java; I don't think people will be attracted to JOS on
the strength of its applications if they're limited in the same ways that
prevented Sun and Corel from selling their ports.  Now, you may say, but
Sun gave up on JavaOS for Business, too, why should we still work on JOS?
Sun targeted JavaOS/B at thin clients, which we all know to have flopped
horribly.  I believe the last effort at a truly object-oriented operating
system were the LispMachines, or possibly some of the Smalltalk systems,
both of which were designed by programmers for programmers, not for
desktops used by Joe White-Collar.
	There is definitely a place for JOS, a robust and reasonably
efficient OS designed in the spirit of the realization that the best
server OSes do not make the best client OSes.  Much of what KDE and GNOME
are trying to do in C and C++ with KParts and CORBA and the like are
facilities that exist in remarkable power and simplicity in Java already;
ditto technologies like OLE and DCOM from the Windows side of things. With
windows comes unreliability; with Linux comes an enourmous complexity and
a design philosophy for power users that prevents things as intuitive as
the delete and backspace keys working in a uniform way from happening
without user intervention and (with each new application) maintenance, and
other things that are so archaic as to be idiotic.  (Pick your favorite;
among mine is the static /dev directory, which was fine idea before the
time when you could add and remove hardware as the system was running.)

	It makes good sense to write code now that runs on extant JVMs,
because a lot of the services and applications (daemons, etc) that will be
distributed with JOS only need to access a particular other set of
services (aka JOSSystem, I believe), and these can be faked to debug the
code you're writing -- which means you don't have to sit idle if you can't
help us over in kernel land.  However, don't let your ambitions be bound
by the limitations of current JVMs and OSes; we can do better.  That's
kind of the point.

-_Quinn





From jake66@iname.com Tue, 16 Nov 1999 10:25:17 -0500
Date: Tue, 16 Nov 1999 10:25:17 -0500
From: Jake Meier jake66@iname.com
Subject: [JOS-Arch] Re: multiple processor architecture

In response to Todd's post about how it would serve very little point 
to have Jos run inside of an existing operating system I have to 
agree.  I currently run Linux, Mac OS X, Mac OS 9, Mac OS 8.6, 
WinNTServer, and Solaris.  Of these OS's I would not be inclined to 
run JOS inside of any of them.  There would be little to no point.  I 
can run a JVM on them and use any native Java application.  So why 
would I intentionally slow down one of my machines just to run a 
bleeding edge pseudo OS that would give me no benefit.  I believe 
that a better option would be to attempt to write a base kernel that 
incorporated the JVM for each platform.  Then, write 100% native Java 
apps to run there.  Linux is having a profound impact on the personal 
computer industry as well as capturing a portion of the corporate 
market.  Why not give linux enthusiasts an alternative that would 
allow all apps to run under the same os.  I am not at all suggesting 
that we take the window manager out of their hands, but I do think 
that we should make this a native os and not focus on the seemingly 
pointless task of creating a virtual os.
	So the question becomes this:  How many of you would use a 
user interface that is going to slow down your machine and allow you 
to do nothing more that the existing JVM running on your particular 
platform can do?  I for one think that my machines run sluggish 
enough without the help of an added layer to impede my everyday tasks.
	If the view of this orginization is to create an pseudo OS to 
run inside of an existing OS, then I think that someone needs to 
create a native JOS.  The framework is not as difficult as one would 
think, although it is beyond my basic skill level.  If we could 
incorporate the JVM into the kernel, and supply a different kernel 
for each processor architecture then applications and window managers 
could be created in pure java eliminating the need for a runtime 
environment inside of an existing OS.



From R.Argentini@student.tudelft.nl Tue, 16 Nov 1999 16:43:05 +0100
Date: Tue, 16 Nov 1999 16:43:05 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] TCP/IP stack ...

>I'm interested in doing the TCP/IP stack for the JOS... anybody want to
hop on ???

I bought "Internetworking with tcp/ip vol 2: Implementation" a while ago,
and while i read it from cover to cover several times, i figured i was
never going to write a tcp/ip protocol stack, cause all the OS's i knew at
the time already had one, and i wasn't going to be megalomaniac enough to
start a new one.

Now it looks like a decent opportunity has presented itself.
I would definately like to collaborate on this project.

The only thing that comes to mind is that it would be a Good Thing to have
a network card driver handy.. has jos already progressed to the level where
one is included? Can we "steal" it from somewhere? 

Ranieri.



From tmiller@haverford.edu Tue, 16 Nov 1999 11:08:45 -0500 (EST)
Date: Tue, 16 Nov 1999 11:08:45 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] TCP/IP stack ...

> The only thing that comes to mind is that it would be a Good Thing to have
> a network card driver handy.. has jos already progressed to the level where
> one is included? Can we "steal" it from somewhere? 

	Unfortunately, no.  I'd be willing to bet, however, that something
could be kludged up on the host build to slurp data out of the network
using the Linux drivers.  I really don't know a lot about this, though.
Let me know what kind of help the kernel could give...

-_Quinn




From gchii@mindspring.com Tue, 16 Nov 1999 12:32:01 -0500
Date: Tue, 16 Nov 1999 12:32:01 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] multiple processor architecture

At 01:32 AM 11/16/99 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:

> This is a dangerous misconception.

Misconceptions don't go away by themselves. It requires a great deal of
discussion to put a misconception to rest. The architecture mailing list is
a forum for discussing the possible architecture of JOS. Cutting short a
discussion about alternative architectures isn't helpful.

What is the misconception again? Is it that JOS has nothing at all written
in Java bytecode? Or, is it that JOS has nothing worthwhile to offer
separate from a native JOS kernel?

> Maintaining compatibility with extant JVMs below the application level
> is a great way to cripple JOS's potential.

We both want JOS to live up to its potential. While you might be thinking
about the ultimate JOS that should be available in 2 to 3 years, I am
thinking about the transition required to move from 17+ native platforms to
the ultimate JOS platform.

We are writing JOS in parallel. By writing JOS in parallel, we can reach
the full potential of JOS in the shortest amount of time.

Native operating systems, like Mac OS, Microsoft Windows, Linux and OS/400,
aren't going to go away any time soon -- if ever. JOS cannot live up to its
potential if you eliminate every consumer that wants to benefit from their
investment in their native OS.

Linux is popular because it provides a transition to a new operating system
while using existing IBM PC-compatible hardware. It looks a lot like UNIX.
That is important because consumers want to benefit from their investment
in UNIX.

Java itself is popular because it provides a transition to a new
platform-independent platform. It looks a lot like C/C++. That is important
because consumers want to benefit from their investment in C/C++.

Of course, you're right. The JOS that runs on some other OS cannot provide
the stability, speed or services of the ultimate JOS. JOS is just like Java
in this regard. If the native OS crashes, a Java virtual machine crashes.

Linux is recommended as a native OS for JOS. Linux doesn't crash like
Windows or the Mac. Since the Linus OS works and Ultimate JOS doesn't, it
is easy to see how I might like Linux better. The Transitional JOS runs
Java applications just like Ultimate JOS. And Transitional JOS runs now; it
does not have to wait until the JOS kernel or multiple process JVM is
finished.

> Java is already slow...

You're talking about the future. I'm talking about the present.

You're comparing the potential of Ultimate JOS to the history of other
virtual machine. How fast is Ultimate JOS today? It's the slowest possible
platform because it doesn't run.

Personally, I am pleased with the performance of IBM's JDK 1.1.6 for the
OS/400. It gets the job done. Others seem to be pleased with the
performance reported by TowerJ, an ahead-of-time compiler for Linux, and
the performance of IBM's JDK 1.1.8 for Linux.

They don't need a new OS to run their Java applications today.

I am helping build Ultimate JOS. But we aren't there yet. It is healthy to
discuss what we can do now make the most stable, robust, rugged, high
quality Java applications now so that they will be ready to run on Ultimate
JOS when the time comes.

I think it is a misconception that the JOS Project must wait until the
Ultimate JOS is finished to start work on the development and distribution
of JOS-specific architectures, models programs and APIs. We have a lot of
work to do in order to catch up with operating systems available five years
ago.

We must work hard. We must work in parallel. Every piece of our operating
system is important, not just the kernel or JVM. All of this work has to be
done so that consumers can choose the operating system that gives them the
greatest benefits.

> What makes JOS worthwhile compared to running an X client on that NT box?

Java is worthwhile. It provides an excellent architecture for
platform-independence. You can run the same application on NT as you run on
a Mac or Linux.

Just as Java is worthwhile, JOS is worthwhile. JOS installs on an NT box
without an X client. JOS is self-contained. JOS is extendable,
network-aware and portable. Unlike Java, JOS provides the greatest level of
backward compatibility and future orientation. It provides all of the
OS-related things that are missing from the Java class libraries.

Your JOS program can read configuration information through a well-known
registry interface across all platforms. While on Linux, you can read/write
.conf files. While on Windows, you can read/write .ini files. While on a
Java platform, you can read/write .properties files. The registry interface
stays the same regardless of the file format.

> If JOS runs locally, what makes it superior to daul-booting into some
> other operating system better suited to your needs?

Java applications that use JOS subsystems will benefit from most -- by not
all -- of these innovations. JOS subsystems are superior to other operating
systems. JOS subsystems rely on well-known interfaces. JOS depends on Java
bytecode to do most of the GUI and application-specific work. Bytecode is
consistently stored, distributed and interpreted under JOS.

Today, JOS has a unified model for independence from different Java
platforms. It embraces your extreme customization of the OS. It uses
loosely-couple class libraries, package files, registries, factories and
experimental models and frameworks. It incorporates all of the benefits of
a native platform-independent virtual machine.

> Both Corel and Sun tried and failed to port major office suites to
> straight-up normal Java;

Don't forget Lotus and their brain-dead e-Suite.

We can learn from Corel, Sun and Lotus. Their failure is not an indication
of our failure. Corel dependend on Sun's object serialization to store
data. Sun changed their serialization API rendering all Corel's data
useless. Serialization is not required by Java.

We can learn from Corel's experience with Sun's serialization. Java did not
require Sun to put new serialization in an old namespace. Java did not
require Sun to put serialization into core Java class libraries. If Sun
would have produced backward compatible class libraries, Corel and others
might be far more successful today.

Lotus asked their customers to use a scaled-down version of their
applications. Customer rejected that. Scaled-down applications are not
required by Java.

We can learn from Lotus' experience. We should offer full featured,
comparable applications that run on JOS, both Transitional JOS and Ultimate
JOS. Who is going to build them? If our JOS development is single threaded,
we would have to start JOS application development after Ultimate JOS is
finished.

Of course, JOS development is in parallel. Every Java application
programmer is building an application that will also run on JOS. When
Ultimate JOS is ready, it will be so easy for people to migrate from
whatever they have to Ultimate JOS.

Oracle, IBM and Sun gave up on the network computer. They gave up on JavaOS
for Business. They offered a product for a very small market. Neither a
network nor a network computer is required by Java.

We can learn from the network computer experience. Consumers do not want
network-dependent machines; they want network-aware machines. A network
dependent machine can't run at all without a network. A network-aware
machine uses a network if one is available.

I want to boot JOS from a 500MB hard drive. While my JOS machine has one, a
NIC should not be required. All of the TCP/IP services should run on a
laptop, too.

While you might feel strongly that Utlimate JOS is the best operating
system ever created (and I would agree), consumers must deal with issues of
here and now. They already bought a native OS. Why should they learn
another one?

At this point, there are many consumers getting ready to invest the rest of
their hard earned money to "upgrade" to Windows 2000. Consumers will get
the same thing they already have: an OS that is going nowhere. They are
expected to spend real money to "upgrade" all of the software they already
have. And for what? To find that, while their situation has changed, it
isn't better.

Consumers don't want more excuses. They want software that works. They have
heard the story too many times that their next OS is going to work right
this time.

A. No double the Java virtual machine will run on Windows 2000. It will
crash when Windows 2000 crashes. Every program written in Java will run on
Windows 2000. Every Java-based subsystem in JOS will run on Windows 2000, too.

People are going to be disappointed in Windows 2000 when they figure out
that Microsoft's attitude hasn't changed. They still believe in for-fee
licensing for low quality software. Their formula has worked for many years
because there was no competition.

JOS is Microsoft's worst nightmare come true. Microsoft hopes that we don't
figure out how to make JOS run on Windows. Once JOS runs on top of Windows,
consumers can run Windows and JOS. Consumers will have the best of both
worlds.

And when Ultimate JOS is ready, all those programmers, all those full
features applications and all those consumers will be ready too. They will
know how to use JOS even when a native OS isn't there anymore.

Since we want JOS to reach its full potential, we must make it easy for
consumers to transition from their native OS to JOS. The Java runtime
environment is a perfect transitional platform. Each programmer, each
machine, each person must make the transition. It adds up over time. A
mass-market transition takes years. If we start now, promoting the
transitional JOS as the right answer, the market will be well groomed for
Ultimate JOS by the time it's done.

We can get a lot of help from the rest of the software industry by
remaining neutral to the issue of native platform. We can distribute
products people can use today, such as

 - JOS for Windows 2000
 - JOS for Mac OS 10
 - JOS for OS/400 R5
 - JOS for Linux

and save the marketing blitz for ultimate JOS until after everybody has a
"slow" copy running on their native OS. How will the mass market see that
Ultimate JOS is faster? They can compare Transitional JOS and Ultimate JOS
side-by-side on their own hardware.

While OS would you choose?




From hegdevenkatesh@usa.net 16 Nov 99 10:44:01 MST
Date: 16 Nov 99 10:44:01 MST
From: Venkatesh Hegde hegdevenkatesh@usa.net
Subject: [JOS-Arch] JOS-TCP/IP stack

Hi, I am venkatesh hegde, a BE Comp science 
engineer and I would like to involve myself 
into the development of TCP/IP stack for the OS.

Sincerely ,
venkatesh hegde

____________________________________________________________________
Get free email and a permanent address at http://www.netaddress.com/?N=1



From gchii@mindspring.com Tue, 16 Nov 1999 12:50:26 -0500
Date: Tue, 16 Nov 1999 12:50:26 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Re: multiple processor architecture

At 10:25 AM 11/16/99 -0500, Jake Meier <jake66@iname.com> wrote:
>I believe  that a better option would be to attempt to write a base
>kernel that incorporated the JVM for each platform.

It is a good idea for each organization that builds an operating system to
incorporate kernel support for Java. I know for sure the people who make
Linux and OS/400 have done this. I'm not sure about others.

It is not for the JOS Project to rewrite the kernel of every other native
operating system.

>...I do think that we should make this a native os and not focus on the
>seemingly pointless task of creating a virtual os.

The native kernel and system tools must come together in order to give
people something they can use. We must keep focus on both the native kernel
and its system tools. While the system tools require a JVM, the native
kernel does not.

Does an OS with a virtual machine make a virtual OS? I don't think so. It
is a better OS, easier to port from one processor to another.

>If the view of this orginization is to create an pseudo OS to
>run inside of an existing OS, then I think that someone needs to 
>create a native JOS.

The architecture group is supposed to hash out the architecture of JOS and
where the virtual machine ends and the system tools begin. Someone must
create a native JOS *and* someone must create the system tools.

>If we could incorporate the JVM into the kernel, and supply a different
>kernel for each processor architecture then applications and window managers 
>could be created in pure java eliminating the need for a runtime 
>environment inside of an existing OS.

Here! Here! The JOS Project can port a different kernel for each processor
architecture. That is the non-Java part of JOS. The JOS Project can supply
system tools in pure Java. You'll notice that Red Hat and SuSE provides
some of their Linux system tools in pure Java. Sounds like a great idea.

As much of the operating system that can be written as Java bytecode should
be written as Java bytecode.

>How many of you would use a user interface that is going to slow down your
>machine and allow you to do nothing...

How true. It is our long-term goal to build a better operating system.
Every person using Windows is in this situation. And yet, they put up with
it. People put up with it because there is no feasible alterative. There is
no easy transition from Windows to anything else.

Every person using Linux is also in this situation, where Linux is far more
complex that what a modern operating system needs to be.




From gchii@mindspring.com Tue, 16 Nov 1999 13:29:49 -0500
Date: Tue, 16 Nov 1999 13:29:49 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] multiple processor architecture

At 01:32 AM 11/16/99 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>	It makes good sense to write code now that runs on extant JVMs,
>because a lot of the services and applications (daemons, etc) that will be
>distributed with JOS only need to access a particular other set of
>services (aka JOSSystem, I believe), and these can be faked to debug the
>code you're writing -- which means you don't have to sit idle if you can't
>help us over in kernel land.  However, don't let your ambitions be bound
>by the limitations of current JVMs and OSes; we can do better.  That's
>kind of the point.

We must do better. We must not do what has already been done.

While building a new operating system is possible, it isn't easy. While
others have finished their operating systems, we have something they don't
have. We benefit from their experience. We know where they went wrong. We
do not have to make the same mistakes.

Historically, it makes sense to permanently disconnect the operating system
and its browser/shell/desktop. Many people have tried. Java technology is
the first time that the industry embraced the idea.

You must disconnect the operating system, its kernel, drivers and system
tools, from the browser/shell/desktop. When you do, you find that you have
an architecture where the JOS browser/shell/desktop will run on any native
OS. You can develop the browser/shell/desktop separately, to build a better
desktop and interactive computing environment.

You can build standard replacements for classic system tools. A JOS
Registry Editor can edit the Windows Registry. A JOS Registry editor can
edit the .conf, .ini and .properties files. You can replace the password
command on any operating system. You can replace the e-mail, web browser,
HTTP server, and all other components on a native OS over time.

While the JOSystem can be "faked" to debug this application, it make sense
to "fake" it permanently. If JOSystem will run on Linux, Mac, Windows,
OS/400, why not run it anywhere?

JOSystem can provide the classic HTTP cache for all applications, not just
an HTML browser. JOSystem can provide a cache on any native OS, not just
Ultimate JOS.

It is better than PCAnywhere. Using distributed processing, you can have a
desktop/shell/browser for each machine on the network. You can run the JOS
desktop on your "other" operating system to use the resources of JOS
servers on the network.

In the single console/multiple processor architecture, you need a better
OS. JOS is it. JOS does not require you to throw out all the software you
already use. Microsoft asks their customers to do this every year. Many
consumers are tired of spending money on software and having nothing to
show for it. Giving away software for free doesn't solve the problem if the
free software is obsolete after two years, too.

While we might wish that everyone on the planet would switch to Ultimate
JOS, it just isn't going to happen. There is competition. There are lots of
legacy applications that won't run on JOS -- and never will.

What is feasible and what is realistic is bringing relief to everyone who
suffers the complexity and the instability of other operating systems
through the power of a Java runtime environment and well designed, reliable
JOS subsystems.

Where are all the device drivers for Ultimate JOS? What is an operating
system without device drivers? Some people prefer an operating system that
works with the hardware they already bought. Some people prefer to buy
hardware and operating system together in the hope that it will work.

Compaq, Dell, Gateway, IBM and Toshiba might be willing to distribute
Transitional JOS on their machines if it runs on Windows 2000. Their
customers might be willing to install Transitional JOS on their machines if
it runs on their native OS.

You must find a way for your customers to take JOS for a test drive. Please
don't ask people to leap from one OS to another. Why not let them evolve?
They can take baby steps from their native OS to JOS if JOS runs on their
native OS. If they like Transitional JOS, they will love Ultimate JOS.
Plus, we can make Ultimate JOS even better by working all of the design
flaws out of Transitional JOS.

The path is clear and easy:

Part 1. From native OS to Transitional JOS
Part 2. From Transitional JOS to Ultimate JOS

Get your feet wet. Some people like to dive into their new OS and immerse
themselves in a new environment. They don't look back -- even for the
things they are missing.

Other people like to test the water first. They want to take their new OS
for a test drive. That is how Java itself was such a sensation. Customers
did not have to throw away anything in order to benefit from Java.

We can learn from the Java experience. We must provide transition. We must
do what Sun didn't: provide perfect backward compatibility. In order to
achieve a stable and high quality operating system, we must have a solid
foundation. Historically, the most successful operating systems have

1. provided a transitional phase from past to future.
  See also CP/M vs. MS-DOS
  See also AS/400 vs. System/36.
  See also Windows 95 vs. Windows 98.

2. maintained highest levels of backward compatibility.
  See also Win32 API.
  See also UNIX/Linux binary compatibility.

The least successful operating systems have the same problems:

1. no easy transition
  See also MS-DOS vs Windows 3.1.
  See also Windows 3.1 vs. OS/2
  See also Novell 3.x vs. Novell 4.x
  See also Windows 95 vs. Windows NT.
  See also Java 1 vs. Java 2.

The Windows 95 desktop should have been sold as a separate product. That
way, I could have installed the Windows 95 desktop on my Windows NT 3.1
operating system with no problem. I would have even installed it on OS/2.

The OS/2 desktop should have been sold separately. That way, I could have
installed the Windows 95 desktop on my Windows 95 operating system.

The benefits are clear when you install more than one desktop on your Linux
box. I can use both Windows 95 desktop and KDE and others. It is not a
kludge to run the JOS browser/shell/desktop on Windows 95. Technically, you
can switch between it and the standard desktop, like you switch desktops on
Linux.

Don't make people pay a high price in order to run the JOSystem. It is too
high of a price to insist that they stop running all of their legacy
applications. Why install a new OS and go out of business because your
legacy applications won't run anymore? That is what people do when
Microsoft asks them to install Windows 98 (or 2000). But it is wrong.

Why should the give up their legacy applications when they don't have to?




From gchii@mindspring.com Tue, 16 Nov 1999 13:56:47 -0500
Date: Tue, 16 Nov 1999 13:56:47 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Transitional JOS

Simple JOS is one example of Transitional JOS. You can run JOS on Linux
today, with Simple JOS. It is unfortunate that there has been so little
focus on transitional JOS that it isn't much to look at. There are
subsystems that are just waiting for application programmers to build a
better desktop.

I am working on the Ultimate Browser. It isn't much to look at. I am a
system programmer (and architect). I am not an application programmer. The
ultimate browser includes a toolbar to switch your view:

 - applet browser
 - plain text browser
 - program browser
 - property browser
 - servlet browser
 - stream tokenizer browser

The Ultimate Browser could benefit from a design with more bitmapped
graphics. It might be a good idea to have a version that runs under Swing.

The more complex HTML browser is a glaring omission. The Ultimate Browser
shows off other JOS subsystems, written in pure Java that can run on
Ultimate JOS and other JREs. The Smart API serves up all kinds of digital
resources. When the time comes, your application program can be smaller,
more powerful and benefit from Smart API configuration. The package manager
custom class loader finds bytecode locally and across the network (and
Internet). You just run programs; you don't "install" them. JOS might be
the last program you ever have to "install".

Other subsystems show how it might be possible to create a JOS "partition"
on Linux or Windows that manages JOS data as if it were a block device,
manage commands on the JOS command line (like clUtilities), build reuable
programs, maintain Java source code, expand the idea of an editor (like Jext).

I wonder how many people on the JOS Project are aware of how much Java code
has already been written, how much will already run on any Java virtual
machine, how much work has been done to refine the architecture and models
needed for multiple user security, system-wide and network-wide
configuration, distributed computing, and others.

The JOS 1d Technical Distribution was downloaded 240+ times in October. The
JJOS kernel was downloaded more than anything else. Is it because the JJOS
kernel is better than anything else? Or rather, is it because the JJOS
kernel has been discussed on this and other forums more than anything else?

People are talking about the JOS kernel. There is far more to JOS than
kernels. "A kernel does not an operating system make," said someone on the
JOS Wiki. (Who said that?) JOS is a sum of all its parts, its kernel, its
JOSBox, its JOSystem. The JOSBox and JOSystem should not continue to have a
low priority while the kernel is being built.

I wish Ultimate JOS were ready. I wish I could run it on my JOS machine. No
matter how hard I have wished for it, JOS is difficult to get up and
running -- even with the JOS 1d Binary Distribution.

Imagine the JOS kernel were ready today. What else would we be working on?
I ask that question all of the time. We should be working on the
Transitional JOS, the one that helps people see the potential of JOS for
themselves. They can take Transitional JOS for a test drive. See what it
might looks like.

Speed is irrelevant for this kind of test drive. Transitional JOS is
expected to run as fast as other Java applications. It isn't expected to
run as fast as non-portable native programs. The fact that it runs on 17+
platforms is most amazing. The fact that consumers do not have to give up
anything in order to use JOS on their native OS is the strongest selling
point.

Efficiency is irrelevant for this kind of test drive. When you are trying
to teach people how to use the tool, you can afford more time than when you
are trying to use the tool to do real work. Better tools are so good that
you can afford for them to be a little less efficient -- they are far more
effective.

Give people what they want. Most people are curious about JOS. They want to
take it for a test drive. They don't care how fast it is. They just want to
see what it might be like, comparing it to the OS they already have.




From gchii@mindspring.com Tue, 16 Nov 1999 14:34:10 -0500
Date: Tue, 16 Nov 1999 14:34:10 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Distribution Group

A distribution group should be formed to help redistribute all of the
existing components of the JOS Project to its members. A distribution group
will help identify and consistenly package existing components so that
members of the JOS Project will have no trouble at all getting their copy
of JOS.

If you would like to join the distribution group, please reply on the
architecture mailing list. Are you wondering if you should join? Ask your
questions here.

JOS needs to be redistributed to members of the JOS Project so that
everyone sees what JOS is today and the potential for what it might be
tomorrow. The distribution group should make recommendations to members of
the JOS Project as to repackaging their code to fit in to the org.jos
namespace.

The distribution group is a special interest group of the architecture
group. Architecture and distribution are closely related, in that, JOS
needs to be packaged to fully support its architecture.

The distribution group should manage the check list of product names and
where development tools can be downloaded or aquired.

The distribution group should be formed now. It will help promote the clear
perception of what is and what is not JOS. It will attempt to keep future
misconceptions to a minimum.

We must be capable of explaining JOS to members of the JOS Project. After
we have a reasonable perception of JOS among members, our public-relations
group should be take over to explain JOS to non-members.

Where can you help? If you know of any JOS-related distribution, you should
post it on this forum. If the distribution is already on a JOS Wiki page,
please indicate the name of the page.

Personally, I have only been a member for a short time. I don't know that I
have everything that has been developed for JOS. I know that I have been
unable to boot JOS from a floppy across my network. It shouldn't be this
difficult for people to download and install JOS, to take JOS for a test
drive.

Feel free to disagree with me. I think that a solid distribution group
might make it easier for every member of the JOS project to build a
distribution and make sure every other member is aware of their work.

The recommendations of the distribution group are not binding. As always,
members can do whatever they like. The distribution group might be able to
offer additional tools (in pure Java, of course) that make it easier and
easier to build a distribution and make it available to other members and
even non-members.

I have tried to use a long list of Java development tools. I must confess
that none of them come close to what I need to get my work done. I am using
many different tools, each tool does almost what I need. I have been
limping along like this for over five years. This is what I do not like
about my operating system: I cannot fix it. With Java and a Java-based
operating system, it will put me in control of my own machine. I will be
able to fix anything I don't like. If I can't get my work done, I will have
no excuses because it is all my responsibility.

I'm sure that my contribution to the JOS Project would have been higher
quality if I had JOS and its tools from the beginning. I can't wait to
develop more of JOS on JOS. Meanwhile, there is source code and bytecode
that needs to be distributed. How should it be done? What should it be called?

For example, I plan to distribute the Smart API and all of its related
classes as a single binary distribution in two equivalent files, called

   "smartapi-1.tgz" and 
   "smartapi-1.zip".

I have been working on the Smart API from the ground up. Everything in this
distribution is functional. If it doesn't work yet, it isn't in the
distribution. If you would like to see what JOS might look like, you should
look at the architecture demonstrated by the Smart API.

It puts a consistent front end on many class libraries found in Java. It is
better than the multiple-stage factory of java.net.URL. While I have been
using the Smart API for a while, it has been difficult to distribute it to
members of the JOS Project. That has got to change.

You don't have to formally "join" the distribution group. You can
contribute to the discussion whenever you feel like it. If you feel
strongly about these issues, you should join and help us shape the
expectations of JOS distribution. We must be prepared for JOS distribution
long before Ultimate JOS is ready.

Based on this discussion, we might build "DistributionGroup" and related
pages on JOS Wiki.

How many JOS Project members would like to know if they have everything? A
distribution group might help build the mechanism to let members verify
that they have everything that is currently available. The hit and miss
documentation on JOS Wiki is adequate for special interest groups; but, it
doesn't serve the needs of the whole JOS Project. When I joined the JOS
Project, I wanted to make Extreme Distributed Computing (XDC) available to
its members. Even after all this time, XDC hasn't been discussed. Do you
have a copy? What can it do for JOS?

An XDC-based IPC is similar to an XML-based IPC. This kind of protocol has
been available for 10+ years, according to one company. While they call it
Dynanic Data Storage (DDS), I call it Dynamic Storage Objects (DSO). It is
the same thing that can be done with XML.

What process should we use to follow up on a JOS product distribution?
Should we review it? Should we "vote" on retaining it for JOS? Or rejecting
it?

How does it work now?




From tmiller@haverford.edu Tue, 16 Nov 1999 16:24:02 -0500 (EST)
Date: Tue, 16 Nov 1999 16:24:02 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] multiple processor architecture

> Misconceptions don't go away by themselves. It requires a great deal of
> discussion to put a misconception to rest. The architecture mailing list is
> a forum for discussing the possible architecture of JOS. Cutting short a
> discussion about alternative architectures isn't helpful.

	This issue has been discussed in both the architecture and the
kernel list before.  Certain things that are absolutely necessary to
what you refer to as 'Ultimate JOS' require our own JVM, one with the
necessary hardware accesses.  The jJOS kernel on which the decaf JVM runs
is simple enough that a close approximation of it is already running on
Linux -- sans h/w access.  If someone more skilled in Linux kernel hackery
than I were willing to provide the necessary kernel mods to allow the host
build of jJOS to access the hardware, I would have no objection -- and it
would probably be very helpful for debugging until JOS is into the
bootstrap phase. (Likewise Bochs or VMWare, neither of which I've been
able to try.)
	I do not object to writing JOS in parallel; but when you say 'JOS
does not require a native kernel' and I read (your phrasing) 'Ultimate
JOS' -- well, that statement is a dangerous misconception, one that will
lead to the crippling of the JOS platform.  I think we agree with each
other more than we initially realised.  I am in favor of parallel
development -- the more the merrier.  However, I will not advocate the
development of emulators of the JOS kernel/VM, because I feel very
strongly that the efforts of programmers suited to this type of work would
be better spent on implementing those featurs on the JOS kernel/VM --
which right now appears to be jJOS and decaf.  This may end up being
sheerest optimism; I could be dramatically underestimating the gestation
time for jJOS/decaf.

	I think we both have only the highest of hopes for JOS; and
(forward referencing other mail in my inbox) that a distribution groups is
Good Idea.  I had been looking forward and seeing a disaster when
jJOS/decaf was ready for 'general consumption' and I had to put together
what amounts to the vast majority of the OS code -- so this puts my mind
much at ease.

	Your point that a 'transitional JOS' (though it's not an
operating system by many definitions) not needing its own
kernel/JVM is a good one; you say,

> You're talking about the future. I'm talking about the present.

	and you're quite correct.  My most major concern -- and it seems I
over-reacted -- is that you don't shortchange the future for the present.

> JOS cannot live up to its potential if you eliminate every consumer
> that wants to benefit from their investment in their native OS.

	What is the investment that consumers make in their operating
systems?  I see two major sections: time investment in training and
familiarity and investment in software.  Time investment in training can
be addressed with work-alikes, to a certain extent, but if JOS is better,
it's going to be different, and we shouldn't worry about it too much --
aside from keeping the learning curve low in general.  Investment in
software there's just not anything we can do about; software running on X
native system isn't going to work on JOS, unless it's already Java.  (That
is, one primary goal of the JOS VM is to run extant Java bytecode w/o
modification.)

> The Transitional JOS runs Java applications just like Ultimate JOS.

	Okay, here's the problem: my contention is that the 'Transitional
JOS' can not run some of the applications which will comprise the
'Ultimate JOS'.  The question here is if the applications which provide
the maximal benefit to the user -- the ones we want to write -- can be
written without those sub-applications (libraries/APIs/etc).

	I suppose I should step back here.  I am not writing the
components of the 'Ultimate JOS' that you and others on the architecture
list are; I can't truly tell you about what is and is not possible with
respect to any particular application you're developing.  (continued
below)

> Java is worthwhile. It provides an excellent architecture for
> platform-independence. You can run the same application on NT as you run on
> a Mac or Linux.

> JOS is self-contained. JOS is extendable, network-aware and portable.
> Unlike Java, JOS provides the greatest level of backward compatibility
> and future orientation. It provides all of the OS-related things that
> are missing from the Java class libraries.

	What you seem to be saying here is that the upper edge of JOS --
the applications/libraries/APIs which compose its interface -- can be
completely separated from their implementation; that the 'Ultimate JOS'
would be this upper edge running on an implementation that best supports
it, and applies its precepts to the management of the hardware.  My
concern is to the realization of this dream, that this upper edge is not
restricted by the restrictions imposed by a 'non-Ultimate' lower edge.

> We can learn from Lotus' experience. We should offer full featured,
> comparable applications that run on JOS, both Transitional JOS and
> Ultimate JOS.

	The same question crops up here.  Can applications that are as
good or better than the competition be written without the aid of the
'Ultimate JOS'?

> While you might feel strongly that Utlimate JOS is the best operating
> system ever created (and I would agree), consumers must deal with issues of
> here and now. They already bought a native OS. Why should they learn
> another one?

	Because JOS /and its applications/ will be better.  That's all we
can offer -- see my question above.  The best thing to do at this point
might just be to try.  If a JOS application won't work without our own
JVM (which, in turn, will almost certainly work best on our own kernel),
or will work better with support from the JVM, then the debate is pretty
much settled, no?  The hard part is not to be trapped by the mindset a
devloper might develop from working on a lesser system.  (That is, the why
should I bother to make my app any more stable than the system on which it
runs? mentality applies to innovation as well, I think -- if it's harder
to get something innovative to work, it's less likely to get done...)

> JOS is Microsoft's worst nightmare come true. Microsoft hopes that we don't
> figure out how to make JOS run on Windows. Once JOS runs on top of Windows,
> consumers can run Windows and JOS. Consumers will have the best of both
> worlds.

	Microsoft killed Netscape because they promised the same thing.
Luckily, we don't have a revenue stream to attack :)


	I pretty much have to trust your (JOS application programmers)
judgment about the portability of JOS APIs, but applications are not the
only thing make an O/S worthwhile.  As we've agreed, there are issues
about running 'Transitional JOS' -- even one that's a full peer of the
'Ultimate JOS' on the user (top-edge) side -- on a system which wasn't
designed to support it.
	However, JOS should also provide things like uniform models for
the various facets of multimedia, resource location and allocation,
hardware awareness -- all things that will need massive amounts of
platform-specific code to support.  jJOS and decaf form a kernel/JVM pair
written from the ground up to support things like this, and I think,
despite the value of writing applications for conventional JVMs (i.e.
those on other platforms), that this type of work would be better used on
the jJOS/decaf itself.

-_Quinn





From tmiller@haverford.edu Tue, 16 Nov 1999 16:25:34 -0500 (EST)
Date: Tue, 16 Nov 1999 16:25:34 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Re: multiple processor architecture

> As much of the operating system that can be written as Java bytecode should
> be written as Java bytecode.

	Hear!  Hear!  (Anything that makes /my/ life easier!)

-_Quinn




From tmiller@haverford.edu Tue, 16 Nov 1999 17:01:05 -0500 (EST)
Date: Tue, 16 Nov 1999 17:01:05 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] multiple processor architecture

> While the JOSystem can be "faked" to debug this application, it make sense
> to "fake" it permanently. If JOSystem will run on Linux, Mac, Windows,
> OS/400, why not run it anywhere?

	Because "faking" your back-end support leads to problems with
stability, speed and generally requires great mounds of platform-specific
code to work in the general case.  If you're going to write
platform-specific code, why not write it for the platform specifically
designed to support it?

	As I've mentioned before, I have doubts about the ability of the
JOS front-end to meet its full potential running on systems other than its
own back-end.

> Why should the give up their legacy applications when they don't have to?

	Mu.  We don't know yet that they won't have to.  And besides,
daul-booting O/Ses is not too terribly complicated, nor is it difficult to
set up -- in fact, the next wave of Linux distros looks like it's going to
automate the process for you.  And while daul-booting OSes is annoying,
writing interoperability software so that the 'Transitional JOS' works
with your native OS apps is nontrivial and fraught with the same dangers
that writing interop code is.

-_Quinn




From iainshigeoka@yahoo.com Tue, 16 Nov 1999 16:11:21 -0600
Date: Tue, 16 Nov 1999 16:11:21 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] Transitional JOS

On 16 Nov 99, at 13:56, Gilbert Carl Herschberger II wrote:

> I am working on the Ultimate Browser. It isn't much to look at. I am a

Sounds interesting.

> People are talking about the JOS kernel. There is far more to JOS than
> kernels. "A kernel does not an operating system make," said someone on the
> JOS Wiki. (Who said that?) JOS is a sum of all its parts, its kernel, its
> JOSBox, its JOSystem. The JOSBox and JOSystem should not continue to have a
> low priority while the kernel is being built.

"A kernel does not an operating system make,"

I (Iain) said that.  It was intended to be said with a Yoda (Star 
Wars) accent.  :)  I agree that the focus seems to be very lopsided 
on the kernel.  I see several JOSystem problems that working 
groups IMHO should be attacking now.  They will be useful with or 
without the rest of the JOS system and will help all java 
installations.  And they can be developed on any jdk available now.

1) a standardized install/uninstall api for java applications.  ala 
Installshield on Win32 and sorta RPM on linux.  The installs should 
actually target classfile -> logical_location mappings so each 
platform can map the logical_location to appropriate filesystem, 
classpath, registry, database or whatever mechanisms to store the 
the classfile and enable loading of the class path.

2) shared library manager.  Basically a way to avoid the DLL hell 
that plagues Win32.  That is, a platform neutral way to load the 
correct classes with the correct programs taking into account 
versions of libraries, etc.  Such a system may require a rewrite of 
the classloader.  Ideally, new versions of shared code will 
_supplement_ and not replace older versions.  Applications will 
attempt operation using the new version (to gain enhancements) 
but failures will cause them to automatically revert to using the 
older (known good) version.

3) package manager/launcher - a method to specify and group 
classfiles together logically without having to do so physically (jar 
them) for managament and application launching.  This gives users 
a view of packages as "single exe" looking entities.  This is cleaner 
and what I image was intended with "executable jars" but allows us 
to continue to share code (and eliminate redundant copies of 
classes).

> Give people what they want. Most people are curious about JOS. They want to
> take it for a test drive. They don't care how fast it is. They just want to
> see what it might be like, comparing it to the OS they already have.

This I think is actually most dependent on the UI group actually 
generating a desktop.  Watching printf debug messages crank gets 
really tiring and is certainly not very impressive!  I think just 
screenshots from a new UI would get more people more excited 
about JOS than probably even a shipping kernel with no GUI 
support.  And, the UI list has been ghostly silent recently.

-iain



From Corrado.Santoro@IIT.UNICT.IT Wed, 17 Nov 1999 08:04:42 +0100
Date: Wed, 17 Nov 1999 08:04:42 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Arch] Distribution Group

Hi Gilbert,
I would like to join to the JOS distribution group.

Bye,
	Corrado.

P.S.: What's up with your JOS boot ?

On Tue, 16 Nov 1999, Gilbert Carl Herschberger II wrote:
> A distribution group should be formed to help redistribute all of the
> existing components of the JOS Project to its members. A distribution group
> will help identify and consistenly package existing components so that
> members of the JOS Project will have no trouble at all getting their copy
> of JOS.
> ......

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://netra.cdc.unict.it/ARCA
======================================================




From Corrado.Santoro@IIT.UNICT.IT Wed, 17 Nov 1999 08:25:43 +0100
Date: Wed, 17 Nov 1999 08:25:43 +0100
From: Corrado Santoro Corrado.Santoro@IIT.UNICT.IT
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

Hey men,
can you tell me something about the JOS packages ?
I mean, is there any web page which describes each of the JOS packages listed
by Gilbert in http://www.mindspring.com/~gchii/jos/library/packages.html ?
Excluding source server, is it possible to download the other packages ?
What's the meaning of "pizza status" ? Does it mean that to compile the package
I need the pizza compiler ? But why I cannot use the "standard" javac ?
Really, I have tried to compile the source server package with javac, but I get
a long list of errors. Some of them are syntax errors, thus they are not
related to the type of compiler used. So, can you tell me something else about
the status of the packages (e.g., written but not compiled, successfully
compiled but not runned, successfully runned) ?

Thank you for your answers,
	Byte.

--
======================================================
Eng. Corrado Santoro - PhD Student

Unversity of Catania - Engineering Faculty
Institute of Computer Science and Telecommunications
Viale A. Doria, 6 - 95125 CATANIA (ITALY)

Tel: +39 095 7382365           Fax: +39 095 7382397

EMail: csanto@iit.unict.it
Personal Home Page:
            http://www.cdc.unict.it/~csanto

ARCA Mobile Agent Framework Home Page:
            http://netra.cdc.unict.it/ARCA
======================================================




From jewel@pixie.co.za Tue, 16 Nov 1999 23:31:49 +0200 (SAST)
Date: Tue, 16 Nov 1999 23:31:49 +0200 (SAST)
From: John Leuner jewel@pixie.co.za
Subject: [JOS-Arch] multiple processor architecture

> Here! Here! I hear a lot of discussion about a native kernel. JOS
> architecture does not require a native kernel. Like all Java bytecode, all
> you need is a JVM. I wish there was more discussion about the Java-side of
> JOS.

Then why is there a need for JOS, last time I checked there are quite a
few VMs out there!
 
> As a Java-related project, JOS fills in the missing pieces in the Java
> class libraries. It is a loose collection of additional applications and
> services, like FTP, HTTP, and TELNET. In addition, it fixes some of the
> defects in the Java class libraries, including backward compatibility and
> future orientation.

Sure, Java implementations of these kinds of utilities would be a useful
part of the operating system, but what most of us (especially in
Jos-kernel) are interested in doing is bringing the JVM closer to the
hardware.
 
> JOS does not require you to replace your favorite machine. JOS does not
> require you to replace your native operating system. But JOS enables you to
> learn one desktop/shell/browser mechanism and carry it with you wherever
> you go.
> 
> On the Mac, JOS appears as a native GUI program. Inside the GUI window, JOS
> has its own set of desktop/shell/browser configurations. JOS supports
> multiple desktops. You start your Mac OS and then start your JOS desktop.
> 
> It is the same for people who use Linux/UNIX (and X/Windows) and people who
> use Microsoft MS-DOS (and Microsoft Windows).

Hmm not quite, we may want to have a clear separation of JOS into two
parts:

Native code / kernel + java drivers etc

Another piece with window managers and all the applications you talk
about.

But the point is that conventional OSes weren't designed to run Java, so
we can expect that they don't deliver maximal performance or resource
usage. 

We have to see if we can do better, and in doing so create some 'identity'
for JOS. People aren't going to want to develop applications (like ftp)
for JOS unless they can identify with something like a bootable OS.

John





From jewel@pixie.co.za Wed, 17 Nov 1999 10:34:10 +0200 (SAST)
Date: Wed, 17 Nov 1999 10:34:10 +0200 (SAST)
From: John Leuner jewel@pixie.co.za
Subject: [JOS-Arch] TCP/IP stack ...

Although I've never written a network stack before, I'ld love to look over
your shoulder and help out wherever possible. 

The first thing to do is identify what we need to get started. What
exactly do we want to implement first, and how can we generate the
necessary input / output to test what we're writing? 

At this stage it might be a good idea to just use Linux to provide the
lower networking layers, and feed the data into a Java app.

John Leuner

 > Hey everybody ,
> I'm interested in doing the TCP/IP stack for the JOS... anybody want to hop on
> ???
> Clarion call to all those network-savvy dudes there ... 
> Lets' get stacking !!!
> 
> Vijay
> 
> ____________________________________________________________________
> Get free email and a permanent address at http://www.netaddress.com/?N=1
> 
> _______________________________________________
> Arch maillist  -  Arch@jos.org
> http://jos.org/mailman/listinfo/arch
> 




From R.Argentini@student.tudelft.nl Wed, 17 Nov 1999 11:48:26 +0100
Date: Wed, 17 Nov 1999 11:48:26 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] TCP/IP stack ...

>The first thing to do is identify what we need to get started. What
>exactly do we want to implement first, and how can we generate the
>necessary input / output to test what we're writing? 

First thing to do is usually to get all the eth. packets received through a
function/method that examines them. This method decides wether they are
handled (in case of ARP RARP or IP) or discarded, and pass them to their
respective handlers.
This could be implemented modularly so new protocols can be added without
modifying the code, simply by adding another instance of a "protocol" class
into a suitable structure.

Next would be to get ARP and RARP working to map IPs onto MAC adresses and
finally the IP stuff, which will be pretty hairy (think routing,
fragmentation and reassembly, errors via ICMP etc.)
Now we should have something semi-useable.
Adding in UDP should be trivial at this stage, for it just a very thin
layer on top of IP.
The TCP is going to prove even hairier than IP, but that's for later worries :)

The very important thing (as in all OO projects) is to have a good
interface definition to the visible objects.
Sun has defined TCP and UDP classes, i just suggest we implement those when
we get there. There's however still a lot of room to improvise.

>At this stage it might be a good idea to just use Linux to provide the
>lower networking layers, and feed the data into a Java app.

While this is undoubtedly a good idea, we need a couple of native methods
to implement some serious black magic, and i'm not much of a linux device
wizard. I'm willing to experiment though :)
We need to make this "black magic class" compatible with the "jos driver
interface for block devices" if such a thing exists, and then plugging it
into the kernel should be fairly painless.

Keep up the brainstorm!
Ranieri.

PS: are we expected to have garbage collection for the tcp/ip stack?




From R.Argentini@student.tudelft.nl Wed, 17 Nov 1999 12:25:05 +0100
Date: Wed, 17 Nov 1999 12:25:05 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] NetworkingGroup Dead?

The NetworkingGroup is reported to work on a tcp/ip implementation.
The problem is that the the contact for TCP/IP (MatthewCaswell) is labeled
unreacheable, just as PehrAnderson of the ethernet drivers.
AdamBeres is reputedly still working on his version of the drivers, but the
last message to the network mailing list archive is from almost 1.5 years
ago (though that could mean that the archiver program html thingy has not
run since :)

So, guys, if you are over there lurking, please give us a sign. That way we
will not waste effort by duplicating code needlessly.

RanieriArgenitini




From kumarrk@usa.net 17 Nov 99 06:05:06 MST
Date: 17 Nov 99 06:05:06 MST
From: Kumar Ramanathan kumarrk@usa.net
Subject: [JOS-Arch] TCP/IP stack.

Hey everybody,
I've been reading the postings on the Networking mailing list and would like
to be part of this effort ... 
I've had some experience in C++/UNIX/OOAD and TCP/IP in the industry and would
like to make a contribution.

Please make me part of all the mailers regarding the stack.I've quite some
free time now after being in a crazily crazily  hectic schedule last 2 months
...

Thanks,
Kumar

Ranieri Argentini <R.Argentini@student.tudelft.nl> wrote:
>The first thing to do is identify what we need to get started. What
>exactly do we want to implement first, and how can we generate the
>necessary input / output to test what we're writing? 

First thing to do is usually to get all the eth. packets received through a
function/method that examines them. This method decides wether they are
handled (in case of ARP RARP or IP) or discarded, and pass them to their
respective handlers.
This could be implemented modularly so new protocols can be added without
modifying the code, simply by adding another instance of a "protocol" class
into a suitable structure.

Next would be to get ARP and RARP working to map IPs onto MAC adresses and
finally the IP stuff, which will be pretty hairy (think routing,
fragmentation and reassembly, errors via ICMP etc.)
Now we should have something semi-useable.
Adding in UDP should be trivial at this stage, for it just a very thin
layer on top of IP.
The TCP is going to prove even hairier than IP, but that's for later worries
:)

The very important thing (as in all OO projects) is to have a good
interface definition to the visible objects.
Sun has defined TCP and UDP classes, i just suggest we implement those when
we get there. There's however still a lot of room to improvise.

>At this stage it might be a good idea to just use Linux to provide the
>lower networking layers, and feed the data into a Java app.

While this is undoubtedly a good idea, we need a couple of native methods
to implement some serious black magic, and i'm not much of a linux device
wizard. I'm willing to experiment though :)
We need to make this "black magic class" compatible with the "jos driver
interface for block devices" if such a thing exists, and then plugging it
into the kernel should be fairly painless.

Keep up the brainstorm!
Ranieri.

PS: are we expected to have garbage collection for the tcp/ip stack?


_______________________________________________
Arch maillist  -  Arch@jos.org
http://jos.org/mailman/listinfo/arch


____________________________________________________________________
Get free email and a permanent address at http://www.netaddress.com/?N=1



From m.caswell@hughesrae.co.uk Wed, 17 Nov 1999 15:23:42 +0000
Date: Wed, 17 Nov 1999 15:23:42 +0000
From: Matt Caswell m.caswell@hughesrae.co.uk
Subject: [JOS-Arch] Re: NetworkingGroup Dead?

This is a cryptographically signed message in MIME format.

--------------msF0AF99059B04EF511B5BF21C
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit



Ranieri Argentini wrote:

> The NetworkingGroup is reported to work on a tcp/ip implementation.
> The problem is that the the contact for TCP/IP (MatthewCaswell) is labeled
> unreacheable, just as PehrAnderson of the ethernet drivers.
> AdamBeres is reputedly still working on his version of the drivers, but the
> last message to the network mailing list archive is from almost 1.5 years
> ago (though that could mean that the archiver program html thingy has not
> run since :)
>
> So, guys, if you are over there lurking, please give us a sign. That way we
> will not waste effort by duplicating code needlessly.
>
> RanieriArgenitini

I'm still lurking around but am no longer working on the TCP/IP stack.
Unfortunately the code that I started to put together on this now resides on a
hard disk in my loft...you're probably better off starting from scratch... :-(

Matt

--
Matt Caswell, Internet Consultant, Morse Hughes Rae
Tel: 01332 600110   Mobile: 07887 620205
email: m.caswell@morse.com


--------------msF0AF99059B04EF511B5BF21C
Content-Type: application/x-pkcs7-signature; name="smime.p7s"
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="smime.p7s"
Content-Description: S/MIME Cryptographic Signature

MIIIZgYJKoZIhvcNAQcCoIIIVzCCCFMCAQExCzAJBgUrDgMCGgUAMAsGCSqGSIb3DQEHAaCC
BhIwggLRMIICOqADAgECAgMBCR8wDQYJKoZIhvcNAQEEBQAwgbkxCzAJBgNVBAYTAlpBMRUw
EwYDVQQIEwxXZXN0ZXJuIENhcGUxFDASBgNVBAcTC0R1cmJhbnZpbGxlMRowGAYDVQQKExFU
aGF3dGUgQ29uc3VsdGluZzEpMCcGA1UECxMgVGhhd3RlIFBGIFJTQSBJSyAxOTk4LjkuMTYg
MTc6NTUxNjA0BgNVBAMTLVRoYXd0ZSBQZXJzb25hbCBGcmVlbWFpbCBSU0EgSXNzdWVyIDE5
OTguOS4xNjAeFw05OTA2MjQwODAyMzZaFw0wMDA2MjMwODAyMzZaMEsxHzAdBgNVBAMTFlRo
YXd0ZSBGcmVlbWFpbCBNZW1iZXIxKDAmBgkqhkiG9w0BCQEWGW0uY2Fzd2VsbEBodWdoZXNy
YWUuY28udWswgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAL2pkV6OgA4aDrqAHKMrn7D0
KLIOPmIJ7EUzW4rXVzt62QORIfHIvUlGL7Tsdy5KPAurcNtfjkXfNMc5rE90q7FlSMfsqMmx
Nvgp7QcjkewCWonuqOhTdWA60Qx4z7hr8R5IlGFrbQa9GX/ZsEuS30DpwATDUdYLAs6XjLiz
Vo85AgMBAAGjVDBSMBEGCWCGSAGG+EIBAQQEAwIFoDAOBgNVHQ8BAf8EBAMCBaAwDAYDVR0T
AQH/BAIwADAfBgNVHSMEGDAWgBT+PmCca4wPsNgzxsrGHliwcTi14DANBgkqhkiG9w0BAQQF
AAOBgQBkqMkFK/f7QSZe4ptbCn2YPHjsM3OvvS3+PNsKLX1tobNBtnvBCSIkZiFMEgzLCn2K
rdEv+IYkv0dgGdHuw8uuIg/atkNl5Pip1Gtlqw6DzaKpjvuuUsrtEMFSNecwf3F45D8tDXYH
Qs3x162hjmddBUBdD0H67ZeRdCsB2RJDSTCCAzkwggKioAMCAQICAQowDQYJKoZIhvcNAQEE
BQAwgdExCzAJBgNVBAYTAlpBMRUwEwYDVQQIEwxXZXN0ZXJuIENhcGUxEjAQBgNVBAcTCUNh
cGUgVG93bjEaMBgGA1UEChMRVGhhd3RlIENvbnN1bHRpbmcxKDAmBgNVBAsTH0NlcnRpZmlj
YXRpb24gU2VydmljZXMgRGl2aXNpb24xJDAiBgNVBAMTG1RoYXd0ZSBQZXJzb25hbCBGcmVl
bWFpbCBDQTErMCkGCSqGSIb3DQEJARYccGVyc29uYWwtZnJlZW1haWxAdGhhd3RlLmNvbTAe
Fw05ODA5MTYxNzU1MzRaFw0wMDA5MTUxNzU1MzRaMIG5MQswCQYDVQQGEwJaQTEVMBMGA1UE
CBMMV2VzdGVybiBDYXBlMRQwEgYDVQQHEwtEdXJiYW52aWxsZTEaMBgGA1UEChMRVGhhd3Rl
IENvbnN1bHRpbmcxKTAnBgNVBAsTIFRoYXd0ZSBQRiBSU0EgSUsgMTk5OC45LjE2IDE3OjU1
MTYwNAYDVQQDEy1UaGF3dGUgUGVyc29uYWwgRnJlZW1haWwgUlNBIElzc3VlciAxOTk4Ljku
MTYwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMSl5dTU0F8IAu4HIX0kv6trjh7rIAcC
FYRrj9CTJB8bne5osrksT+mTZxcQFx6h+UNBI7kwqnaXu/Pn/YHAtTGL9qZQJlTylSjrGaQe
lx6w4ribwQSaMtA8CWxP5DVP8Ha/ABMDT0UIYPP8tNCQAYoSyZy6f1LqKpM1Njw85DUvAgMB
AAGjNzA1MBIGA1UdEwEB/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUcknCczTGVfQLdnKBfnf0
h+fGsg4wDQYJKoZIhvcNAQEEBQADgYEALMeCHwFDPgeP7mlcqWSC+MCWrZMry5tQ10CagcK6
pnadPJVA3FXB4VWCeasKKabVDOFXKD6P+bvV3w2TWKpbLYuPM+TdWBU1dnIVKb1C9FqSC3df
nSfbmi1OG4IGjtKNVruV3tsMZQXelZ4C3VMXvr78a8MaInoUK2G9wp9eeloxggIcMIICGAIB
ATCBwTCBuTELMAkGA1UEBhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTEUMBIGA1UEBxML
RHVyYmFudmlsbGUxGjAYBgNVBAoTEVRoYXd0ZSBDb25zdWx0aW5nMSkwJwYDVQQLEyBUaGF3
dGUgUEYgUlNBIElLIDE5OTguOS4xNiAxNzo1NTE2MDQGA1UEAxMtVGhhd3RlIFBlcnNvbmFs
IEZyZWVtYWlsIFJTQSBJc3N1ZXIgMTk5OC45LjE2AgMBCR8wCQYFKw4DAhoFAKCBsTAYBgkq
hkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw05OTExMTcxNTIzNDJaMCMG
CSqGSIb3DQEJBDEWBBSwP8YQWV4saJmoc5FuQJfCk15raTBSBgkqhkiG9w0BCQ8xRTBDMAoG
CCqGSIb3DQMHMA4GCCqGSIb3DQMCAgIAgDAHBgUrDgMCBzANBggqhkiG9w0DAgIBQDANBggq
hkiG9w0DAgIBKDANBgkqhkiG9w0BAQEFAASBgE9SjvdIe4wg3QRv+8mq4SiZozqc0HYork6f
dVdgI/Ba8ao1SepWb4eaeHomq3svKj+RYqe/tByKeHOsVraxXgigVnz9ZBvPQPk1EV84bemb
4Z5Q+XGjRBz0ARUldQqydlY90uKpnMufw1lEbnNCw4tIT5FB3NK0IEGp+UUvduRE
--------------msF0AF99059B04EF511B5BF21C--




From George.Marrows@Smallworld.co.uk Wed, 17 Nov 1999 17:17:22 -0000
Date: Wed, 17 Nov 1999 17:17:22 -0000
From: George.Marrows@Smallworld.co.uk George.Marrows@Smallworld.co.uk
Subject: [JOS-Arch] TCP/IP stack ...

Hi Ranieri --

> PS: are we expected to have garbage collection for the tcp/ip stack?

jjos/decaf already has functioning Java (and C++ for that matter) garbage
collection in place - though it is admittedly not very sophisticated.
Anything you write in Java for jjos/decaf gets this automatically.

Is that what you meant, or were you referring to some tcp/ip specific
meaning of the phrase I'm completely unaware of?

-- George

> -----Original Message-----
> From:	Ranieri Argentini [SMTP:R.Argentini@student.tudelft.nl]
> Sent:	Wednesday, November 17, 1999 10:48
> To:	John Leuner; Vijay Raghavan
> Cc:	arch@jos.org
> Subject:	Re: [JOS-Arch] TCP/IP stack ...
> 
> >The first thing to do is identify what we need to get started. What
> >exactly do we want to implement first, and how can we generate the
> >necessary input / output to test what we're writing? 
> 
> First thing to do is usually to get all the eth. packets received through
> a
> function/method that examines them. This method decides wether they are
> handled (in case of ARP RARP or IP) or discarded, and pass them to their
> respective handlers.
> This could be implemented modularly so new protocols can be added without
> modifying the code, simply by adding another instance of a "protocol"
> class
> into a suitable structure.
> 
> Next would be to get ARP and RARP working to map IPs onto MAC adresses and
> finally the IP stuff, which will be pretty hairy (think routing,
> fragmentation and reassembly, errors via ICMP etc.)
> Now we should have something semi-useable.
> Adding in UDP should be trivial at this stage, for it just a very thin
> layer on top of IP.
> The TCP is going to prove even hairier than IP, but that's for later
> worries :)
> 
> The very important thing (as in all OO projects) is to have a good
> interface definition to the visible objects.
> Sun has defined TCP and UDP classes, i just suggest we implement those
> when
> we get there. There's however still a lot of room to improvise.
> 
> >At this stage it might be a good idea to just use Linux to provide the
> >lower networking layers, and feed the data into a Java app.
> 
> While this is undoubtedly a good idea, we need a couple of native methods
> to implement some serious black magic, and i'm not much of a linux device
> wizard. I'm willing to experiment though :)
> We need to make this "black magic class" compatible with the "jos driver
> interface for block devices" if such a thing exists, and then plugging it
> into the kernel should be fairly painless.
> 
> Keep up the brainstorm!
> Ranieri.
> 
> PS: are we expected to have garbage collection for the tcp/ip stack?
> 
> 
> _______________________________________________
> Arch maillist  -  Arch@jos.org
> http://jos.org/mailman/listinfo/arch



From iainshigeoka@yahoo.com Wed, 17 Nov 1999 14:51:05 -0600
Date: Wed, 17 Nov 1999 14:51:05 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] NetworkingGroup Dead?

On 17 Nov 99, at 12:25, Ranieri Argentini wrote:

> AdamBeres is reputedly still working on his version of the drivers, but the
> last message to the network mailing list archive is from almost 1.5 years
> ago (though that could mean that the archiver program html thingy has not
> run since :)

You are referring to a spin.de list.  All are now inactive except for 
the annouce list.  You need to refer to active lists at:

http://jos.org/mailman/listinfo

There currently is no networking specific list active.  You might 
want to discuss starting one on the admin and general lists if you 
want to.  Since the Arch list is so quiet, I don't think it will be a 
problem for networking issues to use the list (although, its arguable 
that having a separate archive of a list for networking will help 
"hindsight" documentation later on).

> So, guys, if you are over there lurking, please give us a sign. That way we
> will not waste effort by duplicating code needlessly.

I'd also suggest exploring and cleaning up the network related wiki 
pages.  It should shed light on past work, as well as pave the way 
for newcomers.

-iain




From iainshigeoka@yahoo.com Wed, 17 Nov 1999 14:51:05 -0600
Date: Wed, 17 Nov 1999 14:51:05 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

On 17 Nov 99, at 8:25, Corrado Santoro wrote:

> Hey men,

Careful.  I we have women members too!

> can you tell me something about the JOS packages ?
> I mean, is there any web page which describes each of the JOS packages listed
> by Gilbert in http://www.mindspring.com/~gchii/jos/library/packages.html ?

http://www.metamech.com/wiki/view/Main/Packages

is supposed to be the definitive place to reserve package names for 
the JOS project.  It's a bit ad hoc right now because its pure wiki 
(so chaos and errors can cause problems) but its your best bet 
(beyond the code itself).

> Excluding source server, is it possible to download the other packages ?

CVS.  This is the only place outside of Gilbert's technical 
distribution to get the source.  (See the CVS page in the wiki for 
instructions).  The source server is mostly offline due to some 
configuration problems.  In addition, no new code has been added 
to source server in a long time.  You can browse the cvs on the 
web using:

http://jos.org/cvsweb.cgi

> What's the meaning of "pizza status" ? Does it mean that to compile the package
> I need the pizza compiler ? But why I cannot use the "standard" javac ?

I believe some packages do require pizza.  It's up to the authors 
what tools they use.

> Really, I have tried to compile the source server package with javac, but I get
> a long list of errors. Some of them are syntax errors, thus they are not
> related to the type of compiler used. So, can you tell me something else about
> the status of the packages (e.g., written but not compiled, successfully
> compiled but not runned, successfully runned) ?

The source server itself is actually a perl program so javac should 
not work on it.  I'm probably misunderstanding you though

-iain




From hackcat@banzai.apana.org.au Thu, 18 Nov 1999 08:32:35 +1100
Date: Thu, 18 Nov 1999 08:32:35 +1100
From: Geoff O'Callaghan hackcat@banzai.apana.org.au
Subject: [JOS-Arch] TCP/IP stack ...


>Hi Ranieri --
>
>> PS: are we expected to have garbage collection for the tcp/ip stack?
>
>jjos/decaf already has functioning Java (and C++ for that matter) garbage
>collection in place - though it is admittedly not very sophisticated.
>Anything you write in Java for jjos/decaf gets this automatically.
>
>Is that what you meant, or were you referring to some tcp/ip specific
>meaning of the phrase I'm completely unaware of?
>


I imagine we're talking about plain old Java GC and the impact on real-time
systems.  ie. Not a good effect.  Some sort of concurrent GC which does not
stall threads during GC would be required.

Cheers
Geoff




From RegierAveryJ@JDCORP.deere.com Wed, 17 Nov 1999 15:31:37 -0600
Date: Wed, 17 Nov 1999 15:31:37 -0600
From: Regier Avery J RegierAveryJ@JDCORP.deere.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

> -----Original Message-----
> From:	Corrado Santoro [SMTP:Corrado.Santoro@iit.unict.it]
> Really, I have tried to compile the source server package with javac, but
> I get
> a long list of errors. Some of them are syntax errors, thus they are not
> related to the type of compiler used. So, can you tell me something else
> about
> the status of the packages (e.g., written but not compiled, successfully
> compiled but not runned, successfully runned) ?
> 
> Thank you for your answers,
> 	Byte.
Corrado,

There are a number of reasons for the compiler errors you have run accross:
*	Pizza
*	The SourceServer is rather buggy.  It has a nice little feature
which reformats code to follow our coding standards.  The problem is that
when this reformatting occurs, it sometimes gets confused.  In order to
compile the code you are going to have to manually change the code.  The
problems are all on if() statements. (As I remember it has trouble with
figuring out where to place missing brackets for one-line code blocks.)
Most of the problems are easy to figure out.  Once someone has this fixed,
they should send the code back to Gilbert so no one else has to go through
this process again.
*	Missing packages.  Some of the code relies on the collections
framework.   Some of the authors used the 1.1 package names, and some used
the 1.2 package names.  Further, the 1.2 authors used functions that are not
available in the 1.1 version.  Thank goodness $Classpath has their
collections classes up to 1.2 standards.


Avery J. Regier



>  



From tmiller@haverford.edu Wed, 17 Nov 1999 19:16:49 -0500 (EST)
Date: Wed, 17 Nov 1999 19:16:49 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] TCP/IP stack ...

> I imagine we're talking about plain old Java GC and the impact on real-time
> systems.  ie. Not a good effect.  Some sort of concurrent GC which does not
> stall threads during GC would be required.

	There are three possible solutions to this; the first is to turn
of GC while the real-time bits are running; the second is to implement
some portion of somebody's real-time java spec; the third is to write
'some sort of concurrent GC'.  I think the third is the best solution,
though it might be the hardest to implement.  I think that we can avoid
GC'ing a specific thread (i.e. the currently-running one) because its
root(s) are known...

-_Quinn




From digigod@earthling.net Thu, 18 Nov 1999 00:20:51 -0500 (EST)
Date: Thu, 18 Nov 1999 00:20:51 -0500 (EST)
From: digigod@earthling.net digigod@earthling.net
Subject: [JOS-Arch] Transitional JOS

> "A kernel does not an operating system make,"
> 
> I (Iain) said that.  It was intended to be said with a Yoda (Star 
> Wars) accent.  :)  

It makes more sense like that :)

> I agree that the focus seems to be very lopsided 
> on the kernel.  I see several JOSystem problems that working 
> groups IMHO should be attacking now.  They will be useful with or 
> without the rest of the JOS system and will help all java 
> installations.  And they can be developed on any jdk available now.
> 
> 1) a standardized install/uninstall api for java applications.  ala 
> Installshield on Win32 and sorta RPM on linux.  The installs should 
> actually target classfile -> logical_location mappings so each 
> platform can map the logical_location to appropriate filesystem, 
> classpath, registry, database or whatever mechanisms to store the 
> the classfile and enable loading of the class path.
> 
> 2) shared library manager.  Basically a way to avoid the DLL hell 
> that plagues Win32.  That is, a platform neutral way to load the 
> correct classes with the correct programs taking into account 
> versions of libraries, etc.  Such a system may require a rewrite of 
> the classloader.  Ideally, new versions of shared code will 
> _supplement_ and not replace older versions.  Applications will 
> attempt operation using the new version (to gain enhancements) 
> but failures will cause them to automatically revert to using the 
> older (known good) version.
> 
> 3) package manager/launcher - a method to specify and group 
> classfiles together logically without having to do so physically (jar 
> them) for managament and application launching.  This gives users 
> a view of packages as "single exe" looking entities.  This is cleaner 
> and what I image was intended with "executable jars" but allows us 
> to continue to share code (and eliminate redundant copies of 
> classes).

I think Gilbert's package files are an easier/faster way to do that, but I think doing both would probably the best solution overall
 
> > Give people what they want. Most people are curious about JOS. They want to
> > take it for a test drive. They don't care how fast it is. They just want to
> > see what it might be like, comparing it to the OS they already have.

We should have a big red sign saying: "THE REAL ONE IS FASTER!!!"; so they don't ignore it based upon performance.
 
> This I think is actually most dependent on the UI group actually 
> generating a desktop.  Watching printf debug messages crank gets 
> really tiring and is certainly not very impressive!  I think just 
> screenshots from a new UI would get more people more excited 
> about JOS than probably even a shipping kernel with no GUI 
> support.  And, the UI list has been ghostly silent recently.

I agree, but its silent because most of what we need is in JOSystem (stuff like launching applications and access to devices and drivers and the like).

Cheers,
DigiGod
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-
----------------------------------------------------------------
Get your free email from AltaVista at http://altavista.iname.com



From digigod@earthling.net Thu, 18 Nov 1999 01:08:46 -0500 (EST)
Date: Thu, 18 Nov 1999 01:08:46 -0500 (EST)
From: digigod@earthling.net digigod@earthling.net
Subject: [JOS-Arch] What is JOS?

In the more recent threads here I have noticed some confusion about the seperation of the elements of JOS, so I am going to attempt to clarify these here.

JOS is not like its predecessors, it is not one large monolithic clump-o'-OS. First we have JOSCore, this is the minimal OS consisting of a JOSBox and a minimal JOSystem and no more. Then we have "JOSExtensions" the devices, drivers and services it takes to be able to use JOS for more then the RAM equivalent of a paperweight. Running on top of this is the "Application Level" most notably JADE and its PUI (allowing the computer to interact with the user). This is all suspended in the lime Jell-O that is the Java and JOS API's (I think we should discriminate between JOS API's that require JOS and those that don't, I propose that the ones that do not require JOS be reffered to as the JOS Extra API's -- someone give that a better name...).

An Install/Uninstall library is an excellent idea, although it is not part of JOSystem it is a JOS Extra API (I hate to seem like Im picking on it. I'm not, it's just the first instance I thought of...). Furthermore, JOSystem is -- basically -- just a pure java kernel (it takes on the classic role of the kernel in most senses and buffers between everyone and the real kernel in the other cases) and an appplication runner.

The JOSBox is the computer were writing this OS for, in a sense. It is the virtual hardware the JOSystem "kernel" is running on, if someone made this into real hardware a modified JOSystem would run JOS on it directly. It is the true kernel and the JVM. A JOSBox application could be made sans kernel, this is how you could run JOS on a non-JOS machine; the JOSystem would require extra features the JOSBox supplies to run so just running it on "any old VM" would be painful, a special JOSBox would be the way to go. The main benifit of this I see is not in having a showcase for JOS but in having a multi-process java environment running on ones computer, allowing (with minor modification) to let the OS "launch" Java apps into this environment/quasiOS cutting down on memory and start time (people would get to tour JOS then get to keep a powerful tool like that). I think we should get a kernel/VM JOSBox up then modify it to be an "emulator" JOSBox later on, just my opinion though.

JVM incompatabilities might be solved with the exokernel design. Exokernel is basically a blank slate of a kernel that allows libraries to be plugged into it to provide optimal hardware use (and, of course, having a default library for legacy apps). Whats this have to do with JVM's!? Good question, say we have most of the stuff that makes a JVM and then have little libraries filling the rest in, in a release compatiable manner. That is, we have XVM (exo-VM) with a JDK 1.0 library, a 1.1 lib and a 1.2 lib. I don't know how well that would work, but its worth a thought.

Cheers,
DigiGod
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-
----------------------------------------------------------------
Get your free email from AltaVista at http://altavista.iname.com



From R.Argentini@student.tudelft.nl Thu, 18 Nov 1999 10:12:14 +0100
Date: Thu, 18 Nov 1999 10:12:14 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

>*	Missing packages.  Some of the code relies on the collections
>framework.   Some of the authors used the 1.1 package names, and some used
>the 1.2 package names.  Further, the 1.2 authors used functions that are not
>available in the 1.1 version.  Thank goodness $Classpath has their
>collections classes up to 1.2 standards.

This brings me to the next question: what's the reccomended java class.zip
version, compiler, jvm (for testing outside the kernel) etc?




From R.Argentini@student.tudelft.nl Thu, 18 Nov 1999 13:49:14 +0100
Date: Thu, 18 Nov 1999 13:49:14 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] NetworkingGroup Wiki Update

I have updated the NetoworkingGroup related pages to what i feel is the
current situation, and removed a couple of stale links.

I'm currently delving into sniffer back-end black magic, i'll report back
to y'all as soon as i have something semiworking :)

RanieriArgentini




From gchii@mindspring.com Thu, 18 Nov 1999 08:49:28 -0500
Date: Thu, 18 Nov 1999 08:49:28 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] multiple processor architecture

At 04:24 PM 11/16/99 -0500, "Todd L. Miller" <tmiller@haverford.edu> wrote:
>The jJOS kernel on which the decaf JVM runs is simple enough that a close
>approximation of it is already running on Linux -- sans h/w access.

If I already have my Linux OS running, it would be most helpful to see what
I have never seen before. As you might know, I have never seen jJOS/decaf
actually running on my JOS machine.

I must have missed something. Thank you for taking the time to explain
again what you have explained many times before. The idea that I might be
able to boot up jJOS/decaf on Linux very soon is very exciting for me.

Are you saying that I can run jJOS/decaf on top of my Linux OS?

Are you saying that I do not have to boot it from a floppy, using Etherboot
4.0 and setting up BOOTP/TFTP services?

Sure, I would like to boot jJOS/decaf from a floppy some day. Sure, I would
like to boot jJOS/decaf from my hard drive with GRUB (?) some day.
Meanwhile, I would love to run it. I would like to take it for a test drive.




From gchii@mindspring.com Thu, 18 Nov 1999 09:29:56 -0500
Date: Thu, 18 Nov 1999 09:29:56 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Distribution Group

At 08:04 AM 11/17/99 +0100, Corrado.Santoro@IIT.UNICT.IT wrote:
>Hi Gilbert,
>I would like to join to the JOS distribution group.

Thanks! I hoped you'd volunteer again. Your JOS 1d binary distribution has
been so helpful to me. It might be helpful to other members, too. If you
like, you should make a formal announcement of it and its URL here on this
mailing list.

>P.S.: What's up with your JOS boot ?

When I boot from a floppy, floppyload.bin loads ne.rom. In turn, ne.rom
correctly identifies the network card in my JOS machine. It prints out the
correct MAC address. But instead of JOS, I only see a twirling effect as
floppyload.bin (or ne.rom) slowly prints these four characters (\ | / -).
Since recompiling Etherboot for BOOTP, I do not get a <sleep> message.

As you said, Etherboot 4.0 is distributed with DHCP as the default, not
BOOTP. I removed the ..DHCP define from Config (a copy of Config.32) and
recompiled everything, including both floppyload.bin and ne.rom. I created
a new boot disk using this Linux command:

cat floppyload.bin ne.rom > /def/fd0

I have never seen a bootp entry in my server's message log. If I had to
guess again, I'd say that either (1) my boot disk doesn't broadcast a BOOTP
request, or (2) my BOOTP service does not respond. I have tried a long list
of configurations for BOOTP on my Linux server. Here is my most recent
/etc/bootptab:

.default:\
        :ht=ethernet:\
        :hd=/tftpboot:bf=null:\
        :hn:to=36000:
 
josmachine.com:tc=.default:ha=00400549AD8B:ip=4.65.6.122:bf=jjos-nbi

I have no firewall. I am working on an isolated, three computer network in
a computer lab.

I understand that Etherboot broadcasts a UDP packet to find a BOOTP service
on the network. Since Etherboot "knows" the MAC address of its network card
and the MAC address is embedded in the UDP packet, a BOOTP service should
look up the MAC address and find the machine name, IP address and boot
image. When it works properly, the BOOTP service sends a UDP package back
to my JOS machine and the JOS machine should then be able to download a
boot image from my TFTP service.

Personally, I do not know how to trace TCP or UDP packets. I have seen
other people use a "sniffer" on a laptop. The sniffer stores a copy of
selected packets as they pass through its network card.




From gchii@mindspring.com Thu, 18 Nov 1999 12:50:21 -0500
Date: Thu, 18 Nov 1999 12:50:21 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

At 08:25 AM 11/17/99 +0100, Corrado.Santoro@iit.unict.it wrote:
>can you tell me something about the JOS packages ?

You're right. You bring up an important issue. It is reasonable for someone
to expect to learn something about a JOS package *before* they download it.
Information about JOS packages is found on JOS Wiki, inside the source
code, inside documentation inside a distribution, inside a variety of
mailing lists, and on other Internet websites. Some packages have no synopsis.

My first goal is to identify each JOS package. Have I been able to find all
of them? I don't think so. It is important for members to know that a
package exists.

So far, package descriptions have happened naturally. The author puts a
description inside the package distribution, either in source code, a
README file or index.html file.

On one hand, we might insist the author of a package to provide a
description of it. When an author is developing a package, they are busy
getting the package to work correctly.

Anyone, who might like to volunteer, can look inside a package and write a
brief review for the benefit of the author and other members of the JOS
Project. Where we publish these reviews? It might be a good thing to
publish many descriptions on a single page in JOS Wiki. While there are too
many descriptions to fit all of them on one page, the package descriptions
could be organized by product. A package cross-reference, in alphabetical
order by package name, should explain which product a package "belongs to".

>I mean, is there any web page which describes each of the JOS packages listed
>by Gilbert in http://www.mindspring.com/~gchii/jos/library/packages.html ?
>Excluding source server, is it possible to download the other packages ?

Packages are found in a variety of places, and should be. The JOS 1d
Technical Distribution was an effort to provide one-stop-shopping for as
many packages as I could find. Since I collected all these packages into
one place, I figured I could save other members of the JOS Project the
hassle of collecting them one at a time.

The JOS 1d Technical Distribution is a snapshot of the JOS Project
packages. All of the files were downloaded within October 1999. It was not
an attempt to fix problems; it just shows you what's available.

>What's the meaning of "pizza status" ?

The Pizza compiler used to have an Internet website; but, it seems to have
gone "off the air". I have been unable to find the pizza packages. As
written, FreeBuilder for JOS depends on them as you use the javac tool.
Packages marked with the "pizza" status won't compile without them.

>Does it mean that to compile the package I need the pizza compiler ?

The Pizza compiler is used by FreeBuilder. It is not required to compile
FreeBuilder or any other JOS product.

>But why I cannot use the "standard" javac ?

Yes, you should use the standard javac or whatever IDE you prefer.

>Really, I have tried to compile the source server package with javac, but
>I get a long list of errors. Some of them are syntax errors, thus they are
>not related to the type of compiler used.

Let's think about this. It is going to take coordinated effort to get all
that code free from syntax errors, pre-compiled and pre-jar'd. Ever since
it has been unable to upload new code, it has been unable to upload fixes
to the syntax errors created by Source Server's pretty printer. When the
source server mangles some of the source code, it mangles it for everyone.
We should not ask individual members of the JOS Project to fix these errors.

I have updated my package cross-reference to show individual classes from
Source Server that I haven't been able to compile yet. Within each package
with a "tool" status, I have listed each source file that needs attention,
something like this:

  Out-Of-Date Classes:
  1. <class-name>.java

If you can send me (1) a corrected .java file and/or (2) a pre-compiled
.class file for any of these classe, I will redistributed them to members
of the JOS Project.

Here is my distribution proposal for immediate discussion. The distribution
group should mobilize quickly to create a syntax-error-free distribution of
source code from Source Server code. Not only should we fix the syntax
errors from Source Server and redistribute syntax-error-free source code,
we should also create a binary distribution of the Source Server product.

I propose that members of the JOS Project switch from Source Server to
"normal" distribution of archives (.tgz and .zip). In other words, take the
content of Source Server -- exactly as it is mangled -- and redistribute it
as jos1d-srcserv-#.zip.

We can skip distribution 1. Distribution 1 is not an archive-based
distribution. It is the distribution that came from Source Server rather
than an archive. I downloaded all files from Source Server around October
1st, 1999. I don't think anything could have changed since then.

Personally, I have already "fixed" 70+ syntax errors since October. Here is
what I should do: I should finish jos1d-srcserv.jar and
jos1d-srcserv-src.zip today. These archives contains my 70+ fixes and as
many classes as I could compile with my tools. I have neither
javax.infobus.* nor javax.swing.*, for example.

I have excluded java.* packages from the binary distribution of the Source
Server product. They won't work on an existing JVM. Are any other pieces
are missing (?).

Keep checking the JOSDistribution1d page for a new Source Server archive.
For those members of the JOS Project that have already downloaded source
code from Source Server, you should download jos1d-srcserv-2-src.zip and
validate its contents.

Otherwise, download jos1d-srcserv-2.zip for the .class files.

So far, JOS 1d Technical Distribution has not qualified what should or
should not be redistributed. It is something like garbage in, garbage out.
The JOS 1e Technical Distribution might be a little more focused and less
experimental.

>So, can you tell me something else about the status of the packages (e.g.,
>written but not compiled, successfully compiled but not runned, successfully
>runned) ?

The "unknown" status is meant to be "written, but not compiled".

The "compiled" status is meant to be "compiled, but not yet archived".

The "archived" status is meant to be "compiled and archived, but not yet
distributed".

The "distributed" status is meant to be "distributed", available across the
Internet for immediate download.

As far as running this stuff, you're on your own. Distribution gets it to
you. What you do with it after that is another issue.




From gchii@mindspring.com Thu, 18 Nov 1999 13:01:11 -0500
Date: Thu, 18 Nov 1999 13:01:11 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Breaking up Source Server

Source Server is a big collection of classes. I'm not sure how to do it;
but, I think the Source Server collection should be broken up into smaller
JOS products. As a half-dozen of smaller JOS products, this collection
might be easier to describe, distribute and (re)compile.

I think it should be divided according to package dependencies. For
example, classes that depend on com.sun.java.swing.* should not be in the
same product with classes that depend on javax.swing.*.

Since FreeBuilder for JOS is such a big product, it could fit in a
collection of its own. What do you think?

One of the difficulties in redistributing the classes from Source Server
has been its size. None of the tools that I use would make it. I created a
bulk compiler to get this far.

The binary/source distribution of Source Server does not contain Source
Server itself (or any other pretty printer). A technical distribution of
Source Server should contain the Source Server itself and might someday
contain a version that does not introduce syntax errors into the code.

As for my wishlist, I would like to have a Java servlet version of Source
Server, so JOS Source Server could look more like the Giant Java Tree website.




From tmiller@haverford.edu Thu, 18 Nov 1999 14:53:05 -0500 (EST)
Date: Thu, 18 Nov 1999 14:53:05 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] multiple processor architecture

	The 'host' build of jJOS does not provide all the h/w access
services that the 'i386' build does (it fakes them rather poorly), but
yes, decaf will run on top of it.  Just cd 'JJOS/arch/host/nativecode',
'make', and 'jjos init' will run run jJOS/decaf and execute 'init.class'
(in the zipfile).  Right now I don't think it'll do anything particularly
interesting, especially because we're using Sun's libraries until we can
integrate classpath's.

-_Quinn




From gchii@mindspring.com Thu, 18 Nov 1999 14:50:16 -0500
Date: Thu, 18 Nov 1999 14:50:16 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Transitional JOS

At 04:11 PM 11/16/99 -0600, iainshigeoka@yahoo.com wrote:
>Sounds interesting.

It has been interesting to see different browsers come together (finally)
after each was built on its own. Each browser is a plug-in. You can switch
from one browser to another -- while keeping the same URL. After using it
for a few days, the Ultimate Browser feels, well, very weird.

You know how sometimes you'll pull down the View menu in Netscape and
select Document Source. Or, you'll pull down the View menu in Internet
Explorer and select Source. Both of these browsers create a new window to
show you the same URL in a different viewer/browser. But why?

In the Ultimate Browser, you switch from HTML to Source by clicking a
button on the tool bar. You don't get a new window by accident. You get a
new window whenever you ask for it with File/New Window...

>1) a standardized install/uninstall api for java applications.  ala 
>Installshield on Win32 and sorta RPM on linux.  The installs should 
>actually target classfile -> logical_location mappings so each 
>platform can map the logical_location to appropriate filesystem, 
>classpath, registry, database or whatever mechanisms to store the 
>the classfile and enable loading of the class path.

With the help of a bytecode cache service running as a daemon on your
computer or network, you might skip most of the traditional
install/uninstall process. When you use a program, it is "installed" in
your bytecode cache. For packages that are "transient", bytecode is
automatically "uninstalled" when you haven't used it for a while. It is a
most-recently-used bytecode cache.

Sure, you can force the bytecode cache to remove a package. You can empty
the bytecode cache if you want. But it sits quietly moving the bytecode
around for highest possible optimization on small network or intranet.

Since a bytecode cache can be daisy chained to another, you can set up a
central bytecode cache for your department or company. The central bytecode
cache can "install" bytecode seemlessly through a gateway to the Internet.
Where is the installation step? For running pre-compiled, pre-archived
code, you can just skip all that.

What is a bytecode cache? There are plenty of options. You might install a
bytecode cache servlet in your Java-enabled HTTP server. Configure it for
cache size and trusted Internet websites and you're done. Everyone on the
network can use all your applications.

You might install package files on a static HTTP server. You might install
the bytecode cache daemon on a server and skip the HTTP thing. What does it
really mean to install an application. For everyone that just wants to take
it for a test drive, they just run it. Distributing the bytecode -- that is
what a network is for, isn't it?

>3) package manager/launcher - a method to specify and group 
>classfiles together logically without having to do so physically (jar 
>them) for managament and application launching.  This gives users 
>a view of packages as "single exe" looking entities.  This is cleaner 
>and what I image was intended with "executable jars" but allows us 
>to continue to share code (and eliminate redundant copies of 
>classes).

I'm pretty sure there are two separate issues here. I don't like to confuse
the issue of launching an application with the issues of packagine an
application's bytecode. We have been talking about the .app file. This is
something like a shortcut that starts any Java application.

It doesn't make sense to put each Java application into its own archive.
That idea is almost anti-reuse. I said "almost"! A jar is a container for
lots of executable code. The starting point for your application might be
any class and any method inside a jar. A multiple application jar is a
great way to deal with a product line with very similar tools.

The Smart API jar, for example, contains the ulitmate browser and all the
browser plug-ins. You can run a browser plug-in on its own. It doesn't make
sense to put multiple copies of class files in lots of different archives
just so that I can launch a jar.

Rather, the .app file "explains" an entry point to a browser/shell/desktop,
so that you can jam pack hundreds of applications in a single jar. Only the
.app files need to be one file per application.

Joining these two together, you can "install" .app files on a
browser/shell/desktop without the corresponding jar. By launching the .app
file with your browser/shell/desktop, the class files are read by your
bytecode cache. It means that you can copy very small .app files to each
workstation on a network and get the benefit of all applications on every
machine through the power of the network.

There is no sandbox. There are few restrictions. Your JVM can run any
bytecode you add to your application server.

1. You must install a JVM on each workstation. And it looks like JOS-NC
will be able to do all that.

2. You must install applications that use native methods on each
workstation. The bytecode cache distributes bytecode and other resources
(like .gifs) but does not do the share library thing.

>This I think is actually most dependent on the UI group actually 
>generating a desktop.  Watching printf debug messages crank gets 
>really tiring and is certainly not very impressive!  I think just 
>screenshots from a new UI would get more people more excited 
>about JOS than probably even a shipping kernel with no GUI 
>support.  And, the UI list has been ghostly silent recently.

Screenshots are good enough for some people. Some people want their
operating system to look good. That *is* how Microsoft sells so many copies
of Windows when it doesn't actually work. Sure, I'd like to get a glimps of
JOS and what it looks like. I would like to see something -- anything --
even printf debug messages!

We have got to think about getting more people excited about JOS. The
software industry needs JOS more than ever before, with the decline of
JavaOS and the promotion of Windows 2000. When Windows 2000 doesn't work,
and it won't, the mass market is going to want something that works:

1. Why do you install free-license software? If it is free, why not
distribute it seemlessly to everyone? When corporations figure out that all
of the time they spend installing and reinstalling software is a waste of
their time, they will find a way to cut costs.

2. Why do you keep track of software you haven't used in a while? Why
doesn't your operating system do it for you? Your HTML browser doesn't
bother you with the details of which HTML page it is going to keep and
which it is going to throw away, right? Since the original bytecode is
available elsewhere, why do you care?

3. Why do you upgrade your operating system at all? It has been possible
for over ten years to install a CORE, like JOSBox that never needs to be
upgraded. For example, when is the last time you had to upgrade your IBM PC
bios? It happens but it is rare compared to installing an OS.

Imagine how much money a corporation could save if it spent money on Linux
and JOS instead of Microsoft Windows. Not just cash, but time spent on
reinstallation and reinstallation and reinstallation.

Since an Ultimate JOS kernel needs only to implement a decent JVM, over 80%
of the "operating system" is dynamically linked. When your bytecode cache
serves up the "operating system" bytecode as well as the "application"
bytecode, upgrading your OS would be very rare indeed.

For the network computer, you can download a new JVM from a network server
as a boot image. Why would anyone go back to a 300MB "permanent"
installation of their operating system?

Imagine you have 250+ computers that need JOS. You would install JOS once
on a network server. You would plug in a JOS boot-rom in the other 249
computers. Your network server downloads patches to JOS directly from the
JOS Project website. Your network server downloads applications from JOS
and other websites. No explicit download/installation required after that.

Zero administration. Zero hassle. There is only a little bit of
configuration data that must live on your network. Windows 2000 will never
be able to do that. Why? Because it suffers an unmistakable disadvantage:
for-fee licensing. Because Microsoft is far more concerned about for-fee
licensing than building high quality software, you can always expect
Windows to be a stupid operating system.

By the way, this architecture works with mobile computing, too. Your
bytecode cache uses a dial up connection to periodically refresh its bytecode.




From iainshigeoka@yahoo.com Thu, 18 Nov 1999 14:01:42 -0600
Date: Thu, 18 Nov 1999 14:01:42 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

Hello,

This is an "official" webmaster alert.  Do not use Source Server to 
store source!  It is broken and I'm trying to get every one out of 
Source Server.  If packages exist in both CVS and Source Server, 
use the CVS sources.  CVS is the only working JOS repository for 
source right now.

For now, if you don't want to use CVS, then please, just make an 
archive file (.tgz, .zip, or .jar) available for download.

A new "loose" source repository similar to the old source server is 
on the long list of todo items for the new jos website.

On 18 Nov 99, at 12:50, Gilbert Carl Herschberger II wrote:

> Here is my distribution proposal for immediate discussion. The distribution
> group should mobilize quickly to create a syntax-error-free distribution of
> source code from Source Server code. Not only should we fix the syntax
> errors from Source Server and redistribute syntax-error-free source code,
> we should also create a binary distribution of the Source Server product.

Gilbert.  I snooped around in the source server area of the website. 
I can get you the raw (as submitted), non-pretty printed versions of 
all the source.  Should be as syntax error free as the original 
author submitted it.  Sorry for not being more on the ball about 
this.  If you're willing to package it up and make it available so that 
people have access to the source that may be only available 
through the source server, that would be wonderful.  I'm also 
tempted to use that as the opportunity to take source server so 
people don't try and add source or use source from it.

-iain



From tmiller@haverford.edu Thu, 18 Nov 1999 14:59:05 -0500 (EST)
Date: Thu, 18 Nov 1999 14:59:05 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Distribution Group

> When I boot from a floppy, floppyload.bin loads ne.rom. In turn, ne.rom
> correctly identifies the network card in my JOS machine. It prints out the
> correct MAC address. But instead of JOS, I only see a twirling effect as
> floppyload.bin (or ne.rom) slowly prints these four characters (\ | / -).
> Since recompiling Etherboot for BOOTP, I do not get a <sleep> message.

	Usually this means that it thinks it's doing something useful,
but I might be wrong.  Are you running BOOTP with its debug/logging flags
set?  If your JOS box prints something like server ip=, client ip=,
gateway ip=, then it's downloading jjos-nbi, which at 8 or 9 MB, is going
to take a while with TFTP.  If you're not running BOOTP standalone, is it
activated in inetd.conf?

-_Quinn




From gchii@mindspring.com Thu, 18 Nov 1999 15:37:08 -0500
Date: Thu, 18 Nov 1999 15:37:08 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] multiple processor architecture

At 08:02 PM 11/16/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
>Ah, like how Microsoft moved everyone from Win 3.1 to Win 95?  Win 3.1 (and
>all its previous incarnations) ran on DOS like a lamprey.
>Otherwise, different OS's may have taken root other than Windows.

Windows 3.1 was a necessary evil for Microsoft. Without Windows 3.1 running
on top of MS-DOS, there would be no demand for Windows 95, 98 or 2000
today. It would be something else. It might have been better. It might have
been worse. But, it would have definitely been different.

Microsoft had a brief moment of marketing savy with Windows 3.1 because
they told their corporate customers that Windows 3.1 was good and optional.
"You don't have to use it if you don't want to," they said. Imagine a time
when Microsoft was offering a "choice". But the "choice" wasn't real.
Microsoft strong-armed their customers into using Windows. How? They
stopped working on MS-DOS. They discontinued it. In spite of great demand
for MS-DOS and Linux, Microsoft insisted that your machine has to waste
over 80% of its processing power on Windows. People wanted 32-bit MS-DOS.
They were willing to install Windows 95 to get it.

That is the last time Microsoft did anything savy. They don't understand
why Windows 95 was a success follow up to Windows 3.1 and Windows 98 was
dead-on-arrival. They have been deaf to the demands of the marketplace.
That's why everyone is ready for a new OS. And it ain't Linux either.

>people knew DOS.

Don't underestimate the power of what people already know. See how Java
became successful because people knew C/C++. See how Linux became
successful because lots of people already knew UNIX. Lots of people --
frustrated with their old operating system -- wanted to take UNIX for a
test drive.

>They were familiar with DOS.

Don't underestimate the power of comfort. People don't like surprises. They
are familiar with low quality software. Some have only known low quality
software. They get complacent and comfortable with a familiar routine. Some
people have grown complacent with rebooting Microsoft Windows two or three
times a day. In fact, the Atlanta-Journal/Constitution published an article
last month that says, "You should expect your operating system to crash two
or three times a day. It's normal. Don't call for support."

But it's not normal. It is unacceptable. People don't have high
expectations of an operating system after using Microsoft Windows for a
while. They lost the will to fight.

>They didn't want to switch to a whole new operating system which had
>unknown support and features.

Just as the market resisted Windows 3.1, the market must resist JOS. People
don't like the unknown. There is no way to predict the future when the
facts are unknown. What is JOS exactly? Nobody knows. We know what it might
be. We know of its potential to be something great.

Switching to OS/2 was frightening because it was unknown and unknowable.
DR-DOS was promoted by Microsoft as a Very Bad Thing. Microsoft made it
more frightening. People trusted Microsoft to lead them to best practice.
Microsoft lead them astray.

>But Win 3.1 added features that DOS by itself didn't have.

People would rather fight than switch. They would rather stay with their
stupid operating system than upgrade to a new OS. What will it take? JOS
must have a compelling reason -- beyond the reasons for Linux -- in order
for people to take the first step.

Don't scare people with a cry of revolution. We must use evolution, not
revolution. While the added value of JOS must be compelling, it also must
be safe and non-threatening.

Why not Linux? Linux is great for some people. Linux is a leap away from
Windows. While Linux has great people working on it, it will always be too
much of a leap away from Windows. You can't get there from here.

Like Java-Linux, JOS has the potential to be some sort of middle ground. It
can be familiar to all those using Windows *and* everyone using Linux. JOS
might be the "right" answer to the needs of a mass market, especially a new
market of single console/multiple processors and serverfarm-in-a-box.

IBM is transforming its AS/400 into a perfect Java virtual machine. They
see what the next generation of software is going to look like. Like
always, IBM will wait until after the market "grows-up" before announcing
any products.

On the other hand, Microsoft is only familiar with for-fee licensing.
Microsoft employees are told that making copies of software is always
illegal and unethical. Microsoft is familiar with operating a monopoly.
Rather than switch to the new mass market reality, Microsoft is trying to
fight it. They have done irreparable harm to their own reputation.

If it weren't for the year 2000 thing, we might have planned ahead for
changes in the mass market. But alas, life after 2000 is unpredictable.




From whooops@gmx.de Thu, 18 Nov 1999 22:01:38 +0000
Date: Thu, 18 Nov 1999 22:01:38 +0000
From: Mark Andreas Meyer whooops@gmx.de
Subject: [JOS-Arch] Breaking up Source Server

Gilbert Carl Herschberger II wrote:
> Since FreeBuilder for JOS is such a big product, it could fit in a
> collection of its own. What do you think?

I'm not sure which version of FreeBuilder you mean and I'm not an FB official,
but FB is likely to undergo major changes -RSN- and thus the actual use of a
"FreeBuilder for Jos" is questionable.

Regards, Mark
-- 
"C combines all the power of assembly language with all the 
ease of use of assembly language"  - trad



From onewith1@flash.net Thu, 18 Nov 1999 20:20:02 -0600
Date: Thu, 18 Nov 1999 20:20:02 -0600
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Re: [JOS] What is JOS?

I've started a discussion on this under Wiki JOSArchitectureDiscussion, to
have a better visual area for discussion.  Of course, we can always further
the discussion here.

Like, what I do below :-)

<digigod@earthling.net> wrote:

> The JOSBox is the computer were writing this OS for, in a sense. It is the
virtual hardware the JOSystem "kernel" is running on, if someone made this
into real hardware a modified JOSystem would run JOS on it directly. It is
the true kernel and the JVM. A JOSBox application could be made sans kernel,
this is how you could run JOS on a non-JOS machine; the JOSystem would
require extra features the JOSBox supplies to run so just running it on "any
old VM" would be painful, a special JOSBox would be the way to go. The main
benifit of this I see is not in having a showcase for JOS but in having a
multi-process java environment running on ones computer, allowing (with
minor modification) to let the OS "launch" Java apps into this
environment/quasiOS cutting down on memory and start time (people would get
to tour JOS then get to keep a powerful tool like that). I think we should
get a kernel/VM JOSBox up then modify it to be an "emulator" JOSBox later
on, just my opinion though.

This quickly brings to my mind the question: so the APIs that are in charge
of letting Java code interact with "virtual hardware" in JOSBox or JOSystem,
or is this just a symantic argument?

The drivers and devices in JOSExtentions need to be able to be JOSBox
dependent, i.e. a Mac JOSBox will have different low-level drivers than a
TRS-80 JOSBox. However, hopefully we can make our drivers above this
low-level compatible across the system, such as File System and RAM Disk,
and hence put these drivers truly under the JOSExtentions category. So do
these box-dependent drivers actually belong in JOSBox, not the extentions?

I wouldn't like to think so.  Since the JOSBox is intended to be absolutely
minimal, my TRS-80 won't need low-level network drivers, but my Crey will.
Perhaps a JOSBoxExtentions package to cover this category?


>
> JVM incompatabilities might be solved with the exokernel design. Exokernel
is basically a blank slate of a kernel that allows libraries to be plugged
into it to provide optimal hardware use (and, of course, having a default
library for legacy apps). Whats this have to do with JVM's!? Good question,
say we have most of the stuff that makes a JVM and then have little
libraries filling the rest in, in a release compatiable manner. That is, we
have XVM (exo-VM) with a JDK 1.0 library, a 1.1 lib and a 1.2 lib. I don't
know how well that would work, but its worth a thought.

This may be pushing a moot point, but the way I read it was Exokernels put
the kernel into extention packages. This way, the HttpServer package can
optimize its networking pipeline, which may be different from the
MediaServer's networking pipeline.  It puts all the weight of the kernel
APIs into the dynamically loadable executable.  But perhaps this /is/ what
you are refering to...

>
> Cheers,
> DigiGod

-Matt




From gchii@mindspring.com Fri, 19 Nov 1999 07:22:58 -0500
Date: Fri, 19 Nov 1999 07:22:58 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

At 02:01 PM 11/18/99 -0600, iainshigeoka@yahoo.com wrote:
>Gilbert.  I snooped around in the source server area of the website. 
>I can get you the raw (as submitted), non-pretty printed versions of 
>all the source.  Should be as syntax error free as the original 
>author submitted it.  Sorry for not being more on the ball about 
>this.  If you're willing to package it up and make it available so that 
>people have access to the source that may be only available 
>through the source server, that would be wonderful.  I'm also 
>tempted to use that as the opportunity to take source server so 
>people don't try and add source or use source from it.

I have been thinking about working groups. All working groups need to work
together. I can see how maintaining the website has direct impact on Source
Server. Source Server has direct impact on distributing source code.

All classes are unique so far. We must work hard to keep it that way.
Maintaining a CVS server has direct imact on distributing source code, too.
From my inventory, there are no classes inside CVS that are also inside
Source Server.

I believe that all members of the JOS Project should have direct and
uninhibited access to the raw, as submitted, source code. What does this
mean? It means that the Right Thing to do is take the source code you found
and put it inside an archive (such as jos1c-srcserv-1.tgz and
jos1c-srcserv-1.zip). Put the archive on the JOS website at
http://www.jos.org/download/

IF you found source code that has already been archived, the archive itself
should be put inside the distribution. You should *not* re-archive the
source code.

"JOS 1a", "JOS 1b" and "JOS 1c" are older than "JOS 1d".

I use "you" loosely. I mean someone must make the original code available
to members of the JOS Project. By making it available to everyone --
equally -- I can download a copy, too.

Thanks,




From gchii@mindspring.com Fri, 19 Nov 1999 07:38:52 -0500
Date: Fri, 19 Nov 1999 07:38:52 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

At 02:01 PM 11/18/99 -0600, you wrote:
>...If packages exist in both CVS and Source Server, 
>use the CVS sources.  CVS is the only working JOS repository for 
>source right now.

You bring up an important issue. It would be a disaster to have source code
inside CVS and Source Server, especially if they were different. The
mechanism has not yet been established for synchronizing Source Server.

There is another way. I'm not sure we're ready for it yet.

Imagine that new code were uploaded to CVS. After code is uploaded to CVS,
someone downloads it; periodically, they take a snapshot. From the
snapshot, both a source and binary distribution can be created. Class files
do not have to be pre-compiled and uploaded to CVS. Anyone can download a
distribution with a HTML browser, without using CVS.

This person could run the source code through a syntax highlighter and
pretty printer to create static HTML files. Static HTML files reduce the
burden on our web server. The static HTML files are uploaded to our
Internet website for everyone to browse. All of the heaving processing is
off-line. Tools can be debugged and improved over a long period of time.

1. The HTML-formatted source code could not possibly ruin the source code,
like Source Server did.

2. Pages of HTML-formatted source code should be linked to their
corresponding distribution. When you pick on class, you download the
product that contains the package that contains the class. You don't
download one class at a time.

>For now, if you don't want to use CVS, then please, just make an 
>archive file (.tgz, .zip, or .jar) available for download.

Authors that do not know CVS can make their distribution available as an
archive. If product development is shared by many authors, a distribution
might be uploaded to CVS and maintained there.

>A new "loose" source repository similar to the old source server is 
>on the long list of todo items for the new jos website.

A static version of the Source Server is possible. It would be written in
Java, of course. After all of the bugs are removed, it could be easily
transformed into a Java servlet. As a servlet, you'd upload source code
archives to your web server instead of pre-processed HTML pages. It would
require a Java-enabled HTTP server.

As you might know, I have already developed a syntax highlighter for Java,
C/C++ and COBOL source code. They started out as simple batch HTML
generators, like JavaDoc. Behold the power of Java as these evolved into
Java servlets where the HTML is generated on-the-fly and never stored.




From gchii@mindspring.com Fri, 19 Nov 1999 12:17:37 -0500
Date: Fri, 19 Nov 1999 12:17:37 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Smart API Distribution Update

At long last, I have completed a runtime (binary), source and technical
distribution of Smart API. For more information, see also the
JOSDistribution1d page on JOS Wiki.

Smart API - Release 1a
This is historical, mostly.

Smart API - Release 1b
This is the first release that would do really cool stuff. Check out the
connection factory and stream plus package.

Smart API - Release 2a
This is the first release of the Smart API repackaged "correctly" for long
term stablility. Of course, release 2a does not replace 1a or 1b.
Interfaces are separated from implementation far more consistently than in
Release 1b. This is the first release that contains the Universal Browser
and many, many other applications. When I think about what it takes to run
all the applications inside this release, I can't imagine how to do it with
the java (or jre) tool.




From gchii@mindspring.com Fri, 19 Nov 1999 13:12:39 -0500
Date: Fri, 19 Nov 1999 13:12:39 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Platform API

Question: Is it possible that we are talking about two different device
driver environments?

There are these things, written in native code, that must plug deeply into
the JOSBox. Can't we call them "modules"? If I remember right, these are
called "modules" in Linux. You can plug Linux modules into the kernel, so
that you don't have to recompile the kernel each time your configuration
changes.

Ultimate JOS must have a "module" environment for kernel plug-ins. This
part of the definition of a JOSBox. For all those JOSBox plug-ins, the
executable code would be native to a processor. This is just like a shared
library (or dynamic link library) in a classic Java virtual machine. I know
we want to get away from shared libraries as much as possible; but, kernel
modules need to run in native code.

These aren't "device drivers" in the typical sense; and yet, they are used
to help device drivers use the hardware. I think "JOSBoxExtensions" would
be a bad name for these things.

On the other hand, "device drivers" are supposed to be written in pure
bytecode. Device drivers are plugged into the class loader and device
architecture. Many different device drivers should share modules written in
native code. While modules might be dependent on CPU and platform, device
drivers should not.

Let's look at dial-up networking as a device driver. It uses the serial
port. It presents an interface that makes it look like a network card. It
uses and is used by the TCP/IP stack.

It is possible to write dial-up networking in pure bytecode. In fact, you
could almost write dial-up networking using the javax.comm.* package. In
turn, the TCP/IP stack might use a network card. The physical network card
won't talk to pure bytecode without the help of an network "module" running
inside the JOSBox. A network module is not required for every machine; but,
if it exists it must plug into the "module" environment provided by the
JOSBox.

When a "module" environment is provided by the JOSBox, programmers can
write all kinds of modules to run on JOS, just like they write shared
libraries to run inside a JVM.

The interface between the JVM and the kernel should be simple. The JVM
should be able to "discover" any module that's plugged into the JOSBox. The
way the JVM sees the "module" environment of the JOSBox is entirely
different than the way a "module" sees the "module" environment. "Modules"
live inside the environment. The JVM uses the "module" environment.

In this scenario, C/C++ programmers and Java programmers must work
together. While C/C++ programmers should write ethernet access as a JOSBox
module, Java programmers could write a TCP/IP stack that uses ethernet
access. Of course, the bytecode that implements TCP/IP wouldn't work on a
JOSBox without the ethernet module running. While the C/C++ code must
change from one JOSBox to the next, the bytecode doesn't have to.

When we take this one step farther, a stable version of Ultimate JOS would
not implement "loadLibrary()" like any other JVM. For JOS and only JOS, the
"loadLibrary()" method would search for a pre-loaded module already running
inside the environment. Maybe it could dynamically load it if it doesn't
already exist. Maybe not.

It means that you could configure your JOSBox at boot-time for all of the
modules it is allowed to use. Like Linux, these modules are never
loaded/unloaded except at boot-time.

It means that you could have all shared librarys (or "modules") configured
to meet the needs of a specific machine. When the OS is configured, you
decide which shared libraries you want to use.

When all of the device drivers and all of the applications are written in
bytecode anyway, what difference does it make? Since Ultimate JOS won't be
compatible with shared libraries from Linux or dynamic link libraries from
Windows, JOS shared libraries must implement whatever interface we decide
when they run on Ultimate JOS.

These "modules" can be source-code compatible with shared libraries from
Linux and dynamic link libraries from Windows.




From gchii@mindspring.com Fri, 19 Nov 1999 13:31:33 -0500
Date: Fri, 19 Nov 1999 13:31:33 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Platform API

To follow up on the "module" environment, it is quite possible for any JVM
to be a "module" running in this environment. The Ultimate JOS should be
able to load all three Java platforms as JOSBox "modules".

One or more JVM "modules" is selected from all the JVM "modules" installed
on a machine during kernel/module configuration. I think at least one JVM
"module" is required. In turn, the JVM "modules" would be able to share THE
memory manager "module" that gives the kernel the ability to allocate and
free virtual memory. All JVM "modules" might also share a bytecode cache.

From the domain point of view, only one JVM can be the "primary" domain,
where all of the bytecode "device drivers" live. The primary domain asks
the kernel to create new instances of secondary domains for additional
users (in a multiple user OS) and additional "processes" (in a multiple
process OS).

If you have no reason to ever use the Java 0 Platform, you don't need the
Java 0 "module" installed in your JOSBox (or JOS machine). But for those
that do, they can install the Java 0 "module" in the JOSBox and enjoy Java
0 applications.

If you're not ready to use the Java 3 Platform, you don't need the Java 3
"module" installed in your JOSBox. But for those hearty souls that live on
the bleeding edge, they can install a Java 3 "module" and enjoy their Java
3 applications.

I believe this is where a lot of the simplicity of JOS architecture is
found. There are only a few "modules" necessary when most of the operating
system is written with bytecode.

How do we create "modules"? Anybody that can create a shared library for
Linux or dynamic link library for Windows can create a "module" for JOS.
The "module" is called by bytecode. The "module" itself contains no bytecode.

Inside a JVM, loadLibrary() would call create_module_instance(). The
bytecode would use an instance handle for a "module" running in the JOSBox.
Only the kernel would use load_module() to load and initialize a module.
Once the bytecode has a module instance, it would use it like it might use
a shared library. When we create a bytecode/native code interface that's
fast, you would see great improvements over the performance of Java 1 and 2.

It is natural. It would strongly encourage JOS programmers to write
bytecode for everything.




From jake66@iname.com Fri, 19 Nov 1999 15:29:06 -0500
Date: Fri, 19 Nov 1999 15:29:06 -0500
From: Jake Meier jake66@iname.com
Subject: [JOS-Arch] Clarity once and for all

	When originally joining this project I had the misconception 
that JOS would be more like Linux than Virtual PC.  Upon a few 
discussions via this mailing list it was clarified to me that this 
was indeed not the case.  The purpose of JOS (right now) is to 
develop an operating system that can run inside of an existing OS, 
ie, Mac or Win9x.  I would just like to clarify once and for all that 
this is the case.  That for the moment, we are all focusing on a 
product that can run on everyone's macheine without needing to be the 
only operating system running.  I do now see the advantages of this, 
but I would just like final clarity that this is the case.

-Jake



From RegierAveryJ@JDCORP.deere.com Fri, 19 Nov 1999 15:16:33 -0600
Date: Fri, 19 Nov 1999 15:16:33 -0600
From: Regier Avery J RegierAveryJ@JDCORP.deere.com
Subject: [JOS-Arch] Clarity once and for all

Jake,

As far as it is concerned for myself and several others in the project, this
is NOT the case.  Some believe this is a good thing.  It is still a matter
of debate.  If this were to happen, it would take some developers writing
code to make this happen.  As it is, no developers who are writing code are
writing it to make this happen.  As far as an 'official' position of the JOS
organization, there isn't one.  The only thing official in this organization
at this point is the Constitution and Policy Book.

Please note that I am not trying to start a flame war, but only clarify the
current status of this topic.

Regards,
Avery J. Regier



> -----Original Message-----
> From:	Jake Meier [SMTP:jake66@iname.com]
> Sent:	Friday, November 19, 1999 3:29 PM
> To:	arch@jos.org
> Subject:	[JOS-Arch] Clarity once and for all
> 
> 	When originally joining this project I had the misconception 
> that JOS would be more like Linux than Virtual PC.  Upon a few 
> discussions via this mailing list it was clarified to me that this 
> was indeed not the case.  The purpose of JOS (right now) is to 
> develop an operating system that can run inside of an existing OS, 
> ie, Mac or Win9x.  I would just like to clarify once and for all that 
> this is the case.  That for the moment, we are all focusing on a 
> product that can run on everyone's macheine without needing to be the 
> only operating system running.  I do now see the advantages of this, 
> but I would just like final clarity that this is the case.
> 
> -Jake
> 
> _______________________________________________
> Arch maillist  -  Arch@jos.org
> http://jos.org/mailman/listinfo/arch



From tmiller@haverford.edu Fri, 19 Nov 1999 16:36:17 -0500 (EST)
Date: Fri, 19 Nov 1999 16:36:17 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Clarity once and for all

> The purpose of JOS (right now) is to 
> develop an operating system that can run inside of an existing OS, 
> ie, Mac or Win9x.  I would just like to clarify once and for all that 
> this is the case.  That for the moment, we are all focusing on a 
> product that can run on everyone's macheine without needing to be the 
> only operating system running.  I do now see the advantages of this, 
> but I would just like final clarity that this is the case.

	The architecture mailing list seems to think this is the case, but
(AFAIK) nobody on the kernel mailing list agrees.  Where the twain shall
meet I haven't the slightest idea.  Gilbert referred to this as
parallel(izing) development.

-_Quinn




From tmiller@haverford.edu Fri, 19 Nov 1999 16:36:58 -0500 (EST)
Date: Fri, 19 Nov 1999 16:36:58 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Platform API

	Am I correct in understanding this to mean that JOS java drivers
will be against the JOSBox (that is, a generic interface to hardware), and
that the JOSBox will be implemented by kernel modules?

-_Quinn





From R.Argentini@student.tudelft.nl Fri, 19 Nov 1999 23:37:52 +0100
Date: Fri, 19 Nov 1999 23:37:52 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] [TCPIPStack] Almost-working prototype!!

Howdy all!

I have invested some of my spare time into producing a first prototype of a
network stack in java. I have tentatively called it JOS Experimental
Protocol Stack.

You can get it at http://villa28.cs.kpn.cx/jos or visit topic TCPIPStack on
Wiki.

The only thing it does so far is discriminate between IP, ARP and other
packets and passes them to their respective (empty) handlers.
The interface with the NICs is fixed up with a couple of native methods in
the class EtherHostDriver.

Please give me feedback on this guys!




From gchii@mindspring.com Fri, 19 Nov 1999 19:17:33 -0500
Date: Fri, 19 Nov 1999 19:17:33 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Clarity once and for all

At 03:29 PM 11/19/99 -0500, Jake Meier <jake66@iname.com> wrote:
>	When originally joining this project I had the misconception 
>that JOS would be more like Linux than Virtual PC.  Upon a few 
>discussions via this mailing list it was clarified to me that this 
>was indeed not the case.  The purpose of JOS (right now) is to 
>develop an operating system that can run inside of an existing OS, 
>ie, Mac or Win9x.  I would just like to clarify once and for all that 
>this is the case.  That for the moment, we are all focusing on a 
>product that can run on everyone's macheine without needing to be the 
>only operating system running.  I do now see the advantages of this, 
>but I would just like final clarity that this is the case.

Clarity is important and difficult. Clarity is important so that everybody
knows full well what it is we are working on. Clarity is difficult because
so many people are using a traditional operating system as their point of
reference.

Sure, JOS is like Linux. Like Linux is a stable operating system, written
in a little assembler and C/C++ and does not have any dependency on another
operating system. JOS is more like Linux than a Java runtime environment.

Look at the difference between Linux and a Java runtime environment. A Java
runtime environment depends on another operating system, somewhere in the
mix to provide the kernel and device drivers, security, processes,
services, TCP/PI stack, and more. JOS is less like a Java runtime
environment, and more like a full operating system. This is JOS, the
Java-based operating system.

But JOS is not Linux (is it?). JOS does not serve up the Linux platform API
(does it?). JOS does not use the Linux mechanism for shared libraries (does
it?). If your thinking about JOS as if it is just another operating system
-- forget it. You must stop and think about the assumptions you have picked
up through your experience with all these other operating systems.

JOS is a pioneer of the next generation of operating systems. There is
nothing like it on the IBM PC. It has never been done before (well, not
exactly).

Architecture-wise, JOS is actually more like OS/400. OS/400 has a
well-defined "machine interface" just as JOS has a JOSBox. Through this
abstraction, a very large portion (over 80%) of OS/400 is identical for
every AS/400 processor. The AS/400 is a series of minicomputer/mainframe
computers from IBM. The small AS/400 runs on a microprossor. It's
instruction set is incompatible with its older bigger brothers.

But with the help of a well-defined machine interface, IBM has been able to
run one implementation of OS/400 on many different kinds of machines. Part
of this was by design; part was out of sheer desparation. Imagine having
30+ operating systems to maintain, one for each machine. That's what IBM
was doing before creating this machine interface, an abstract machine.

The kernel group is working on a JOS kernel and a JVM that runs on the JOS
kernel. The kernel group is using Sun Microsystems' implementation of the
Java class libraries (aren't they?). They are compiling the JOS kernel
using Linux. JOS cannot be compiled on JOS. They are developing a JVM on
Linux and testing it on JOS.

But, just as the decaf JVM runs on Linux, any JVM can be turned into a
classic JVM in the style and precedent set by Sun Microsystems and their
JDK. The JVM is separate and distinct from its kernel. Like the machine
interface of OS/400, the JVM can run on many different kernels. While some
like this idea, other members of the JOS project see how it would cripple
the performance of the platform. And yet, the decaf JVM needs to run on
Linux so that we have some hope of debugging it within our lifetime.

If we have another operating system available to us, why not use it? It can
only help us refine JOS more quickly. For more information on using a
"foreign" operating system to develop a new one, see also "Soul of a New
Machine" by Tracy Kidder.

The JOS Project works on many different things at the same time. The
discussion on the architecture group is discussion about what is possible.
Meanwhile, the kernel group is actual building a kernel and JVM.

It is our working assumption that the classpath project will provide a
clone of the Java class libraries (isn't it?). These will plug into the
decaf JVM without too much trouble (won't they?).

It is also our assumption that an operating system is more than a kernel
and JVM. There are a lot of subsystems and services that must be built in
order for JOS to do work. It is our assumption (isn't it) that most of
these will be built from bytecode, compiled by an unmodified javac tool.
Here are a few subsystems and services that come to mind.

 - device subsystem
 - file subsystem
 - security subsystem
 - window manager
 - syslogd
 - tftpd
 - bootpd
 - telnetd
 - ftpd
 - httpd
 - inetd

In order to debug and demonstrate, develop and test the bytecode that goes
into these systems, JOS is more like a Virtual OS. Parallel development
means that we can build bytecode now. We do not have to wait for the kernel
or JVM to be completely finished and perfected.

You can download a javac tool. You can purchase a javac tool. And javac
tool will do; you do not have to wait for the JOS javac tool to compile
bytecode for the JOS project.

Like you, I am struggling to understand what the JOS Project is going to do
with such a historically significant idea. Odds are against us. We're the
underdog. Many people think that Microsoft is going to figure out the next
generation operating system and JOS will be a moot point. I don't think so.
I have invested a lot of time and energy in JOS because it has great
potential, both now and into the future.

This is my first and only open-source project. This is my first Internet
mailing list. I don't have any say-so in how the jJOS kernel or decaf JVM
will be distributed. That's not what I'm working on.

If you want to know how the two project shall meet, here is a pretty good
estimate. The jJOS kernel and decaf is capable of running the init.class
(isn't it?). Imagine that we had a release that implemented the Java 2
Platform perfectly. Every opcode has been tested and it works. Every
mechanism, including Java Native Interface, has been finished. What then?

The init.class isn't much to look at. The init.class, once in bytecode, is
going to need to go somewhere useful. It needs to start the JADE
application; but JADE isn't finished yet. It needs to start a syslogd
service; but syslogd hasn't been written yet. It needs to start telnetd;
but that's not finished.

I might not want to play pong on my JOS machine. I want to start a telnet
program on my JOS machine and watch as it connects to my Linux server. That
would be something useful. In turn, I want to start telnet on my Linux
server and watch as it connects to my JOS machine. That would be a
milestone we could all celebrate (wouldn't it?). 

I would like to help the JOS project succeed. We need volunteers to make it
happen. I sincerely regret scaring volunteers away from the JOS project. We
can use all of the help we can get.




From gchii@mindspring.com Fri, 19 Nov 1999 19:20:02 -0500
Date: Fri, 19 Nov 1999 19:20:02 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Clarity once and for all

At 03:16 PM 11/19/99 -0600, Regier Avery J <RegierAveryJ@JDCORP.deere.com>
wrote:
>As far as it is concerned for myself and several others in the project, this
>is NOT the case.  Some believe this is a good thing.  It is still a matter
>of debate.

I agree with Regier.




From R.Argentini@student.tudelft.nl Sat, 20 Nov 1999 01:32:13 +0100
Date: Sat, 20 Nov 1999 01:32:13 +0100
From: Ranieri Argentini R.Argentini@student.tudelft.nl
Subject: [JOS-Arch] [TCPIPStack] Almost-working prototype!! -- Try
 this.

>You can get it at http://villa28.cs.kpn.cx/jos or visit topic TCPIPStack on
>Wiki.

If you had troubles getting that, try http://villa28.cs.kpn.cx/jos/
I found that the last slash can make a difference over here.




From gchii@mindspring.com Fri, 19 Nov 1999 19:49:25 -0500
Date: Fri, 19 Nov 1999 19:49:25 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] What is JOS?

At 01:08 AM 11/18/99 -0500, digigod@earthling.net wrote:
>JOS is not like its predecessors, it is not one large monolithic clump-o'-OS.

JOS architecture is not like MVS, TSO, CP/M, UNIX, Linux, MS-DOS, OS/2,
OS/400, Windows, Netware, Mac OS, and the others. What other operating
system architecture can scale from an electronic gadget to a supercomputer
cluster? Only OS/400 comes close to a JOSBox, with its machine interface.
It should be no surprise that Java is a natural on OS/400.

>First we have JOSCore, this is the minimal OS consisting of a JOSBox and a
>minimal JOSystem and no more.

Please help! I was under the mistaken impression from JOS Wiki pages that
JOSystem is a marriage or JOSBox and JOSCore. I went back to review JOS
Wiki pages today to see where this comes from.

 - On one page, there's a paragraph about how JOSCore is pure bytecode and
you can find it inside the org.jos.core.* packages. JOSCore is not
org.jos.core.*, is it?

 - On another, there's a paragraph that says you only get JOSystem when you
put JOSBox and JOSCore together. If you get JOSystem when you add JOSBox
and JOSCore together, you can't get JOSCore when you add JOSBox and
JOSystem together.

IF
  JOSCore' = JOSBox + JOSystem
  JOSystem' = JOSBox + JOSCore
THEN
  JOSCore != JOSCore'
  JOSystem != JOSystem'

This week, you've said you get JOSCore when you put JOSBox and JOSystem
together. I think you're right. If I knew what you meant, I could update
articles on JOS Wiki so that they are accurate.

Could you explain it again? I am often frustrated by the fact that I can't
see JOSCore. I don't have a copy of it to look at. If I knew what it was, I
could propably help build it. You probably get tired of the
misinterpretations of these three critical pieces of JOS, too.

Are you saying that JOSCore is a "minimum" install of JOS? I can choose to
install either a "minium" or "typical" or "maximum" or "custom" copy of
Linux. If so, that would mean that JOSCore is orthogonal to the platform
API. JOSCore isn't a "layer" in the platform API at all.




From gchii@mindspring.com Fri, 19 Nov 1999 19:56:40 -0500
Date: Fri, 19 Nov 1999 19:56:40 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] What is JOS?

At 01:08 AM 11/18/99 -0500, digigod@earthling.net wrote:
>Then we have "JOSExtensions" the devices, drivers and services it takes to be
>able to use JOS for more then the RAM equivalent of a paperweight.

Do you see JOSExtensions as native code, bytecode, or a combination of both?

Somewhere in the mix, we must allow for native code to be dynamically
linked with the kernel. What is the interface between kernel and these
shared libraries?

JOS isn't Linux. Since JOS doesn't implement the Linux platform API, what
API does it implement?

Since Linux is required to compile, develop and test JOS, JOS might adopt
its shared library loader and executable file format. JOS might also adopt
its calling convention.

With these assumptions, I should be able to write a shared library that
plugs into the JOS kernel or JVM -- using Linux tools like gcc. But Linux
calls won't work on JOS (will it?). I can't use the standard library for
Linux IPC or Linux file subsystem (can I?).




From tmiller@haverford.edu Fri, 19 Nov 1999 20:25:17 -0500 (EST)
Date: Fri, 19 Nov 1999 20:25:17 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Clarity once and for all

> The kernel group is working on a JOS kernel and a JVM that runs on the JOS
> kernel. The kernel group is using Sun Microsystems' implementation of the
> Java class libraries (aren't they?).

	Until we can write enough native code to get classpath working,
yes.  (ugh!)
 
> And yet, the decaf JVM needs to run on
> Linux so that we have some hope of debugging it within our lifetime.

	hear, hear!

> It is our working assumption that the classpath project will provide a
> clone of the Java class libraries (isn't it?). These will plug into the
> decaf JVM without too much trouble (won't they?).

	Yes.  The main reason to use classpath is, in fact, because we
have the source code and can port its native libraries with relative ease.

> In order to debug and demonstrate, develop and test the bytecode that goes
> into these systems, JOS is more like a Virtual OS. Parallel development
> means that we can build bytecode now. We do not have to wait for the kernel
> or JVM to be completely finished and perfected.

> You can download a javac tool. You can purchase a javac tool. And javac
> tool will do; you do not have to wait for the JOS javac tool to compile
> bytecode for the JOS project.

	I would actually strongly recommend that we (the JOS project) not
spend any time working on our own javac so long as free one exists, much
like we're hoping to save ourselves trouble by using classpath...

> This is my first and only open-source project. This is my first Internet
> mailing list. I don't have any say-so in how the jJOS kernel or decaf JVM
> will be distributed. That's not what I'm working on.

	If you (Jake) want to talk about that, bother us over on
kernel@jos.org.

> If you want to know how the two project shall meet, here is a pretty good
> estimate. The jJOS kernel and decaf is capable of running the init.class
> (isn't it?).

	Depends on what's in it.  (Sorry, bad pun :))  Various versions of
init crank out console or keyboard drivers or VGA drivers.

> I might not want to play pong on my JOS machine. I want to start a telnet
> program on my JOS machine and watch as it connects to my Linux server. That
> would be something useful. In turn, I want to start telnet on my Linux
> server and watch as it connects to my JOS machine. That would be a
> milestone we could all celebrate (wouldn't it?). 

	Say, that's a neat target to works towards.  I'll look into that.
(i.e. what do we in kernel land need to be doing to make this work?)

-_Quinn




From tmiller@haverford.edu Fri, 19 Nov 1999 20:27:56 -0500 (EST)
Date: Fri, 19 Nov 1999 20:27:56 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] What is JOS?

> Since Linux is required to compile, develop and test JOS, JOS might adopt
> its shared library loader and executable file format. JOS might also adopt
> its calling convention.

	I would expect that we'd adopt someone else's calling convention,
and Linux is certainly the obvious choice...

> With these assumptions, I should be able to write a shared library that
> plugs into the JOS kernel or JVM -- using Linux tools like gcc. But Linux
> calls won't work on JOS (will it?). I can't use the standard library for
> Linux IPC or Linux file subsystem (can I?).

	Linux kernel calls won't work on JOS unless you write them into
the kernel, or into a kernel module loaded before yours.  The standard
library is almost certainly NOT going to be ported, because it's huge and
we're hoping to need little enough native code not to make it worthwhile.

-_Quinn




From onewith1@flash.net Fri, 19 Nov 1999 21:52:22 -0600
Date: Fri, 19 Nov 1999 21:52:22 -0600
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Platform API

[A brief intro to my message: since there has been considerable interest in
borrowing some ideas in JavaOS for Business (referenced simply as JavaOS),
I'll mention them as "fact", even though they are nothing more than a
starting point to begin discussion, and my memory isn't too exact on its
specifics.]

Gilbert Carl Herschberger II <gchii@mindspring.com> wrote:
> Question: Is it possible that we are talking about two different device
> driver environments?

Most definitely.  JavaOS specifies in its device driver spec that there are
3 kinds of interrupts, directly related to their priority in processing.
Type 1 consists of native code, for time-critical interrupt handling.  Type
2 is a combination of native and Java code (I believe), while Type 3 is all
Java.

This doesn't answer your question specifically, but it does show that there
is/can be a need for native support.

> There are these things, written in native code, that must plug deeply into
> the JOSBox. Can't we call them "modules"? If I remember right, these are
> called "modules" in Linux. You can plug Linux modules into the kernel, so
> that you don't have to recompile the kernel each time your configuration
> changes.

If we have a need for native code support under Java interpretation in JOS,
then, yes, we'll need something like modules.

But, I'm saying this with incredible hesitation.  The point behind JOS was
to minimize the native code, and this shows me that we're opening a gateway
to letting Monopoly Company A produce an API which requires a native module,
which, of course, they made to only work on Hardware B.

Modules would give us more modularity (hence the name "module", I suppose).
We wouldn't need to worry as much about a micro- or pico- kernel bloating to
the size of Montana.

Whatever we call these "kernel plug-ins", the idea is the same.  Break up
the kernel into small, optional pieces.

> Ultimate JOS must have a "module" environment for kernel plug-ins.

"Must" is a tad too strong for my taste.  But that's pushing the point.

> This [is]
> part of the definition of a JOSBox. For all those JOSBox plug-ins, the
> executable code would be native to a processor. This is just like a shared
> library (or dynamic link library) in a classic Java virtual machine. I
know
> we want to get away from shared libraries as much as possible; but, kernel
> modules need to run in native code.

> These aren't "device drivers" in the typical sense; and yet, they are used
> to help device drivers use the hardware. I think "JOSBoxExtensions" would
> be a bad name for these things.

So all we're doing is refining the definition of JOSBox.  Since in your
other posting you state that the JVM(s) are themselves modules, then JOSBox
would be "the pico-kernel in charge of getting modules loaded and talking to
each other."  Modules might have an "entry point" in which they begin some
execution upon being loaded, and could exit to let the pico-kernel
(exo-kernel, micro-kernel, what have you) get the next module loaded.  Heck,
the pico-kernel could even have some hooks itself for knowing how to load
modules, and handle basic memory management (maybe).  But I'm getting ahead
of myself.

But according to the premise behind JOSBox and JOSystem (which, at last
count, is being called "JOSCore"), these must be as minimal as possible.
Anything else is filed under "JOSExtention" (which is where Device Drivers
were filed under, as well).

So the modules themselves cannot be in JOSBox.  That means that the JVM is
an extention!

To me, this sounds like we're writing a JVM on top of MS-DOS 5.0.  But is
that a bad thing?  Not if we keep to the sound prinicples of reducing as
much native code as possible.

> On the other hand, "device drivers" are supposed to be written in pure
> bytecode. Device drivers are plugged into the class loader and device
> architecture. Many different device drivers should share modules written
in
> native code. While modules might be dependent on CPU and platform, device
> drivers should not.

I absolutely agree on this point.  We may face some trouble in knowing which
device drivers to load based on the modules, but I'm positive we can devise
a simple way to handle this.

> When a "module" environment is provided by the JOSBox, programmers can
> write all kinds of modules to run on JOS, just like they write shared
> libraries to run inside a JVM.

Which reduces the amount of 100% pure java code running on JOS.

> When we take this one step farther, a stable version of Ultimate JOS would
> not implement "loadLibrary()" like any other JVM. For JOS and only JOS,
the
> "loadLibrary()" method would search for a pre-loaded module already
running
> inside the environment. Maybe it could dynamically load it if it doesn't
> already exist. Maybe not.
>
> It means that you could configure your JOSBox at boot-time for all of the
> modules it is allowed to use. Like Linux, these modules are never
> loaded/unloaded except at boot-time.

This sends of warning bells in my head.  One of my lifetime goals is to
create an OS where you don't have to reboot the machine 932 times just to
get your NIC running correctly (my last count was 54 times on Win 98, spread
over 2 machines).  I would love to have libraries which can be dynamically
loaded and unloaded, and even restarted on the fly.  This, I imagine, may
entail a crate of overhead, but may be well worth the effort.

Of course, we could have a module in charge of handling the dynamic loading
of other modules.  That way, after finding a stable configuration for your
machine, you can stop loading that module to reduce its overhead.  But we
need to keep our eyes open, and our minds blown at all times.

> It means that you could have all shared librarys (or "modules") configured
> to meet the needs of a specific machine. When the OS is configured, you
> decide which shared libraries you want to use.

And when you push "Shift" during the boot phase, to select which
configuration of modules you want.

> When all of the device drivers and all of the applications are written in
> bytecode anyway, what difference does it make?

Plenty.  We don't want another Windows, where you need module DirectJ 12.5
to run your favorite Java games, and you need to reboot after downloading
the 16 MB patch for the "World-o" commerce symbol (just puffing out my own
frustration in an indirect way...).

Bytecode is (in my dimented view, anyway), the golden brick road.  It leads
us to the Wizard, but has a bunch of native-library monkies flying around,
keeping us from the emerald city.

Ok, I've been arguing and agreeing on many points, without really saying
much.  The 5 cent version is that Modules can be a good path to take.  But
they don't belong directly in the category of "JOSBox,"  nor are they
directly "JOSExtentions."  They are "JOSNativeModules" (using the word
"Native" to stress that it's not bytecode).  Which brings us to a JOS
version of JNI, which requires Java code to interact with it, which can lead
to unstability (can't it?).


Pax Amorque
-Matt




From gchii@mindspring.com Sat, 20 Nov 1999 09:34:32 -0500
Date: Sat, 20 Nov 1999 09:34:32 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Platform API

At 09:52 PM 11/19/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
> Which brings us to a JOS version of JNI, which requires Java code to
> interact with it, which can lead to unstability (can't it?).

This is a very good topic for discussion. It is a critical component of the
JOS Platform API. I am looking forward to using JNI for JOS. I think we can
implement the JNI completely. That includes the mechanism for managing more
than one JVM.

What is JNI?

Java Native Interface (JNI) defines two mechanisms. The first mechanism is
an API to enable any native program to create one or more "Java Virtual
Machines" at runtime. The second mechanism is an API to enable a "Java
Virtual Machine" to load shared libraries and call native methods from them.

In fact, the JNI already defines a mechanism for a "multiple process" Java
Virtual Machine. A native process is able to create one virtual machine for
each independent process. Even while the mechanism is defined, so far it is
useless. It does not actually work on Sun's Solaris or Microsoft Windows.
Does it work on Linux? I don't think so. Is it efficient? Not at all.

Do we have a choice?

According to Sun Microsystems, anyone who writes a "Java Virtual Machine"
has no option, no choice, no flexibility here. Sun insists that a "Java
Virtual Machine" must implement the Java Native Interface. Sun has provided
THE jni.h header file for all your C/C++ code.

Microsoft tried to ship a "Java Virtual Machine" without the Java Native
Interface and Sun took them to court. Sun prevailed. Microsoft lost.
Legally, "Java" isn't "Java" without the Java Native Interface.

Isn't that a double standard?

But wait! There's more. Sun doesn't implement the whole JNI themselves. Sun
Microsystems continues to distribute a "Java Virtual Machine" that does not
comply with the Java Native Interface. Sun doesn't follow Sun's rules. They
don't have to. Of course they won't take themselves to court. Only Sun can
get away with shipping a JVM without JNI. What's in a name? If you call it
a "Java Virtual Machine", it must implement the JNI unless you work at Sun
Microsystems.

There are problems with the JNI that have a negative impact on performance.
For more information on performance, compare the performance of native
methods in Java 0 vs. Java 1. Java 0 (without the JNI) is much faster than
Java 1.

JNI has failed miserably. It was supposed to be a stable API for everyone
implementing a JVM. The JNI for the Java 1 Platform is incompatible with
the JNI for Java 2.

My proposal for a native interface is this: dynamic binding of a native
class structure for both fields and methods. Each class is bound when a
shared library is loaded, not with each call to a native method.

For a given Java class,

public class org.jos.demo.NativeExample {
  public static native void staticMethod();
  public static int staticField;
  public native void instanceMethod();
  public int instanceField;

  public void reset();
}

a javah -jos command might produce the following structure:

typedef struct {

  // public static native void staticMethod();
  void (*staticMethod)( ENV *, jClass * );

  // public static int staticField;
  jint (*staticField_reader)( ENV *, jClass * );
  void (*staticField_writer)( ENV *, jClass *, jint );

  // public native void instanceMethod();
  void (*instanceMethod)( ENV *, jObject * );

  // public int instanceField;
  jint (*instanceField_reader)( ENV *, jObject * );
  void (*instanceField_writer)( ENV *, jObject *, jint );

  // public void reset();
  void (*reset)( ENV *, jObject * );

} NATIVE_org_jos_demo_NativeExample;

When a shared library is loaded, the pointers to these methods are bound to
the entry points of the subroutine inside the shared library.

Inside the implemenation of a native method, you can use these methods like
this:

void example( ENV * env, jClass *c ) {
  NATIVE_org_jos_demo_NativeExample *s;

  jint x;

  s = c->getVTable();

  x = s->staticField_reader( env, c );

  if ( x > 100 ) {
    s->reset( env, c );
  }
  else {
    s->staticField_writer( env, c, x + 1 );
  }
}

The Java environment is passed (as a hidden argument) to a native method
because a native method might be called from more than one thread or more
than one virtual machine. The Java environment enables a native method to
stay with its own thread.

Unlike the JNI, you do not search for one method at a time. Instead you get
the whole method index for a class with a single call (c->getVTable()). It
maps nicely to the corresponding NATIVE_.. structure.

A V-table is an array of pointers to subroutines. The array is populated
the moment the shared library is loaded. It anticipates that all native
methods will be used, and will be used repeatedly. Each class "has-a" V-table.

It is important to turn Java fields into subroutines. Fields cannot be
exposed through a V-table without a pair of corresponding subroutines. The
default implmentation of the reader is provided automatically by the JVM.
You can override its implementation by writing and linking in your own.




From gchii@mindspring.com Sat, 20 Nov 1999 10:08:11 -0500
Date: Sat, 20 Nov 1999 10:08:11 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Platform API

At 09:52 PM 11/19/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
>This doesn't answer your question specifically, but it does show that there
>is/can be a need for native support.

Even if we need native support for one subroutine, we need a complete
design for native support. I know, I know. I don't like the idea of opening
up JOS to hundreds of customized native libraries. Some people might get
confused and build software with native code rather than using bytecode
like they are supposed to. All open source projects are annoyed by people
who do not know what they are doing.

Is the JOS Project an exclusive group? With a platform free of customized
native libraries, only members of the JOS Project could write native code.

There is a lot of work to do. We need help from everyone willing to help
us. From a project estimate viewpoint, the JOS Project would be delayed if
we look for an architecture completely free of customized native libraries.
Let's imagine that there is no native platform API. The only choice for
customization would be to build Java class libraries. Even if native code
works and is perfectly stable, it cannot run on a platform free from
customized native libraries.

On the other hand, maybe everything should be decided at compile time. If
you want native code in your JOS kernel, you write code using the Linux
compiler and recompile your kernel. While your product works for you, you
can't distribute it to other members of the JOS Project. It won't work on
their kernel.

JOS Kernel Modules are a good idea from a future oriented operating system.
What happens when you want to switch from the Java 2 platform to Java 3?
When a JVM is a JOS Kernel Module, you can plug-in the Java 3 JVM.

JOS Kernel Modules are a good idea from the viewpoint of domains. What
happens when you want a secondary domain for a guest user of your JOS
machine? What happens when I telnet from my Linux server to my JOS machine?
The JOS kernel can load a new JVM module. It is a new domain. It has its
own class path.

JOS Kernel Modules are a good idea from the viewpoint of multiple process
operating system. What happens when you want to run TCP/IP services in a
secondary domain? The JOS kernel can load a new JVM module using the JNI.

JOS Kernel Modules are a good idea from the viewpoint of debugging and
developing the next version of JOS. While using a stable JVM as your
primary domain, you can recompile and reload your test JVM as a kernel
module. Of course, it has a different class path.

We have to stretch our imagination to look forward to the day that JOS is
developed on JOS. It must have an Intel assembler. It must have a C/C++
compiler. It must have a javac tool, even if we have to "borrow" it from
another open source project. The architecture of JOS for today must not
eliminate the potential of JOS to be completely stand alone from all other
operating systems.

When we start with simple native support for one subroutine, we can develop
a mechanism that supports any native subroutine. We don't have to make the
JOS Project an exclusive club. Anyone with the right header files should be
able to create a JOS Kernel Module that plugs into the JOS Kernel.

A JOS Kernel will use a module if it follows the rules. Size doesn't
matter. A module can be from 1K to 500K in size. While we might frown on a
500K module, it doesn't belong to us to prevent people who know what they
are doing from doing it.

I frown on the idea of a boot image that's over 50K. When a JVM is a JOS
Kernel Module, it helps the JOS-NC machine. When JOS runs on a network
computer, the kernel is loaded as THE boot image. In turn, it loads each
JOS Kernel Module separately, according to its configuration.

Inside my /tftpboot directory, I should see one file for the jJOS and
another file for decaf. How do I upgrade it separately when it is tightly
bound to the jJOS kernel?

I agree that developing jJOS and decaf side-by-side and creating jjos-nbi
was necessary. JOS architecture must include something more abstract.




From iainshigeoka@yahoo.com Sat, 20 Nov 1999 13:14:53 -0600
Date: Sat, 20 Nov 1999 13:14:53 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

On 19 Nov 99, at 7:22, Gilbert Carl Herschberger II wrote:

> At 02:01 PM 11/18/99 -0600, iainshigeoka@yahoo.com wrote:
> >Gilbert.  I snooped around in the source server area of the website. 
> >I can get you the raw (as submitted), non-pretty printed versions of 
> >all the source.  Should be as syntax error free as the original 
> >author submitted it.  Sorry for not being more on the ball about 
> >this.  If you're willing to package it up and make it available so that 
> >people have access to the source that may be only available 
> >through the source server, that would be wonderful.  I'm also 
> >tempted to use that as the opportunity to take source server so 
> >people don't try and add source or use source from it.
> 
> I believe that all members of the JOS Project should have direct and
> uninhibited access to the raw, as submitted, source code. What does this
> mean? It means that the Right Thing to do is take the source code you found
> and put it inside an archive (such as jos1c-srcserv-1.tgz and
> jos1c-srcserv-1.zip). Put the archive on the JOS website at
> http://www.jos.org/download/

The SourceServer contents have been put into a compressed tar 
ball (2.7 MB) located at:

http://www.jos.org/source/jos1c_srcserv.tar.Z

This has also been announced on the main jos webpage.  
Hopefully someone will integrate it into the normal distribution as 
there is a lot of extra content in that tar ball (3 copies of every 
source file, and the SourceServer code itself for example).  If 
someone does, let me know.  I think I'll want to remove the tar ball 
as well as take the SourceServer offline.

-iain



From iainshigeoka@yahoo.com Sat, 20 Nov 1999 13:14:53 -0600
Date: Sat, 20 Nov 1999 13:14:53 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] SourceServer (was: JOS Packages.. I'm a litte confused!)

Hello,

This is getting off topic for the arch list.  I'm cross posting to the 
admin list and setting the reply-to to point there.  Please followup 
to this only on the admin list.

On 19 Nov 99, at 7:38, Gilbert Carl Herschberger II wrote:

> At 02:01 PM 11/18/99 -0600, you wrote:

> Imagine that new code were uploaded to CVS. After code is uploaded to CVS,
> someone downloads it; periodically, they take a snapshot. From the
> snapshot, both a source and binary distribution can be created. Class files
> do not have to be pre-compiled and uploaded to CVS. Anyone can download a
> distribution with a HTML browser, without using CVS.
> 
> This person could run the source code through a syntax highlighter and
> pretty printer to create static HTML files. Static HTML files reduce the
> burden on our web server. The static HTML files are uploaded to our
> Internet website for everyone to browse. All of the heaving processing is
> off-line. Tools can be debugged and improved over a long period of time.
> 
> 1. The HTML-formatted source code could not possibly ruin the source code,
> like Source Server did.
> 
> 2. Pages of HTML-formatted source code should be linked to their
> corresponding distribution. When you pick on class, you download the
> product that contains the package that contains the class. You don't
> download one class at a time.

This is what I had in mind too.  :)  It's on the to-do list after getting 
the current next gen website online.  The current next gen website 
is about 80% of the way to beta state.  It's basically going to 
exhibit the same functionality as the current wiki. But the big 
unseen infrastructure addition is a fully integrated user/session 
management foundation.  With this in place, permission issues 
(esp. upload and edit permissions) will be much easier to address 
for things like source repositories.

> >For now, if you don't want to use CVS, then please, just make an 
> >archive file (.tgz, .zip, or .jar) available for download.
> 
> Authors that do not know CVS can make their distribution available as an
> archive. If product development is shared by many authors, a distribution
> might be uploaded to CVS and maintained there.

My experience as webmaster answering questions for JOS is that 
most open source programmers are not comfortable with using 
CVS.  Especially those that are writing small utilities.  (Or those 
that want to download source for anything).  

This is the reason that the SourceServer even with all its 
shortcomings, was so popular.  No CVS tools, no new techniques 
to learn.  Just upload your jar and SourceServer displays source for 
that jar and that's it.  No merging, no client software, no 
updating/commiting etc.  What's in SourceServer is the latest and 
"canonical" version of that source.

The big question is, what should be JOS' "canonical" source 
repository?

IMHO, it should be a tool like SourceServer (let's call it SSTNG for 
SourceServer: The Next Generation) not CVS.  All JOS source 
should be checked into SSTNG, even if that means there's also a 
version in CVS.  The source in SSTNG basically serves as "official" 
snapshots of the JOS source.  This simplifies things for most 
people.

CVS becomes a working repository only used by those projects 
that require collaboration between several developers (such as the 
kernel group) that isn't feasible to handle by more traditional (if less 
technical) methods such as emailing diffs to a "lead" programmer.  
CVS will still allow adventurous and bleeding-edge people to 
anonymously get CVS source that is basically "daily build" source. 

Groups that use CVS appoints a "lead" programmer that 
periodically checks out CVS sources and inserts it into SSTNG.

SSTNG only stores 1 copy of source.  If new source is checked in 
by users with permission, it replaces the version in SSTNG.  This 
follows the behavior of the old SourceServer and keeps things 
simple for everyone.

For record keeping purposes, every so often, someone from the 
distribution group takes a snapshot of the entire SSTNG contents.  
The last x number of snapshots and other "signficant" snapshots 
can then be made available for download.

Within SSTNG itself, we have functionality as per Gilbert's 
suggestions:

You upload source as "distributions".  For clarity, I'm going to call 
them source jars.  Basically, a jar of all the source needed to build 
a single product (the product being a java application, a library, 
etc).  A source jar can be linked to other source jars to indicate 
dependence on other JOS products (such as shared class library 
jars).

SSTNG handles uploads and downloads at the source jar level.  It 
is up to the "lead" developer(s) how many source files belong to a 
single product (and thus a single source jar).

SSTNG will display source on a source file level via pretty printed 
HTML.  

Each pretty printed source file is linked to the raw source file, and 
its associated source jar.  Anyone is free to view/download source 
file by file via their web browser, or via the entire source jar using 
the link to its associated sourcejar.

For a project you have a "lead" developer or developers that has 
upload permissions to SSTNG for a project.  Each project can have 
as many source jars as they want (within reason).  If you replace 
one of your source jars with a new one, SSTNG delete's all source 
associated with the old jar and replaces it with the new one.  

So to browse source, you first choose a project, then a source jar, 
then navigate via package names.  This does allow for overlapping 
package names/spaces/classes so developers should be careful of 
package name usage.  A JOS Package name reservation system 
is also planned at some really future date for the website...

Each uploaded source jar will be exploded into individual source 
files, pretty printed HTML versions can be auto-generated, as well 
as javadoc'd.

Anything I missed or got wrong?  Let me know.  I'm obviously not 
working on this right now but it is a future project or my list.  If 
anyone wants to help out, let me know.

-iain



From mbz@starbellysoftware.com Sat, 20 Nov 1999 17:37:25 -0500
Date: Sat, 20 Nov 1999 17:37:25 -0500
From: Maciej Zawadzki mbz@starbellysoftware.com
Subject: [JOS-Arch] Thoughts on JOS and JNI

Hello,

I have been following the discussions on various JOS lists for several weeks
now.  Like the rest of you, I'm prestty excited about the possibilities of
JOS.  While time and expertise constraints have prevented me from
contributing code as of yet, I hope to help out coding in the near future.

I would like to comment on JNI and JOS.  I'm not sure that I understand why
a Java operating system (as opposed to a Java runtime environment) would
require a native interface at all.  In a Java runtime environment (RT) it
makes a lot of sense to provide a native interface because the RT is encased
within a foreign operating system and is supposed to coexist with native
applications.  This is not the case when we are talking about a Java
operating system.

My understanding is that a Java Operating System would have a thin layer of
native code between the byte code and machine code;  but that is the only
time native code would be developed within an Java OS.  Normall development
on a Java OS (as opposed development of the OS itself) would make the
assumption that byte code is native code.  Even when developing a C or C++
application on a Java OS that application should compile to byte code rather
than processor specific machine code.

This may sound like an inefficient architecture, however it is self
consistent.  Efficiency is a completely separate issue and as such can be
handled completely separately (lets not confuse or complicate matters).  To
gain the efficiency advantage of native code over byte code, we may want to
develop a flash compiler as opposed to a byte code interpreter or JIT
compiler.  A flash compiler would precompile any byte code to native machine
code at the time the code is loaded.  Once the compilation is done, we are
executing native code at native code speeds.

Obviously there are many more issues that should enter this discussion, but
I wanted to share my view with you guys and get some feedback.

maciej



>At 09:52 PM 11/19/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
>>This doesn't answer your question specifically, but it does show that
there
>>is/can be a need for native support.
>
>Even if we need native support for one subroutine, we need a complete
>design for native support. I know, I know. I don't like the idea of opening
>up JOS to hundreds of customized native libraries. Some people might get
>confused and build software with native code rather than using bytecode
>like they are supposed to. All open source projects are annoyed by people
>who do not know what they are doing.
>
>Is the JOS Project an exclusive group? With a platform free of customized
>native libraries, only members of the JOS Project could write native code.
>
>There is a lot of work to do. We need help from everyone willing to help
>us. From a project estimate viewpoint, the JOS Project would be delayed if
>we look for an architecture completely free of customized native libraries.
>Let's imagine that there is no native platform API. The only choice for
>customization would be to build Java class libraries. Even if native code
>works and is perfectly stable, it cannot run on a platform free from
>customized native libraries.
>
>On the other hand, maybe everything should be decided at compile time. If
>you want native code in your JOS kernel, you write code using the Linux
>compiler and recompile your kernel. While your product works for you, you
>can't distribute it to other members of the JOS Project. It won't work on
>their kernel.
>
>JOS Kernel Modules are a good idea from a future oriented operating system.
>What happens when you want to switch from the Java 2 platform to Java 3?
>When a JVM is a JOS Kernel Module, you can plug-in the Java 3 JVM.
>
>JOS Kernel Modules are a good idea from the viewpoint of domains. What
>happens when you want a secondary domain for a guest user of your JOS
>machine? What happens when I telnet from my Linux server to my JOS machine?
>The JOS kernel can load a new JVM module. It is a new domain. It has its
>own class path.
>
>JOS Kernel Modules are a good idea from the viewpoint of multiple process
>operating system. What happens when you want to run TCP/IP services in a
>secondary domain? The JOS kernel can load a new JVM module using the JNI.
>
>JOS Kernel Modules are a good idea from the viewpoint of debugging and
>developing the next version of JOS. While using a stable JVM as your
>primary domain, you can recompile and reload your test JVM as a kernel
>module. Of course, it has a different class path.
>
>We have to stretch our imagination to look forward to the day that JOS is
>developed on JOS. It must have an Intel assembler. It must have a C/C++
>compiler. It must have a javac tool, even if we have to "borrow" it from
>another open source project. The architecture of JOS for today must not
>eliminate the potential of JOS to be completely stand alone from all other
>operating systems.
>
>When we start with simple native support for one subroutine, we can develop
>a mechanism that supports any native subroutine. We don't have to make the
>JOS Project an exclusive club. Anyone with the right header files should be
>able to create a JOS Kernel Module that plugs into the JOS Kernel.
>
>A JOS Kernel will use a module if it follows the rules. Size doesn't
>matter. A module can be from 1K to 500K in size. While we might frown on a
>500K module, it doesn't belong to us to prevent people who know what they
>are doing from doing it.
>
>I frown on the idea of a boot image that's over 50K. When a JVM is a JOS
>Kernel Module, it helps the JOS-NC machine. When JOS runs on a network
>computer, the kernel is loaded as THE boot image. In turn, it loads each
>JOS Kernel Module separately, according to its configuration.
>
>Inside my /tftpboot directory, I should see one file for the jJOS and
>another file for decaf. How do I upgrade it separately when it is tightly
>bound to the jJOS kernel?
>
>I agree that developing jJOS and decaf side-by-side and creating jjos-nbi
>was necessary. JOS architecture must include something more abstract.
>
>
>_______________________________________________
>Arch maillist  -  Arch@jos.org
>http://jos.org/mailman/listinfo/arch
>
>




From gchii@mindspring.com Sat, 20 Nov 1999 18:02:59 -0500
Date: Sat, 20 Nov 1999 18:02:59 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

At 01:14 PM 11/20/99 -0600, iainshigeoka@yahoo.com wrote:
>The SourceServer contents have been put into a compressed tar 
>ball (2.7 MB) located at:
>
>http://www.jos.org/source/jos1c_srcserv.tar.Z

A "tar ball" is an expression I might not have heard before. Once it is
downloaded, how do I uncompress a "tar ball". I'm used to .tar.gz and .tgz;
but not .tar.Z.

>Hopefully someone will integrate it into the normal distribution as 
>there is a lot of extra content in that tar ball (3 copies of every 
>source file, and the SourceServer code itself for example).

I volunteer. I can integrate this into a "normal" distribution. I'll make
that part of my check-list for the Source Server packages.




From gchii@mindspring.com Sat, 20 Nov 1999 18:38:09 -0500
Date: Sat, 20 Nov 1999 18:38:09 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Thoughts on JOS and JNI

At 05:37 PM 11/20/99 -0500, "Maciej Zawadzki" <mbz@starbellysoftware.com>
wrote:
>I have been following the discussions on various JOS lists for several weeks
>now.  Like the rest of you, I'm prestty excited about the possibilities of
>JOS.  While time and expertise constraints have prevented me from
>contributing code as of yet, I hope to help out coding in the near future.

Welcome. Insight into this puzzle is valuable, too. Anyone can contribute
to the discussion without contributed code.

>I would like to comment on JNI and JOS.  I'm not sure that I understand why
>a Java operating system (as opposed to a Java runtime environment) would
>require a native interface at all.  In a Java runtime environment (RT) it
>makes a lot of sense to provide a native interface because the RT is encased
>within a foreign operating system and is supposed to coexist with native
>applications.  This is not the case when we are talking about a Java
>operating system.

Some say a native interface is a good idea; some say its not. A Java
operating system does not require a native interface, except the interface
already provided by opcodes in the JVM. It is optional. We don't have to
have one. The question is: Should we?

I like your explanation. The native interface takes on a critical
significance when a runtime environment runs on top of a foreign operating
system. It is a strong selling point. Sun Microsystems and others have used
this to promote Java as a viable platform for here and now.

>My understanding is that a Java Operating System would have a thin layer of
>native code between the byte code and machine code;  but that is the only
>time native code would be developed within an Java OS.  Normall development
>on a Java OS (as opposed development of the OS itself) would make the
>assumption that byte code is native code.  Even when developing a C or C++
>application on a Java OS that application should compile to byte code rather
>than processor specific machine code.

An operating system that runs on bytecode and only bytecode would require a
real Java processor. The opcodes would be interpreted with microcode in a
Java processor, just as the opcodes are interpreted by a Intel '486 chip.
An Intel chip running in an IBM PC can't run on bytecode.

Tolk has a list of C and C++ "compilers" that create bytecode for a Java
virtual machine. That is a very good idea. Just as there are "compilers"
for COBOL, Pascal, Jasmin and more.

When we compile a kernel and Java virtual machine with a C or C++ compiler,
it must be able to produce machine code. In a second generation of JOS, you
might expect a JOS program running on top of JOS would be able to emit that
machine code.

TowerJ is already going the other direction. They take your Java code and
emit machine code. TowerJ is a true ahead-of-time compiler for Java, the
programming language. TowerJ expects a foreign operating system, such as
Linux, to handle all of the standard library calls. In theory, one could
write a JOS kernel and JVM using TowerJ on Linux.

>This may sound like an inefficient architecture, however it is self
>consistent.  Efficiency is a completely separate issue and as such can be
>handled completely separately (lets not confuse or complicate matters).  To
>gain the efficiency advantage of native code over byte code, we may want to
>develop a flash compiler as opposed to a byte code interpreter or JIT
>compiler.  A flash compiler would precompile any byte code to native machine
>code at the time the code is loaded.  Once the compilation is done, we are
>executing native code at native code speeds.

In a choice to run JOS on Intel chips, such as the '486 and Pentium, we
have created this inconsistency. Anything that can be written as bytecode
should be written as bytecode. Therefore, anything that cannot be written
as bytecode should be written in machine code.

JOS is unique when you think about ahead-of-time compiler and just-in-time
compiler. An ahead-of-time compiler is a compiler in the traditional sense.
The fully formed executable image is stored ahead-of-time, before the first
opcode is performed. A just-in-time compiler meets a new deadline, creating
part of an executable image as it is needed.

Take a walk on the wild side. Imagine you could download a special version
of the javac tool that's custom made for JOS and only JOS. This javac tool
contains a command line option to produce machine code for a specific
processor. It puts the machine code into a class file using the attribute
mechanism already provided by Sun Microsystems. This is a mechanism taylor
made for situations like this.

IF we could choose the class file format for JOS' shared libraries, we
could write JOS with our own javac tool. Here is an example of what I have
been experimenting with:

public class org.jos.demo.MixedLanguageProgram {
  public MixedLanguageProgram() {
  }
  public void run() {
    int iMax = 22000;
    cpp {
      for ( int i = 0; i < iMax; i++ ) {
        cout << i;
      }
    }
  }
}

Just like you can have your assembler program embedded inside a C or C++
program, you can have your C or C++ program embedded in your Java program.
All it takes is a javac tool with JOS power.

IBM has experimented with a selective ahead-of-time compiler for Java.
Before a program is distributed, it is pre-compiled for Windows and OS/2.
If you use Windows or OS/2 you're actually running the pre-compiled machine
code. If not, you get the interpreted bytecode. Either way the program
runs. The only difference is speed.




From tmiller@haverford.edu Sat, 20 Nov 1999 19:44:05 -0500 (EST)
Date: Sat, 20 Nov 1999 19:44:05 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] Thoughts on JOS and JNI

> I'm not sure that I understand why
> a Java operating system (as opposed to a Java runtime environment) would
> require a native interface at all.

	The only reason I can think of for native code outside the
kernel/JVM is for situations in which hardware timing constraints prevent
java device drivers from functioning.  This native code ought to be in modules,
but that will require an enourmous amount of investment of time from the
kernel programmers; for now, it makes more sense just to code this code
directly into the kernel/JVM using the same mechanisms already present for
native code calls (i.e. java.lang.System.arraycopy()).  Various other
chunks of the kernel (modules) will provide whatever h/w access services
the kernel might not.  (Which shouldn't be very many...)

-_Quinn




From mbz@starbellysoftware.com Sat, 20 Nov 1999 19:43:32 -0500
Date: Sat, 20 Nov 1999 19:43:32 -0500
From: Maciej Zawadzki mbz@starbellysoftware.com
Subject: [JOS-Arch] Fw: [JOS-Arch] Thoughts on JOS and JNI

-----Original Message-----
From: Maciej Zawadzki <mbz@starbellysoftware.com>
To: Gilbert Carl Herschberger II <gchii@mindspring.com>
Date: Saturday, November 20, 1999 7:35 PM
Subject: Re: [JOS-Arch] Thoughts on JOS and JNI


>I believe that we agree in idea, which is (as you state) "everything that
>can be written in byte code should be written in byte code."  So, if we
>accept that as our goal or assumption, then what need is there for JNI ?
>The only part that could not be written in byte code is the layer between
>the byte code and the machine.  What do we call this layer; kernel? JOSBox
?
>JOSCore ?  That is a different discussion.  The point is, that once this
>layer is written, there is no more need to write anything else in native
>code, thus no more need for JNI.
>
>>>My understanding is that a Java Operating System would have a thin layer
>of
>>>native code between the byte code and machine code;  but that is the only
>>>time native code would be developed within an Java OS.  Normall
>development
>>>on a Java OS (as opposed development of the OS itself) would make the
>>>assumption that byte code is native code.  Even when developing a C or
C++
>>>application on a Java OS that application should compile to byte code
>rather
>>>than processor specific machine code.
>>
>>An operating system that runs on bytecode and only bytecode would require
a
>>real Java processor. The opcodes would be interpreted with microcode in a
>>Java processor, just as the opcodes are interpreted by a Intel '486 chip.
>>An Intel chip running in an IBM PC can't run on bytecode.
>
>
>I'm a little confused here.  Lets jump forward a little and try a though
>experiment.  Once JOS is complete, will I be able to write an application
>for JOS and compile the application to native code?  Personally, I think
>this should not be the normal mode of operation.  I think that any
>application developed for JOS, whether developed in Java or any other
>programming language (C, C++, etc.), should be compiled to byte code.  This
>way, that application can be deployed on a JOS system running on any
>hardware.  It is the job of JOS to execute the byte code (how this is
>accomplished is another discussion).
>
>>In a second generation of JOS, you
>>might expect a JOS program running on top of JOS would be able to emit
that
>>machine code.
>
>I agree that this should be possible, but usefull in a very limited number
>of situations.  The only time it would serve any purpose to compile code
>into native code directly rather than byte code, is when working on JOS
>itself.
>
>
>I guess the basic issue here is the format of JOS executable files.  Are
JOS
>executables native code or byte code.  It is my understanding that they
need
>to be byte code.  Is this the view shared by others ?
>
>If JOS executables are in byte code, then there is no need for JNI.
>
>
>




From mbz@starbellysoftware.com Sat, 20 Nov 1999 19:45:00 -0500
Date: Sat, 20 Nov 1999 19:45:00 -0500
From: Maciej Zawadzki mbz@starbellysoftware.com
Subject: [JOS-Arch] Thoughts on JOS and JNI

I believe that we agree in idea, which is (as you state) "everything that
can be written in byte code should be written in byte code."  So, if we
accept that as our goal or assumption, then what need is there for JNI ?
The only part that could not be written in byte code is the layer between
the byte code and the machine.  What do we call this layer; kernel? JOSBox ?
JOSCore ?  That is a different discussion.  The point is, that once this
layer is written, there is no more need to write anything else in native
code, thus no more need for JNI.

>>My understanding is that a Java Operating System would have a thin layer
of
>>native code between the byte code and machine code;  but that is the only
>>time native code would be developed within an Java OS.  Normall
development
>>on a Java OS (as opposed development of the OS itself) would make the
>>assumption that byte code is native code.  Even when developing a C or C++
>>application on a Java OS that application should compile to byte code
rather
>>than processor specific machine code.
>
>An operating system that runs on bytecode and only bytecode would require a
>real Java processor. The opcodes would be interpreted with microcode in a
>Java processor, just as the opcodes are interpreted by a Intel '486 chip.
>An Intel chip running in an IBM PC can't run on bytecode.


I'm a little confused here.  Lets jump forward a little and try a though
experiment.  Once JOS is complete, will I be able to write an application
for JOS and compile the application to native code?  Personally, I think
this should not be the normal mode of operation.  I think that any
application developed for JOS, whether developed in Java or any other
programming language (C, C++, etc.), should be compiled to byte code.  This
way, that application can be deployed on a JOS system running on any
hardware.  It is the job of JOS to execute the byte code (how this is
accomplished is another discussion).

>In a second generation of JOS, you
>might expect a JOS program running on top of JOS would be able to emit that
>machine code.

I agree that this should be possible, but usefull in a very limited number
of situations.  The only time it would serve any purpose to compile code
into native code directly rather than byte code, is when working on JOS
itself.


I guess the basic issue here is the format of JOS executable files.  Are JOS
executables native code or byte code.  It is my understanding that they need
to be byte code.  Is this the view shared by others ?

If JOS executables are in byte code, then there is no need for JNI.






From iainshigeoka@yahoo.com Sat, 20 Nov 1999 21:42:53 -0600
Date: Sat, 20 Nov 1999 21:42:53 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] JOS Packages.. I'm a litte confused!

> At 01:14 PM 11/20/99 -0600, iainshigeoka@yahoo.com wrote:

> >The SourceServer contents have been put into a compressed tar 
> >ball (2.7 MB) located at:

> A "tar ball" is an expression I might not have heard before. Once it is
> downloaded, how do I uncompress a "tar ball". I'm used to .tar.gz and .tgz;
> but not .tar.Z.

Sorry.  A tar ball is simply a *.tar file.  I guess its a play on the fact 
that they're called tar files.  Anyhow, you uncompress a *.Z file 
using the unix uncompress (or sometimes its compress with a 
flag).  That should give you a *.tar file which you can untar using 
'tar -xvf'.  If you're on Windows, WinZip will handle compressed tar 
balls just like a zip file.  I couldn't find a zip/gzip program on our 
server so decided to just compress it.

> >Hopefully someone will integrate it into the normal distribution as 
> >there is a lot of extra content in that tar ball (3 copies of every 
> >source file, and the SourceServer code itself for example).
> 
> I volunteer. I can integrate this into a "normal" distribution. I'll make
> that part of my check-list for the Source Server packages.

Thank you.

-iain



From gchii@mindspring.com Sun, 21 Nov 1999 19:53:31 -0500
Date: Sun, 21 Nov 1999 19:53:31 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Thoughts on JOS and JNI

At 07:45 PM 11/20/99 -0500, "Maciej Zawadzki" <mbz@starbellysoftware.com>
wrote:
>I believe that we agree in idea, which is (as you state) "everything that
>can be written in byte code should be written in byte code."  So, if we
>accept that as our goal or assumption, then what need is there for JNI ?

I think this is an important issue. The API between the Java class
libraries and Java virtual machine from Sun Microsystems is growing in
complexity.

How many native methods are there?

If we want one person to use one native method for the sake of performance,
we have to recognise the need for something like JNI. The TCP/IP stack is a
good example of a project that would benefit from a modular approach to the
JOS kernel. A second-best architecture would put modules in the JVM.

decaf has a kludge in place so that the bytecode interpreter can call
native methods that are compiled and linked in statically. We can restart
this discussion there, if you like. Even a statically linked library and
more formal design of the JVM-native interface wouldn't hurt (would it?).

A NativeMethod object might be a good place to start. The JVM might include
an array of these objects. A native method needs (1) a UTF8-compatible name
and (2) a pointer to the entry point of a native method. In addition, a
native method and an opcode method are similar. The JVM might include an
array of OpcodeMethod objects, indexed by opcode. That is what an opcode is
for. A large switch statement, on the other hand, is unnecessary and
suffers from poor performance. It is also difficult to customize at
runtime. When NativeMethods and OpcodeMethods are formalized, they can also
be customized at run-time somwhere down the road.

Someday these native methods might centralized in a few packages -- taken
out of the java.* packages entirely. decaf already has a few native
methods. Java class libraries won't be fully implemented until all of these
native methods are resolved.

Using pure reflection library, I have created a partial list of native
methods from the Java 1 Platform. That's far more complexity that Java 0.

Class java.awt.image.ColorModel
  private native void deletepData();

Class java.io.File
  private native boolean exists0();
  private native boolean canWrite0();
  private native boolean canRead0();
  private native boolean isFile0();
  private native boolean isDirectory0();
  private native long lastModified0();
  private native long length0();
  private native boolean mkdir0();
  private native boolean renameTo0( java.io.File );
  private native boolean delete0();
  private native boolean rmdir0();
  private native java.lang.String[] list0();
  private native java.lang.String canonPath( java.lang.String );
  public native boolean isAbsolute();

Class java.io.FileDescriptor
  public native boolean valid();
  public native void sync();
  private static native java.io.FileDescriptor initSystemFD(
java.io.FileDescriptor, int );

Class java.io.FileInputStream
  private native void open( java.lang.String );
  public native int read();
  private native int readBytes( byte[], int, int );
  public native long skip( long );
  public native int available();
  public native void close();

Class java.io.FileOutputStream
  private native void open( java.lang.String );
  private native void openAppend( java.lang.String );
  public native void write( int );
  private native void writeBytes( byte[], int, int );
  public native void close();

Class java.io.ObjectInputStream
  private native java.lang.Class loadClass0( java.lang.Class,
java.lang.String );
  private native void inputClassFields( java.lang.Object, java.lang.Class );
  private static native java.lang.Object allocateNewObject(
java.lang.Class, java.lang.Class );
  private static native java.lang.Object allocateNewArray( java.lang.Class,
int );
  private native boolean invokeObjectReader( java.lang.Object,
java.lang.Class );

Class java.io.ObjectOutputStream
  private native void outputClassFields( java.lang.Object, java.lang.Class );
  private native boolean invokeObjectWriter( java.lang.Object,
java.lang.Class );

Class java.io.ObjectStreamClass
  private static native int getClassAccess( java.lang.Class );
  private static native java.lang.String[] getMethodSignatures(
java.lang.Class );
  private static native int getMethodAccess( java.lang.Class,
java.lang.String );
  private static native java.lang.String[] getFieldSignatures(
java.lang.Class );
  private static native int getFieldAccess( java.lang.Class,
java.lang.String );
  private native java.io.ObjectStreamField[] getFields0( java.lang.Class );
  private static native long getSerialVersionUID( java.lang.Class );
  private static native boolean hasWriteObject( java.lang.Class );

Class java.io.RandomAccessFile
  private native void open( java.lang.String, boolean );
  public native int read();
  private native int readBytes( byte[], int, int );
  public native void write( int );
  private native void writeBytes( byte[], int, int );
  public native long getFilePointer();
  public native void seek( long );
  public native long length();
  public native void close();

Class java.lang.Class
  public static native java.lang.Class forName( java.lang.String );
  public native java.lang.Object newInstance();
  public native boolean isInstance( java.lang.Object );
  public native boolean isAssignableFrom( java.lang.Class );
  public native boolean isInterface();
  public native boolean isArray();
  public native boolean isPrimitive();
  public native java.lang.String getName();
  public native java.lang.ClassLoader getClassLoader();
  public native java.lang.Class getSuperclass();
  public native java.lang.Class[] getInterfaces();
  public native java.lang.Class getComponentType();
  public native int getModifiers();
  public native java.lang.Object[] getSigners();
  native void setSigners( java.lang.Object[] );
  static native java.lang.Class getPrimitiveClass( java.lang.String );
  private native java.lang.reflect.Field[] getFields0( int );
  private native java.lang.reflect.Method[] getMethods0( int );
  private native java.lang.reflect.Constructor[] getConstructors0( int );
  private native java.lang.reflect.Field getField0( java.lang.String, int );
  private native java.lang.reflect.Method getMethod0( java.lang.String,
java.lang.Class[] );
  private native java.lang.reflect.Constructor getConstructor0(
java.lang.Class[] );

Class java.lang.ClassLoader
  private native void init();
  private native java.lang.Class defineClass0( java.lang.String, byte[],
int, int );
  private native void resolveClass0( java.lang.Class );
  private native java.lang.Class findSystemClass0( java.lang.String );
  private static native java.io.InputStream getSystemResourceAsStream0(
java.lang.String );
  private static native java.lang.String getSystemResourceAsName0(
java.lang.String );

Class java.lang.Compiler
  private static native void initialize();
  public static native boolean compileClass( java.lang.Class );
  public static native boolean compileClasses( java.lang.String );
  public static native java.lang.Object command( java.lang.Object );
  public static native void enable();
  public static native void disable();

Class java.lang.Double
  public static native long doubleToLongBits( double );
  public static native double longBitsToDouble( long );
  static native double valueOf0( java.lang.String );

Class java.lang.Float
  public static native int floatToIntBits( float );
  public static native float intBitsToFloat( int );

Class java.lang.Math
  public static native double sin( double );
  public static native double cos( double );
  public static native double tan( double );
  public static native double asin( double );
  public static native double acos( double );
  public static native double atan( double );
  public static native double exp( double );
  public static native double log( double );
  public static native double sqrt( double );
  public static native double IEEEremainder( double, double );
  public static native double ceil( double );
  public static native double floor( double );
  public static native double rint( double );
  public static native double atan2( double, double );
  public static native double pow( double, double );

Class java.lang.Object
  public final native java.lang.Class getClass();
  public native int hashCode();
  protected native java.lang.Object clone();
  public final native void notify();
  public final native void notifyAll();
  public final native void wait( long );

Class java.lang.Runtime
  private native void exitInternal( int );
  private static native void runFinalizersOnExit0( boolean );
  private native java.lang.Process execInternal( java.lang.String[],
java.lang.String );
  public native long freeMemory();
  public native long totalMemory();
  public native void gc();
  public native void runFinalization();
  public native void traceInstructions( boolean );
  public native void traceMethodCalls( boolean );
  private native java.lang.String initializeLinkerInternal();
  private native java.lang.String buildLibName( java.lang.String,
java.lang.String );
  private native int loadFileInternal( java.lang.String );

Class java.lang.SecurityManager
  protected native java.lang.Class[] getClassContext();
  protected native java.lang.ClassLoader currentClassLoader();
  protected native int classDepth( java.lang.String );
  protected native int classLoaderDepth();
  private native java.lang.Class currentLoadedClass0();

Class java.lang.String
  public native java.lang.String intern();

Class java.lang.System
  private static native void setIn0( java.io.InputStream );
  private static native void setOut0( java.io.PrintStream );
  private static native void setErr0( java.io.PrintStream );
  public static native long currentTimeMillis();
  public static native void arraycopy( java.lang.Object, int,
java.lang.Object );
  public static native int identityHashCode( java.lang.Object );
  private static native java.util.Properties initProperties(
java.util.Properties );

Class java.lang.Thread
  public static native java.lang.Thread currentThread();
  public static native void yield();
  public static native void sleep( long );
  public native void start();
  private native boolean isInterrupted( boolean );
  public final native boolean isAlive();
  public native int countStackFrames();
  private native void setPriority0( int );
  private native void stop0( java.lang.Object );
  private native void suspend0();
  private native void resume0();
  private native void interrupt0();

Class java.lang.Throwable
  private native void printStackTrace0( java.lang.Object );
  public native java.lang.Throwable fillInStackTrace();

Class java.lang.Win32Process
  public native int exitValue();
  public native int waitFor();
  public native void destroy();
  private native void create( java.lang.String, java.lang.String );
  private native void close();

Class java.lang.reflect.Array
  public static native int getLength( java.lang.Object );
  public static native java.lang.Object get( java.lang.Object, int );
  public static native boolean getBoolean( java.lang.Object, int );
  public static native byte getByte( java.lang.Object, int );
  public static native char getChar( java.lang.Object, int );
  public static native short getShort( java.lang.Object, int );
  public static native int getInt( java.lang.Object, int );
  public static native long getLong( java.lang.Object, int );
  public static native float getFloat( java.lang.Object, int );
  public static native double getDouble( java.lang.Object, int );
  public static native void set( java.lang.Object, int, java.lang.Object );
  public static native void setBoolean( java.lang.Object, int, boolean );
  public static native void setByte( java.lang.Object, int, byte );
  public static native void setChar( java.lang.Object, int, char );
  public static native void setShort( java.lang.Object, int, short );
  public static native void setInt( java.lang.Object, int, int );
  public static native void setLong( java.lang.Object, int, long );
  public static native void setFloat( java.lang.Object, int, float );
  public static native void setDouble( java.lang.Object, int, double );
  private static native java.lang.Object newArray( java.lang.Class, int );
  private static native java.lang.Object multiNewArray( java.lang.Class,
int[] );

Class java.lang.reflect.Constructor
  public native int getModifiers();
  public native java.lang.Object newInstance( java.lang.Object[] );

Class java.lang.reflect.Field
  public native int getModifiers();
  public native java.lang.Object get( java.lang.Object );
  public native boolean getBoolean( java.lang.Object );
  public native byte getByte( java.lang.Object );
  public native char getChar( java.lang.Object );
  public native short getShort( java.lang.Object );
  public native int getInt( java.lang.Object );
  public native long getLong( java.lang.Object );
  public native float getFloat( java.lang.Object );
  public native double getDouble( java.lang.Object );
  public native void set( java.lang.Object, java.lang.Object );
  public native void setBoolean( java.lang.Object, boolean );
  public native void setByte( java.lang.Object, byte );
  public native void setChar( java.lang.Object, char );
  public native void setShort( java.lang.Object, short );
  public native void setInt( java.lang.Object, int );
  public native void setLong( java.lang.Object, long );
  public native void setFloat( java.lang.Object, float );
  public native void setDouble( java.lang.Object, double );

Class java.lang.reflect.Method
  public native int getModifiers();
  public native java.lang.Object invoke( java.lang.Object,
java.lang.Object[] );

Class java.math.BigInteger
  private static native void plumbInit();
  private static native byte[] plumbAdd( byte[], byte[] );
  private static native java.math.BigInteger plumbSubtract( byte[], byte[] );
  private static native byte[] plumbMultiply( byte[], byte[] );
  private static native byte[] plumbDivide( byte[], byte[] );
  private static native byte[] plumbRemainder( byte[], byte[] );
  private static native byte[][] plumbDivideAndRemainder( byte[], byte[] );
  private static native byte[] plumbGcd( byte[], byte[] );
  private static native byte[] plumbModPow( byte[], byte[], byte[] );
  private static native byte[] plumbModInverse( byte[], byte[] );
  private static native byte[] plumbSquare( byte[] );
  private static native byte[] plumbGeneratePrime( byte[] );

Class java.net.InetAddressImpl
  native java.lang.String getLocalHostName();
  native void makeAnyLocalAddress( java.net.InetAddress );
  native byte[][] lookupAllHostAddr( java.lang.String );
  native java.lang.String getHostByAddr( int );
  native int getInetFamily();

Class java.net.PlainDatagramSocketImpl
  protected native void bind( int, java.net.InetAddress );
  protected native void send( java.net.DatagramPacket );
  protected native int peek( java.net.InetAddress );
  protected native void receive( java.net.DatagramPacket );
  protected native void setTTL( byte );
  protected native byte getTTL();
  protected native void join( java.net.InetAddress );
  protected native void leave( java.net.InetAddress );
  private native void datagramSocketCreate();
  private native void datagramSocketClose();
  private native void socketSetOption( int, java.lang.Object );
  private native int socketGetOption( int );

Class java.net.PlainSocketImpl
  private native void socketCreate( boolean );
  private native void socketConnect( java.net.InetAddress, int );
  private native void socketBind( java.net.InetAddress, int );
  private native void socketListen( int );
  private native void socketAccept( java.net.SocketImpl );
  private native int socketAvailable();
  private native void socketClose();
  private static native void initProto();
  private native void socketSetOption( int, boolean, java.lang.Object );
  private native int socketGetOption( int );

Class java.net.SocketInputStream
  private native int socketRead( byte[], int, int );

Class java.net.SocketOutputStream
  private native void socketWrite( byte[], int, int );

Class java.util.ResourceBundle
  private static native java.lang.Class[] getClassContext();

Class java.util.zip.Adler32
  public native void update( byte[], int, int );
  private native void update1( int );

Class java.util.zip.CRC32
  public native void update( byte[], int, int );
  private native void update1( int );

Class java.util.zip.Deflater
  public native void setDictionary( byte[], int, int );
  public native int deflate( byte[], int, int );
  public native int getAdler();
  public native int getTotalIn();
  public native int getTotalOut();
  public native void reset();
  public native void end();
  private native void init( boolean );

Class java.util.zip.Inflater
  public native void setDictionary( byte[], int, int );
  public native int inflate( byte[], int, int );
  public native int getAdler();
  public native int getTotalIn();
  public native int getTotalOut();
  public native void reset();
  public native void end();
  private native void init( boolean );






From onewith1@flash.net Sun, 21 Nov 1999 21:44:43 -0600
Date: Sun, 21 Nov 1999 21:44:43 -0600
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] Thoughts on JOS and JNI

Maciej Zawadzki <mbz@starbellysoftware.com> wrote:
> I would like to comment on JNI and JOS.  I'm not sure that I understand
why
> a Java operating system (as opposed to a Java runtime environment) would
> require a native interface at all.  In a Java runtime environment (RT) it
> makes a lot of sense to provide a native interface because the RT is
encased
> within a foreign operating system and is supposed to coexist with native
> applications.  This is not the case when we are talking about a Java
> operating system.
>
> My understanding is that a Java Operating System would have a thin layer
of
> native code between the byte code and machine code;  but that is the only
> time native code would be developed within an Java OS.  Normall
development
> on a Java OS (as opposed development of the OS itself) would make the
> assumption that byte code is native code.  Even when developing a C or C++
> application on a Java OS that application should compile to byte code
rather
> than processor specific machine code.

These are all excellent points.  Gilbert was right, though, that Sun
requires JVMs to support JNI.  But we could make a valid argument that our
"native interface" is actually Java (argument omitted for brevity).

I believe that the only modules that should be allowable are JVMs.  This
way, we can add, remove, and test JVMs as they come along and as users need
them.  Possibly even allow extentions for testing new versions of the JOS
kernel.

However, this does not mean native-code interfaces for any Jane's classes
that come along.  The native code is Java!  (We just happen to be making a
true Java Virtual Machine, one that emulates a Java Computer with the bare
essentials).

Yes, it certainly would be neat to have your Java3D implementation in native
code, making blazing fast graphics for your Wiz-Bang Graphics Card to play
Quake DCLXVI on JOS.  However, the initial JOS philosophy was, like Maciej
said, to make an absolute minimal layer between bare-iron hardware, and Java
code.  This means drivers are written in Java.

Yes, this means your Modem driver may lose data.  Yes, your network driver
may lose packets.  Native code gives us efficient coding that can't be done
well in interpreted byte-codes.  That's what "flash compiling" and JITs are
for: creating native code from byte-codes.  We may even make a special JIT
just for drivers, that moves the kernel calls to do I/O port and memory
access directly into the compiled code (thus, a form of "call unrolling"
optimization).

But, above all else, these on-the-fly compiling techniques are all part of
the JVM.  They have no business being in a Java Machine, since a Java
Machine runs byte-codes natively.

Modules are a great idea.  They allow us to pick and choose our kernel parts
(possibly even on-the-fly changing), but they don't belong with JNI.

-Matt




From mchulet@cabletron.com Mon, 22 Nov 1999 01:08:43 -0500
Date: Mon, 22 Nov 1999 01:08:43 -0500
From: Chulet, Mahesh mchulet@cabletron.com
Subject: [JOS-Arch] (no subject)

 
 

____________________________________________ 
you have slept for millions of years, why not wake up this morning 

 



From digigod@earthling.net Mon, 22 Nov 1999 01:31:02 -0500 (EST)
Date: Mon, 22 Nov 1999 01:31:02 -0500 (EST)
From: digigod@earthling.net digigod@earthling.net
Subject: [JOS-Arch] What is JOS?

> >First we have JOSCore, this is the minimal OS consisting of a JOSBox and a
> >minimal JOSystem and no more.
> 
> Please help! I was under the mistaken impression from JOS Wiki pages that
> JOSystem is a marriage or JOSBox and JOSCore. I went back to review JOS
> Wiki pages today to see where this comes from.
> 
>  - On one page, there's a paragraph about how JOSCore is pure bytecode and
> you can find it inside the org.jos.core.* packages. JOSCore is not
> org.jos.core.*, is it?
> 
>  - On another, there's a paragraph that says you only get JOSystem when you
> put JOSBox and JOSCore together. If you get JOSystem when you add JOSBox
> and JOSCore together, you can't get JOSCore when you add JOSBox and
> JOSystem together.
> 
> IF
>   JOSCore' = JOSBox + JOSystem
>   JOSystem' = JOSBox + JOSCore
> THEN
>   JOSCore != JOSCore'
>   JOSystem != JOSystem'
> 
> This week, you've said you get JOSCore when you put JOSBox and JOSystem
> together. I think you're right. If I knew what you meant, I could update
> articles on JOS Wiki so that they are accurate.
> 
> Could you explain it again? I am often frustrated by the fact that I can't
> see JOSCore. I don't have a copy of it to look at. If I knew what it was, I
> could propably help build it. You probably get tired of the
> misinterpretations of these three critical pieces of JOS, too.
> 
> Are you saying that JOSCore is a "minimum" install of JOS? I can choose to
> install either a "minium" or "typical" or "maximum" or "custom" copy of
> Linux. If so, that would mean that JOSCore is orthogonal to the platform
> API. JOSCore isn't a "layer" in the platform API at all.

Firstly, org.jos.core is something entirely different from JOSCore it should be reffered to as: "jos core".

The confusion with JOSBox/JOSystem and JOSCore/JOSExtensions is because they are -- conceptually -- unrelated. You are correct in saying that JOSCore/JOSExtensions are not layers -- they are more like divisions. JOSCore is the "minimum" required *of* JOSBox/JOSystem to boot; JOSExtensions is all those extravegant extra's like device drivers. JOSCore allows JOSExtensions to shape the OS, allowing it to fill any niche: embedded, personal or server. Simply put, JOSExtensions is anything not required to boot the OS in JOSBox/JOSystem (allthough you'll probably need that handful of drivers to get pong up and running). 

JOSBox is the mostly native system that acts as an insulating layer between the "real" OS (JOSystem) and the computer its running on. I think we should regard JOSystem as the kernel/OS and JOSBox as the computer, its like were designing the "hardware" (JOSBox) to run our "OS" (JOSystem) on.

I hope that helps.

Cheers,
DigiGod
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-
----------------------------------------------------------------
Get your free email from AltaVista at http://altavista.iname.com



From gchii@mindspring.com Mon, 22 Nov 1999 09:51:10 -0500
Date: Mon, 22 Nov 1999 09:51:10 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Thoughts on JOS and JNI

At 09:44 PM 11/21/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
>These are all excellent points.  Gilbert was right, though, that Sun
>requires JVMs to support JNI.  But we could make a valid argument that our
>"native interface" is actually Java (argument omitted for brevity).

Excellent! It is a valid argument that our "native interface" *is* Java. It
takes us back to the implementation of a "JNI" in bytecode.

We can do it! I'm really excited about this point of view. For me, it has
been a real breakthrough. I has changed forever the way I think about JOS
architecture. It solves a long list of problems. It is easy to implement in
a JVM. It is future-oriented. It might be the highest performance JNI ever
designed. The development of this "JNI" in bytecode is truely why I joined
the JOS project in the first place. Here is a project that can be done in
parallel. It can be broken into managable pieces.

Here is my proposal: We do the Right Thing. We separate our just-for-JOS
native interface into a just-for-JOS JNI project and just-for-JOS JNI
package, called jos.jni. This jos.jni package should contain the interface
between java.* packages and a JOS JVM. Our JOS JNI is an object factory and
only an object factory.

The object factory creates the JVM-specific implementation of a well-known
interface. The object factory returns the same implementation with each
request. At runtime, there is only one instance of an implementation no
matter how many custom class loaders have been created.

This is the mechanism to control system-wide instances vs. class loader
instances. An object obtained through the jos.jni.Factory is truely
once-per-virtual-machine. Here is where the system-wide registry lives.
Here is where the system-wide TCP/IP stack lives. Here is where the
system-wide device tree lives. The static keyword means
once-per-class-loader, not once-per-virtual-machine. It has been a constant
problem for implementing objects that are truely shared system-wide.

An example is needed. The experience from a number of different projects
seem to fall into place. For example, the jos.jni package would include an
interface for each class in java.* that used a native interface.

Let me use java.io.FileInputStream as an example of the necessary conversion:

Class java.io.FileInputStream
  private native void open( java.lang.String );
  public native int read();
  private native int readBytes( byte[], int, int );
  public native long skip( long );
  public native int available();
  public native void close();

public interface jos.jni.NativeFileInputStream {
:
  public void open( FileInputStream, java.lang.String );
  public int read( FileInputStream );
  public int readBytes( FileInputStream, byte[], int, int );
  public long skip( FileInputStream, long );
  public int available( FileInputStream );
  public void close( FileInputStream );
}

Where once there was a native method, a new non-native method uses an
object provided by the JNI to do the grunt work.

public class java.io.FileInputStream {
:
  // *D! private native void open( String );
  private void open( String v ) {
    tool.open( this, v );
  }

  // *D! public native int read();
  public int read() {
    return tool.read( this );
  }

  // *D! public native int readBytes( byte[] b, int v1, int v2);
  public int readBytes( byte[] b, int v1, int v2) {
    return tool.readBytes( this, b, v1, v2 );
  }
:
}    

With this interface inside the jos.jni package, we could convert the source
code from the class path project to use this interface, instead of the
native one. We can systematically eliminate all native methods from the
java.* packages. Such a focused JNI in bytecode would make it all too easy
to implement a new JVM for a new operating system.

Where does java.io.FileInputStream get an implementation of
jos.jni.native.NativeFileInputStream? It uses the "JNI" interface for JOS.
So there only needs to be one native interface for JOS.

public class jos.jni.Factory {
  public static native Object getObject( String v );
}

Is it possible? Can all of these problems be simplified through a single
method written in machine code? My experiment with the Smart API tells me
that, yes, it can.

What happens when a JVM isn't finished yet? Here is a really good part of
the JOS JNI: the getObject() method is allowed to return null. When a JVM
does not implement a given interface, it returns null. A JVM is free to
implement as much or as little of the JOS JNI as it needs on a specific JOS
machine.

Horray! Our version of the java.* class libraries remain identical on every
JOS machine -- even a JOS machine incapable of performing a function. Take
the AWT for example. If your JVM does not support the AWT, you simply
return null for every jos.jni.native interface related to the AWT.

Our version of java.* classes are nearly identical to class path. And yet,
if your JVM does not support practical reflection, you simply return null
for every jos.jni.native interface related to practical reflection.

Here is the JOS architecture that I have been looking for. On the one hand,
it enable "Java applications" to run as if they were in a classic JRE, 100%
compatible with Sun's JDK. On the other, it enables "JOS applications" to
go where no other bytecode can go. Each JVM can be optimized for its unique
purpose. Source code is compiled with the javac tool. We don't have to
write our own.

>I believe that the only modules that should be allowable are JVMs.  This
>way, we can add, remove, and test JVMs as they come along and as users need
>them.  Possibly even allow extentions for testing new versions of the JOS
>kernel.

When we have a JNI in bytecode, the only modules left are JVMs. With a JVM
as a JOS Kernel Module, we can do all those things we need to implement
security, domains, performance, backward compatibility and future orientation.

>However, this does not mean native-code interfaces for any Jane's classes
>that come along.  The native code is Java!  (We just happen to be making a
>true Java Virtual Machine, one that emulates a Java Computer with the bare
>essentials).

When the JOS Project has completed (1) a jos.jni package (the API), and (2)
an implementation of jos.jni for decaf, and (3) a modified version of
classpath, we might never write another native method.

>Yes, it certainly would be neat to have your Java3D implementation in native
>code, making blazing fast graphics for your Wiz-Bang Graphics Card to play
>Quake DCLXVI on JOS.  However, the initial JOS philosophy was, like Maciej
>said, to make an absolute minimal layer between bare-iron hardware, and Java
>code.  This means drivers are written in Java.

A modified JVM still has the power to implement additional interfaces when
absolutely needed. This compromise puts all native code in the hands of the
JVM developer where it belongs. You can have your blazingly fast graphics.
How? Anyone can implement a JVM as a JOS Kernel Module.

>Yes, this means your Modem driver may lose data.  Yes, your network driver
>may lose packets.  Native code gives us efficient coding that can't be done
>well in interpreted byte-codes.  That's what "flash compiling" and JITs are
>for: creating native code from byte-codes.  We may even make a special JIT
>just for drivers, that moves the kernel calls to do I/O port and memory
>access directly into the compiled code (thus, a form of "call unrolling"
>optimization).

Whoa! On the one hand, it is unacceptable for a modem or a network driver
to lose data. Please don't make the assumption that a program stored as
bytecode is *always* too slow to do real processing.

Device drivers are the best argument for a fully automatic, seemless
mechanism to convert from bytecode to machine code. They would benefit the
most from ahead-of-time or just-in-time compiling. Like the machine
interface in OS/400, bytecode can be converted to machine code and stored.
By comparing the last modified date of the bytecode with its corresponding
executable image, OS/400 JVM automatically recompiles when its bytecode
changes. It uses the directly executable image when available.

>But, above all else, these on-the-fly compiling techniques are all part of
>the JVM.  They have no business being in a Java Machine, since a Java
>Machine runs byte-codes natively.

Here is where we can have the most fun. We can design a JOS-compatible JVM
that uses pre-compiling AND one that doesn't. We can compare the
performance difference between these two JVMs, side by side on a single JOS
machine. The JOS Kernel loads each JVM as a JOS Kernel Module.

>Modules are a great idea.  They allow us to pick and choose our kernel parts
>(possibly even on-the-fly changing), but they don't belong with JNI.

Yes, we can keep separate the JOS Kernel Module and JNI for JOS. The
interface between the JOS Kernel and any module should be the "Kernel
Interface". The JOS Kernel must provide common services to all of its
modules, such as memory management and inter-module communication.

Someday, it might be possible to define our own JOS Kernel Module file
format so that modules can be loaded dynamically. But that's a topic for
another day.




From gchii@mindspring.com Mon, 22 Nov 1999 11:24:10 -0500
Date: Mon, 22 Nov 1999 11:24:10 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Thoughts on JOS and JNI

At 03:15 PM 11/22/99 GMT, mgangelen@quintop.nl wrote:
>To go further on the issue of nativecode in JOS, It must be said that not
>all of the native methods in the SUN JAVA 1.1 API have to be in the JOS
>JAVA 1.1 API.

Absolutely! This might be the only thing that save us when it comes to
using Java without a foreign operating system. By showing the Java 1.1 API,
I hoped to show that Sun's architecture is a Bad Idea. Sun's architecture
assumes that the JVM-specific code is always going to be implemented in
native methods. This puts an unnecessary burden on everyone making a JVM.

JVM-specific code might be native code or it might not. With a JNI in
bytecode, we offer everyone who wants to build their own JVM a critical
choice, a choice that Sun's architecture can't offer.

As for here and now, we have to work with classes that we already have. As
unfortunate as it might be, decaf is using class libraries from a foreign
JVM. We don't have the source code to all of the classes in the java.*
packages yet. At first, we were going to write them ourselves. Then, we
hoped that the classpath project would write most of the code for us.
Meanwhile, the development of decaf goes on.

There is nothing in the java.* packages that would require a method to be
implemented as native. Native is oblique to the method signature. This
means that the JOS Project can build a version of the Java class libraries
that are byte-for-byte reusable on every JVM.

To emphasise this point, the JOS Project can offer standard copies the
java.* packages that everybody can use -- unchanged -- in their
experimental JVM. The software community can implement both core and
extended class libraries once and they'll run on every JVM. Work is done
once for all time. That is a benefit of extreme software reuse.

It could build a JOS community. If it works, everybody gets something that
works. If there is a bug, everybody gets the bug.

Plus, public and protected methods in the java.* packages are the only
methods that we must clone to implement the Java platform. While private or
default methods are not required, I believe these might be helpful to
implement in order to continue our cooperation with the classpath project.

>e.g. a large portion of the java.lang.Math Class and almost all of the
>java.net package do NOT have to implement all of the native methods,
>because these (bytecode)methods will be handled by the classes in the
>jos.core packages (or should I say modules...:-) ).

Does jos.jni replace jos.core? Or is my explanation of jos.jni what was
meant by jos.core? jos.core is where we meant to put common code.

After thinking about a just-for-JOS version of JNI, I am sure that jos.core
is just about the worst place we could put JVM-specific classes. JOS JNI
separates the interfaces needed by classes in java.* packages from their
JVM-specific implementations. Shouldn't decaf, for example, use its own
packages for its own JVM-specific implementation?

I'm sure that the decaf-specific implementation will have many things in
common with other JOS-compatible JVMs. Even then, the common JVM-specific
bytecode wouldn't go in jos.core (would it?).




From gchii@mindspring.com Mon, 22 Nov 1999 11:44:09 -0500
Date: Mon, 22 Nov 1999 11:44:09 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] What is JOS?

At 01:31 AM 11/22/99 -0500, digigod@earthling.net wrote:
>Firstly, org.jos.core is something entirely different from JOSCore it
should be reffered to as: "jos core".

You have helped a lot. That explains it in a nutshell.

>The confusion with JOSBox/JOSystem and JOSCore/JOSExtensions is because they
>are -- conceptually -- unrelated. You are correct in saying that
>JOSCore/JOSExtensions are not layers -- they are more like divisions.

I like the idea of JOS "divisions" too. JOSCore and JOSExtensions are not
layers, but divisions.

Then, there is another way we might think about JOSCore and JOSExtensions.
We can determine if a JVM is "JOS-compatible" when it implements all of the
requirements of JOSCore. A JVM is still "JOS-compatible" even when it does
not fully implement all of JOSExtensions. And when a JVM offers an
extension, the extension must be compatible with our JOSExtension model.

Even as we haven't been able to implement JOS ourselves, we can describe
some sort of a description of what is and what is not JOS. This description
shows what we are planning to build in the future.

>JOSCore is the "minimum" required *of* JOSBox/JOSystem to boot; JOSExtensions
>is all those extravegant extra's like device drivers. JOSCore allows
>JOSExtensions to shape the OS, allowing it to fill any niche: embedded,
>personal or server. Simply put, JOSExtensions is anything not required to
>boot the OS in JOSBox/JOSystem (allthough you'll probably need that
>handful of drivers to get pong up and running). 

Let me run this past you. With the invention of a JNI in bytecode, it might
be as simple as this.

A JOSBox must implement 
(1) a kernel,
(2) a Java virtual machine, and
(3) a jos_jni_getObject( jString ) method, the only true native method.

A JOSystem must redistribute
(1) java.* packages from the JOS Project, modified to use just-for-JOS JNI,
and
(2) jos.jni and jos.native packages.

The JOS Project writes the implementation of jos.jni. The JOS Project does
the research and discusses every detail that goes into jos.jni.native. The
JOS Project downloads the java.* packages from classpath. We rework them to
use the just-for-JOS JNI in bytecode.

We might have solved the puzzle. By providing THE native method, the
designer of a custom JVM has every flexibility to implement the
jos.jni.native interfaces.

For example, someone will surely want the extremely good performance of
fully planned and pre-compiled structures, just like the Java 0 Platform.
Behind the scenes, it is completely up to the discretion of the JVM
designer to do this. We don't have to know. Neither do any of our
applications.

Hey! If we truely want to write most of the OS in bytecode, I can't think
of a better way. We only write one truely native method; but it is a
gateway to the other world. Since we would prefer more bytecode than not,
we would write our own JVM with lots of bytecode and few (none?) native
methods.




From gchii@mindspring.com Mon, 22 Nov 1999 12:12:02 -0500
Date: Mon, 22 Nov 1999 12:12:02 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Classpath Project?

What is the current status of the classpath project?

Are their classes ready for us to use in the JOS Project?

How many members of the JOS Project are also working on classpath?




From George.Marrows@Smallworld.co.uk Mon, 22 Nov 1999 17:38:37 -0000
Date: Mon, 22 Nov 1999 17:38:37 -0000
From: George.Marrows@Smallworld.co.uk George.Marrows@Smallworld.co.uk
Subject: [JOS-Arch] TCP/IP stack ...

I think the biggest problem with the current state of things is that when
the gc is running (or indeed any other long-running part of jjos / decaf --
though gc is by far the worst offender), interrupts will of course still get
handled, but just get put in a queue to be dealt with later from Java.
There's no chance for the driver to talk back to the device until the gc has
finished.

I must admit to not knowing how stringent the real-time pressures are on
device-drivers, or what manipulations they have to do in real-time. I'm
assuming it's pretty limited - eg say thanks to the device, copy some memory
- but please correct me if I'm wrong (examples would be nice). If there's
not too much to be done or resources needed to do it, then perhaps the
following would work, and has the advantage of not needing native threads
(which are a way off, I believe --is anyone giving them any thought?).

When an interrupt comes in, a small bit of device-specific native code (yes
I know we don't want that!) runs in the context of the interrupt to do the
necessary real-time stuff; any other work being queued for handling from
Java. The native code could perhaps be allowed access to existing objects on
the heap, but would not be able to create new ones or modify the
connectivity of objects (as this would risk race conditions with gc and
indeed the jvm). Or else it could have it's own non-heap bit of memory to
play in that the Java part of the driver could see also (via some native
method somehow). Does that work?

With native threads we could  have a similar scheme except that a very high
priority Java thread could run to do the real-time stuff by pre-empting any
GC that was going on. Again, it's access to the heap would have to be
carefully controlled.

Does this scheme have the potential to let the device drivers do their stuff
without having to wait for concurrent gc (which I fully believe to be a pig
and a looong way off)?

-- George

> -----Original Message-----
> From:	Todd L. Miller [SMTP:tmiller@haverford.edu]
> Sent:	Thursday, November 18, 1999 00:17
> To:	Geoff O'Callaghan
> Cc:	George.Marrows@Smallworld.co.uk; arch@jos.org
> Subject:	Re: [JOS-Arch] TCP/IP stack ...
> 
> > I imagine we're talking about plain old Java GC and the impact on
> real-time
> > systems.  ie. Not a good effect.  Some sort of concurrent GC which does
> not
> > stall threads during GC would be required.
> 
> 	There are three possible solutions to this; the first is to turn
> of GC while the real-time bits are running; the second is to implement
> some portion of somebody's real-time java spec; the third is to write
> 'some sort of concurrent GC'.  I think the third is the best solution,
> though it might be the hardest to implement.  I think that we can avoid
> GC'ing a specific thread (i.e. the currently-running one) because its
> root(s) are known...
> 
> -_Quinn



From iainshigeoka@yahoo.com Mon, 22 Nov 1999 11:37:13 -0600
Date: Mon, 22 Nov 1999 11:37:13 -0600
From: Iain Shigeoka iainshigeoka@yahoo.com
Subject: [JOS-Arch] What is JOS?

Hello,

Would someone be willing to try and summarize this information 
and either add it to:

http://www.metamech.com/wiki/view/Main/AboutJOS

or put a link on that page to a new page about the overall JOS 
architecture and nomeclature.

-iain

On 22 Nov 99, at 11:44, Gilbert Carl Herschberger II wrote:

> At 01:31 AM 11/22/99 -0500, digigod@earthling.net wrote:
> >Firstly, org.jos.core is something entirely different from JOSCore it
> should be reffered to as: "jos core".
> 
> You have helped a lot. That explains it in a nutshell.
> 
> >The confusion with JOSBox/JOSystem and JOSCore/JOSExtensions is because they
> >are -- conceptually -- unrelated. You are correct in saying that
> >JOSCore/JOSExtensions are not layers -- they are more like divisions.
> 
> I like the idea of JOS "divisions" too. JOSCore and JOSExtensions are not
> layers, but divisions.
> 
> Then, there is another way we might think about JOSCore and JOSExtensions.
> We can determine if a JVM is "JOS-compatible" when it implements all of the
> requirements of JOSCore. A JVM is still "JOS-compatible" even when it does
> not fully implement all of JOSExtensions. And when a JVM offers an
> extension, the extension must be compatible with our JOSExtension model.
> 
> Even as we haven't been able to implement JOS ourselves, we can describe
> some sort of a description of what is and what is not JOS. This description
> shows what we are planning to build in the future.
> 
> >JOSCore is the "minimum" required *of* JOSBox/JOSystem to boot; JOSExtensions
> >is all those extravegant extra's like device drivers. JOSCore allows
> >JOSExtensions to shape the OS, allowing it to fill any niche: embedded,
> >personal or server. Simply put, JOSExtensions is anything not required to
> >boot the OS in JOSBox/JOSystem (allthough you'll probably need that
> >handful of drivers to get pong up and running). 
> 
> Let me run this past you. With the invention of a JNI in bytecode, it might
> be as simple as this.
> 
> A JOSBox must implement 
> (1) a kernel,
> (2) a Java virtual machine, and
> (3) a jos_jni_getObject( jString ) method, the only true native method.
> 
> A JOSystem must redistribute
> (1) java.* packages from the JOS Project, modified to use just-for-JOS JNI,
> and
> (2) jos.jni and jos.native packages.
> 
> The JOS Project writes the implementation of jos.jni. The JOS Project does
> the research and discusses every detail that goes into jos.jni.native. The
> JOS Project downloads the java.* packages from classpath. We rework them to
> use the just-for-JOS JNI in bytecode.
> 
> We might have solved the puzzle. By providing THE native method, the
> designer of a custom JVM has every flexibility to implement the
> jos.jni.native interfaces.
> 
> For example, someone will surely want the extremely good performance of
> fully planned and pre-compiled structures, just like the Java 0 Platform.
> Behind the scenes, it is completely up to the discretion of the JVM
> designer to do this. We don't have to know. Neither do any of our
> applications.
> 
> Hey! If we truely want to write most of the OS in bytecode, I can't think
> of a better way. We only write one truely native method; but it is a
> gateway to the other world. Since we would prefer more bytecode than not,
> we would write our own JVM with lots of bytecode and few (none?) native
> methods.
> 
> 
> _______________________________________________
> Arch maillist  -  Arch@jos.org
> http://jos.org/mailman/listinfo/arch
> 





From gchii@mindspring.com Mon, 22 Nov 1999 12:55:21 -0500
Date: Mon, 22 Nov 1999 12:55:21 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Different architectures

Since JOS is capable of having different architectures, shouldn't we give a
new name to each new architecture? JOSBox/JOSystem is a general
architecture. An entire family of JVMs can be built upon it.

What should we call a JOS kernel with kernel modules? Earlier this week,
XVM was suggested. It is a great name. XVM might be an architecture where
any VM plugs into the kernel. It also assures us that our architecture is
not limited to only one kind of virtual machine.

What should we call a JOS kernel without kernel modules? It tightly binds
the kernel and VM together.

For me, the most exciting part is just-for-JOS JNI, not JOS kernel modules.
It is a separate issue. JOS JNI can be implemented with XVM, or not. decaf
could support just-for-JOS JNI with only minor modification. The
just-for-JOS JNI only explains how bytecode is bound to native code through
an system-wide object factory. It has no assumption about (1) multiple
process, (2) multiple modules or (3) kernel.

Yes, that's right. A just-for-JOS bytecode JNI has no assumption about
processor or platform. You can use just-for-JOS JNI on a foreign operating
system, like Linux or Windows.




From tmiller@haverford.edu Mon, 22 Nov 1999 13:03:33 -0500 (EST)
Date: Mon, 22 Nov 1999 13:03:33 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] bytecode JNI

	While it had crossed our minds over in kernel-land that most/many
native methods would actually be re-implemented in calls to bytecode, we
had been thinking more along the lines of trapping the native calls in the
JVM and re-exporting them to Java, so we'd have less to work to do porting
and maintaining classpath.

	On the other hand, Gilbert's idea for the implementation of
bytecode JNI is simply too brilliant to be ignored.  While there are
obviously tasks for which native code is unavoidable, all of them are
or should be JVM/kernel-specific, and it is therefore perfectly proper for
them to handled in a JVM/kernel-specific way.  (Tasks like writing bytes
into video ram, for instance, or starting a new process -- that is, the
interface for h/w access should be consistent, but how that native-calling
bytecode ends up executing the proper bits of machine code isn't
relevant; ditto process management, etc.)

	I'm in too much of a hurry to go into how much I like this idea,
despite it making more work* for whoever ports the class library, but it's
very, very, elegant, and very, very, powerful.

	More on this later, I hope :)

-_Quinn

* This assumes that classpath's native code would be readily portable to
jJOS, which may not be the case -- and doesn't include the work it would
take to make decaf JNI-compliant...




From tmiller@haverford.edu Mon, 22 Nov 1999 13:11:28 -0500 (EST)
Date: Mon, 22 Nov 1999 13:11:28 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] TCP/IP stack ...

> and has the advantage of not needing native threads
> (which are a way off, I believe --is anyone giving them any thought?).

	I believe -- correct me if I'm wrong here, JM, if you're on this
list -- that JM, who's writing the jJOS kernel, has thought about this
once or twice and still wakes up to screaming nightmares.  Apparently
the x86's idea of a process/thread is unbelievably barbaric.

	I've just finished implementing mapByteArray(), which will pass
back a Java byte array (single dim of length N) at a given physical
address A, so yes, a native device driver could scribble data into a
buffer somewhere and have Java access it.  Currently, mapByteArray()
doesn't interact at all with the GC, so Bad Things would happen if it gave
back memory above the 1 MB limit.  That, and it's an enourmous security
hole, but we don't a security model at present anyay.

	-_Quinn




From onewith1@flash.net Mon, 22 Nov 1999 22:05:14 -0600
Date: Mon, 22 Nov 1999 22:05:14 -0600
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] just-for-JOS JNI (was: What is JOS?)

I'm wanting to get a clearer picture on the just-for-JOS JNI.

Gilbert Carl Herschberger II <gchii@mindspring.com> wrote:
> Let me run this past you. With the invention of a JNI in bytecode, it
might
> be as simple as this.
>
> A JOSBox must implement
> (1) a kernel,
> (2) a Java virtual machine, and
> (3) a jos_jni_getObject( jString ) method, the only true native method.
>
> A JOSystem must redistribute
> (1) java.* packages from the JOS Project, modified to use just-for-JOS
JNI,
> and
> (2) jos.jni and jos.native packages.

When the JVM encounters a call to a method tagged "native", it instead calls
jos_jni_getObject( jString ), where jString is the string version of the
method name, with class and package prefixes.

Then this native, JVM method determines if there is a kernel or native JVM
method which handles this method, and calls it if it exists; or if it isn't
implemented natively, it instead calls the static factory method in
jos.jni.*.  That factory uses the SmartAPI to determine which object and
method to call to process this request.  I *hope* I got that right.

In such a way, even Sun's implementation of the java.* files don't need to
be recompiled.  Any existing code which depends upon "native" methods
wouldn't need to be recompiled.  And, we can have the added bonus of using
native code to implement basic functions.

-Matt




From gchii@mindspring.com Tue, 23 Nov 1999 10:35:16 -0500
Date: Tue, 23 Nov 1999 10:35:16 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] just-for-JOS JNI (was: What is JOS?)

At 10:05 PM 11/22/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
>I'm wanting to get a clearer picture on the just-for-JOS JNI.

Let's keep this kind of discussion going. I thought about it last night and
this morning. It keeps on getting better. The bytecode JNI and
"just-for-JOS JNI" discussion is good foundation. But, it isn't polished
enough to plug into the decaf JVM.

After some consideration, I found that the "J" in "JNI" is redundant. It
isn't so much a Java Native Interface -- that's the other API for classic
JVMs.

Instead, this thing is a general concept of all the JVM-specific classes
that might be implemented in bytecode. I suggest we use "BCNI" to refer to
the general idea.

>When the JVM encounters a call to a method tagged "native", it instead calls
>jos_jni_getObject( jString ), where jString is the string version of the
>method name, with class and package prefixes.

I like your idea of fully automatic detection and resolution. You're design
is feasible. A backward compatible JVM would be able to detect "native"
methods and call the right "method" in bytecode.

Obviously, a general purpose BCNI might have many different ways of doing
things. Unlike your idea, my BCNI design is not based on methods. Rather,
it is based on objects.

I modified my design based on your e-mail. Here is how my new object-level
BCNI design might work.

1. The JVM encounters a method with a "native" tag.

2. Real Native. Real native methods are part of a JVM-specific
implementation. The JVM invokes a real native method, using whatever
mechanism it needs and we're done resolving.

  public void example() {
    jos.demo.realNative();
  }

A classic JVM might translate the Java invocation of jos.demo.realNative()
into jos_demo_realNative(). But a BCNI-compatible JVM can translate the
entire method name into any thing it wants. A JVM can create a hash table
of its own native methods, from those subroutines statically linked at
link-time.

No particular naming convention is required. You can build a JVM on a
method-by-method basis. The important things is: we don't care.

The jos.jni.Factory.getObject() is a real native method. It is available to
all bytecode, as well. And decaf, for example, might scan a list of all
classes that have real native methods implemented in the decaf JVM.

3. You suggested a new kind of "native" method from bytecode viewpoint. It
is a kind of "native" methods that are not implemented as real native
methods. These are pseudo-native methods, implemented in bytecode.
Pseudo-native methods are not required; they are optional. A
cross-compatible JVM would not give up when it encounters a native method
that is not implemented in the JVM. Instead, it takes the name of the BCNI
interface and invokes the corresponding bytecode.

  void invoke_pseudo_method( jObject o ) {
    jString cn = o.getClass().getName();
    jString s;

    if ( cn.equals( java.io.FileInputStream ) ) {
      s = "jos.jni.native.NativeFileInputStream";
    }

    if ( cn.equals( java.io.FileOutputStream ) ) {
      s = "jos.jni.native.NativeFileOutputStream" );
    }
    :
    jObject o = jos_jni_Factory_getObject( s );
    invokeVirtual( o, m );
  }

I have been unable to find a way to invoke a pseudo-native method; but, it
looks promising. It might be the bridge we need to use classpath as is,
without streamlined BCNI customization.

4. In my original design, class libraries are completely streamlined for
BCNI. This is a mechanism to obtain instances of JVM-specific classes
implemented in bytecode. When you write java.io.FileInputStream for BCNI,
you get a JVM-specific class by passing the name of the interface.

  package java.io;
  public class FileInputStream {
    static {
      String s = "jos.jni.native.FileInputStream";
      tool = (NativeFileInputStream) jos.jni.getObject( s );
    }

    private static NativeFileInputStream tool;
    :
  }

>Then this native, JVM method determines if there is a kernel or native JVM
>method which handles this method, and calls it if it exists; or if it isn't
>implemented natively, it instead calls the static factory method in
>jos.jni.*.  That factory uses the SmartAPI to determine which object and
>method to call to process this request.  I *hope* I got that right.

The JVM determines if there's a machine language subroutine which handles
this method. The JVM can use any mechanism to determine this. The JVM can
call any subroutine. It might be implemented in the kernel, a shared
library, or code of its own.

Oops. In my earlier example, I mistakenly used the Smart API as if the
Smart API and jos.jni.Factory were already connected.

  package java.io;
  public class FileInputStream {
    static {
      URI uri = new URI( "bcni:jos.jni.native.FileInputStream" );
      tool = (NativeFileInputStream) uri.getObject();
    }

    private NativeFileInputStream tool;
    :
  }

Um, well. Someday, the Smart API might be connected to jos.jni.Factory. We
only need to implement a BCNI controller. While jos.jni.Factory and Smart
API are object factories, Smart API isn't implementable by jos.jni.Factory.
While jos.jni.Factory is meant to be one per JVM (system-wide), Smart API
is meant to be one per class loader.

>In such a way, even Sun's implementation of the java.* files don't need to
>be recompiled.  Any existing code which depends upon "native" methods
>wouldn't need to be recompiled.  And, we can have the added bonus of using
>native code to implement basic functions.

With the introduction of pseudo-native methods, Sun's implementation of the
java.* packages don't need to be recompiled. This might reduce the amount
of work required to get the JVM up-and-running.

On the other hand, pseudo-native methods have added a complexity to the
basic design of BCNI that needs additional explanation. The streamlined
BCNI is simpler if we could do the extra work. A JVM, like decaf, would
invoke real native methods from one of two places: jos.jni.* and
org.jos.decaf.*.

In order for this to be uniform for all JVMs everywhere, a common set of
org.jos.native interfaces is required. When skipping over the common
interfaces, each JVM must map its own pseudo-native methods. While this
might not be uniform, it would be expedient.

What should we call it?

"BCNI" is Bytecode Native Interface. It is a general idea. Expect BCNI to
mature over time.

"Streamlined BCNI" sounds like a good implementation name for an
implementation of BCNI where there are no native methods in the java.*
packages. It takes a lot of effort to recast the java.* packages in a
streamlined BCNI. I believe that this effort would be well worth it. Why?
Because such a modification might make it possible for anyone with
streamlined BCNI to implement a Java platform with the highest possible
flexibility and freedom.

"Classic BCNI" sounds like a good name for an implementation of BCNI where
there are native methods in the java.* packages, like those packages
created by Sun. It provides all of the critical benefits of BCNI. Anyone
already distributing a classic JVM can quickly upgrade to the classic BCNI.

"Streamlined BCNI" requires you to have source code to the java.* packages.
On the other hand, Classic BCNI does not. Classic BCNI might be your only
choice when working from the pre-compiled class libraries. While the whole
idea of pseudo-native methods might be confusing, only the JVM developer
has to worry about it. The JVM hides all of this complexity from the Java
programmer.

Both forms of BCNI require a JVM developer to write native methods. The
amount of effort to create native methods is equal.

We want to use the java.* packages sooner rather than later. Where should
we start? decaf works with pre-compiled class libraries. I think we should
start with the Classic BCNI and pseudo-native methods. We can put off the
design of jos.jni.native interfaces for later.

We might reexamine this issue when classpath is further along.




From gchii@mindspring.com Wed, 24 Nov 1999 15:53:57 -0500
Date: Wed, 24 Nov 1999 15:53:57 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] BCNI API - Release 1a

Distribution 1 of Bytecode Native Interface (BCNI) - Release 1a is
available now at

http://www.metamech.com/wiki/view/Main/JOSDistribution1a#bcni1a

It is a significant improvement over the design suggested here.

(a) The jos.jni.Factory class assumes that every JVM must have at least one
native method. The org.jos.bcni1a.Factory class does not.

(b) jos.jni.Factory is called directly, using
jos.jni.Factory.getObject(...). On the other hand, org.jos.bcni1a.Factory
is called indirectly using org.jos.bcni1a.Factory.getFactory().getObject(...).

(c) A JOS JVM can install its own extension of org.jos.bcni1a.Factory
before executing any other bytecode. Only the first request to install a
BCNI factory is useful. All other requests are ignored.

This is better because it puts Factory in the org.jos.* packages where any
JOS application can use it.

This is better because methods can be added to Factory and many
implementations of Factory can exist at the same time within one JVM.

This is better because decaf can be fully implemented while looking for
native methods in the java.* packages. When decaf detects a native method,
it decides whether to call machine code or not.

This is better because it is fully compatible with Java Native Interface on
a classic JVM. Did you catch that? JNI can be useful when bringing BCNI to
existing JVMs. We can partially (a) design, (b) develop and (c) debug
JVM-specific classes on any JVM, making these classes available to a Java
application through BCNI.

I did it this morning.

 - I installed BCNI classes on my Windows 95 machine.

 - I installed my copy of JNI from IBM. (IBM got it from Sun.)

 - I created a new NativeFactory class, something like this:

   public class NativeFactory
       extends Factory {
     static {
       Runtime.getRuntime().loadLibrary( "bcni1a" );
     }
     public NativeFactory() {
     }
     public native Object getObject();
   }

 - I used javah -jni NativeFactory to build nativefactory.h.

 - I implemented Java_NativeFactory in bcni1a.cpp. It always prints the
given interface name (using printf) and always returns null.

 - I used Borland C++ 5.0 to build bcni1a.dll.

 - I installed bcni1a.dll on Windows 95.

 - I started JRE/Universal Browser, which in turn uses the Smart API, which
in turn uses the new BCNIController.

 - I typed in this URI:

   bcni:interface-name

 - org.jos.bcni1a.Factory is used by default. It printed out this message:

   BCNI Request: interface-name

 - I restarted JRE/Universal Browser and typed in this URI:

   bcni:interface-name?install=NativeFactory

 - The machine code in bcni1a.dll printed the interface name, like this:

   BCNI (JNI) Request: interface-name

This means that members of the JOS Project can write the bulk of our
bytecode for JOS on any JVM on any platform, using existing tools, like
javac, and IDEs like FreeBuilder and JBuilder. In the end, this bytecode
runs -- unmodified -- on decaf.

It means that members of the JOS Project can write the bulk of our machine
code for JOS on any JVM on any platform, using Java Native Interface. In
the end, the source code is recompiled into the JOS platform.

It means that members of the JOS Project can incorporate C/C++ code from
other shared libraries into JOS.

What's next?




From digigod@earthling.net Wed, 24 Nov 1999 18:24:09 -0500 (EST)
Date: Wed, 24 Nov 1999 18:24:09 -0500 (EST)
From: digigod@earthling.net digigod@earthling.net
Subject: [JOS-Arch] What is JOS?

> >The confusion with JOSBox/JOSystem and JOSCore/JOSExtensions is because they
> >are -- conceptually -- unrelated. You are correct in saying that
> >JOSCore/JOSExtensions are not layers -- they are more like divisions.
> 
> I like the idea of JOS "divisions" too. JOSCore and JOSExtensions are not
> layers, but divisions.
> 
> Then, there is another way we might think about JOSCore and JOSExtensions.
> We can determine if a JVM is "JOS-compatible" when it implements all of the
> requirements of JOSCore. A JVM is still "JOS-compatible" even when it does
> not fully implement all of JOSExtensions. And when a JVM offers an
> extension, the extension must be compatible with our JOSExtension model.

JOSExtensions requiring JOSCore's extension system
 
> Even as we haven't been able to implement JOS ourselves, we can describe
> some sort of a description of what is and what is not JOS. This description
> shows what we are planning to build in the future.
> 
> >JOSCore is the "minimum" required *of* JOSBox/JOSystem to boot; JOSExtensions
> >is all those extravegant extra's like device drivers. JOSCore allows
> >JOSExtensions to shape the OS, allowing it to fill any niche: embedded,
> >personal or server. Simply put, JOSExtensions is anything not required to
> >boot the OS in JOSBox/JOSystem (allthough you'll probably need that
> >handful of drivers to get pong up and running). 
> 
> Let me run this past you. With the invention of a JNI in bytecode, it might
> be as simple as this.
> 
> A JOSBox must implement 
> (1) a kernel,
> (2) a Java virtual machine, and
> (3) a jos_jni_getObject( jString ) method, the only true native method.

technically a JOSBox doesn't require a kernel, if you were to run an "emulator JOS" you'd need a JOSBox sans kernel that worked like an application.
 
> A JOSystem must redistribute
> (1) java.* packages from the JOS Project, modified to use just-for-JOS JNI,
> and
> (2) jos.jni and jos.native packages.

perhaps we need a third division JOSLibraries (further divided into CoreLibraries and ExtensionLibraries), as a library may be neither core or extension.

lets say to be JOS-comp. you need this:
 (1) JOSCoreLibraries (includes java.* --putting the 'J' in JOS)
 (2) a JOSBox
 (3) a JOSystem

then, to be a JOSBox you need:
 (1) a JOS compatabile VM
 (2) everything needed to get the PlatformAPI's working
 (3) module support or whatever we find work, in the end

and to be a JOSystem you need:
 (1) the bytecode ("real") kernel: init.class
 (2) the extension system (for devices, drivers and the like)
 (3) a solid API for JOSBox access. Well, two: one for low-level stuff as required by the drivers; and one for more high-level stuff like managing processes

I consider JOSBox and JOSystem to be the active components in JOS, they are the first things loaded into memory and they are never unloaded from memory. You can't do anything in JOS without JOSystem (and hence, JOSBox). Of course no one knows this (not even the application programmers) because, unless your making a JOS-specific app (for some reason that, for the sake of argument, is germane), JADE does it for you (you click on the icon it proccesses the info and makes a call to JOSystem to create a process for the app). This is why I consider JOSBox the hardware and JOSystem the OS. I'd also like to note I dont consider JADE to be nessecary to the function of JOS, which is why it is an application and not part of the OS (JOSystem); its only use is on PC's to allow users to easily run apps in a generic fashion, and while that is our key market that doesnt effect its placement in JOS.

Cheers,
DigiGod
_________________________
Quote of the Moment:
        No, I'm Canadian. It's like an American, but without a 
        gun.
              -Dave Foley
_________________________
Prank of the Moment:
	Using the conferencing feature of your office phone, dial
	one Induhvidual, then while it's ringing dial another and
	conference them together. Put your own phone on mute
	and listen to see how long they'll make small talk before
	figuring out that neither one placed the call.
O-
----------------------------------------------------------------
Get your free email from AltaVista at http://altavista.iname.com



From gchii@mindspring.com Thu, 25 Nov 1999 22:21:35 -0500
Date: Thu, 25 Nov 1999 22:21:35 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Smart API - Release 2a

Distribution 3 is now available for the Smart API - Release 2a. For more
details, see also

http://www.metamech.com/wiki/view/Main/JOSDistribution1d#smartapi2a

The next step in the project is to create "icons" for a desktop. These are
components that paint a "picture" without an external .gif or .jpg file. On
top of the picture, this component must paint a label, possibly centered
and word-wrapped. It looks like the right time to return to my Paintable
collection.

Anyone care to help?




From gchii@mindspring.com Fri, 26 Nov 1999 12:41:57 -0500
Date: Fri, 26 Nov 1999 12:41:57 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] Article announcement - Universal Browser

UniversalBrowser is a new article on JOS Wiki. For everyone who wants to
see what the Universal Browser might look like, here is the place to look.

Then, there's a question of how Universal Browser runs on JOS. Here is one
possible scenario.

Sometime during March of the year 2000...

When I turn on my JOS machine, it boots from my hard drive. My JOS machine
loads jJOS. jJOS loads decaf. decaf loads init.class. init.class loads
BCNI, system-wide registry and all those device drivers. And then...

And then the init.class creates a new class loader. The new class loader is
used to start JADE. Another class loader is used to starts the Universal
Browser. From the Universal Browser you can start (1) any Java application
that implements a static void main( String[] ) method. You can start (2)
any applet,  (3) any process, (4) any program, (5) any desktop, (6) any
browser and (7) any servlet.

It is because both Smart API and Universal Browser are open-ended and
future oriented, there's more. Yes, you can put an HTML browser inside. You
can put a servlet browser inside. You can put a "control panel" browser
inside. You can do anything you want.

And because it is perfectly compatible from one release to the next, you
can build software that lasts. You can build it now. Why wait?




From gchii@mindspring.com Fri, 26 Nov 1999 12:53:23 -0500
Date: Fri, 26 Nov 1999 12:53:23 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] HTML browser

The HTML browser is obviously missing from the Universal Browser. Why is
that? Because there's nothing overwhelmingly defective in the HTML browser
you already have. I have been procrastinating under "If it ain't broke,
don't fix it."

To be "finished" and "complete" the Universal Browser needs an HTML browser
plug-in. Then, we can add an HTML button to the toolbar. HTML browser is
expected to implement all of its own plug-ins, providing the usual features
of applets, plain text, FTP, HTML, image, sound and telnet client.

Both the Applet Browser and HTML browser support applets. Is this
redundent? All of the browsers have things in common. The Applet Browser
runs an applet entirely without the complexities of HTML, codebase, and a
security manager. On the other hand, an HTML browser expects only an applet
embedded inside an HTML page. The Applet Browser is great for developing
applets, running applets that have already been written, testing applets
with parameters and unexpected (real-world) conditions. An HTML browser is
great for integrating an applet into an HTML page, publishing an applet
across the Internet/intranet, and demonstrating the applet after all of the
difficult development work has been done.

The Applet Browser is a little more sophisticated than appletrunner, the
tool from a Java Development Kit. While appletrunner still requires you to
know HTML, the applet browser does not. Applet Browser, like JavaBee, makes
it much easier to use the applet to get your work done.

There is a need for everything.




From onewith1@flash.net Sat, 27 Nov 1999 09:56:12 -0600
Date: Sat, 27 Nov 1999 09:56:12 -0600
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] BCNI API - Release 1a

Gilbert Carl Herschberger II <gchii@mindspring.com> wrote:
> This is better because it is fully compatible with Java Native Interface
on
> a classic JVM. Did you catch that? JNI can be useful when bringing BCNI to
> existing JVMs. We can partially (a) design, (b) develop and (c) debug
> JVM-specific classes on any JVM, making these classes available to a Java
> application through BCNI.
>
> I did it this morning.

<snip for brevity>

> This means that members of the JOS Project can write the bulk of our
> bytecode for JOS on any JVM on any platform, using existing tools, like
> javac, and IDEs like FreeBuilder and JBuilder. In the end, this bytecode
> runs -- unmodified -- on decaf.
>
> It means that members of the JOS Project can write the bulk of our machine
> code for JOS on any JVM on any platform, using Java Native Interface. In
> the end, the source code is recompiled into the JOS platform.
>
> It means that members of the JOS Project can incorporate C/C++ code from
> other shared libraries into JOS.

I've been wondering to myself for the last couple of days why one would need
this base factory to have one native method.

The best I can figure, is that it allows any classloader which opens this
class to be forced to use the only implementation system wide.  In other
words, Multiple classloaders, and even multiple JVMs if set up right, can
share the same method, and it will return objects shared between
classloaders (and even JVMs).  Thus, giving us a shared object model.

My questions, then.  Note that some of these may be due to my ignorace of
the neuances of JNI.

1) Which classloader (or even JVM) are the returned objects associated with?
Is there a way to determine this?  (Does it matter?  Yes!  Especially if the
JVM it was loaded with has a System.exit() performed on it!)

2) I can forsee a major problem.  The BNCI has a setup to return an
interface to the low-level harddrive.  Say that JVM #1 is running, with its
architecture setup to use FAT-32 for the file system on the harddrive
interface.  Whereas JVM #2 has its architecture setup to use OS/2's HPFS on
the same harddrive interface.  Both JVMs are running at the same time, so
the harddrive is thus absolutely corrupted upon the first write to it.

Do we solve this by putting all the underlying architecture in the BNCI
access (so that java.io.File would access the Kernel/Kernel Module level
support, as opposed to the JVM level support)?  How do we enforce this?

Note: This is an example for a more general problem.  The same thing can
happen with networking, sound support, video access, and nearly anything
else that uses the hardware directly.

3) If the Kernel returns the particular architecture entry point for a given
hardware device, how do we support a Java implementation of this
architecture, especially on setup?

From questions 1 and 3, I'm seeing a pattern.  There could (should?) be a
"Super JVM" from which the basic kernel functionality is run.  All
Application level Java functionality could (should?) be run in separate JVMs
from the Kernel.

This way, all these other JVMs can share the Kernel resources via the single
native entry point.  Since the kernel is aware of where the "Super JVM"
(perhaps Kernel JVM is a better term) is, it uses that JVM for creating all
objects, yet returns them to the requesting JVM.

Is this feasable?

-Matt




From onewith1@flash.net Sat, 27 Nov 1999 10:02:46 -0600
Date: Sat, 27 Nov 1999 10:02:46 -0600
From: Matt Albrecht onewith1@flash.net
Subject: [JOS-Arch] HTML browser

Gilbert Carl Herschberger II <gchii@mindspring.com> wrote:
> To be "finished" and "complete" the Universal Browser needs an HTML
browser
> plug-in. Then, we can add an HTML button to the toolbar. HTML browser is
> expected to implement all of its own plug-ins, providing the usual
features
> of applets, plain text, FTP, HTML, image, sound and telnet client.

HTML uses many different kinds of viewers for its content.  The base viewer,
of course, is the HTML Viewer, but it can imbed within it other kinds of
viewers.  In general, this seems to be in reference to: 1) The HTML tags
informing what to put there, and 2) The mime type of the retrieved "object".

A really good HTML browser can use an "Edtor" as well.  Where am I going
with this?

The SmartAPI could use the mime-type (or be given the mime-type) for
returning the kind of editor/viewer desired.  This would be dependent upon
the Editor/Viewer Controller class, but could work.

-Matt




From gchii@mindspring.com Sat, 27 Nov 1999 12:21:02 -0500
Date: Sat, 27 Nov 1999 12:21:02 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] BCNI API - Release 1a

At 09:56 AM 11/27/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
>I've been wondering to myself for the last couple of days why one would need
>this base factory to have one native method.

Why do we need one native method? A mostly-bytecode operating system would
need one native method to push the object factory "below" the line. There's
a thin line between the JVM and the Java class libraries. They are
co-dependent and are expected to play well together. JVM and class
libraries must work in harmony to accomplish its purpose.

The classic JVM has many native methods to push the JVM-specific
functionality "below" the line. A classic JVM based on Sun's class
libraries are cross-connected in so many ways. As more methods "go native"
on us, it is increasingly difficult to build a JVM that provides everything
expected by the Java class libraries.

In machine code, a native method might use an application-wide object or a
system-wide object. It calls upon the resources of the applcation, its
shared libraries to use application-wide objects, such as standard in and
standard out. It calls upon the resources of the kernel and its platform
API to use system-wide objects, such as a file subsystem.

When writing for BCNI, you have similar options. A JVM-specifci class might
be implemented to use the resources of a JVM. It might also use the
resources of the kernel. It is up to the designer of a JVM to decide.

>The best I can figure, is that it allows any classloader which opens this
>class to be forced to use the only implementation system wide.  In other
>words, Multiple classloaders, and even multiple JVMs if set up right, can
>share the same method, and it will return objects shared between
>classloaders (and even JVMs).  Thus, giving us a shared object model.

It also has the desired side-effect of making choices as far as dependence
on a class loader. What is the static keyword used for? It classifies an
object reference a once-per-class loader. In the real world, there is also
a need for static at once-per-JVM and once-per-kernel. In a classic JVM,
the primordial class loader (null) classifies an object as once-per-JVM.

This classification has an impact on the life-expectance of a class. When
you use a custom class loader, you can garbage-collect a program and all of
its classes. This enables a servlet environment to reload servlets, such as
when an upgrade becomes available.

When you use a primordial class loader, a class must persist until you
destroy the JVM. (Otherwise the JVM gets terribly confused.)

What we need is a system-wide class loader. This class loader is closely
associated with the kernel. A class using the system-wide class loader will
persist until you restart the kernel. Many instances of a JVM will share
the system-wide class loader (and system-wide classes).

>From questions 1 and 3, I'm seeing a pattern.  There could (should?) be a
>"Super JVM" from which the basic kernel functionality is run.  All
>Application level Java functionality could (should?) be run in separate JVMs
>from the Kernel.

You're exactly right. There must be a "Super JVM" from which the basic
kernel functionality is run. A "Super JVM" provides a mostly-bytecode
processing space we have come to know as the "Primary Domain".

The "Super JVM" has the highest level of authority on your JOS machine. As
the highest level security domain, it supplies system-wide classes such as
all device drivers for hardware. All of the low-level device drivers run in
the unique environment provided by the Super JVM.

Classes for a file subsystem can only run inside the primary domain. From
your example, let's say that a "Super JVM" is running, with its
architecture setup to use FAT-32 for the file system on the hard drive
interface.

1. How do we go from one JVM to two? If there is ever a second JVM, it must
be loaded and launched by JVM #1. JVM #2 depends on the JVM #1 for every
connection to real hardware devices.

2. JVM #2 is a "secondary domain" with close association with an end-user
account (protected with a classic name and password). JVM #1 doesn't launch
another copy of itself. It launches a JVM with far less authority than itself.

3. With less authority, JVM #2 will fail in any attempt to start OS/2's
HPFS on the same hard drive interface. Typically, it will be able to get
high-level objects only through the BCNI. So, the hard drive is protected
as any hard drive should be.

Going to the next level...

While JVM #1 is running, it maintains the root of the object graph for all
Java objects. JVM #1 creates and controls the system-wide class loader and
the system-wide class path. JVM #1 determines what classes are trusted
enough to run inside the primary domain and where to get these classes
(stored locally or across the network).

As JVM #1 launches other JVMs, other JVMs get a new object graph, new
security profile, new "primordial" class loader, and a new class path. The
classes running in a secondard JVM might be experimental. Secondard JVMs
enable the architecture to be multple-user.

A secondard JVM does not need to be modified extensively to deal with (1) a
new pair of standard in and standard out, (2) a new "static" Runtime object
with its exit() method. As JVM #1 launches other JVMs, JVM #1 gives the new
JVM its own class loader. It might be a real class loader (not null).

With its own class loader, the "static" Runtime object is inherently
different than the static Runtime object for JVM #1.

JVM #1 has the power to shutdown JVM #2 whenever it feels like it. Plus,
you can "reboot" JVM #1 without rebooting your kernel.

When an application running inside a secondary JVM calls Runtime.exit(), it
is a signal to JVM #1 to close JVM #2. The entire JVM #2 is
garbage-collected. In fact, the result code from JVM #2 can be returned to
JVM #1 (if any other process is interested).

When an application running inside a primary JVM calls Runtime.exit(), it
is a signal to JVM #1 to close itself and all the other JVMs and return to
the kernel. If the kernel has been signaled to "reboot" JVM #1, a return
from JVM #1 causes the kernel to start JVM #1 all over again with its
system-wide object graph, system-wide class loader, and device detection.
The rest of the start-up sequence is performed to the point where you're
looking at a brand new environment.

Such a "reboot" is necessary if you recompile any bytecode below the
system-wide class loader. JVM #1 still has a few classes that must be
loaded before bytecode kicks in. This is like restarting the java tool on a
foreign OS. While the java tool is "down", new classes can be installed,
classpath can be modified and the java tool restarted.

JVM #1 can use additional class loaders for device drivers. By
garbage-collecting the class loader, a device driver can be upgraded and
restarted without rebooting the entire OS. Certain hardware might not be
compatible with this approach. But this architecture must enable this
flexibility for all the hardware today and in the future that's dynamically
and independently restarted. The OS file subsystem itself can be
re-configured and re-mounted even while applications are running.

When we talk about saving time and effort on the JOS Project, I make the
following proposal:

Why not think about each bytecode interpreter as a separate class loader
and JVM? None of the bytecode in java.lang.Runtime needs to be rewritten
when a bytecode interpreter comes to its end. It is garbage-collected when
an application calls Runtime.exit().

By taking advantage of BCNI and pseudo-native methods, even the
complexities of Runtime.exit() are greatly simplified.

By this architecture, such a platform can support all the Java platforms:
0, 1, 2 and beyond. Even while the "Super JVM" is running in Java 2, a
secondard JVM -- with its own classpath -- can provide applications brand
new classes for Java 3.




From gchii@mindspring.com Sat, 27 Nov 1999 12:53:23 -0500
Date: Sat, 27 Nov 1999 12:53:23 -0500
From: Gilbert Carl Herschberger II gchii@mindspring.com
Subject: [JOS-Arch] HTML browser

At 10:02 AM 11/27/99 -0600, "Matt Albrecht" <onewith1@flash.net> wrote:
>The SmartAPI could use the mime-type (or be given the mime-type) for
>returning the kind of editor/viewer desired.  This would be dependent upon
>the Editor/Viewer Controller class, but could work.

A browser is a client agent. An HTML browser is an advanced client agent.
The client agent is part of the presentation of a digital resource. As a
client agent, an HTML browser should be concerned with mime-type.

On one hand, SmartAPI doesn't implicitely select an editor or viewer based
on a given URI. The SmartAPI is a subsystem for all kinds of programs, not
just browsers. The SmartAPI has nothing to do with the presentation of a
digital resource. While a browser might use the SmartAPI to create all
kinds of digital resources (including editors, viewers and other browsers),
the SmartAPI doesn't use mime-types. SmartAPI uses protocols and protocol
chaining to get you the document you want. The SmartAPI has reached the end
of its scope when it delivers a document to a client agent. What the client
agent does with it after that is up to the client agent.

On the other hand, it is a Good Idea to create a MIMEFactory and plug it
into the SmartAPI. The MIMEFactory can use whatever mechanism it wants to
select an editor/viewer. To plug into the SmartAPI, it must use its own
explicit protocol. It might benefit from protocol chaining.

It might provide a viewer by default.

  mime:[viewer:]awt[version]:<document>
  mime:[viewer:]swing[version]:<document>
  mime:editor:awt[version]:<document>
  mime:editor:swing[version]:<document>

A mime-based browser must explicitely prefix a <document> with the kind of
editor/viewer it expects. Specifically, a AWT-compatible browser gets AWT
components and a Swing-compatible browser gets Swing-compatible components.




From tmiller@haverford.edu Sun, 28 Nov 1999 04:14:52 -0500 (EST)
Date: Sun, 28 Nov 1999 04:14:52 -0500 (EST)
From: Todd L. Miller tmiller@haverford.edu
Subject: [JOS-Arch] BCNI API - Release 1a

	The system-wide classloader is just the primordial classloader.
Its job is only to load enough classes to implement processes.  These
processes == the multiple JVMs you've been talking about.  (The Sun model
is one process == one JVM.  This does not have to be the case, and
implementing multiple java processes will be much easier than introducing
native multiprocessing.)  When the primordial classloader allows the
generation of classloaders without arbitrary shared classes, we get
processes; I believe I've spoken on this list about this before.  All the
primordial class loader needs to do then, is load the classes that manage
h/w access before spawning any new classloaders, enforcing system-wide
classes.  Concieving of the secondary JVMs as processes also immediately
returns you to the UNIX model of user-inherited permissions on a process.

> A secondard JVM does not need to be modified extensively to deal with (1) a
> new pair of standard in and standard out, (2) a new "static" Runtime object
> with its exit() method. As JVM #1 launches other JVMs, JVM #1 gives the new
> JVM its own class loader. It might be a real class loader (not null).
>
> With its own class loader, the "static" Runtime object is inherently
> different than the static Runtime object for JVM #1.
>
> When an application running inside a secondary JVM calls Runtime.exit(), it
> is a signal to JVM #1 to close JVM #2. The entire JVM #2 is
> garbage-collected. In fact, the result code from JVM #2 can be returned to
> JVM #1 (if any other process is interested).

	Right on; you're saying exactly what I have about multiple
processes in the same JVM.  All sorts of problems go away when you control
the classloaders :)  The only difference -- which is worth noting -- is
that different versions of the Java platform do, in fact, require
different interpreters, so for that to work, multiple JVMs (multiple
native processes) are in fact necessary, though I hadn't realized before
that process model can be cleanly extended to doing multiple JVMs in this
way.  Anyway, the kernel group isn't expecting to have multiple native
processes for a while yet, but you shouldn't be able to tell the
difference as long as you're using a uniform platform revision.


> Why not think about each bytecode interpreter as a separate class loader
> and JVM? None of the bytecode in java.lang.Runtime needs to be rewritten
> when a bytecode interpreter comes to its end. It is garbage-collected when
> an application calls Runtime.exit().

	Yup!  I have phrased it as "each process as a separate class
loader" but adopting Sun's pov (JVM == process), this make sense; given
that the JVM is actually the same, we're in total agreement here.  (How
remarkable! ;))

> By taking advantage of BCNI and pseudo-native methods, even the
> complexities of Runtime.exit() are greatly simplified.

	Well, BCNI isn't necessary for any of this, but it certainly
helps.

-_Quinn






From Matt.Albrecht@trilogy.com Tue, 30 Nov 1999 10:39:24 -0600
Date: Tue, 30 Nov 1999 10:39:24 -0600
From: Matt.Albrecht@trilogy.com Matt.Albrecht@trilogy.com
Subject: [JOS-Arch] Why Not To Use Statics

I was reviewing StefansAPIStructureProposal, and some of Gilbert's notes on
it.  I remember having discussed here why using static methods and fields
is bad, but I can't recall the arguments (but I know it stemmed from
problems with static void main() ).  Was it having to do with subclassing
and overloading problems?  I just want to get a clearer picture in my head.
Thanks.


"A gaping head wound is just nature's way of telling you to slow down."
-Matt






