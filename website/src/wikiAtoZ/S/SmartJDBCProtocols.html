<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
    <TITLE>SmartJDBCProtocols.Main @ jos.sf.net</TITLE>
  </HEAD>

<BODY BGCOLOR="#FFFFFF">

<!-- The FORM encloses the entire header, because it renders better that way. !-->
<FORM ACTION="/jump.php"><input type="hidden" name="PHPSESSID" value="ce33051d1f870662699662653891618b" />

<!-- The JOS logo. !-->
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR VALIGN="TOP" ALIGN="LEFT">
	<TD><A HREF="http://cjos.sourceforge.net/archive/"><IMG 
		VSPACE="0" HSPACE="0" ALIGN="MIDDLE" BORDER="0"
		SRC="http://cjos.sourceforge.net/archive/media/jos_logo_mini.gif"></A></TD>
	<!-- The tab table. !-->
	<TD WIDTH="100%" ALIGN="RIGHT" BGCOLOR="#FFFFFF" VALIGN="BOTTOM"> 
		<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%" ALIGN="RIGHT">
			<TR VALIGN="MIDDLE" ALIGN="LEFT">

<TD BGCOLOR="White" WIDTH="60%">&nbsp;</TD>
<TD BGCOLOR="#FFFFCC"><A HREF="http://cjos.sourceforge.net/archive/">Home</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/info/">Info</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/dev/">DevZone</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFCC66" ALIGN="CENTER"><A
HREF="http://jos.sourceforge.net/">Wiki</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
			</TR>
			<TR>
				<TD BGCOLOR="#FFCC66" ALIGN="RIGHT" COLSPAN="9">
					<A HREF="/view/Users/?PHPSESSID=ce33051d1f870662699662653891618b">UsersWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Main/?PHPSESSID=ce33051d1f870662699662653891618b">MainWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Info/?PHPSESSID=ce33051d1f870662699662653891618b">InfoWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/DevZone/?PHPSESSID=ce33051d1f870662699662653891618b">DevZoneWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Support/?PHPSESSID=ce33051d1f870662699662653891618b">SupportWeb</A>
				</TD>
			</TR>
		</TABLE>
	</TD>		
</TR>
<!-- The WikiHeader. !-->
<TR><TD COLSPAN="2">
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="CENTER">
		<B>[&nbsp;<a href="/info//SmartJDBCProtocols?PHPSESSID=ce33051d1f870662699662653891618b">SmartJDBCProtocols</a>&nbsp;]</B>
	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="CENTER">
		<B>[ not logged in ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="CENTER">
		<B>[ Web: <a href="/view/Main/?PHPSESSID=ce33051d1f870662699662653891618b">Main</a> ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFCC66" VALIGN="CENTER">
		goto:&nbsp;<INPUT TYPE="TEXT" SIZE="10" NAME="topic"><!--<INPUT TYPE="IMAGE" SRC="/media/go.gif?PHPSESSID=ce33051d1f870662699662653891618b" BORDER="0" VALUE="topic" ALT="goto">!-->&nbsp;<a href="/search.php?PHPSESSID=ce33051d1f870662699662653891618b"><FONT SIZE="-1">options</FONT></a>
	</TD>
</TR>
</TABLE>

<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
	<TR>
	<TD ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="TOP">
		[&nbsp;get <a href="/info/Main/SmartJDBCProtocols?PHPSESSID=ce33051d1f870662699662653891618b">info</a> on or <a href="/edit/Main/SmartJDBCProtocols?PHPSESSID=ce33051d1f870662699662653891618b">edit</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="TOP">
		[&nbsp;<a href="/user.php?op=login&redirect=%2Fview%2F%2FSmartJDBCProtocols&PHPSESSID=ce33051d1f870662699662653891618b">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FSmartJDBCProtocols&PHPSESSID=ce33051d1f870662699662653891618b">new&nbsp;user</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="TOP">
		[&nbsp;list of <a href="/topics/Main/?PHPSESSID=ce33051d1f870662699662653891618b">topics</a>, <a href="/hubsnodes/Main/?PHPSESSID=ce33051d1f870662699662653891618b">hubs&nbsp;&amp;&nbsp;nodes</a>, or <a href="/changes/Main/?PHPSESSID=ce33051d1f870662699662653891618b">recent&nbsp;changes</a>&nbsp;]	</TD>
	</TR>
</TABLE>

<!-- From CommonHeader !-->
</TR></TD>
</TABLE>
</FORM>

<!-- start BODY page !-->
<P>
<a href="/view.php?topic=SmartProtocolPages&PHPSESSID=ce33051d1f870662699662653891618b">SmartProtocolPages</a><wikitopic SmartProtocolPages /wikitopic>; <a href="/view.php?topic=SmartAPIConnectionFactory&PHPSESSID=ce33051d1f870662699662653891618b">SmartAPIConnectionFactory</a><wikitopic SmartAPIConnectionFactory /wikitopic>; <a href="/view.php?topic=CjOSPages&PHPSESSID=ce33051d1f870662699662653891618b">CjOSPages</a><wikitopic CjOSPages /wikitopic>
<HR>
<h3>Overview</h3>
<h4>About this document</h4>
Article contributed by <a href="/view.php?topic=GilbertHerschberger&PHPSESSID=ce33051d1f870662699662653891618b">GilbertHerschberger</a><wikitopic GilbertHerschberger /wikitopic> (29 September 1999, updated 27 December 2001, updated 18 May 2004).
<h4>Introduction</h4>
The jdbc: scheme is used to create a connection using the Java Database Connectivity <nolink>API, otherwise known as a <nolink>JDBC connection. The <nolink>JDBC <nolink>API provides a "driver manager" class to manage a collection of custom <nolink>JDBC drivers. Every database is expected to have its own drivers.
</P><P>
While the built-in <nolink>JDBC driver manager is functional, it is barely adequate. The Connection Factory is better. The Connection Factory is a plug-in for the Smart <nolink>API. For example, the Connection Factory does not require an explicit step to pre-register a <nolink>JDBC driver. Pre-registering a driver adds unnecessary complexity to driver configuration. Rather, a pre-configured controller is created for each subscheme/driver combination. In turn, these controllers are plugged into the generic Connection Factory. An application uses the Connection Factory to create connections and only connections.
</P><P>
The Connection Factory is future oriented. Anyone can create a subscheme/driver controller and plug it into their Connection Factory. A central collection of controllers would make it much easier to jump into <nolink>JDBC programming without having to learn so much unnecessary trivia about the internal workings of the <nolink>JDBC driver <nolink>API.
</P><P>
<H4>Connection example</H4>
The following example illustrates the simplicity using the smart connection factory to create a <nolink>JDBC-ODBC connection:
<PRE>
  public void example() {
    URI uri = new URI( "jdbc:odbc:JOSDEMO" +
        "?user=ANONYMOUS&amp;password=ANONYMOUS" );
    Connection c = (Connection) uri.getObject();
    if ( c == null ) {
      return;
    }

    try {
      c.close();
    }
    catch( SQLException e ) {
    }
  }
</PRE>
</P><P>
When the jdbc: scheme is presented to the Smart <nolink>API, it is dispatched to the Connection Factory plug-in. In turn, when the jdbc:odbc: scheme is presented to the Connection Factory plug-in, it is dispatched to the <nolink>ODBC Connection Controller. In turn, the <nolink>ODBC Connection Controller loads a specific driver, the JDBC-ODBC Bridge driver, as needed. The controller uses the driver manager to return a connection object. An application programmer needs only the <nolink>URI to get a database connection.
</P><P>
<H4>Statement example</H4>
Every connection should be capable of creating a statement. It is part of the connection interface. The following example illustrates using the statement: scheme to create a <nolink>JDBC-compatible statement object:
<PRE>
  public void example() {
    URI uri = new URI( "statement:jdbc:odbc:JOSDEMO" +
        "?user=ANONYMOUS&amp;password=ANONYMOUS" );
    Statement s = (Statement) uri.getObject();
    if ( s == null ) {
      return;
    }

    try {
      s.close();
    }
    catch( SQLException e ) {
    }

    try {
      s.getConnection().close();
    }
    catch( SQLException e ) {
    }
  }
</PRE>
</P><P>
"Scheme chaining" is a technique for assembling a specific digital resource. One scheme depends upon another to modify or convert a digital resource from one well-known interface to another. Here we are using scheme chaining to convert a connection to a statement.
</P><P>
<h4>Datasource example</h4>
The datasource: subscheme supports an external configuration file, <code>jdbc.datasource.ini</code>. Here is a configuration file for our example:
<PRE>
section=test

[test]
josdemo=jdbc:odbc:JOSDEMO?user=ANONYMOUS&amp;password=ANONYMOUS
</pre>
</P><P>
The datasource: scheme provides a connection pool. It always uses another <nolink>URI to open a connection. The datasource: scheme returns an instance of <code>java.sql.Connection</code>.
</P><P>
</P><P>
<PRE>
  public void example() {
    URI uri = new URI( "jdbc:datasource:josdemo" );
    Connection c = (Connection) uri.getObject();
    if ( c == null ) {
      return;
    }

    try {
      onConnection( c );
    }
    finally {
      try {
        c.close();
      }
      catch( SQLException e ) {
      }
    }
  }
</pre>
</P><P>
<h4>Database example</h4>
A typical <nolink>JDBC request involves a connection, a statement and a result set. These properties have been combined into a well-known interface called <code>org.jos.database1a.Database</code>. The database: scheme returns an instance of this interface. With a database, your custom codes does not need to explicitly close a connection, statement or result set, not even when invoking multiple <nolink>SQL statements.
</P><P>
</P><P>
</P><P>
</P><P>
</P><P>
<PRE>
  public void example() {
    URI uri = new URI( "database:odbc:JOSDEMO" +
        "?user=ANONYMOUS&amp;password=ANONYMOUS" );
    // or rather URI uri = new URI( "database:datasource:josdemo" );
    Database db = (Database) uri.getObject();
    if ( db == null ) {
      return;
    }

    try {
      onDatabase( db );
    }
    finally {
      try {
        db.close();
      }
      catch( SQLException e ) {
      }
    }
  }
</pre>
</P><P>
Certain code is always required to reference and close a connection, statement and result set. This code is encapsulated in a <nolink>Database object to reuse it instead of (re)writing it into your application.
</P><P>
<HR>
</P><P>
<h3>Schemes and Subschemes</h3>
<h4>Introduction</h4>
A scheme is a type of digital resource. A scheme should be the first part of a Uniform Resource Identifier, or <nolink>URI, and can be used to find a resource factory. For example, a <nolink>JDBC Connection is a digital resource. This type of resource can be identified with the jdbc: scheme.
</P><P>
A series of schemes can be arraged in a hiearchy. Subsequent schemes are sometimes called subschemes. A subscheme is a subtype and used to find a more specific factory.
</P><P>
<H4>Scheme</H4>
The following table contains <nolink>JDBC-related schemes and its well-known interfaces.
</P><P>
</P><P>
<table border="2" cellspacing="2" cellpadding="2"><TR><TD> <STRONG>Scheme</STRONG> </TD><TD> <STRONG>Interface</STRONG> </TD><TD> <STRONG>Description</STRONG> </TD></TR>
<TR><TD> <code>database:</code> </TD><TD> <code>org.jos.database1a.Database</code> </TD><TD> This scheme expects a jdbc: subscheme and returns an instance of a well-known Database interface. </TD></TR>
<TR><TD> <CODE>jdbc:</CODE> </TD><TD> <CODE>java.sql.Connection</CODE> </TD><TD> This scheme expects a <nolink>JDBC subscheme. The Connection Factory is responsible for creating a connection. It encapsulates the process of loading any <nolink>JDBC drivers, parsing user and password parameters, and using the driver manager to create a connection. This factory expects a <nolink>JDBC <nolink>URL to follow the scheme of a specific subprotocol. User and/or password parameters must be passed as a query string for all connections which requires them. </TD></TR>
<TR><TD> <CODE>statement:</CODE> </TD><TD> <CODE>java.sql.Statement</CODE> </TD><TD> This protocol expects the <CODE>jdbc:</CODE> protocol above. The statement factory is responsible for creating a statement from a connection. It encapsulates the process of loading any <nolink>JDBC driver, parsing user and password parameters and, finally, creating a statement from the connection. </TD></TR>
</TABLE>
<H4>Subscheme</H4>
The following table contains some of the <nolink>JDBC subschemes and their well-known interfaces.
<table border="2" cellspacing="2" cellpadding="2"><TR><TD> <STRONG>Subscheme</STRONG> </TD><TD> <STRONG>Interface</STRONG> </TD><TD> <STRONG>Description</STRONG> </TD></TR>
<TR><TD> <CODE>as400:</CODE> </TD><TD> <CODE>java.sql.Connection</CODE> </TD><TD> This subscheme loads the AS/400 <nolink>JDBC driver (if necessary) and returns a new <nolink>JDBC connection. </TD></TR>
<TR><TD> <code>csv:</code> </TD><TD> <code>java.sql.Connection</code> </TD><TD> This subscheme loads the Fositex <nolink>CVS driver (if necessary) and returns a new connection. </TD></TR>
<TR><TD> <code>datasource:</code> </TD><TD> <code>java.sql.Connection</code> </TD><TD> This subscheme uses an external configuration file, <code>jdbc.datasource.ini</code>, to load another jdbc: <nolink>URI by name. It also provides a connection pool. </TD></TR>
<TR><TD> <CODE>db2:</CODE> </TD><TD> <CODE>java.sql.Connection</CODE> </TD><TD> This subscheme loads the DB2 <nolink>JDBC driver (if necessary) and returns a new connection. </TD></TR>
<TR><TD> <code>microsoft:sqlserver:</code> </TD><TD> <code>java.sql.Connection</code> </TD><TD> This subscheme loads the Microsoft <nolink>SQL Server <nolink>JDBC Driver (if necessary) and returns a new connection. </TD></TR>
<TR><TD> <code>mysql:</code> </TD><TD> <code>java.sql.Connection</code> </TD><TD> This subscheme loads the <nolink>MySQL Connector/J driver (if necessary) and returns a new connection. </TD></TR>
<TR><TD> <CODE>odbc:</CODE> </TD><TD> <CODE>java.sql.Connection</CODE> </TD><TD> This subscheme loads the <nolink>JDBC-ODBC driver (if necessary) and returns a new connection.</TD></TR>
<TR><TD> <code>oracle:thin:</code> </TD><TD> <code>java.sql.Connection</code> </TD><TD> This subscheme load the Oracle <nolink>JDBC driver (if necessary) and returns a new connection. </TD></TR>
</TABLE>
<HR>
<h3>Feedback</h3>
<h4>About a <nolink>JDBC pool</h4>
Gilbert:
</P><P>
This could be much better if you returned a JDBCPool instead.  The JDBCPool interface would have three methods at least required:
<UL> <LI> Connection getConnection()
<LI> void releaseConnection(Connection c)
<LI> void failConnection(Connection c) (called when a <a href="/view.php?topic=SQL&web=Main&PHPSESSID=ce33051d1f870662699662653891618b">SQL</a> <wikitopic SQL /wikitopic>Exception is thrown to tell the pool to get rid of the connection out of the pool)
</UL> 
This way you could hide the implementation of the pool behind the <a href="/view.php?topic=SmartAPI&PHPSESSID=ce33051d1f870662699662653891618b">SmartAPI</a><wikitopic SmartAPI /wikitopic> and define performance characteristics via the <a href="/view.php?topic=SmartAPI&PHPSESSID=ce33051d1f870662699662653891618b">SmartAPI</a><wikitopic SmartAPI /wikitopic> configuration of the pool.
</P><P>
Once this was done, you could go even further and define a set of brokers that do the connection handling in one place, eliminating the need boilerplate error handling and connection closing code everywhere you use JDBC.
</P><P>
I've done this for my work and it is of huge advantage.  You eliminate a lot of bugs from other teammembers not doing the boilerplate code right for their situation and connections getting lost in the ether.
</P><P>
</P><P>
</P><P>
Heres some hints on how to design it:
<UL> <LI> interface <a href="/view.php?topic=ConnectionHandler&PHPSESSID=ce33051d1f870662699662653891618b">ConnectionHandler</a><wikitopic ConnectionHandler /wikitopic>
<UL> <LI> (implementation's constructor would always take a JDBCPool as a parameter)
<LI> void getResults(Query query, <a href="/view.php?topic=ResultFiller&PHPSESSID=ce33051d1f870662699662653891618b">ResultFiller</a><wikitopic ResultFiller /wikitopic> filler) throws SQLException);
<UL> <LI> Do all connection handling here, delegating to the query to get the statement of whatever type (regular, prepared, etc), and to the filler to iterate over the <a href="/view.php?topic=ResultSet&PHPSESSID=ce33051d1f870662699662653891618b">ResultSet</a><wikitopic ResultSet /wikitopic>.
</UL> </UL> <LI> interface Query
<UL> <LI> Statement prepareStatement(Connection c) throws SQLException;
<LI> boolean hasMoreStatements();
<UL> <LI> handles prepared statements where you call execute() multiple times
</UL> </UL> <LI> interface <a href="/view.php?topic=ResultSet&PHPSESSID=ce33051d1f870662699662653891618b">ResultSet</a><wikitopic ResultSet /wikitopic>
<UL> <LI> void fill(ResultSet rs) throws SQLException;
<LI> void setException(Throwable t);
<LI> void checkException() throws (whatever type of wrapper exception you want);
<LI> void complete();
<LI> void join(); (wait until complete() is called by the <a href="/view.php?topic=ConnectionHandler&PHPSESSID=ce33051d1f870662699662653891618b">ConnectionHandler</a><wikitopic ConnectionHandler /wikitopic>)
</UL> </UL> 
Once all this is done you can define standard implementations:
<UL> <LI> <a href="/view.php?topic=ConnectionHandler&PHPSESSID=ce33051d1f870662699662653891618b">ConnectionHandler</a><wikitopic ConnectionHandler /wikitopic> -&gt; <a href="/view.php?topic=AsyncConnectionHandler&PHPSESSID=ce33051d1f870662699662653891618b">AsyncConnectionHandler</a><wikitopic AsyncConnectionHandler /wikitopic> (do the work in seperate thread)
<LI> Query -&gt; <a href="/view.php?topic=SimpleQuery&PHPSESSID=ce33051d1f870662699662653891618b">SimpleQuery</a><wikitopic SimpleQuery /wikitopic>, <a href="/view.php?topic=PreparedQuery&PHPSESSID=ce33051d1f870662699662653891618b">PreparedQuery</a><wikitopic PreparedQuery /wikitopic>, etc
<LI> <a href="/view.php?topic=ResultFiller&PHPSESSID=ce33051d1f870662699662653891618b">ResultFiller</a><wikitopic ResultFiller /wikitopic> -&gt; <a href="/view.php?topic=TableResultFiller&PHPSESSID=ce33051d1f870662699662653891618b">TableResultFiller</a><wikitopic TableResultFiller /wikitopic> (fills a non-visual table with the results off of the database, or <a href="/view.php?topic=SwingTableResultFiller&PHPSESSID=ce33051d1f870662699662653891618b">SwingTableResultFiller</a><wikitopic SwingTableResultFiller /wikitopic> if you prefer)
<LI> etc.
</UL> 
Your example then can become:
<PRE>
public void example() throws WhateverWrapperException {
    URI uri = new URI( "tableResult:Async:jdbc:odbc:JOSDEMO" +
                       "?user=ANONYMOUS;password=ANONYMOUS"+ // ideally this would be pulled from a config file
                       "?sql=SELECT * FROM ATABLE" );
    TableResultFiller filler = (TableResultFiller) uri.getObject();
    if ( filler  == null ) {
        return;
    }

    Table t = filler.getTable(); // this method would wait until the first 
                                 // result came back then dynamically create
                                 // the Table and call checkException()
    RowIterator rows = t.getRows();
    while(rows.hasMoreRows()) { // the implementation of the table would have a 
                                // complete() method that would be called by the 
                                // ResultFiller implementation's complete() method
        // fill a JSP bean or whatever you want to do.
        // Do compuationally expensive operations at the same time
        // as the network intensive pulling of the JDBC data happens
    }
    
}
</PRE>
</P><P>
Notice that no explicit connection handling occurs in your user code.
</P><P>
-Avery
</P><P>
Thanks, Avery. Your tableresult:async: scheme is easily supported. It can do all that you describe. When invoked, it should return an instance of <code>TableResultFiller</code> or <code>null</code>. Here is the procedure:
</P><P>
<OL> <LI> Define <code>TableResultFiller</code> as an interface. This enables you to support multiple implementations.
<LI> Create a basic implementation of the <code>TableResultFiller</code> interface.
<LI> Create <code>TableResultFillerController</code>, a plug-in for Smart <nolink>API. By extending <code>BaseController</code>, it can easily implent your scheme by invoking <code>super( "tableresult:async:" )</code> in its constructor.
</OL> 
Your tableresult:async: scheme is easily tested. Here is code that tests a single controller:
<PRE>
  public void runTest() {
    URI uri = new URI( "tableresult:async:datasource:josdemo" +
                       "?sql=SELECT+*+FROM+ATABLE" );

    // plug in alternative controller here
    uri.setController( new TableResultFillerController() );

    TableResultFiller filler = (TableResultFiller) uri.getObject();
    if ( filler  == null ) {
        return;
    }

  }
</pre>
</P><P>
Just one thing. Certain characters are not valid within a <nolink>URI. Please be aware that an <nolink>SQL statement should be <nolink>URI encoded by the calling code and then <nolink>URI decoded by your controller so that it is preserved. For example, <pre>sql=select * from <a href="/view.php?topic=ATABLE&web=Main&PHPSESSID=ce33051d1f870662699662653891618b">ATABLE</a> <wikitopic ATABLE /wikitopic>where f1='a'</pre> becomes something like <pre>sql=select+*+from+ATABLE+where+f1%3F'a'</pre>.
</P><P>
-- <a href="/view.php?topic=GilbertHerschberger&PHPSESSID=ce33051d1f870662699662653891618b">GilbertHerschberger</a><wikitopic GilbertHerschberger /wikitopic><BR><BR></P><!--

<TABLE width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="737b9c">
<TR><TD ALIGN="CENTER">
<a href="/user.php?op=login&redirect=%2Fview%2F%2FSmartJDBCProtocols&PHPSESSID=ce33051d1f870662699662653891618b">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FSmartJDBCProtocols&PHPSESSID=ce33051d1f870662699662653891618b">new&nbsp;user</a><TR><TD>
</TABLE>

!-->
<!-- end BODY page !-->

<HR>

<DIV ALIGN="CENTER">
<TABLE BORDER="0" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR>
	<TD ALIGN="CENTER" COLSPAN="2">
		Content of these pages are owned and copyrighted by the poster.
	</TD>
</TR>
<TR>
	<TD ALIGN="RIGHT" WIDTH="50%">
		Hosted by:
	</TD>
	<TD ALIGN="LEFT">
		<A HREF="http://sourceforge.net/"><IMG 
			SRC="http://sourceforge.net/sflogo.php?group_id=2376&type=1"
			BORDER=0 HSPACE=0 VSPACE=0></A>
	</TD>
</TR>
</TABLE>
</DIV>
</BODY>
</HTML>
