<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
    <TITLE>SmartAPIProposal.Imported @ jos.sf.net</TITLE>
  </HEAD>

<BODY BGCOLOR="#FFFFFF">

<!-- The FORM encloses the entire header, because it renders better that way. !-->
<FORM ACTION="/jump.php"><input type="hidden" name="PHPSESSID" value="becd042f61d1b17a5e0d81fef27bcb48" />

<!-- The JOS logo. !-->
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR VALIGN="TOP" ALIGN="LEFT">
	<TD><A HREF="http://cjos.sourceforge.net/archive/"><IMG 
		VSPACE="0" HSPACE="0" ALIGN="MIDDLE" BORDER="0"
		SRC="http://cjos.sourceforge.net/archive/media/jos_logo_mini.gif"></A></TD>
	<!-- The tab table. !-->
	<TD WIDTH="100%" ALIGN="RIGHT" BGCOLOR="#FFFFFF" VALIGN="BOTTOM"> 
		<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%" ALIGN="RIGHT">
			<TR VALIGN="MIDDLE" ALIGN="LEFT">

<TD BGCOLOR="White" WIDTH="60%">&nbsp;</TD>
<TD BGCOLOR="#FFFFCC"><A HREF="http://cjos.sourceforge.net/archive/">Home</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/info/">Info</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/dev/">DevZone</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFCC66" ALIGN="CENTER"><A
HREF="http://jos.sourceforge.net/">Wiki</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
			</TR>
			<TR>
				<TD BGCOLOR="#FFCC66" ALIGN="RIGHT" COLSPAN="9">
					<A HREF="/view/Users/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">UsersWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Main/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">MainWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Info/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">InfoWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/DevZone/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">DevZoneWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Support/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">SupportWeb</A>
				</TD>
			</TR>
		</TABLE>
	</TD>		
</TR>
<!-- The WikiHeader. !-->
<TR><TD COLSPAN="2">
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="CENTER">
		<B>[&nbsp;<a href="/info//SmartAPIProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">SmartAPIProposal</a>&nbsp;]</B>
	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="CENTER">
		<B>[ not logged in ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="CENTER">
		<B>[ Web: <a href="/view/Imported/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">Imported</a> ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFCC66" VALIGN="CENTER">
		goto:&nbsp;<INPUT TYPE="TEXT" SIZE="10" NAME="topic"><!--<INPUT TYPE="IMAGE" SRC="/media/go.gif?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48" BORDER="0" VALUE="topic" ALT="goto">!-->&nbsp;<a href="/search.php?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48"><FONT SIZE="-1">options</FONT></a>
	</TD>
</TR>
</TABLE>

<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
	<TR>
	<TD ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="TOP">
		[&nbsp;get <a href="/info/Imported/SmartAPIProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">info</a> on or <a href="/edit/Imported/SmartAPIProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">edit</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="TOP">
		[&nbsp;<a href="/user.php?op=login&redirect=%2Fview%2F%2FSmartAPIProposal&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FSmartAPIProposal&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">new&nbsp;user</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="TOP">
		[&nbsp;list of <a href="/topics/Imported/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">topics</a>, <a href="/hubsnodes/Imported/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">hubs&nbsp;&amp;&nbsp;nodes</a>, or <a href="/changes/Imported/?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">recent&nbsp;changes</a>&nbsp;]	</TD>
	</TR>
</TABLE>

<!-- From CommonHeader !-->
</TR></TD>
</TABLE>
</FORM>

<!-- start BODY page !-->
<P>
<FONT SIZE=-1><a href="/view.php?topic=SmartAPIPages&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">SmartAPIPages</a><wikitopic SmartAPIPages /wikitopic></FONT>
<HR SIZE="1" NOSHADOW>
<EM>Article contributed by <a href="/view.php?topic=GilbertHerschberger&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">GilbertHerschberger</a><wikitopic GilbertHerschberger /wikitopic> (20 Jul 1999).</EM>
<H4>Summary</H4>
<BLOCKQUOTE><EM>It is neither necessary nor desirable to reuse namespace.</EM></BLOCKQUOTE>
<H4>Introduction</H4>
<P>An <nolink>API is one of the most important parts of a complete operating system. Sure, an operating system becomes well known for the performance of its kernel, its games and applications, and its ability to connect to all kinds of different devices. But, we cannot afford to ignore the <nolink>API.</P>
<P>Programmers need an great <nolink>API. Programmers write the games, applications and device drivers. Without an <nolink>API, there's hardware and a kernel that's difficult to work with.</P>
<P>Somebody has to write the <nolink>API. Most of the <nolink>API should be written by the same organization that wrote the kernel. Some of the <nolink>API can be written by other organizations, <EM>and should be.</EM></P>
<H4>About distributions</H4>
<P>We can solve an entire class of distribution problems with a smart <nolink>API. Rarely is any package required on every unique installation. Almost all of the packages are optional. A smart <nolink>API continues to work within normal operating parameters even when no optional package has been installed.
<OL>
<LI>Distribution and development are separate issues. We do not have to look at an operating system as a whole. The first distribution of an operating system, like JOS, is separate and distinct from the version of its kernel and all of the packages that are provided with a distribution. The (fictional) <nolink>JOS 1 distribution may or may not include all of the packages available. Some of the packages may not be ready for prime time distribution. The (fictional) <nolink>JOS 2 distribution may or may not include all of the packages available in <nolink>JOS 1.
<LI>After you install <nolink>JOS 1 distribution, you can download additional packages to manually upgrade from <nolink>JOS 1 to <nolink>JOS 2. The standard mechanism is to add new packages with new package names. With the new packages installed, you re-configure smart factories to use new packages, too.
<LI><STRONG>Downgrade</STRONG> It's possible you'd like to downgrade from <nolink>JOS 2 to <nolink>JOS 1. It happens. Even with the new packages installed, you re-configure smart factories to use old packages again.
<LI><STRONG>Experiment</STRONG> As a <nolink>JOS developer, you'd like to experiment with <nolink>JOS 2 implementations. No problem. You re-configure smart factories to point to the package you just wrote. You can change anything from the ground up. If it doesn't work, you re-configure smart factories to point to an earlier package that works.
<LI><STRONG>Share</STRONG> As a <nolink>JOS developer or application programmer, you can share your implementations with others. You put your code in a standard <nolink>JOS package and provide standard instructions for re-configuring a smart factory. Your code becomes an inherent part of other systems.
<LI><STRONG>Get extreme</STRONG> As a <nolink>JOS developer, you can go beyond the limits of a standard <nolink>JOS distribution. You can use the smart <nolink>API as a toolkit to develop a radical new <nolink>API. It doesn't have to include any interfaces or classes from an existing <nolink>API. And yet, the smart <nolink>API package makes your extreme <nolink>API compatible with <nolink>JOS.
</OL>
<P>Without a smart <nolink>API, distributions of an operating system must be carefully monitored. There are lots of rules to keep different distributions stable.</P>
<H4>About versioning</H4>
<P>We should tie our goal for the operating system to our approach to versioning. What do we want in a future-oriented operating systems? We want to produce a stable <EM>and</EM> constantly improving operating system. We want to build a future-oriented operating system. Since we're working with Java, the programming language, there is only one long-term strategy for versioning.</P>
<UL>
<LI><STRONG>Stable</STRONG> We want an <nolink>API that we can count on. It doesn't have to be complete. It doesn't have to be bug-free. But, above all else, it must be predictable. If it is stable and predictable, we have a chance to complete it and fix all of its bugs.
<LI><STRONG>Constantly improving</STRONG> We want an <nolink>API that we can count on to give us the latest and greatest implementation available on each machine. Each machine will be different. It is a choice of the person who owns the machine to decide which implementation they are going to use. Even when implementations are different, Java provides the perfect mechanism, the well-known interface, to give us an opportunity to improve.
</UL>
<P>Can we do both? Is it possible?</P>
<P>Have your cake and eat it, too. It has always been possible in theory for all of these other operating systems to be stable and constantly improving. For one reason or another, all of these other operating systems don't seem to do this well over the long term. (Unfortunately, this includes the Java <nolink>API).</P>
<P>When we combine Java, the programming language, with a smart <nolink>API architecture, we can build something that no one has ever been able to build before. It is a future-oriented operating system.</P>
<P>It won't have problems with versioning because the whole class of versioning problems is thrown out. Admit defeat. You can't use the same package names for different versions and win. Use different package names for different versions. And configure your smart factory to pick any version.
<UL>
<LI>Java provides a very large namespace. The namespace is so large that many programmers (including programmers at Sun Microsystems) don't quite know what to do with it.
<LI>Every package name must be unique. The package part of a class name must not conflict with other packages. To meet our requirements of building a stable operating system, we must not put more than one package under a single package name. This eliminates Sun Microsystems' proposal for versioning, with a secret namespace.
<LI>Class names can be reused, <EM>and should be</EM>. When upgrading an application from one <nolink>API to another, it is most thoughtful if the designer keeps the same class names (if possible). When moving from one <nolink>API to another, classes can be added and dropped. Methods can be added and dropped. There is almost total freedom to do the right thing. It is <EM>polite</EM> to keep the same class names. It is part of showing off your good manners.
<LI>Keep package names three levels deep. As a rule, package names should be no more than three levels deep. Sometimes, this rule might be broken if there is a special case.
</UL>
<H4>Package names</H4>
<P>We should be careful about the kind of example we immitate. We want to do something different, right? We want high quality operating system. We don't want an operating system that's just like all of the others. Should we match quality for quality of Sun Microsystems. I hope not. That would require us to lower our expectations.</P>
<P>Sun Microsystems sets a <STRONG>bad example</STRONG>. Look at what horrible things they've done to <CODE>java.sql</CODE>! We should not immitate their mistakes. Their own Java <nolink>API is not stable. You can't count on it. Neither is it constantly improving. It is not future-oriented.</P>
<TABLE WIDTH="90%">
<TR>
<TD>
<STRONG>Package</STRONG>
</TD>
<TD>
<STRONG>Note</STRONG>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">
<CODE>java.events</CODE>
</TD>
<TD>
<P>The <CODE>events</CODE> package stands alone. It provides generic events and listeners.</P>
<P>Events are not the exclusive domain of the Java AWT. Events are used by both Java Beans and Swing. Events are also used by non-visual classes.</P>
<P>Are all the interfaces and classes provided inside <CODE>java.awt.events</CODE> used by the <a href="/view.php?topic=AWT&web=Imported&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">AWT</a> <wikitopic AWT /wikitopic>and only the AWT? No. In practice, Sun Microsystems was short-sighted in their thinking. When the <CODE>events</CODE> package was created they couldn't imagine how it would be used in practice.</P>
<HR SIZE="1" NOSHADOW>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">
<CODE>java.reflection</CODE>
</TD>
<TD>
<P>The <CODE>reflection</CODE> package should stand alone. There should have been a separate <CODE>reflection.Class</CODE> class for reflecting classes. It was not necessary or advantageous to complicate the <CODE>lang.Class</CODE> class for reflection.</P>
<P>Are the interfaces and classes inside <CODE>reflection</CODE> used by the language and only the language? No. These are supposed to be used by beans, other <nolink>APIs and applications.</P>
<HR SIZE="1" NOSHADOW>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">
<CODE>com.sun.zip</CODE>
</TD>
<TD>
<P>Originally, Sun Microsystems put their <CODE>zip</CODE> package in <CODE>sun.util.zip</CODE>. Java worked just fine with it. Why didn't they leave it there? Was there anything technically difficult with zip as a separate package?</P>
<P>Archives are not required by any JVM. The class file format doesn't use archives. The zip archive might be popular; but, a <a href="/view.php?topic=JVM&web=Imported&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">JVM</a> <wikitopic JVM /wikitopic>can survive without it.</P>
<P>Zip is an archive file format. What does <CODE>util</CODE> add to the name of the <a href="/view.php?topic=ZIP&web=Imported&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">ZIP</a> <wikitopic ZIP /wikitopic>package? Utilities are everywhere inside the Java <nolink>API. Reflection is a utility. <a href="/view.php?topic=JDBC&web=Imported&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">JDBC</a> <wikitopic JDBC /wikitopic>is a utility. Servlet is a utility. Applet is a utility.</P>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">
<CODE>com.sun.jar</CODE>
</TD>
<TD>
<P>Jars are a special kinds of archive. It's an archive for Java. Maybe the jar package should be used by the JVM. Other archives should be used by the JVM, too. Why is there no <CODE>java.archive</CODE> package? A .cab file is an archive, too. Why is there no <CODE>java.cab</CODE> package?</P>
<P>Archives are still not required by a Java virtual machine. Some people continue to use jars because they are more like the C/C++ programs they used to know. Jars make it almost possible to use a static linking model in Java. A jar is self-contained. As long as your application is small and you don't want to re-use any code, jars are good enough.</P>
<P>Java 2 (JDK 1.2) uses a ~/lib/ext directory for your jar file collection (instead of the confounded classpath). But, that doesn't work either. A class can be stored in multiple jars inside the ~/lib/ext directory. Which one should the <a href="/view.php?topic=JVM&web=Imported&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">JVM</a> <wikitopic JVM /wikitopic>use? The <a href="/view.php?topic=JVM&web=Imported&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">JVM</a> <wikitopic JVM /wikitopic>still has problems with the semantics of the <CODE><STRONG>static</STRONG></CODE> keyword.
</TD>
</TR>
</TABLE>
<P>While Sun Microsystems fully expects you to abandon all of the code you wrote in Java 1.1, we cannot afford to keep abandoning source code that works. Our operating system must be able to last over a long time. We have to create a few design rules to keep it compatible. These rules are simple. When I follow them, I succeed. When I break them, I fail. We need to learn how to best use Java, the programming langauge. You can follow them if you want.</P>
<H4>Design rules for <CODE>org.jos.smartapi</CODE></H4>
<P>The <CODE>org.jos.smartapi</CODE> package must never have sub-packages. The smart <nolink>API toolkit stands alone. It can be used by any other package. It can be used on any Java-compatible platform.</P>
<UL>
<LI>This package contains interfaces, abstract and concrete packages. It is a optional toolkit and framework for building smart <nolink>APIs. Smart <nolink>APIs that use this package might benefit from the generic mechanisms that use any smart <nolink>API. It might be beneficial, for example, when configuring a smart <nolink>API to use a standard smart <nolink>API configuration program.
<LI>These interfaces and classes do not use a Jos prefix. Why? Because they are already found inside the <CODE>org.jos</CODE> package.
<LI>The design of these interfaces and classes cannot be changed. Bugs may be fixed. Optimizations may be performed. But, once released, no class can be <STRIKE>added or</STRIKE> dropped (depretiated). No method can be <STRIKE>added or</STRIKE> dropped.
<UL>
<LI><STRONG>Experts: Use extreme caution.</STRONG> As a rule, a package should not be changed once it has been released. No new classes or methods is good premise. On occasion, though, a new class can be introduced to a package without breaking backward compatibility. That's what maintenance programmers do for a living. An experienced maintenance programmer may be able to introduce a new class without bringing down the system. A new class may be a quick fix to a bug.</P>
<P>There is no such thing as a public software recall. Once a package has been released to the public, it cannot be recalled. You cannot build your application upon a package as if every machine has the new class when there are machines out there using the early release. You cannot guarantee that all machines have the latest release unless you own all of those machines.</P>
<P>What is true for new classes is also true for new methods. In general, a package should not be changed once it is released. It should not be re-released in the same namespace. It is possible to successfully introduce a new private method (most of the time), a new constructor (some of the time) or a new public/protected method (rarely).</P>
</UL>
</UL>
<H4>Versions</H4>
<P>The logical name of this package is <CODE>smartapi</CODE>. The physical name of the package must change over the long term.
<UL>
<LI>The first version shall be <CODE>org.jos.smartapi1a</CODE>.
<LI>The second version shall be <CODE>org.jos.smartapi1b</CODE>.
<LI>The next versions shall be <CODE>org.jos.smartapi1c</CODE>, <CODE>org.jos.smartapi1d</CODE> and so on.
<LI>JOS 2 versions might be <CODE>org.jos.smartapi2a</CODE>, <CODE>org.jos.smartapi2b</CODE> and so on.
<LI>JOS 3 versions might be <CODE>org.jos.smartapi3a</CODE>, <CODE>org.jos.smartapi3b</CODE> and so on.
</UL>
<P><EM>Note:</EM> All versions of this package can be installed on a single machine. Applications which depend on all versions of this package can run on a single machine. Every line of code in all versions of this package can be debugged without any problem.</P>
<H4>Name clashes</H4>
<P>There is no real need to avoid name clashes with other packages. This is unlike <A HREF="StefansAPIStructureProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48#designrules">Stefan's proposal</A>. The Java virtual machine and Java, the programming language, use fully qualified class names inside class files. The language provides a mechanism to use a specific class using its fully qualified name.</P>
<P>It is important when developing subsequent versions of an <nolink>API to reuse names. Changing an import statement may be the only thing required to upgrade from one <nolink>API to another.</P>
<UL>
<LI>It is not necessary for every public class to extends any well-known class (except <CODE>java.lang.Object</CODE>). This also is unlike <A HREF="StefansAPIStructureProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48#designrules">Stefan's proposal</A>.
<LI>Like <A HREF="StefansAPIStructureProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48#designrules">Stefan's proposal</A>, every future-oriented class (let's call it Example) should contains these elements:
<PRE>
public class Example {
  public static Example getXXX() {
	 if ( implementation == null ) {
		implementation = new Example();
	 }
	 return implementation;
  }
  public static void setXXX( Example v ) {
	 if ( implementation == null ) {
		implementation = v;
	 }
  }
  private static Example implementation = null;

  protected Example() {
  :
  }
:
}
</PRE>
<LI>Like <A HREF="StefansAPIStructureProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48#designrules">Stefan's proposal</A>, there should be no public static methods except <CODE>get/setXXX()</CODE> and there should be no public final methods.
</UL>
<H4>About abstract classes</H4>
<P>A smart <nolink>API should provide interfaces first. Then, if abstract classes are helpful, provide them, too. The reason is extensibility, the same reason given in Stephan's proposal.</P>
<BLOCKQUOTE><EM>Imagine we would want to extend a certain <nolink>JOS 1 interface in <nolink>JOS 2. If we added methods to the interface, <nolink>JOS 1 implementations of that interface wouldn't work in <nolink>JOS 2 (since they don't implement the new methods).</EM> -- Stefan <A HREF="StefansAPIStructureProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48#quote1">[1]</A></BLOCKQUOTE>
<P>The problem with this comes from the unspoken assumption that we must add methods to an interface <EM>after it has been released</EM>. There is no such requirement. The rules of a smart <nolink>API are very clear that you cannot add or drop methods for an interface (or any other class) after a package has been released.</P>
<BLOCKQUOTE><EM>So I think abstract classes are a much better choice. The only disadvantage I can see is that a given class can only inherit from one abstract class, while it can implement multiple interfaces. But in the presence of (anonymous) inner classes, this drawback is already less important.</EM> -- Stefan <A HREF="StefansAPIStructureProposal?PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48#quote2">[2]</A></BLOCKQUOTE>
<P>Abstract classes are not the best choice in the long term. The disadvantage mentioned is a huge and unnecessary disadvantage. In practice, a new <nolink>API can be made run-time compatible with an old <nolink>API.</P>
<UL>
<LI>A new <nolink>API might extend the interfaces of an old <nolink>API. This method is not recommended because both the old and the new <nolink>API must be installed in order for this to work.
<LI>You can use a bridge. A bridge implements an interface of a new <nolink>API and uses an interface of an old <nolink>API. The bridge typically uses the dispatch model to pass requests from the new interface to an implementation of an old interface. This method is far more flexible than extending an old interface.
<LI>You can build a future-oriented bridge. Using reflection and dynamic class loading, a bridge works only when the old <nolink>API exists on a machine. If the old <nolink>API doesn't exist, there's nothing a bridge can do.
<LI>An new <nolink>API is responsible for providing necessary bridges to old <nolink>APIs. The old package must not be changed for any reason, even to make an old <nolink>API look like a new <nolink>API.
</UL>
<H4>Releases</H4>
<P>Once a package has been released, these editing rules encourage stability.
<UL>
<LI>No existing classes are changed or removed. No new classes can be added.
<LI>No existing methods are changed or removed. No new public or protected methods can be added.
</UL>
<P>And yet, when you're moving from one version to another, you have total freedom to be completely rude and independent. While we would encourage politeness, we encourage working code even more.
<UL>
<LI>All classes can be changed or removed. New classes may be added. Classes can be renamed. Here is an opportunity to give a class the "right" name.
<LI>All methods can be changed or removed. New methods can be added. This applies across the board to public and protected methods, too.
<LI>New versions should attempt to become completely self-contained, even re-implementing all old interfaces. It should not depend on code inside an old version (even though it could).
<LI>New versions should attempt to implement bridges of compatibility. You should be easy for others to upgrade from one version to the next.
<LI>Do not make arbitrary changes. What is an arbitrary change? A change that, technically, wasn't needed after all. It's a judgement call.
<LI>After a release, you must create a new package to work in. Do not code "in place". Copy your code and test programs forward for the new release.
</UL>
<H4>How to use a smart factory</H4>
<P>A smart factory provides two or more mechanisms. There is a standard Java programming mechanism and a smart <nolink>API <a href="/view.php?topic=URL&web=Imported&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">URL</a> <wikitopic URL /wikitopic>mechanism.</P>
<PRE>
  public void example() {
	 X x = XFactory.getImplementation().getX();
	 if ( x == null ) {
		// there's no implementation of the X interface.
	 }
  }
</PRE>
or
<PRE>
  public void example() {
	 String url = "x:";
	 X x = (X) ObjectFactory.getImplementation().getObject( url );
	 if ( x == null ) {
		// there's no implementation of the X interface.
	 }
  }
</PRE>
<P>The configuration of standard smart factories are performed automatically. There is no code required in your application. Unlike <a href="/view.php?topic=StefansAPIStructureProposal&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">StefansAPIStructureProposal</a><wikitopic StefansAPIStructureProposal /wikitopic>, smart factories that take advantage of the smart <nolink>API as a toolkit are automatically configured through the system-wide registry.</P>
<H4><nolink>JOS Administration</H4>
<P>It must be easy to administer your local <nolink>JOS operating system. You should be able to install and recall any Java package. You should be able to choose when a package runs inside or outside a sandbox. You should be able to upgrade and downgrade when you want to.</P>
<P>The smart <nolink>API makes it possible to reduce the inter-dependencies of software applications. When we say that it runs on <nolink>JOS, it should run on <nolink>JOS. Period. It should run on any version of <nolink>JOS, anywhere. Upgrades should be painless, not painful. Smart factories are a matter of configuration, not programming.</P>
<P>While working with network administrators, I find that they do not want to deal with versioning. They don't want to put all their jars in a single ~/lib/ext directory. They want tools to configure a machine to use a list of Java packages. They would prefer the original copy of all Java packages to be stored on a central network-based application service. A machine is enabled to use a package (or not).</P>
<P>Network administrators want to choose (with a mouse click) if a package should be run inside or outside a sandbox. They don't want a vendor to make that decision. They don't want their choice reflected in an archive file. Their most recent choice should be immediately reflected on every machine, everywhere.</P>
<P>The administrator "installs" packages on an application service and configures packages on the service. The rest of the distribution process is on auto-pilot.</P>
<P>Administrators want to install and recall packages. They want to upgrade and downgrade. The administrator has the responsibility to make sure the business machines are up-and-running and secure.</P><BR><BR></P><!--

<TABLE width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="737b9c">
<TR><TD ALIGN="CENTER">
<a href="/user.php?op=login&redirect=%2Fview%2F%2FSmartAPIProposal&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FSmartAPIProposal&PHPSESSID=becd042f61d1b17a5e0d81fef27bcb48">new&nbsp;user</a><TR><TD>
</TABLE>

!-->
<!-- end BODY page !-->

<HR>

<DIV ALIGN="CENTER">
<TABLE BORDER="0" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR>
	<TD ALIGN="CENTER" COLSPAN="2">
		Content of these pages are owned and copyrighted by the poster.
	</TD>
</TR>
<TR>
	<TD ALIGN="RIGHT" WIDTH="50%">
		Hosted by:
	</TD>
	<TD ALIGN="LEFT">
		<A HREF="http://sourceforge.net/"><IMG 
			SRC="http://sourceforge.net/sflogo.php?group_id=2376&type=1"
			BORDER=0 HSPACE=0 VSPACE=0></A>
	</TD>
</TR>
</TABLE>
</DIV>
</BODY>
</HTML>
