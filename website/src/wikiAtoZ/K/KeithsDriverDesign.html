<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
    <TITLE>KeithsDriverDesign.Imported @ jos.sf.net</TITLE>
  </HEAD>

<BODY BGCOLOR="#FFFFFF">

<!-- The FORM encloses the entire header, because it renders better that way. !-->
<FORM ACTION="/jump.php"><input type="hidden" name="PHPSESSID" value="dedbe11a647f9a0b28eca7a189059d2f" />

<!-- The JOS logo. !-->
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR VALIGN="TOP" ALIGN="LEFT">
	<TD><A HREF="http://cjos.sourceforge.net/archive/"><IMG 
		VSPACE="0" HSPACE="0" ALIGN="MIDDLE" BORDER="0"
		SRC="http://cjos.sourceforge.net/archive/media/jos_logo_mini.gif"></A></TD>
	<!-- The tab table. !-->
	<TD WIDTH="100%" ALIGN="RIGHT" BGCOLOR="#FFFFFF" VALIGN="BOTTOM"> 
		<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%" ALIGN="RIGHT">
			<TR VALIGN="MIDDLE" ALIGN="LEFT">

<TD BGCOLOR="White" WIDTH="60%">&nbsp;</TD>
<TD BGCOLOR="#FFFFCC"><A HREF="http://cjos.sourceforge.net/archive/">Home</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/info/">Info</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/dev/">DevZone</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFCC66" ALIGN="CENTER"><A
HREF="http://jos.sourceforge.net/">Wiki</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
			</TR>
			<TR>
				<TD BGCOLOR="#FFCC66" ALIGN="RIGHT" COLSPAN="9">
					<A HREF="/view/Users/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">UsersWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Main/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MainWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Info/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">InfoWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/DevZone/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">DevZoneWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Support/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SupportWeb</A>
				</TD>
			</TR>
		</TABLE>
	</TD>		
</TR>
<!-- The WikiHeader. !-->
<TR><TD COLSPAN="2">
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="CENTER">
		<B>[&nbsp;<a href="/info//KeithsDriverDesign?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">KeithsDriverDesign</a>&nbsp;]</B>
	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="CENTER">
		<B>[ not logged in ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="CENTER">
		<B>[ Web: <a href="/view/Imported/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">Imported</a> ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFCC66" VALIGN="CENTER">
		goto:&nbsp;<INPUT TYPE="TEXT" SIZE="10" NAME="topic"><!--<INPUT TYPE="IMAGE" SRC="/media/go.gif?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f" BORDER="0" VALUE="topic" ALT="goto">!-->&nbsp;<a href="/search.php?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f"><FONT SIZE="-1">options</FONT></a>
	</TD>
</TR>
</TABLE>

<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
	<TR>
	<TD ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="TOP">
		[&nbsp;get <a href="/info/Imported/KeithsDriverDesign?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">info</a> on or <a href="/edit/Imported/KeithsDriverDesign?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">edit</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="TOP">
		[&nbsp;<a href="/user.php?op=login&redirect=%2Fview%2F%2FKeithsDriverDesign&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FKeithsDriverDesign&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">new&nbsp;user</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="TOP">
		[&nbsp;list of <a href="/topics/Imported/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">topics</a>, <a href="/hubsnodes/Imported/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">hubs&nbsp;&amp;&nbsp;nodes</a>, or <a href="/changes/Imported/?PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">recent&nbsp;changes</a>&nbsp;]	</TD>
	</TR>
</TABLE>

<!-- From CommonHeader !-->
</TR></TD>
</TABLE>
</FORM>

<!-- start BODY page !-->
<P>
Here is the start of some device driver design information.  I would appreciate any comments regarding my ideas.  However, please be constructive.  (Just saying "it sucks!" doesn't help…)  It may be a good idea for now for nobody but me to modify this page; so please leave notes here: <a href="/view.php?topic=NotesAboutKeithsDeviceDriverDesign&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">NotesAboutKeithsDeviceDriverDesign</a><wikitopic NotesAboutKeithsDeviceDriverDesign /wikitopic>
</P><P>
Please note that this isn't even a first draft.  It is still wildly incomplete.  The rest of the design is floating around in my head, and I haven't had the time to type it out.  Some things haven't even been thought through yet; I still don't know how some of the objects relate to each other in terms of subclassing or interfaces.  As it is, I'm way past my bedtime.
</P><P>
I also have some ideas regarding interrupt handing and interrupt blocking that is <a href="/view.php?topic=CPU&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">CPU</a> <wikitopic CPU /wikitopic>independent and prevents a driver from crashing the system (with the exception of a few core system drivers).  I'll get around to noting those later.
</P><P>
Well, here goes.
</P><P>
	- <a href="/view.php?topic=KeithMason&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">KeithMason</a><wikitopic KeithMason /wikitopic>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a></STRONG><wikitopic RMI /wikitopic>
</P><P>
A core concept to this device driver architecture is the use of Sun's Remote Method Invocation (RMI) to communicate between user programs and device drivers.  Device drivers are implemented as remote objects such that any communication to a device driver's object actually results in an <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>call to the object.  For operations that can be put in the background (methods that do not need to return any data), the <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>call can occur and the current task can go on, scheduling the actual call for when it is appropriate and reducing the number of context switches that occur.
</P><P>
<a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>will also allow device drivers to be started and stopped manually or automatically.  <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>provides mechanisms to auto-load a Java VM and class set when a message is sent.  If an object goes unused for a period of time, the Java VM maintaining it can be shut down and unloaded, freeing up memory space for other uses.  Device drivers in this architecture are implemented as basic objects that can take advantage of RMI's features.
</P><P>
<a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>also provides naming protocols for access to these device objects from non-device objects.  When a device object is instantiated, it can register its name and object reference in a local or network nameserver.  Any task interested in accessing this device can simply query the nameserver for the object's instance.
</P><P>
The downside to using <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>currently is permissions.  A security system will have to be devised to dictate what permissions a task has to have before it can access device objects.  Perhaps prevention of access to the nameserver would be sufficient.  However, this is unlikely.  A permission system that allows access at the method level is preferable: it will be desirable to give a task permission to access the read method, but not the write method of an arbitrary device object.  Furthermore, it will be necessary to have persistent permissions: when a system boots up, permissions for a newly created object must already be correct (having to set permissions on every device object at startup or for transient devices at every initialization is unacceptable).
</P><P>
<HR>
</P><P>
<STRONG>Internal sockets class</STRONG>
</P><P>
With use of <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>comes the need for sockets.  The only sockets that Java defines are IP based.  TCP/IP shouldn't be a core mechanism for the OS to operate; it should be an option that can be loaded and unloaded at runtime without affecting access to device drivers from user programs.  Therefore, sockets as defined by the default Java <a href="/view.php?topic=API&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">API</a> <wikitopic API /wikitopic>are insufficient.
</P><P>
Java does allow for other socket types to be designed.  (And good thing!  TCP/IP isn't the only way networks work!)  What is needed for device drivers with <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>is a socket type that uses a <STRONG>very</STRONG> simple protocol and is localized to the computer that the OS is running on.  These internal sockets must always be available, and must be usable to pass any kind of data stream from any task to any other task at any time without fear of failure.  The internal sockets class cannot, then, be a device driver.  Instead, it must be in a class that is loaded automatically (and is not unloadable) in every task that is created.  This class must be loaded in the initial bootstrap of the OS, and then passed on when additional Java VMs are spawned.  (Reloading from disk will not work: disk access requires <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>messaging which requires the internal sockets class already be functional.)
</P><P>
The internal sockets class must not rely on any device driver because it cannot access them.  So all resources needed to pass along messages must be internal to the class.  This means that it cannot request memory pages from the <a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> (a core device driver, described below).  Although the class cannot acquire memory pages, it must have them to write data into.  So it must either own a pool of memory, there must be some memory that is shared with the Java VM it wants to communicate with, or it must go directly to the processor to get the memory it wants.  It also need a mechanism to notify the destination task that there is data to be received.
</P><P>
Internal sockets class also needs the ability to communicate between processors on an <a href="/view.php?topic=SMP&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SMP</a> <wikitopic SMP /wikitopic>system.
</P><P>
No futher design has been done here.  I am looking for comments and suggestions.  This is probably the second most difficult part of the design (after bootstrapping).
</P><P>
<HR>
</P><P>
<STRONG>Device driver access using <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>with TCP/IP sockets</STRONG>
</P><P>
Although for proper operation, internal sockets are needed for the OS to work properly, once a TCP/IP stack is in place, there is no reason that <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>can't be extended to use TCP/IP for some device driver communication.
</P><P>
One very nice use of this would be for network multi-processing.  Tasks on one computer could be offloaded to other trusted computers on the user's network, effectively giving a user the ability to use every idle computer available to perform local processing tasks.  Memory blocks, and even entire address spaces could be transferred to another computer (an address space is actually a very small object, all things considered, and could be transferred quickly) to allow the remote computer to execute one of the local tasks.  Any device driver references (as well as permissions to access them) would follow the task to the new computer, allowing the task to continue to access filesystems and devices on the local computer (over TCP/IP), as though the task were still running locally.  As code was executed remotely, page faults could be resolved over the network within a few milliseconds (or faster as faster networks are designed).  This network page faulting between real memory is faster than swapping from hard drive; even good hard drives would take on average more 10 milliseconds just to seek to the correct track for the swap file!  Three 1500 byte packets (one 4K memory page) can be send over 10Mbit Ethernet in under 4 milliseconds.  Future optimizations could perform advanced page faulting to transfer the necessary pages before the memory is actually needed, so that no delay is noticed at all.
</P><P>
<a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>used in this fashion to provide device driver access to remote computers could also be used as a means of file sharing.  If both computers understand the filesystem stored on a given hard drive, either one of them (local or remote) could access the hard drive directly through <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>over TCP/IP without the need for protocols like <a href="/view.php?topic=NFS&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">NFS</a> <wikitopic NFS /wikitopic>or FTP.  Local hard drive access is identical in operation to remove access.  (Designer's note: direct hard drive access may be dangerous.  It would probably be better to contact the filesystem driver over the network and let the filesystem driver access the hard drive driver locally.  But the basic concept still applies.)
</P><P>
<HR>
</P><P>
<STRONG>Device</STRONG>
</P><P>
All device classes are subclasses of Device.  The device class does not (at this time) define any methods or variables, mainly because most devices do not have any characteristics in common (other than the fact that they are hardware).  It is simply there to provide a common parent for every device.
</P><P>
Not all devices need to be hardware.  For example, PPP, which is just a serial port protocol, must act as though it were a network adapter.  So it is best if the <a href="/view.php?topic=PPP&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PPP</a> <wikitopic PPP /wikitopic>software acted as though it were a piece of hardware.  (This needs to be discussed: maybe these so-called "pseudo-devices" should be separated from real hardware, and the <a href="/view.php?topic=NetworkController&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">NetworkController</a><wikitopic NetworkController /wikitopic> class [or whatever it ends up being called] could be an interface instead of a class.  For that matter, would the TCP/IP stack be considered a pseudo-device?  If not, where is the distinction?  Perhaps a new class, Protocol , as well as Device should be a subclass of something called Service, and there could be network adapter subclasses descending from both Protocol and Device.  Clearly, some more thought needs to go into this.)
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> &amp; <a href="/view.php?topic=AddressSpaceDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AddressSpaceDevice</a><wikitopic AddressSpaceDevice /wikitopic></STRONG>
</P><P>
These two driver classes share the same Java VM for efficiency; they interact with each other a lot.
</P><P>
The <a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> is responsible for doling out pages of <a href="/view.php?topic=RAM&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RAM</a> <wikitopic RAM /wikitopic>(or virtual RAM) and for swapping this <a href="/view.php?topic=RAM&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RAM</a> <wikitopic RAM /wikitopic>out to disk when more is needed.  It operates tightly bound with the <a href="/view.php?topic=AddressSpaceDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AddressSpaceDevice</a><wikitopic AddressSpaceDevice /wikitopic> which is responsible for mapping system memory pages into virtual address spaces (in which Java VMs reside, execute, and operate their data).  Upon initialization*, the <a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> class takes ownership of all system memory pages that aren't reserved for the system or devices.  (Reserved memory on PCs would include the interrupt page [0-4K] and device space [640K-1M].)  Programs allocate additional memory for their address spaces (when objects are instantiated) or for new address spaces (when a new Java VM is spawned) by using <a href="/view.php?topic=RMI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">RMI</a> <wikitopic RMI /wikitopic>with internal sockets to message the <a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> driver to request a page.
This page can then be sent to the <a href="/view.php?topic=AddressSpaceDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AddressSpaceDevice</a><wikitopic AddressSpaceDevice /wikitopic> that the current Java VM is running in, instructing where the page should be placed.  (Perhaps this operation would occur in one step for efficiency?)  Likewise, tasks can share memory pages with each other by sending each other <a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> instances which they can then forward to their own <a href="/view.php?topic=AddressSpaceDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AddressSpaceDevice</a><wikitopic AddressSpaceDevice /wikitopic> to add to their address spaces.  Pages can be set to shared or copy-on-write arbitrarily (permissions allowing; copy-on-write can be locked-in by the source to prevent the destination from breaking it).
</P><P>
Note that the implementation of these two classes is one of the few architecture dependent parts of the device driver system.  They have to communicate with the processor to manage memory pages and address spaces.  There will need to be a different implementation of these two classes for different processor types.
</P><P>
Designer's note: death of this task will cause system failure.  Is there any way around this?  (I.e., restarting the process automatically upon exit.)
</P><P>
* Bootstrapping the OS creates one address space that the Java VM, <a href="/view.php?topic=AddressSpaceDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AddressSpaceDevice</a><wikitopic AddressSpaceDevice /wikitopic>, and <a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> drivers are loaded into.  When the <a href="/view.php?topic=MemoryPageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MemoryPageDevice</a><wikitopic MemoryPageDevice /wikitopic> class is initialized, it queries the state of the processor to determine all memory pages in the system, and compares them with the pages in use by the current address space.  All pages not marked "hands off" by the bootstrapper and not used by the current address space are added to the available list.  When the <a href="/view.php?topic=AddressSpaceDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AddressSpaceDevice</a><wikitopic AddressSpaceDevice /wikitopic> class initializes, it creates an instance of itself referring to the address space it is in.
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic> &amp; <a href="/view.php?topic=AttachedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachedDevice</a><wikitopic AttachedDevice /wikitopic></STRONG>
</P><P>
These are poor names because they are ambiguous.  I considered calling "attachable" devices either bus, controller, or parent devices, and "attached" devices "removable".  Any ideas?
</P><P>
First a definition to reduce confusion: a device is attachable if it can have devices connected to it; a device is attaching if it gets plugged into an attachable device.  <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic> is an interface (not a class, for reasons that become apparent later<STRONG>) that defines a device that can have other devices attached to it.  <a href="/view.php?topic=AttachedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachedDevice</a><wikitopic AttachedDevice /wikitopic> is an interface (also not a class</STRONG>) that defines a device that is plugged into an <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic>.  Almost all devices are attached to an <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic>, so some subclass not too far down from Device should be defined to implement the <a href="/view.php?topic=AttachedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachedDevice</a><wikitopic AttachedDevice /wikitopic> interface.
</P><P>
What exactly is an <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic>?  The easiest example is a bus device: ISA, PCI, PCMCIA, whatever.  These are devices that are designed for the sole purpose of having devices plugged into them.  Other obvious <a href="/view.php?topic=AttachableDevices&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevices</a><wikitopic AttachableDevices /wikitopic> are hard drive controllers: IDE, SCSI, etc., because they also exist to support devices plugged into them.  These devices are generally storage devices (disk drives, CDROMs, etc.), but this isn't always the case: you could put a <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>controller onto a <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>bus, resulting in unlimited types, because a <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>controller is an <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic> itself.
</P><P>
A less obvious example of an <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic> is, for example, a disk drive.  You might not ordinarily realize that you can plug a device into a disk drive, but a disk is exactly that: a device that plugs into a disk drive.  Disks attach to disk drives in the same way that a disk drive attaches to a <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>bus or a <a href="/view.php?topic=FLASH&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">FLASH</a> <wikitopic FLASH /wikitopic>card plugs into a <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>bus.  Even more importantly, for removable disks, is that they attach in a hot-swappable fashion; removing a disk is the same as ejecting a <a href="/view.php?topic=FLASH&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">FLASH</a> <wikitopic FLASH /wikitopic>card.  Disks in hard drives are simply not hot-swappable because they cannot be removed; but they are still separate devices for interface consistency.
</P><P>
* The reason that <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic> and <a href="/view.php?topic=AttachedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachedDevice</a><wikitopic AttachedDevice /wikitopic> are interfaces and not classes should be apparent at this point.  Many devices are defined as implementing one or both of these, without much regard for class structure.  A system bus device is always an <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic>, but so is a serial port driver, and a <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>bus, and a disk drive.  There is no class hierarchy-based rationale that defines whether a device can support sub-devices.  Any device in any leg of the device driver system may want to implement this.  The same goes for <a href="/view.php?topic=AttachedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachedDevice</a><wikitopic AttachedDevice /wikitopic>.  A great example of this is the <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>bus.  In some systems, it is a top-level bus; that is, it isn't attached to anything.  In others, the <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>controller may be chained off of the ISA, PCI, or even the <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>bus.  So some subclasses of <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>will implement <a href="/view.php?topic=AttachedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachedDevice</a><wikitopic AttachedDevice /wikitopic>, while others will not.  It all depends on the hardware.
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=HotSwappedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">HotSwappedDevice</a><wikitopic HotSwappedDevice /wikitopic></STRONG>
</P><P>
Instances of any <a href="/view.php?topic=HotSwappedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">HotSwappedDevice</a><wikitopic HotSwappedDevice /wikitopic> (disks included) may remain in the system after the actual disk or other device has been removed from its parent (ed. note: first use of this word!), if their objects are kept around and not garbage collected.  When one of these "stale" devices is accessed, the driver object needs to message a request back to some listening object who would then be responsible, for example, for popping up a dialog box asking the user to re-insert the desired device (disk, etc).  This request for re-insertion would also apply to other hot-swappable (non-disk) devices such as <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>cards (for example, a modem card, if dialing is attempted).
</P><P>
Instances of hot-swappable objects might be created before they are ever inserted in the system in the first place.  They may be created from a marshalled object stream (see Remove Method Invocation documentation for details on marshalling an objects). This could happen, for example, if they are stored on an install disk to refer to continuation disks for the install (disk 2, disk 3, etc.), or saved when a hot-swappable device is inserted for the first time and reloaded from disk upon a subsequent reboot.
</P><P>
By definition, any device that is hot-swappable is also an attached device.  Therefore, there should be a <a href="/view.php?topic=HotSwappedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">HotSwappedDevice</a><wikitopic HotSwappedDevice /wikitopic> interface that inherits from <a href="/view.php?topic=AttachedDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachedDevice</a><wikitopic AttachedDevice /wikitopic> and defines the additional methods required to support hot-swapping capabilities (including the method callback requesting the user connect the device if the system wants to use it).
</P><P>
<HR>
</P><P>
<STRONG>Combination Attachable/Attached</STRONG>
</P><P>
Note that many devices fall under both Attachable and Attached (or <a href="/view.php?topic=HotSwapped&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">HotSwapped</a><wikitopic HotSwapped /wikitopic>).  (I think that all devices fall under one or the other.)  These would be disk drive controllers (because they connect to a system bus such as <a href="/view.php?topic=PCI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCI</a> <wikitopic PCI /wikitopic>and disk drives attach to them), disk drives (because they attach to disk drive controllers and disks attach to them), as well as some system busses (such as <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>because they can attach to both other system busses (like an <a href="/view.php?topic=ISA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">ISA</a> <wikitopic ISA /wikitopic>bus) and <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>busses, and <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>cards attach to them).  But less obvious devices also fall under this category.  Serial ports are one of them.  A serial port (RS-232 being the most common) generally attaches to the <a href="/view.php?topic=ISA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">ISA</a> <wikitopic ISA /wikitopic>bus.  Modems, fax modems, printers, etc. can attach to a serial port.  The same goes for parallel ports (IEEE-1284).
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=SystemBusDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SystemBusDevice</a><wikitopic SystemBusDevice /wikitopic></STRONG>
</P><P>
<a href="/view.php?topic=SystemBusDevices&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SystemBusDevices</a><wikitopic SystemBusDevices /wikitopic> are devices that specify controls for system busses such as ISA, PCI, and PCMCIA.  Each type of system bus is a subclass of <a href="/view.php?topic=SystemBusDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SystemBusDevice</a><wikitopic SystemBusDevice /wikitopic>.  They implement the Attachable interface, because you can connect devices to them.  Reading and writing is not allowed to busses except by devices that are attached to them.
</P><P>
Many busses support plug-and-play operation.  It may be desirable to either define a plug-and-play interface, or to have busses such as <a href="/view.php?topic=PCI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCI</a> <wikitopic PCI /wikitopic>and <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>be subclasses of a <a href="/view.php?topic=PlugAndPlayBusDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PlugAndPlayBusDevice</a><wikitopic PlugAndPlayBusDevice /wikitopic> class.
</P><P>
Designer's note:  I am not yet familiar with bus/chipset operations.  It may be necessary to break bus class definitions to something substantially different than what is provided here.  I would like input from more knowledgeable people.
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=StorageControllerDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageControllerDevice</a><wikitopic StorageControllerDevice /wikitopic></STRONG>
</P><P>
<a href="/view.php?topic=StorageControllerDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageControllerDevice</a><wikitopic StorageControllerDevice /wikitopic> is an abstract class that defines communication with devices designed to support mass storage devices.  Floppy controllers, IDE, and <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>are among these.  This class contains support for this kind of device in terms of addressability, and access to the connected devices.  Very few user-visible operations are supported.  Most operation the user will interact with is defined in <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic> and <a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic>.  In general, all that the user will access is the methods to retrieve <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic> instances.
</P><P>
Support is provided for <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic> instances to communicate to their respective hardware through the controller.  Obviously, a driver for a <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>disk knows nothing about the <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>controller its disk drive is connected to.  So the <a href="/view.php?topic=StorageControllerDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageControllerDevice</a><wikitopic StorageControllerDevice /wikitopic> is responsible for this communication.
</P><P>
Note that there is no software distinction between a <a href="/view.php?topic=SystemBusDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SystemBusDevice</a><wikitopic SystemBusDevice /wikitopic> and a <a href="/view.php?topic=StorageControllerDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageControllerDevice</a><wikitopic StorageControllerDevice /wikitopic> at the abstracted level.  You can connect a <a href="/view.php?topic=PCMCIA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">PCMCIA</a> <wikitopic PCMCIA /wikitopic>device to a <a href="/view.php?topic=SCSI&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SCSI</a> <wikitopic SCSI /wikitopic>controller just as easily as you can to an <a href="/view.php?topic=ISA&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">ISA</a> <wikitopic ISA /wikitopic>bus.  The abstraction is provided for OS end-users to visibly differentiate what is normally a disk controller from what is normally a more generic system bus.
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic></STRONG>
</P><P>
A <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic> provides the abstraction for accessing a storage medium's physical hardware.  It provides the consistent shell that a <a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic> instance will use to retrieve data from the actual disk.  To the user, it does nothing more that supply <a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic> instances for whatever disk is currently in the drive and issue events for insertion and ejection (and, in some cases, offer an option to eject the disk electronically or to lock the eject button).
</P><P>
For the end-user's understanding of his system description, <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic> is further abstracted in subclasses for disks (<a href="/view.php?topic=DiskDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">DiskDriveDevice</a><wikitopic DiskDriveDevice /wikitopic>), tape (<a href="/view.php?topic=TapeDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">TapeDriveDevice</a><wikitopic TapeDriveDevice /wikitopic>), etc. which are also further subclassed to specific device types (floppies, hard drives, CDROMs, DVDs, etc.; 2120 tape, 8mm tape, 4mm tape, etc.).  This additional abstraction is also useful because some of these devices behave differently than others in trivial ways (tape isn't random access; CDROMs can't generally be written to).  However, the <a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic> and its subclasses normally would handle most of these distinctions.
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic></STRONG>
</P><P>
A <a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic> is the actual parent class that handles the real storage medium.  Any accesses a filesystem or backup program would make to a disk uses instances of some subclass of <a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic>.  There is a complete device-type hierarchy for disks, tapes, etc., as described in <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic>.
</P><P>
This class provides the sector addressing mechanisms needed for each kind of device, ejection requests (which are just forwarded to the device's owner, a <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic> instance), disk change handling, etc.  (If the user changes a floppy disk while it's being accessed, the <a href="/view.php?topic=StorageDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDevice</a><wikitopic StorageDevice /wikitopic> instance is guaranteed [to the capability of the hardware] to not read from the correct device; either a device-not-ready error of some kind occurs or a event requesting the user to re-insert the necessary device is generated.)
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=ExternalBus&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">ExternalBus</a><wikitopic ExternalBus /wikitopic></STRONG>
</P><P>
Like <a href="/view.php?topic=StorageControllerDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageControllerDevice</a><wikitopic StorageControllerDevice /wikitopic>, this abstraction is provided purely for the user's convenience in identifying his device types.  This class may be subclassed further, depending on abstraction need.  For example, we may have a <a href="/view.php?topic=SerialBus&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SerialBus</a><wikitopic SerialBus /wikitopic> subclass that further has <a href="/view.php?topic=USB&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">USB</a> <wikitopic USB /wikitopic>and Firewire as its subclasses.  The same operations as the <a href="/view.php?topic=SystemBusDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">SystemBusDevice</a><wikitopic SystemBusDevice /wikitopic> and <a href="/view.php?topic=StorageDriveDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">StorageDriveDevice</a><wikitopic StorageDriveDevice /wikitopic> are provided, giving the user access to the child devices connected to the bus.
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=NetworkDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">NetworkDriver</a><wikitopic NetworkDriver /wikitopic></STRONG>
</P><P>
<a href="/view.php?topic=NetworkDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">NetworkDriver</a><wikitopic NetworkDriver /wikitopic> contains abstraction that exists with most network devices: support for hardware addressing, reading of a packet, writing of a packet, etc.  <a href="/view.php?topic=NetworkDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">NetworkDriver</a><wikitopic NetworkDriver /wikitopic> should be subclassed with additional abstract classes that define specific types of network adapters (for example, <a href="/view.php?topic=EthernetDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">EthernetDriver</a><wikitopic EthernetDriver /wikitopic>).  Subclasses of <a href="/view.php?topic=NetworkDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">NetworkDriver</a><wikitopic NetworkDriver /wikitopic> should not be instantiated directly; they should always be abstract classes themselves, with their subclasses written as concrete classes for actual network controllers.
</P><P>
<HR>
</P><P>
<STRONG><a href="/view.php?topic=CursorDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">CursorDriver</a><wikitopic CursorDriver /wikitopic></STRONG>
</P><P>
<a href="/view.php?topic=CursorDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">CursorDriver</a><wikitopic CursorDriver /wikitopic> is an abstract class that is subclassed with <a href="/view.php?topic=MouseDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MouseDriver</a><wikitopic MouseDriver /wikitopic> and <a href="/view.php?topic=TabletDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">TabletDriver</a><wikitopic TabletDriver /wikitopic>.  Those classes are subclassed with actual mouse hardware concrete classes (such as <a href="/view.php?topic=LogitechMouseDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">LogitechMouseDriver</a><wikitopic LogitechMouseDriver /wikitopic>).  The distinction between a <a href="/view.php?topic=MouseDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MouseDriver</a><wikitopic MouseDriver /wikitopic> and a <a href="/view.php?topic=TabletDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">TabletDriver</a><wikitopic TabletDriver /wikitopic> is mostly the option of relative vs. absolute coordinates.
</P><P>
The <a href="/view.php?topic=CursorDriver&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">CursorDriver</a><wikitopic CursorDriver /wikitopic> is an event-based driver. As such, there is no read method.  Programs interested in receiving mouse motion information will need to register a listener.  Whether this listener uses the <a href="/view.php?topic=MouseEvent&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MouseEvent</a><wikitopic MouseEvent /wikitopic> and listener mechanism of the <a href="/view.php?topic=AWT&web=Imported&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AWT</a> <wikitopic AWT /wikitopic>is yet to be determined.  Even if this mechanism is used, the actual <a href="/view.php?topic=MouseEvent&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">MouseEvent</a><wikitopic MouseEvent /wikitopic> will need to be enhanced to support the idea of relative motion.
</P><P>
<HR>
</P><P>
Designer's note: Event-based driver operation may be something that we want throughout the device driver system.  Why explicitly have to request reading when input from many devices is already unsolicited.  Obviously, operations such as disk reading would not apply.  However, input events from the keyboard and mouse have aren't the only useful candidates for events.  Network adapters received data packets spontaneously; should that be event based?  Disk insertion, audio/video streaming, serial port data input, and parallel port out-of-paper notification all qualify.  Any <a href="/view.php?topic=AttachableDevice&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">AttachableDevice</a><wikitopic AttachableDevice /wikitopic> could also benefit from an event based input system: the kinds of unsolicited input received from devices attached to them are unlimited.  It would need to use this mechanism to indicate when <a href="/view.php?topic=HotSwappedDevices&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">HotSwappedDevices</a><wikitopic HotSwappedDevices /wikitopic> are connected and disconnected; in fact, it would be unreasonable for any piece of software to try to poll for this activity!<BR><BR></P><!--

<TABLE width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="737b9c">
<TR><TD ALIGN="CENTER">
<a href="/user.php?op=login&redirect=%2Fview%2F%2FKeithsDriverDesign&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FKeithsDriverDesign&PHPSESSID=dedbe11a647f9a0b28eca7a189059d2f">new&nbsp;user</a><TR><TD>
</TABLE>

!-->
<!-- end BODY page !-->

<HR>

<DIV ALIGN="CENTER">
<TABLE BORDER="0" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR>
	<TD ALIGN="CENTER" COLSPAN="2">
		Content of these pages are owned and copyrighted by the poster.
	</TD>
</TR>
<TR>
	<TD ALIGN="RIGHT" WIDTH="50%">
		Hosted by:
	</TD>
	<TD ALIGN="LEFT">
		<A HREF="http://sourceforge.net/"><IMG 
			SRC="http://sourceforge.net/sflogo.php?group_id=2376&type=1"
			BORDER=0 HSPACE=0 VSPACE=0></A>
	</TD>
</TR>
</TABLE>
</DIV>
</BODY>
</HTML>
