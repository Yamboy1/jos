<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
    <TITLE>CjOSMemoryNode.Imported @ jos.sf.net</TITLE>
  </HEAD>

<BODY BGCOLOR="#FFFFFF">

<!-- The FORM encloses the entire header, because it renders better that way. !-->
<FORM ACTION="/jump.php"><input type="hidden" name="PHPSESSID" value="4a3ec1ce7d6a664881b01f1a51889e3b" />

<!-- The JOS logo. !-->
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR VALIGN="TOP" ALIGN="LEFT">
	<TD><A HREF="http://cjos.sourceforge.net/archive/"><IMG 
		VSPACE="0" HSPACE="0" ALIGN="MIDDLE" BORDER="0"
		SRC="http://cjos.sourceforge.net/archive/media/jos_logo_mini.gif"></A></TD>
	<!-- The tab table. !-->
	<TD WIDTH="100%" ALIGN="RIGHT" BGCOLOR="#FFFFFF" VALIGN="BOTTOM"> 
		<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%" ALIGN="RIGHT">
			<TR VALIGN="MIDDLE" ALIGN="LEFT">

<TD BGCOLOR="White" WIDTH="60%">&nbsp;</TD>
<TD BGCOLOR="#FFFFCC"><A HREF="http://cjos.sourceforge.net/archive/">Home</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/info/">Info</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFFFCC" ALIGN="CENTER"><A HREF="http://cjos.sourceforge.net/archive/dev/">DevZone</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
<TD WIDTH="10%" BGCOLOR="#FFCC66" ALIGN="CENTER"><A
HREF="http://jos.sourceforge.net/">Wiki</A></TD>
<TD BGCOLOR="White">&nbsp;</TD>
			</TR>
			<TR>
				<TD BGCOLOR="#FFCC66" ALIGN="RIGHT" COLSPAN="9">
					<A HREF="/view/Users/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">UsersWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Main/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">MainWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Info/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">InfoWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/DevZone/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">DevZoneWeb</A>
					&nbsp;|&nbsp;
					<A HREF="/view/Support/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">SupportWeb</A>
				</TD>
			</TR>
		</TABLE>
	</TD>		
</TR>
<!-- The WikiHeader. !-->
<TR><TD COLSPAN="2">
<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
<TR>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="CENTER">
		<B>[&nbsp;<a href="/info//CjOSMemoryNode?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">CjOSMemoryNode</a>&nbsp;]</B>
	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="CENTER">
		<B>[ not logged in ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="CENTER">
		<B>[ Web: <a href="/view/Imported/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">Imported</a> ]</B>	</TD>
	<TD WIDTH="25%" ALIGN="CENTER" BGCOLOR="#FFCC66" VALIGN="CENTER">
		goto:&nbsp;<INPUT TYPE="TEXT" SIZE="10" NAME="topic"><!--<INPUT TYPE="IMAGE" SRC="/media/go.gif?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b" BORDER="0" VALUE="topic" ALT="goto">!-->&nbsp;<a href="/search.php?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b"><FONT SIZE="-1">options</FONT></a>
	</TD>
</TR>
</TABLE>

<TABLE BORDER="0" CELLSPACING="0" CELLPADDING="3" WIDTH="100%">
	<TR>
	<TD ALIGN="CENTER" BGCOLOR="#FFFFCC" VALIGN="TOP">
		[&nbsp;get <a href="/info/Imported/CjOSMemoryNode?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">info</a> on or <a href="/edit/Imported/CjOSMemoryNode?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">edit</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFEE88" VALIGN="TOP">
		[&nbsp;<a href="/user.php?op=login&redirect=%2Fview%2F%2FCjOSMemoryNode&PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FCjOSMemoryNode&PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">new&nbsp;user</a>&nbsp;]	</TD>
	<TD ALIGN="CENTER" BGCOLOR="#FFDD77" VALIGN="TOP">
		[&nbsp;list of <a href="/topics/Imported/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">topics</a>, <a href="/hubsnodes/Imported/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">hubs&nbsp;&amp;&nbsp;nodes</a>, or <a href="/changes/Imported/?PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">recent&nbsp;changes</a>&nbsp;]	</TD>
	</TR>
</TABLE>

<!-- From CommonHeader !-->
</TR></TD>
</TABLE>
</FORM>

<!-- start BODY page !-->
<P>
<FONT SIZE="-1"><a href="/view.php?topic=CjOSPages&PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">CjOSPages</a><wikitopic CjOSPages /wikitopic></FONT>
<HR SIZE="1" NOSHADE>
<P><EM>Article contributed by <a href="/view.php?topic=GilbertHerschberger&PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">GilbertHerschberger</a><wikitopic GilbertHerschberger /wikitopic> (15 March 2001).</EM></P>
<H4>Introduction</H4>
<P>I may have made heap-based memory allocation far more complicated than it needs to be. We need only two memory functions: <CODE>mc_alloc()</CODE> and <CODE>mc_free()</CODE>. Here is some of my current thinking.</P>
<H4>Heap based</H4>
<P>A virtual machine <EM>probably</EM> should use multiple heaps. For a virtual machine limited to a single process, additional heaps might be constructed when existing heaps become full. Total heap size does not need to be fixed when a virtual machine is created. Multiple heaps seem to be a direct approach for mapping objects to a bytecode process. Each bytecode process could have its own heap. When a process dies, its heap is discarded.</P>
<H4>Top</H4>
<P>A heap object maintains a top node for each heap. From the top node, a heap can be walked to find individual nodes.</P>
<PRE>
class mc_Heap {
  :
  private:
	 void *payload;
	 size_t size;
	 mc_Node *ptop;
	 mc_Node *pend;

};
</PRE>
<H4>Node</H4>
<P>A node provides the following properties.</P>
<UL>
<LI><CODE>busy flag</CODE>
<LI><CODE>payload_size</CODE>
<LI><CODE>next_node</CODE>
<LI><CODE>payload</CODE>
</UL>
<H4>Busy flag</H4>
<P>Each node has a busy flag. A node is <EM>busy</EM> when it has already been allocated. A busy node cannot be allocated again. A busy node cannot be joined or split.</P>
<H4>Payload size</H4>
<P>The payload part of a node can be variable in side. The size of a node's payload does not include the busy flag, payload size, next node of the node itself. It only includes the use-able size of a payload.</P>
<H4>Next node</H4>
<P>Starting with the top node, the next node property points directly to the next node. Next node is calculated once and then stored in order to increase heap-walk performance.</P>
<H4>Example 1</H4>
<P>Here is an example of walking a heap.</P>
<PRE>
void example1() {
  mc_MemoryNode *pcurr = &lt;EM&gt;get top of a heap&lt;/EM&gt;

  for (;;) {
	 if ( pcurr == NULL ) {
		return;
	 }

	 printf( "Heap: %s %uin", 
		  pcurr-&gt;isBusy() ? "Busy" : "Free",
		  pcurr-&gt;getSize() );

	 pcurr = pcurr-&gt;getNext();
  }
}
</PRE>
<H4>Operations</H4>
<P>There are two operations on a memory node.</P>
<UL>
<LI><P><STRONG>Split</STRONG></P>
<P>The payload of a node can be split. This creates an additional node. A busy node cannot be split. A small node cannot be split. The split operating requires only the payload size of the first node. The second node gets the remaining size.</P>
<P>Node N can be split into nodes N1 and N2. After a split, <CODE>N2->getNext()</CODE> points to <CODE>N->getNext()</CODE>; and <CODE>N1->getNext()</CODE> points to N2.</P>
<PRE>
void mc_splitNode( mc_Node *node, size_t size );
</PRE>
<LI><P><STRONG>Join</STRONG></P>
<P>A join is the opposite of a split. Two nodes can be joined. The second node becomes part of the first node's payload. A busy node cannot be joined. The join operating requires only a pointer of the first node to be joined.</P>
<P>Nodes N1 and N2 can be joined, creating node N. After a join, <CODE>N->getNext()</CODE> points to <CODE>N2->getNext()</CODE>; and <CODE>N->getSize()</CODE> equals <CODE>N1->getSize() + N2->getSize() + <EM>e</EM></CODE> where <EM>e</EM> is the size of extra properties in a node.</P>
<PRE>
void mc_joinNode( mc_Node *node );
</PRE>
</UL>
<H4>Example 2</H4>
<P>The following example illustrates part of the split operation.</P>
<PRE>
void example2( mc_Node *node, size_t size ) {
  if ( node == NULL ) {
	 return;
  }

  if ( node-&gt;isBusy() ) {
	 return;
  }

  // size &gt; node-&gt;getSize();
  if ( size &gt; node-&gt;getSize() + e ) {
	 return;
  }

  mc_Node *n2 = (mc_Node *) ( node-&gt;getPayload() + size );
  n2-&gt;setBusy( false );
  n2-&gt;setSize( node-&gt;getPayload() - size - e );
  n2-&gt;setNext( node-&gt;getNext() );
  node-&gt;setSize( size );
  node-&gt;setNext( n2 );
}
</PRE>
<H4>Example 3</H4>
<P>The following example illustrates part of the join operation.</P>
<PRE>
void example3( mc_Node *node ) {
  if ( node == NULL ) {
	 return;
  }

  if ( node-&gt;isBusy() ) {
	 return;
  }

  mc_Node *n2 = node-&gt;getNext();

  if ( n2 == NULL ) {
	 return;
  }

  if ( n2-&gt;isBusy() ) {
	 return;
  }

  node-&gt;setNext() = n2-&gt;getNext();
  node-&gt;setSize( node-&gt;getSize() + e + n2-&gt;getSize() );
}
</PRE>
<P><EM>Note:</EM> The join operation could easily be recursive, so that a heap can partially recover from fragmentation.</P>
<H4>Host heap</H4>
<P>A host-based heap can allocate a 4M, 8M or 16M block of memory using <CODE>alloc()</CODE> (or <CODE>new</CODE>). Once a block of memory is reserved by the host kernel, it can be sub-divided using the heap node.</P>
<P>A memory block must be initialized. When initialized, top points to the memory block. Two nodes are initially defined. The payload of the first node contains most of the heap. The payload of the second node is zero. Here is an example.</P>
<PRE>
void initializeHeap( void *v, size_t size ) {
  mc_Node *n2 = (mc_Node *) ((char *) v + size - e );
  n2-&gt;setBusy( true );
  n2-&gt;setSize( 0 );
  n2-&gt;setNext( NULL );

  mc_Node *n1 = (mc_Node *) v;
  n1-&gt;setBusy( false );
  n1-&gt;setSize( size - e );
  n1-&gt;setNext( n2 );
}
</PRE>
<P><EM>Note:</EM> Since the last node in a heap is always busy, it cannot be split or joined.</P>
<H4>Re-initialized</H4>
<P>Instead of free'ing a heap when a process dies, a multiple process virtual machine can simply re-initialize a process heap. It is as if the space was free'd and a new heap was initialized.</P>
<P>A multiple process virtual machine can pre-allocate a heap for its system process and several other processes, in anticipation of building a heap for each process.</P>
<PRE>
mc_Node *mc_createHeap( size_t size ) {
  char *p = new char[ size ];
  if ( p == NULL ) {
	 return NULL;
  }

  initializeHeap( p, size );

  return (mc_Node *)p;
}
</PRE>
<H4>Allocating memory</H4>
<P>A simple heap is a singly-linked list of memory nodes. The allocation process always starts at the top. Here is an example of what an allocation function might look like:</P>
<PRE>
void *mc_alloc( size_t size ) {
  mc_MemoryNode *pcurr = &lt;EM&gt;get top of a heap&lt;/EM&gt;

  for (;;) {
	 if ( pcurr == NULL ) {
		return;
	 }

	 if ( !pcurr-&gt;isBusy() ) {
		if ( pcurr-&gt;getSize() == size ) {
		  pcurr-&gt;setBusy( true );
		  return pcurr-&gt;getPayload();
		}
		if ( pcurr-&gt;getSize() &lt; size ) {
		  splitNode( pcurr, size );

		  pcurr-&gt;setBusy( true );
		  return pcurr-&gt;getPayload();
		}
	 }

	 pcurr = pcurr-&gt;getNext();
  }
}
</PRE>
<H4>Free'ing memory</H4>
<P>The following function illustrates how to free a block of memory.</P>
<PRE>
void mc_free( void *payload ) {
  if ( payload == NULL ) {
	 return;
  }
  if ( payload &lt; ptop + e ) {
	 return;
  }
  if ( payload &gt;= pend ) {
	 return;
  }

  mc_Node *node = (mc_Node *) ((char *)payload - e );
  /* check for a valid node. */
  if ( node-&gt;getNext() == NULL ) {
	 return;
  }
  if ( node &gt; node-&gt;getNext() ) {
	 return;
  }
  if ( node + e + node-&gt;getSize() != node-&gt;getNext() ) {
	 return;
  }

  node-&gt;setBusy( false );
  mc_joinNode( node );
}
</PRE><BR><BR></P><!--

<TABLE width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="737b9c">
<TR><TD ALIGN="CENTER">
<a href="/user.php?op=login&redirect=%2Fview%2F%2FCjOSMemoryNode&PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">login</a> or <a href="/user.php?op=newacct&redirect=%2Fview%2F%2FCjOSMemoryNode&PHPSESSID=4a3ec1ce7d6a664881b01f1a51889e3b">new&nbsp;user</a><TR><TD>
</TABLE>

!-->
<!-- end BODY page !-->

<HR>

<DIV ALIGN="CENTER">
<TABLE BORDER="0" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR>
	<TD ALIGN="CENTER" COLSPAN="2">
		Content of these pages are owned and copyrighted by the poster.
	</TD>
</TR>
<TR>
	<TD ALIGN="RIGHT" WIDTH="50%">
		Hosted by:
	</TD>
	<TD ALIGN="LEFT">
		<A HREF="http://sourceforge.net/"><IMG 
			SRC="http://sourceforge.net/sflogo.php?group_id=2376&type=1"
			BORDER=0 HSPACE=0 VSPACE=0></A>
	</TD>
</TR>
</TABLE>
</DIV>
</BODY>
</HTML>
